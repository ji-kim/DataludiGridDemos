/*jscrambler
 {
 "ignore_transformations_@": {
 "*": {
 "*": false
 },
 "ignorewm": {
 "*": false,
 "string_splitting": true
 }
 }
 }
 */

var _vm__ = "UhEUgAAAOMAAAA3CAYAAAD+I";
var _wm_ = (function() {
    "jscrambler ignore_transformations_@ ignorewm";
    return "iVBORw0KGgoAAAANS" + _vm__ + "f11AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAA7k2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMwMTQgNzkuMTU2Nzk3LCAyMDE0LzA4LzIwLTA5OjUzOjAyICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTUtMDctMTZUMTQ6NDg6MzkrMDk6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE1LTA3LTE2VDE0OjQ4OjM5KzA5OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNS0wNy0xNlQxNDo0ODozOSswOTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6MGYwNDAxNWYtNzg4Yy1mYzQxLTllYWYtYjZiMjJlMzM2ZDk3PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6NDk1ZTNiMGUtMmI3ZS0xMWU1LTg1YzMtZTMzMDBkNTU3OTgzPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6MzdhMjNhMGQtMzkzZi03MDQyLWFlNTItZTdmZWMwNGNmMzQ2PC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjM3YTIzYTBkLTM5M2YtNzA0Mi1hZTUyLWU3ZmVjMDRjZjM0Njwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNS0wNy0xNlQxNDo0ODozOSswOTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowZjA0MDE1Zi03ODhjLWZjNDEtOWVhZi1iNmIyMmUzMzZkOTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTUtMDctMTZUMTQ6NDg6MzkrMDk6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8cGhvdG9zaG9wOlRleHRMYXllcnM+CiAgICAgICAgICAgIDxyZGY6QmFnPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHBob3Rvc2hvcDpMYXllck5hbWU+ICAgICAgICAgICAgICAgIGkgICAgaSA8L3Bob3Rvc2hvcDpMYXllck5hbWU+CiAgICAgICAgICAgICAgICAgIDxwaG90b3Nob3A6TGF5ZXJUZXh0PiAgICAgICAgICAgICAgICBpICAgIGkgPC9waG90b3Nob3A6TGF5ZXJUZXh0PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6QmFnPgogICAgICAgICA8L3Bob3Rvc2hvcDpUZXh0TGF5ZXJzPgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJRUM2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj4yMjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NTU8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PjSIgs0AAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAGjVJREFUeNrsfe9vnNeV3nPOve8vzgx/SKIkylJMK6oSSAk2G7fZpNvCCrZBEw7TAgFYFC2SOECbv6KF6f4D+6kfmkVho7soCnPborGGbou24bZud9NEybaBtV3ZlrWxLJoakUNyZvj+uvecfhjJdmyLMxRnLC4yB+AHiS/v+7znOefcc8+573tJVTGWsYzl8QuPVTCWsYydcSxjGcvYGccylrEzjmUsYxk741jGMnbGsYxlLAOIHfRCIjr83VQJz4OW7/9zGQCeQ6+3QgBA4z7LR5VGeKCVj9MdHXGd/ZpwPowWIQ06yKGcUZWWAXr5BzC1izC1zjoDc4iPQ5s5NEnf0LsnL8j5m5DL16HLfxmMbMQGvPw86LVLoJvnwSfvvsFpcoFmI1C2CQLW0a7OSfsG/De/D7+MI6ivQ3Auzz6bAHgawCUAZwC0ANwE8Cq/+GLrKFK2H2Z64YXWEXFGpWUF/fgVBGWnFYeVmcRIFpYOHFiIQj1L4rq+7SqmVuxOogTg1q7A/1o6pCpdWYMBYCd3EXR9O6yYmhVOLYHMA715joui20qD6kz2W99AuUzQozPLPDrn8r3vxQC+fd+gPywpgN/nF1+8cwQdcV/M9MILfTHb0fMCvHwN5nyAuB0kM4bL2VIwySEFTiBMKCV0WSSc5m63E7Z4F51u98raqXxN9dfLIe87Yvj2RoRqpZIbmYwiUxV2iXqKvVLAIbgULQMud22QNKsBWi9fg0DhQEflOR6dc8f8V63ImYeMnAD4WwD+1RFj7umHOOKBMI+8gLP8POh8AZtmaZWMnv7h14OfEOmbJPo6sYoAEPGnlcysgbkQhOHJSrVSmW3eDpaf/6TNSwn6oR/oJ4Zh+XnQbPN2UKlWKkEYnjQwF5TMrIg/LQCIVUj0dSJ984dfD35CRk+nWVo9X8B+8roaDedW5It9hj8vzz47cwSdcV/M+r3v9cU8+pnxOaC5BjMpZaImOg4Aq/Xk1v3fvvnhyxdeyb9UBsFU21XytWdQQnVE66FeYeTB2qw5C7pYA7VWQJ1qz7CrneuKly75leuqWB5xGqhKa2tg26yEcRBMCevEar3yH/eNpMzH2ef3mnli8NyD6sgRkENwDmAQR5u5vyY7KjIUzCOfGV9bASXpFnvDgahU+/6B1ylxrlKz1l68MaJor0pLL4GXVhBce3o9ziNMVLo7tfX19lQedWdIMROU3ekte662M4X4+4swWB79zHPxBqhmrRXnKvA61XetolL1hoMk3eLXVo7OzHgYzhW0PcAtjloRpzWMaz6RPmMZELGAmSjoP19JwpZDgExrZgQGpkpLK+DbuB3uTaDizPQxZ/M57+05z/G8MJ9XSj/tLM9PTESnNdubarURXXkG3EtbR8joDAggw5ZDJUn6kkcUsIDLgOiIGecjc56b8Gd9Lr95BCuq1/phHqSi+ok1/YVBov3vx0qGDNib0RjY8vOgThV2wk5NaJHPstBTSnSJAvMFVZkX5tMsTABDS98NrJ7Md7sV4NYnsi7zhogMmJVM/5kRLIwj54iH4fzVJ77yfwA8rPKYAvgvR/BRrw0D83DXjPdnjuXnQXiu9193roHX32UOiUi972s4SiD1+HhP/ND4r62sELD03q8vL0HxPLD8XlP5w2s8pTWs8WR5JbQ2mHRWp0jordVvhP/jYXjqq/nXlLKdsEg6B33+g+O7P4wHKR1dJxsl57/3ue+ml3b/9A/ObG9/EX9J+oz84oupPPvs7+OQfUY7LEKWVsAz18A32jD/6/yGmVo7RfnuPSqDEzRJNjJCgRqYRxidlu8XN2ZXrnNz9hJfexrcXmnyZLREZfDAaLfwsx+KZl/xcmXtlJ9tQvCS+pXr0Pd2qigwu3KFM25HCp6EN5NXF6Of7D/70LSKSYowCu7MoVhe1p4zPTAxBZaBw+FbxqELQ83roPc3C/xqEPjYQPCBTKHv9b3QqJ8U52d/93dTEL0K4NXhFupGpxd64YX0Pt5Hxny4pr8qLa2sMLBkmmiGxsZRpVqLNMsiJbIPUiiyZYjSzqrSpcZi9M/3u89CI/2WUawLy1snJyrb3ZOQ7Oa6TdM4CKpBGNhqUHSzUJkshTCUlwZhCBaoknpjtdRCC0KSO7NVpBu7Bebn3ZUrkLU1cPj2RpRMTh5zluZV9URjMfn3++GpX83+Ebj4hZJ7p+wca8+cRYHb1z1wyQPAzHnw+vp6cFh8a1cgSyuwedSdEebznjC3Wk/+3b66upp9h8n9rFtxt2eb03ud6htk/QVDcs+UwQkqOy0CgKA6o9UEggget+GbsxAASFIY69Hn+useeM2vLC1JL6CNjnMWuRnlldbKEsqhVNDvB4xO9Q07ar0MYzucPeyDAl8JdyeRxGlt0loz5cpsilhqgI1UPBsYr6UhADVATwwYyyg2RFu7CHYBU8V0JUlczStXS5dVOKREiWISH8JYq15IWUUFpc81Y+KO0F7beLs7eWx2F7v39tbWTpS1DtidODWhZTEDYFbJTQ0AZxawp5WshJV8It2Urg3OdL1dLwDg7ttJqPZw+HaB7tJ1FJUuOI8OGveJjDcmj+5FcXghdGlWcTaKgcImkxUCAHGF7OZacioZTyTdsEAxFYIy346BYGK/66PgUmd7eyJbWkG5oiqj4nwU6fOVNZgsWQ/j8EIyOr2slCtQ+Ujm8Ik5431HzBJEJDM1luK4Wsx5+EmCbqrynyv5O6uLyd5iIz+uhAsQ/YJCnxr0FqmQ8b6T2K6vAuEphT2tygSVTWVssmBHiW43FuO992ex9ASIZgQ4C+JzotaLDdalKO/VOujkITgqimPC7qySeZKU7QCBYZ7AyoIZFWx6RZNMvAFMt3tVw3ySVA6Fr9bB3ZbDDipN7+wEsRyAQAeyEVtnk8BnxQwBpwxF016R+EIsABBzyYIuEGyR5neti9o5gZ2Jpo2Xkw+/Hls5dt6dnp7fxEXI0z+4xtmZp4NRcT7sQt2tZ2A3TK0iWXFiNHqZ3rxeXhYoZBiYHyFN7fXocBZhvodJl3fnlGgeQlsE/LRRT/YemvI1sr/bqMf/oV/KAsaGEr1zH+AMC5WqeKexGB9o8b7Q2Ps0g39DCfdIuSmuILA9vfrN+L8dRmkLL6dfZua7PXwypXQ4fN7Yu4C7nQRxu0zTWAlPCnC6b5r6SvYdUv9/Cym2rEwkMK72Sr3y0/2xZ8/AclPL0hJRvPrNif+93/XfuJr9DTJ6q5ok2zsFNDaojoLzB2nqv3zln04ez1r/sE/BZHmQWdE2W5WJaGK2MG562HpZeMX9NlD+RXU62fzXv/ePzxh1397Xf154YXn4M+NyrzVgN1HxXJwkDc6ryq3VetyvP4R+pLxfTSQyRFxqEVrm5Gq98vNHcZrV+sSb9UZ+B9C/DWhIgS2UePZQjng1fZKZqwDtsBTswMnqYnIofOTd18DGpe0MAIEipUFjrXVEZNg65ooRTPcNqtATUJ8pm0AJEwNE4WOkdDfrtLNY2DgbjITzYcvFG6DmrLUlc4VHoBeV4nhozUYzR69E5YZQlT1wHv4MGECk2J0R0XMCWR+ElEfuVYmdrq9mj7wXsVGPUoD+u6o7J6LHWXTqUICIKgCMuIKAEMyYOSw+UrwK785aa6Y4pJCFeFBqlEGkZAguUrZ9NwooUQWgyBDFpDrAxgKpABTl3iZFaKc/Cc6HIQ82UGBEegHshHcUJOkWFwiG0oY6mDP2mt5WeK8CBCfIwKzW4z8etiJJVH2pElBYGNKUVD9/mPEaC9GWknmXmaaEER5OYXoC0CKIg0IpKwDeOzS+xXgLxJte/bQwxaQwRDIwwcK9jQKk0jfTYUVACgPAEDDA7hgKSCmMjKvA6eyoOB+FPNhAMQq9sEjAdri7nw7kjEuXQJO7CILSVEX1JHn5s1EokQ1USD1pJxc226RmCLv0tQVQTHq4hEJJWEnaEkgKBHtmePjaBKoBLnKAOXDS4mmgjQJKIOHepoJBNveRhyF1oWdTNTQ6zkdWVB1wA8VB9aIE6mVHwxN7EDMErptdPhfVgriGUuPGYvzGfn9Rb6RVKL4DpjlS2lPSHzUW4j/peysHxKS+W4b5hPptb1Crr2bHIXoCoCfAOAXRE0SIBJSQKoHwJ4168p8fnl3yHVX8plHdra+mn1JFApCs1uPX932G1fw3SXyuzDm8ZEJmT6XY9iVSS6pM1HI8BHyqG0r6aVIKiYkBORI7cIjATikySrGSRI36xGg4H8sBwq8CzdkJDsSE3lNVoe/2Z5L/vhJlpPxzQO+o4psDGYCB5g5aMbUCVLYBepcUlxR8kUiPK6mowV0lcweMd8EkAP2dPqnqLwHvAWkp6Reh/DUCFgaA810FvqoknyemJy2K1kRlshWW3WxibyqjNB4OvsXkbYAiOLKk4KPyrTBiMIFCYqoCPDLOx3IAxpefB9U682xCDtX7ChNt7h8hs5OkCNnjLVZ3SxhvE+nGweDdg5B4KbRQMingchWIAVmIVlTdFKlOA1QDoX9zmdkpcdt42lCROwps97UtxW2wvskib0iOX1o32bRbt/fm5ubKThWihOHhE1hmMAygKkfCQMSLIUWoIhVVujd6zn99ZfA09TmgvdbkaicKHMWxEoo++c0Z9XIP1tyDR4fFkJeyO2BCTEFI3C2jMAxswqGfVqJZYnMM0LYCTSLzLqm2ri7EzQMk2p5UcyW/B7YTUO27UBfVHSu06Wu454OkffI4ihvtszoDUDVBkPq0wixDwcemt24hOTqbxInAHhIwUcw6Os7HcgBnfG0FlFQNE2JDBmHjG9GNPqZ/ilS7zmlqE8m95xLgvsUTFRCYjBJFEzYIS5ITLDyvQneJ8EdX6/HeIxuWQtWp97GW6lGA+hdzlFCUornpunzzHRR//Y/hbzwDvrWJMCzSKWE7R+qeGgY+1aP3poaSIVIxpBRerUd/PgrOx3LgAs792oopGN7aAQxLDJsyVPV5G2piqGr//Xvcq3xZ713VM1dY+Akl/M/VejiUL4KxhapARaE0wH5CUigblTwSOT8DwXpPb3HWreZReMp496QSDQ3fkVvHiJAwGOpHxvlYDlrAeU8Ga9P1XlhyyA+eFpESRQwzbcicJcXPGgvxkTD05ixo7RmwdYiK0E4br+cg9POjgu+xp7SPyPlYHnFmZCnUq+lbXVACOyFjLHEQg/Kc2OhAzs8skog1kYpvNRaTm/sUDKpQXAHhIlSrjcXknw3dwBhsmDjKmWda4OYsOCy6iQgfA/NOYzF+bPiUQHK/Pzbo9jkFiIWYDFhkAD6YVVSUB9gMfQjOH386flC9PM6Z8fISNChFlQLPxhSLjfTc/jMc7TJTIq6Ms4wjsggVEg5i/komUpEpJd7oo8B/AODzJMpEPDlA5Gb5QAOYBkqhKBLHsbNlnEeIrENEaieYeYpUm8PFR3y/6UyDBUYELBSQkmEB6wCFHyYKvEEIUAQZ4Ps0CjWAJ8PFYiP71Gg4PwIp4gH18thnxiz2EpRwSporcdyHxV1V+hzYHiOViBzNMNPkAOSzQgwxTUD0zT7O9RQYb4pTIfV9v0KmJAFKssaAVVTV9HdGEZ0xho9bmtxTRsCSqjemajxqAnlruPh8YGAsBCwYZNcIVZVQAaJcyVseyImpRk5mlDRW0r5v4RNBnKqznnIlikbB+UhTZ2OVvNNh6+WxzozLgE7tlFI6KVk0VdV9o2SjHl9XQtUQ5o3SU4A+qeDOAOQTsWEW2A++C/gQY7QqGhMjAZu+m3tJTUKWQmeIlSFE/St9zNRVj0/7wv8Vp9lTYYE5FplWksrqPq8OPRo+SuB9BPiBjIFUrbCeNOSnYClS6k+nqk4R86cAPAnQG4MUZZhMoaSpqj45Cs5HJcarenUDdWwPqpfHXsDpVDOJSQoypkuq4QDG8l9V9CIMfQGkoQJ/0D/as5J6HeQlIiK9xsTzAJ2Hyn8aQOXvADRBSgZWnZIeG4ClF5T0XUO0CdY/FabTKnqSlJKh42P6pTAlpNYMkkKT4t8C9JZXPQUvFVIZhM+fkYqq0iur9f7vdSqpiGgJcBeq0Sg4H4XMtKAuqIqF9YME3YPq5fGmqUR691/8VE4/caGAKTrs6dxiI5vYr6/WWEx+AeAXB6zIiRKXqpLVV/OLjYWH9zMbC/G/qTeyayBab9TjASIwrQr73zI+ZAAlqXYWG+nZq/Xk9j7RvgPgDx/8e+Hq3h2AvqwiwWIj++zVevz/hoVPiV5mwe8ACMDc19mv1uO3ALxVv5o/RaQxQH0DZGMx+sMDFTYUYgiFsMmgOhLOh5+bkt74kWrU3JUgSUpC/yByUL089pnx/MxNKQMUXqSj5HcF+OzQ9agQeJ8b5V1VfaKvEuvx64M5ItBYiFLj7YxwIUY08yo7wubTB8G3ujjxU2IqQLACOj9sfEqYcdBcRWmxkR4f0PbuofdK8sRCI58YsoF4UpMbrx2FjIpzJTPcfuRsE8pV55yVTEipvjpcvZBC2Yb62JxxZWlJjH/DkbquU2oy8JmDkl9vZPsu6IW1gOEuIC1SnDmoEuuN/KHjLzSyz8FqDtgckD0yZoucHFtopAe6h6r+CIAH9LP1q9nQ8NVXs8/D654hbRtL94TN5wbCA72rClbRPYZeHqaBKHEhXBTeSQeKkXCuxE49xHgdmnFfvg61/pgLnKYG3CLVzwxTL8JcioME5fAwH6yfQqTVzgWXdtLUMG+SwTpDnjkAKVUA3+qz5uiSml0vsgWhuwC+PPj4aQXQf1JvZA8xYp0T0Y6zkgLlnpJvEWObiL98EDWs1pPXwfRnpGgBeGZY+MjrHBNtq/PbrvRNFn98oZH3XdcS+AaYcyXdBugziwMGl/pqfqF+Nf1uPz4s25RC1w3A90bCubi0FyDV85D2xy8/B41TOCDeE+ZNYswPGtgH0Qvg9ozVMk2OSYhSP3lnBLCyBLl4fjYPi3gHht4RFb9wNf36Yp9oudjIz0HxbSj6RElqAdIiy1sa0DuACxcb+VfrV9N+458l8LdAdJNAf7N+NbvwcdVKFrMTFUmah7VUqdg1vrxDimCxkX+1vjqYES808kvClBLhFoPjhUb6O8PAp4ZiNmYrSHgbATdJsU6kv11fzY7tv3aMUlL3F1BqAmgp8Zf6GtzV/DdU9VtK5Pe7zqtuUS57RbdIi3A0nAtjm0W6beccDWsra++7q76dNjNSv0XAlir+2rD0QhxuliLZbAQPP6zU9xE+Yrysyj9+BYHwbiUoo+PCOgfBSSXaINL1xkLvpeNe+kdzDJoX1dNMtA04J2xDFomVTEAqrMTeEFL1sq3EG8aHWyzbeR7ZgDSYEdEzBMwy6YYS3Xkwfs8B6DxYTwI4QUpNEU3JUCiix5m1Q2o2BLLBsA7wl5Twyx3X2br8xInsRhtmptWu5FF4XEnnSDEL0AaptpRovbEQbd5/juOkdIYMTUP0uAh2md1d5yWzJo4BmRXFiWHg8yXeNkG+0wtM0aR6nWM2p5T8JgTvNhaTNz4QFM6CqULqYxGEQWjaUsICMquCaWVdJ8XtxmKvQLXYyM8K9CQgTzAoBnhXCaKCmIliJQS9iiw7Ye0CsoW8eJcDbHWbrRTz84jy3YlRcC5c3DuVVNvzf4RieZmGMz+q0tLK9aAMLk3kUX4cTs8ScGxYeomgm6+Xd/ZeW7pU6hC+m/qIXxR//5joKN9O9iaimnVmmpSnAT8pKgkxmNQ4EU1hZZfU7Gqhewr1FJFRgiUlYx3IWShp7owEmU3irkuRxufhmnfBle5OwhrVSvHTbM00qdSUbAx4QwqnxHuksitstkMTtkvXLTVjqxNcQekn2XCiHkTGdI33m6YWt4Im9i4vwb3WO4vRRgkSLVArXTEtzFOkvsZCiagPeh0HU3rVjFk7bMxOUfjdiOK2cduOatMm38mqYv3UMPAJ59vdylSapNBgEqG00kkKzDRKmRGSKVJKlGCVjADIRaSjkJZh3jQSd53pkOa2wqGfZjHTHlIDKIIxIOdKYtMllV0l0/ZG0t6Xzsl+kA9hiLNaskgW5Ulne/tWNluZL3vtLdjRcL6etqtzxbCPj19eVv7xl3p26u30pOfuseHq5Sflyt9bkmFsiD/E5/17DnnnGsyt6xshnUyiKLexEkfeUCAMsq4HXvckt9FENlFBmXUgeQiKM3AZgMpOi4LqjAblPVU+4Z15w1c7F9zl69DeWQeXzc7UpYAUUZTvfXR8pyWHPguLSuYtiva9WzL7mXlq3W6FbIMoDEzgC1BgpSyDSgogr3bgVpZ6fcxl3H+GzY2QNImAyYg0i6yjgNA7CUqhvlB1cSy56fjcztTyTory3ElIKwHt3MbQ8V1egr78g2vmzJkzgdBcZPxe8mBs0tKwhloE6sJSizx0WZxV091JlPcridYdQ5TtpAlHHCr1WlhK8KGRIoXPp7ia7whcVEDbaZMno1n6IB8f+xn7D+prBJyvLEGGfzBuz05fW7lum5gNZ47NDl8vQ/q8/+HO2ngvFQDfPA+utWHCYsPEmWHgBKJJaNaBOAN/923I+RnI5d5BNB85oQlYweXrS/r+oTL3SRlw/DSBv3IFstw7lARra+DZZm9j92zzNnWqZ+Xu29fkm99/2i8Dv3oa8oN7tMC18JapnZjnuArOd3tIHtynXYVcrMG3bkLeO1AHwIjwAapYWlnhm60lrl18f+wyYArKY7qbQ2vJujgz9974eB547RIIuG5uY9LUps5ynN1jAMjiEzK1A8Fl+OZdyIPre3z86la6fQ++GTXno5D3jqMYjV6G4Yy9F84G+BnkYaFKy8vKy6q89NJLZlmVl5f1/iGjhzxo9MDj966HKuHBNf0OO/2Ye3zkPg8bY5T4PjK2mqWXdP/xP/Q3D37euxeG8CLzqDkfkVOOQi+D+tF+P6Q6fvdzLGM5CsJjFYxlLGNnHMtYxjJ2xrGMZeyMYxnLWMbOOJaxjJ1xLGMZywDy/wcAtEN4yeiJqMUAAAAASUVORK5CYII=";
})();

//"use strict";
var DataLudi = (function ($) {
	var _win = $ || window;
	var _doc = ($ && $.document) || document;
	var _ver = "1.4.0.15780";
	var $$_rootContext = "";
    var $$_assets = "assets/";

	var _setRootContext = function (path) {
        path = _toStr(path);
		if (path) {
			path = String(path).trim();
		}
		if (path && path.lastIndexOf('/') != path.length - 1) {
			path += '/';
		}
		$$_rootContext = path;
	};
    var _setAssetRoot = function (path) {
        path = _toStr(path);
        if (path) {
            path = String(path).trim();
        }
        if (path && path.lastIndexOf('/') != path.length - 1) {
            path += '/';
        }
        $$_assets = path;
    };
	var _getAsset = function (url) {
		return "url(" + $$_rootContext + $$_assets + url + ")";
	};
	var _getVersion = function () {
		return _ver;
	};

if (!Function.prototype.bind) {
	Function.prototype.bind = function (oThis) {
		if (typeof this !== 'function') {
			throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
		}
		var aArgs   = Array.prototype.slice.call(arguments, 1),
			fToBind = this,
			fNOP    = function() {},
			fBound  = function() {
				return fToBind.apply(this instanceof fNOP
						? this
						: oThis,
					aArgs.concat(Array.prototype.slice.call(arguments)));
			};
		fNOP.prototype = this.prototype;
		fBound.prototype = new fNOP();
		return fBound;
	};
}
if (!String.prototype.trim) {
	(function() {
		var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
		String.prototype.trim = function() {
			return this.replace(rtrim, '');
		};
	})();
}
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(searchElement, fromIndex) {
		var k;
		if (this == null) {
			throw new TypeError('"this" is null or not defined');
		}
		var O = Object(this);
		var len = O.length >>> 0;
		if (len === 0) {
			return -1;
		}
		var n = +fromIndex || 0;
		if (Math.abs(n) === Infinity) {
			n = 0;
		}
		if (n >= len) {
			return -1;
		}
		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
		while (k < len) {
			if (k in O && O[k] === searchElement) {
				return k;
			}
			k++;
		}
		return -1;
	};
}
if (!Array.prototype.filter) {
	Array.prototype.filter = function(fun/*, thisArg*/) {
		'use strict';
		if (this === void 0 || this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;
		if (typeof fun !== 'function') {
			throw new TypeError();
		}
		var res = [];
		var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
		for (var i = 0; i < len; i++) {
			if (i in t) {
				var val = t[i];
				if (fun.call(thisArg, val, i, t)) {
					res.push(val);
				}
			}
		}
		return res;
	};
}
(function () {
	var lastTime = 0;
	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = function (callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				},
				timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}
}());
var UNDEFINED;
var $_language = (window.navigator.language || window.navigator.userLanguage || "").substr(0, 2);
var $_debug = false;
var $_testing = false;
var $_logging = false;
var $_evl = window.addEventListener;
var console = window.console;
var log = console && typeof console.log == "function" ? Function.prototype.bind.call(console.log, console) : undefined;
var _console = console;
var MSECS_PER_DAY = 24 * 3600 * 1000;
var __epoch = new Date().getTime();
var __epochlc = new Date(__epoch - MSECS_PER_DAY * 3);
var toString = Object.prototype.toString;
var PI = Math.PI;
var _2PI = Math.PI * 2;
var _RADIAN = 180 / Math.PI;
var MAX_INT = Math.pow(2, 53) - 1;
var MIN_INT = -MAX_INT;
var _sigma = '\u03A3';
var $_autoinc = 0;
var $_temp_size = { width: 0, height: 0 };
var $_csvreg = /,(?=(?:[^"]*"[^"]*")*(?![^"]*"))/; // ,뒤에 "가 없거나 반드시 짝수개로 존재할 때만(?)
var $_colonreg = /;(?=(?:[^"]*"[^"]*")*(?![^"]*"))/; // ,뒤에 "가 없거나 반드시 짝수개로 존재할 때만(?)
var $_linereg = /\r\n|\r|\n/;
var $_currencyreg = /[^\d.\-\+]/g;
var $_linebrreg = /(?:\r\n|\r|\n)/g;
var $_linebr = '<br>';
var $_NULL_FUNC = function () {};
var $$_loc = window.location;
var $$_htmlreg = /[<>]/g;
var $$_htmlmap = { '<': '&lt;', '>': '&gt;'};
var $$_htmlrep = function (s) { return $$_htmlmap[s]; };
var $$_image64 = "data:image/png;base64,";
var _lictool = 'tool';
var _runloc = window.location;
var _isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
var _isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
var _isFirefox = (navigator.userAgent.indexOf("Firefox") >= 0) || (typeof InstallTrigger !== 'undefined');   // Firefox 1.0+
var _isChrome = !!window.chrome && !_isOpera;              // Chrome 1+
var _isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification)
    ||(!_isChrome && !_isOpera && window.webkitAudioContext !== undefined);
var _isIE = /*@cc_on!@*/false || !!document.documentMode || /Edge/i.test(navigator.userAgent); // At least IE6
var _ieVer = (function(){
    var undef,
        v = 3,
        div = document.createElement('div'),
        all = div.getElementsByTagName('i');
    while (
        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
            all[0]
        );
    return v > 4 ? v : undef;
})();
var _ieOld = _ieVer !== undefined && _ieVer <= 9;
var _ieLeg = _ieVer !== undefined && _ieVer <= 8;
var _norgba = false;
var _ieTen = navigator.appVersion.indexOf("MSIE 10") !== -1;
var _window = window;
var _document = document;
var _nop = function () {};
var _throwDebug = _nop;
var _check = _nop;
var _assert = _nop;
var assert = _assert;
var _setDebug = function (debug) {
    $_debug = debug;
    _throwDebug = debug ? function (err) {
        throw err instanceof Error ? err : new Error(err);
    } : _nop;
    _check = debug ? function _ok(v, msg) {
        if (!v) throw new Error('Failed: [' + v + '] ' + msg);
    } : _nop;
    assert = _assert = debug ? function (test, message) {
        if (!test) {
            throw new AssertError(message);
        }
    } : _nop;
};
var _log = function () {
    log && log.apply(console, arguments);
};
var _dlog = function () {
    $_debug && log && log.apply(console, arguments);
};
var _setLogging = function (logging) {
    $_logging = logging;
};
var _trace = function () {
	$_logging && log && log.apply(console, arguments);
};
var trace = _trace;
var _dtrace = function () {
    $_debug && $_logging && log && log.apply(console, arguments);
};
var _createError = function (name, arg) {
    var f = function (message, v1) {
        this.name = name; // 이 것을 안하면 chrome console에서 error type이 표시되지 않는다.
        this.message = message;
        if (typeof (arg) == 'string') {
            this[arg] = v1;
            if (v1) {
                this.message += '\r\n' + JSON.stringify(v1);
            }
        }
    };
    f.prototype = new Error();
    f.prototype.constructor = f;
    return f;
};
var _throwError = function (message) {
    throw new Error(message);
};
var _DPPX = _window.devicePixelRatio ||
    (_window.matchMedia && _window.matchMedia("(min-resolution: 2dppx),(-webkit-min-device-pixel-ratio: 1.5),(-moz-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5)").matches ? 2 : 1) || 1;
_DPPX = isNaN(_DPPX) ? 1 : Math.max(1, Math.floor(_DPPX));
var _isValidAddr = function (domains, d) {
    var i, j, valid, host,
        arr = d.split('.');
    for (i = domains.length; i--;) {
        if (domains[i] == $$_fileloc) return true;
        if (d) {
            if (d == domains[i]) return true;
            host = domains[i].split('.');
            valid = true;
            for (j = Math.min(arr.length, host.length); j--;) {
                if (host[j] != '*' && arr[j] != host[j]) {
                    valid = false;
                    break;
                }
            }
            if (valid) return true;
        }
    }
};
var alertOnce = (function () {
	var alerted = false;
	return function (message) {
		if (!alerted) {
			alerted = true;
			alert(message);
		}
	}
}());
var _alert = function (message) {
    alert(message);
};
var _alertConfirm = function (msg) {
    alert(msg);
};
var _getTimer = function () {
	return new Date().getTime() - __epoch;
};
var getTimer = _getTimer;
var _setTimeout = function (callback, delay, param1) {
    setTimeout(callback, delay, param1);
};
function _defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}
var defined = _defined;
function _isEmpty(value) {
    return value === UNDEFINED || value === null || value === "";
}
function _isNaN(value) {
	return value === null || isNaN(value);
}
function _isObject(obj) {
	return obj !== null && typeof obj === "object";
}
var isObject = _isObject;
function _asObject(obj) {
    return (obj !== null && typeof obj === 'object') ? obj : null;
}
function _makeObject() {
    var obj = {};
    for (var i = 0, len = arguments.length; i < len; i += 2) {
        obj[arguments[2 * i]] = arguments[2 * i + 1];
    }
    return obj;
}
function _isEmptyObject(obj) {
    if (obj == null) return true;
    for(var p in obj) {
        if(obj.hasOwnProperty(p))
            return false;
    }
    return true;
}
function _equalTexts(s1, s2, ignoreCase) {
	if (s1 && s2) {
		return ignoreCase ? s1.toLowerCase() == s2.toLowerCase() : s1 == s2;
	} else {
		return !s1 && !s2;
	}
}
function _replaceChar(s, start, end, char) {
    var s2 = '';
    end = Math.min(end, s.length);
    for (var i = start; i < end; i++) {
        s2 += char;
    }
    return s.substr(0, start) + s2 + s.substr(end);
}
function _isFunction (v) {
    return typeof v === "function";
}
function _asFunction (v) {
	return typeof v === "function" ? v : null;
}
var _isFunc = _isFunction;
var _asFunc = _asFunction;
function _isString (v) {
	return typeof v === "string";
}
function _isNumber(v) {
	return typeof v === "number";
}
function _isFiniteNumber(v) {
	return typeof v === "number" && isFinite(v);
}
function _isBoolean(v) {
    return typeof v === 'boolean';
}
function _isWhiteSpace(s) {
	return !s || !s.trim();
}
function _forceFloat(v) {
    v = Number(v);
	return isNaN(v) ? 0 : v;
}
function _isInt(v) {
    if (isNaN(v)) return false;
    var x = parseFloat(v);
    return (x | 0) === x;
}
function _forceInt(v) {
	v = Number(v);
	return isNaN(v) ? 0 : Math.floor(v);
}
function _isDate(d) {
    return toString.call(d) === '[object Date]';
}
var _isArray = (function () {
    if (typeof Array.isArray === 'function') {
        return Array.isArray;
    } else {
        return function (value) {
            return toString.call(value) === '[object Array]';
        }
    }
})();
var isArray = _isArray;
function _asArray(obj) {
	 return _isArray(obj) ? obj : null;
}
var asArray = _asArray;
function _makeArray(obj) {
	return _isArray(obj) ? obj : [obj];
}
function _equalsArray(a1, a2) {
    var len, v1, v2, i;
    if ((a1 === null || a1 === undefined) && (a2 === null || a2 === undefined)) {
        return true;
    }
	if (!_isArray(a1) || !_isArray(a2)) {
		return false;
	}
	len = a1.length;
	if (a2.length != len) {
		return false;
	}
	for (i = 0; i < len; i++) {
        v1 = a1[i];
        v2 = a2[i];
        if (v1 instanceof Date && v2 instanceof Date) {
            if (v1.getTime() != v2.getTime()) {
                return false;
            }
        } else if (a1[i] != a2[i]) {
            return false;
        }
	}
	return true;
}
function _dedupe(arr) {
    for (var i = arr.length - 1; i > 0; i--) {
        if (arr[i] === arr[i - 1]) {
            arr.splice(i, 1);
        }
    }
};
function _asDate(d) {
    return d instanceof Date ? d : null;
}
function _toDate(d, converter) {
    if (d instanceof Date) return d;
    if (typeof d === "string") {
        return converter ? converter.getDateNull(d) : new Date(d);
    }
    if (d && d.getTime) return new Date(d.getTime);
    return undefined;
}
function _isFontText(v) {
    return typeof v === 'string' && v.lastIndexOf('pt') == v.length - 2;
}
function _irandom(max) {
    return Math.floor(Math.random() * max);
}
function _irandom2(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}
function _tempSize(w, h) {
	$_temp_size.width = w;
	$_temp_size.height = h;
	return $_temp_size;
}
function _pick() {
    var i, v,
	    args = arguments,
	    len = args.length;
	for (i = 0; i < len; i++) {
		v = args[i];
		if (v !== undefined && v !== null) {
			return v;
		}
	}
	return UNDEFINED;
}
function _pickStr(s1, s2) {
    return (s1 === undefined || s1 === null) ? s2 : s1;
}
function _included(value) {
	var i,
        args = arguments,
	    len = args.length;
	for (i = 1; i < len; i++) {
		if (args[i] == value) {
			return true;
		}
	}
	return false;
}
function _getObj(source, path) {
	if (source && path) {
		var i, cnt,
            arr = path.split("."),
		    v = source;
		for (i = 0, cnt = arr.length; v && i < cnt; i++) {
			v = v[arr[i]];
		}
		return v;
	}
	return null;
}
function _toStr(value) {
    if (typeof value === "number") {
        return !isNaN(value) ? String(value) : "";
    } else {
        return value !== null && value !== undefined ? String(value) : "";
    }
}
function _toLower(value) {
    return typeof value === 'string' ? value.toLowerCase() : value;
}
function _toUpper(value) {
    return typeof value === 'string' ? value.toUpperCase() : value;
}
function _strLen(value) {
    return typeof value === 'string' ? value.length : 0;
}
function _pad(value, len, c) {
	var s = String(value);
	len = Math.max(len || 2, 1);
	c = c || '0';
	return new Array(len - s.length + 1).join(c) + s;
}
var pad = _pad;
function hex(value, len, c) {
	len = Math.max(len || 2, 1);
	c = c || 0;
	var s = value.toString(16);
	return new Array(len - s.toString(16).length + 1).join(c) + s;
}
var $$_week_days = ['일', '월', '화', '수', '목', '금', '토'];
var $$_month_days = [
    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
];
function _isLeapYear(year) {
	return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
}
function _incMonth(d, delta) {
    var day = d.getDate();
    d.setDate(1);
    d.setMonth(d.getMonth() + delta);
    d.setDate(Math.min(day, $$_month_days[_isLeapYear(d.getYear()) ? 1 : 0][d.getMonth()]));
    return d;
}
function _minDate(d1, d2) {
	if (d1 !== null) return d1;
	if (d2 !== null) return d2;
	return d1.getTime() < d2.getTime() ? d1 : d2;
}
function _maxDate(d1, d2) {
	if (d1 !== null) return d2;
	if (d2 !== null) return d1;
	return d1.getTime() > d2.getTime() ? d1 : d2;
}
function _toArray(v) {
	return _isArray(v) ? v : defined(v) ? [v] : null;
}
var toArray = _toArray;
function incArray(array, value) {
	array.push(value);
	return value;
}
function _getter(prop) {
	return "get" + prop.chartAt(0).toUpperCase() + prop.substr(1);
}
function _setter(prop) {
	return "set" + prop.charAt(0).toUpperCase() + prop.substr(1);
}
function _isWhitespace(c) {
	return /\s/.test(c);
}
function _trim(s) {
	return s ? s.trim() : s;
}
var trim = _trim;
var _trimLeftRgx = /^\s+/;
function _trimLeft(s) {
    return s ? s.replace(_trimLeftRgx, '') : s;
}
var _trimRightRgx = /\s+$/;
function _trimRight(s) {
    return s ? s.replace(_trimRightRgx, '') : s;
}
var _stripRgx = /(\s+)(.*)(\s+)$/;
var _stripRgx2 = /\s+/g;
function _strip(s) {
    s.replace(_stripRgx, function (match, p1, p2, p3) {
        return p1 + p2.replace(_stripRgx2, '') + p3;
    });
    return s ? s.replace(_stripRgx, '') : s;
}
function _capitalize(s) {
	return s.charAt(0).toUpperCase() + s.substr(1);
}
function _uncapitalize(s) {
	return s.charAt(0).toLowerCase() + s.substr(1);
}
function byteLength(str) {
	var b, i, c;
	for (b = i = 0; c = str.charCodeAt(i++); b += c >> 11 ? 3 : c >> 7 ? 2 : 1);
	return b;
}
function _createProperties(obj, props, def) {
	if (props) {
		var names = props.split(",");
		for (var i = 0, cnt = props.length; i < cnt; i++) {
			obj[names[i]] = def;
		}
	}
}
var _floor = Math.floor;
var _int = Math.floor;
var _round = Math.round;
var _ceil = Math.ceil;
var _abs = Math.abs;
var _slice = Array.prototype.slice;
function _enum(name, domain, map) {
	if (domain) {
		var p, v, f,
            d = domain.$DOMAIN = {};
		for (p in domain) {
			v = domain[p];
			if (typeof v === 'string') {
				d[v] = p;
			}
		}
		domain.$ENUM = name;
        if (map) {
            for (f in map) {
                domain[f] = map[f];
            }
        }
		return Object.freeze ? Object.freeze(domain) : domain;
	}
}
function _getEnumLength(enumType) {
    var v, t,
        cnt = 0;
    if (enumType && (t = enumType.$DOMAIN)) {
        for (v in t) {
            cnt++;
        }
    }
    return cnt;
}
function _getEnumNames(enumType) {
	var vals, t, v;
	if (enumType && (t = enumType.$DOMAIN)) {
		vals = [];
		for (v in t) {
			vals.push(t[v]);
		}
	}
	return vals;
}
function _getEnumValues(enumType) {
	var vals, t, v;
	if (enumType && (t = enumType.$DOMAIN)) {
		vals = [];
		for (v in t) {
			vals.push(v);
		}
	}
	return vals;
}
function _isEnum(v) {
	return v && v.$ENUM;
}
function _isEnumValue(v, enumType) {
	return v && enumType && enumType.$ENUM && enumType.$DOMAIN.hasOwnProperty(v);
}
function _checkEnumValue(enumType, v) {
		if (!v || !enumType.$DOMAIN.hasOwnProperty(v)) {
			throw "Invalid " + enumType.$ENUM + " value: " + (typeof v === 'string' ? '"' + v + '"' : v);
		}
	return v;
}
function _clone(v) {
	var p,
        c = new v.constructor();
	for (p in v) {
		c[p] = v[p];
	}
	return c;
}
function _extend(obj) {
    var i, len, src, prop;
	obj = obj || {};
	for (i = 1, len = arguments.length; i < len; i++) {
		src = arguments[i];
		if (src) {
			for (prop in src) {
				obj[prop] = src[prop];
			}
		}
	}
	return obj;
}
function _deepExtend(obj) {
    var i, len, src, prop, v, arr, j;
	obj = obj || {};
	for (i = 1, len = arguments.length; i < len; i++) {
		src = arguments[i];
		if (src) {
			for (prop in src) {
				v = src[prop];
				if (_isArray(v)) {
					arr = [];
					for (j = 0; j < v.length; j++) {
						arr.push(_deepExtend(v[j]));
					}
					v = arr;
				} else if (_isObject(v)) {
					v = _deepExtend({}, v);
				}
				obj[prop] = v;
			}
		}
	}
	return obj;
}
var _createCallback = function (script) {
	return typeof script == "function" ? script :
		typeof script == "string" ? eval('({func:function () {' + script + '}})').func : null;
};
var AbortError = _createError('DataLudi.AbortError');
var _abort = function (message) {
    throw new AbortError(message);
};
var _checkAbort = function (func, caller, args) {
    try {
        func.apply(caller, _slice.call(arguments, 2));
    } catch (err) {
        if ((err instanceof AbortError)) return false;
        throw err;
    }
    return true;
}
var _rethrow = function (err) {
    if (!(err instanceof AbortError)) throw err;
}
function AssertError(message) {
	this.message = message || "Assert error";
}
AssertError.prototype = new Error();
AssertError.prototype.constructor = AssertError;
var DLCallback = { data: 'ludi' };
var NullFunc = function () {};
var _EnumProperty = function (enumType, defaultValue) {
	this.$enum = enumType;
	this.defaultValue = defaultValue;
};
var EnumProp = function (enumType, defaultValue) {
	return new _EnumProperty(enumType, defaultValue);
};
var _IntegerProperty = function (defaultValue) {
	this.defaultValue = defaultValue;
};
var IntProp_0 = new _IntegerProperty(0);
var IntProp = function (defaultValue) {
	return new _IntegerProperty(defaultValue);
};
var _INHERITTING = {};
var DLBase = function () {
    this.$_hash = String(++DLBase.$_hash);
};
DLBase.$_hash = 0;
DLBase.isProperty = function (ctor, prop) {
    var attrs,
        f = ctor;
    while (f) {
        attrs = f.$attrs;
        if (attrs && prop in attrs) {
            return true;
        }
        f = f.prototype.$base && f.prototype.$base.constructor;
    }
    return false;
};
DLBase.getPropertyNames = function (ctor) {
	var attrs, p,
        names = [],
	    f = ctor;
	while (f) {
		attrs = f.$attrs;
		if (attrs) {
			for (p in attrs) {
				if (names.indexOf(p) < 0) {
					names.push(p);
				}
			}
		}
		f = f.prototype.$base && f.prototype.$base.constructor;
	}
	return names;
};
DLBase.getPropertyDefaults = function (ctor) {
	var attrs, p, attr,
        props = {},
	    f = ctor;
	while (f) {
		attrs = f.$attrs;
		if (attrs) {
			for (p in attrs) {
				if (!props.hasOwnProperty(p)) {
					attr = attrs[p];
					props[p] = attr.value;
				}
			}
		}
		f = f.prototype.$base && f.prototype.$base.constructor;
	}
	return props;
};
$_getAllAttrs = function (f) {
    var b, p, baseAttrs,
        attrs = f.$attrs2 = {};
    if (f.Base) {
        b = f.Base.constructor;
        baseAttrs = b.$attrs2 || $_getAllAttrs(b);
        for (p in baseAttrs) {
            attrs[p] = baseAttrs[p];
        }
    }
    baseAttrs = f.$attrs;
    for (p in baseAttrs) {
        attrs[p] = baseAttrs[p];
    }
    return attrs;
};
var $$clscnt = 0;
var defineClass = function (name, baseClass, members, statics, callback) {
	if (baseClass !== null && !(typeof baseClass == "function")) {
		if ($_debug) debugger;
		throw "Base class is not a function";
	}
    var attrs, p, v, noinit, getter, getter2, setter, fn, notifier, $attr, $attrs,
	    f = function () {
            if (arguments[0] !== _INHERITTING) {
                this.$inited = false;
                this.init && this.init.apply(this, arguments);
                this.$inited = true;
            }
        },
        proto = f.prototype = baseClass ? new baseClass(_INHERITTING) : new DLBase(_INHERITTING);
    $$clscnt++;
	proto.constructor = f;
	f.Base = proto.$base = baseClass ? baseClass.prototype : DLBase.prototype;
	proto.$name = name;
	if (members) {
		attrs = {};
		for (p in members) {
			v = members[p];
            if (v === DLCallback) {
                proto[p] = undefined;
            } else if (typeof v === "function") {
				v.$name = p;
				v.$owner = proto;
				proto[p] = v;
			} else {
				attrs[p] = v;
			}
		}
        $attrs = f.$attrs = {};
		for (p in attrs) {
            $attr = $attrs[p] = {
                $enum: undefined
            };
            v = attrs[p];
            noinit = false;
			name = _capitalize(p);
			getter = p;
			setter = "set" + name;
			notifier = p + "PropChanged";
			fn = null;
			getter2 = p + "_";
            if (proto[getter2] === NullFunc) {
                fn = proto[getter] = null;
                delete proto[getter2];
            } else if (proto.hasOwnProperty(getter2)) {//[getter2]) { // "prop_" 함수로 getter를 지정할 수 있다.
				fn = proto[getter2];
				delete proto[getter2];
			} else if (v && v.get) {
				fn = v.get;
                noinit = true;
			} else if (!proto.hasOwnProperty(getter)) {//[getter]){
                /*
				fn = (function (p) {
					return function () {
						return this["_" + p];
					};
				})(p);
				*/
                fn = new Function('return this._' + p + ';');
			}
			if (fn && fn !== NullFunc) {
				fn.$name = getter;
				fn.$owner = proto;
				proto[gg = getter] = fn;
			}
			fn = null;
			if (v && v.set) {
                fn = v.set;
                noinit = true;
            } else if (proto[setter] === NullFunc) {
                fn = proto[setter] = null;
			} else if (!proto.hasOwnProperty(setter) && (!v || !v.hasOwnProperty("set"))) { // 명시적으로 set을 null로 지정하면 read-only 속성이 된다.
				if (v instanceof _EnumProperty) {
					fn = (function (e, p, getter) {
						return function (value) {
							_checkEnumValue(e.$enum, value);
							var oldValue;
							if (proto[getter] && (oldValue = proto[getter].call(this)) != value) {
								this["_" + p] = value;
								if (this.$inited) {
									if (this[notifier]) this[notifier].call(this, p, oldValue, value);
									else this.propertyChanged(p, oldValue, value);
								}
							}
							return this;
						};
					})(v, p, getter);
				} else if (v instanceof _IntegerProperty) {
					fn = (function (p, getter) {
						return function (value) {
							var oldValue;
							value = parseInt(value);
							if (!isNaN(value) && proto[getter] && (oldValue = proto[getter].call(this)) != value) {
								this["_" + p] = value;
								if (this.$inited) {
									if (this[notifier]) this[notifier].call(this, p, oldValue, value);
									else this.propertyChanged(p, oldValue, value);
								}
							}
							return this;
						};
					})(p, getter);
				} else {
					fn = (function (p, getter) {
						return function (value) {
							var oldValue;
							if (proto[getter] && (oldValue = proto[getter].call(this)) != value) {
								this["_" + p] = value;
								if (this.$inited) {
									if (this[notifier]) this[notifier].call(this, p, oldValue, value);
									else this.propertyChanged(p, oldValue, value);
								}
							}
							return this;
						};
					})(p, getter);
				}
			}
			if (fn) {
				fn.$name = setter;
				fn.$owner = proto;
				proto[ss = setter] = fn;
			}
            if (v instanceof _EnumProperty) {
                $attr.$enum = v.$enum;
                v = v.defaultValue;
            } else if (v instanceof _IntegerProperty) {
                v = v.defaultValue;
            } else if (v && v.hasOwnProperty('value')) {
                v = v.value;
                noinit = false;
            }
            if (noinit) {
                $attr.noinit = noinit;
            } else {
                $attr.field = "_" + p;
                $attr.value = v;
            }
            $attr.getter = proto[getter] ? getter : null;
            $attr.setter = proto[setter] ? setter : null;
		}
	}
	if (statics) {
		for (p in statics) {
			f[p] = statics[p];
		}
	}
	if (typeof callback === "function") {
		callback.call(f, f, statics);
	}
	return f;
};
var _throwCallerError = function () {
    throw new Error("Not supported Function.caller");
}
var _throwInvalidMethod = function (method) {
    throw new Error("Method is not exists: " + method);
}
var _throwCheckedError = function (err) {
    throw err instanceof Error ? err : new Error(err.message || err);
};
var _throwDebugError = function (err) {
    if ($_debug) {
        throw err;
    }
};
var _throwAbstractError = function () {
    var caller = _throwAbstractError.caller;
    throw new Error(Locale._default.notImplemeted + (caller ?  (": " + caller.$owner.$name + "::" + caller.$name) : ""));
};
var _cast = function (obj, clazz) {
    return obj instanceof clazz ? obj : null;
};
var $$_locproto = window.location.protocol;
var Base = DLBase.prototype;
Base.constructor = DLBase;
Base.init = function (nohash) {
	!nohash && (this.$_hash = String(++DLBase.$_hash));
    var p, attr, f,
        attrs = this.constructor.$attrs2 || $_getAllAttrs(this.constructor);
    for (p  in attrs) {
        attr = attrs[p];
        if (!attr.noinit) {
            v = attr.value;
            if (typeof v === 'function') {
                v = v.call(this);
            }
            this[attr.field] = v;
        }
    }
};
Base._super = function () {
	var fn,
        m = this._super.caller;
	if (m) {
		fn = m.$owner.$base[m.$name];
		if (fn) {
			return fn.apply(this, arguments);
		}
	} else {
		_throwCallerError();
	}
};
Base._callbase = function (method) {
	this.constructor.prototype.$base[method].apply(this, _slice.call(arguments, 1));
};
Base.className = function () {
	return this.constructor.prototype.$name;
};
Base.baseClass = function () {
	return this.constructor.prototype.$base;
};
Base.baseClassName = function () {
	var base = this.constructor.prototype.$base;
	return base && base.$name;
};
Base.clone = function (props) {
    var attr, p,
	    f = this.constructor,
	    obj = new f(props),
	    attrs = f.$attrs2;
	for (p in attrs) {
		attr = attrs[p];
		obj[attr.field] = this[attr.field];
	}
	return obj;
};
Base.assign = function (source) {
    if (source === this) return;
    var attrs, p, thisAttr, gg, ss, v,
        thisAttrs = this.constructor.$attrs2;
	if (source instanceof DLBase) {
        attrs = source.constructor.$attrs2;
        for (p in attrs) {
            thisAttr = thisAttrs[p];
            if (thisAttr && (ss = thisAttr.setter)) {
                attr = attrs[p];
                if (gg = attr.getter) {
                    v = source[gg].call(source);
                    this[ss].call(this, v);
                }
            }
        }
	} else if (_isObject(source)) {
        for (p in source) {
            thisAttr = thisAttrs[p];
            if (thisAttr && (ss = thisAttr.setter)) {
                this[ss].call(this, source[p]);
            }
        }
	} else {
		this.assignSimple(source);
	}
    return this;
};
Base.assignSimple = function (source) {
};
Base.assignProps = function (source, props) {
    var attrs, attrs2, i, cnt, p, attr, attr2, ss, gg, v;
	if (source && source !== this && props) {
        attrs = this.constructor.$attrs2;
        if (source instanceof DLBase) {
            attrs2 = source.constructor.$attrs2;
            for (i = 0, cnt = props.length; i < cnt; i++) {
                p = props[i];
                attr2 = attrs2[p];
                if (attr2 && (gg = attr2.getter)) {
                    attr = attrs[p];//this.getAttr(p);
                    if (attr && (ss = attr.setter)) {
                        v = source[gg].call(source);
                        this[ss].call(this, v);
                    }
                }
            }
        } else {
            for (i = 0, cnt = props.length; i < cnt; i++) {
                p = props[i];
                if (source.hasOwnProperty(p)) {
                    attr = attrs[p];//this.getAttr(p);
                    if (attr && (ss = attr.setter)) {
                        this[ss].call(this, source[p]);
                    }
                }
            }
        }
	}
};
Base.propertyChanged = function (prop, oldValue, newValue) {
};
Base.getAttribute = function (prop, proxy) {
	if (prop) {
        var p, i, cnt,
		    props = prop.split('.'),
		    self = this,
		    attr = null;
		for (i = 0, cnt = props.length; i < cnt; i++) {
			p = props[i];
			attr = self.constructor.$attrs2[p];//self.getAttr(p);
			if (attr) {
				if (i < cnt - 1) {
                    self = self[attr.getter]();
				}
			} else {
				break;
			}
		}
		return { target: self, prop: p, attr: attr };
	}
	return undefined;
};
Base.getProperty = function (prop, proxy) {
    if (prop) {
        var i, cnt, p, v,
            props = prop.split('.'),
            self = this,
            attr = null;
        for (i = 0, cnt = props.length; i < cnt; i++) {
            p = props[i];
            attr = self.constructor.$attrs2[p];//self.getAttr(p);
            if (attr) {
                if (i < cnt - 1) {
                    self = self[attr.getter]();
                }
            } else {
                break;
            }
        }
        if (attr && attr.getter) {
            v = self[attr.getter]();
            return (proxy && v && v.proxy) ? v.proxy() : v;
        }
    }
    return undefined;
};
Base.getProperties = function (props, proxy) {
    if (props && props.length > 0) {
        var i, cnt, p,
            obj = {};
        for (i = 0, cnt = props.length; i < cnt; i++) {
            p = props[i];
            obj[p] = this.getProperty(p, proxy);
        }
        return props;
    }
    return null;
};
Base.setProperty = function (prop, value, raiseError) {
    if (prop) {
        var i, cnt, p,
            props = prop.split('.'),
            self = this;
            attr = null;
        for (i = 0, cnt = props.length; i < cnt; i++) {
            p = props[i];
            attr = self.constructor.$attrs2[p];//self.getAttr(p);
            if (attr) {
                if (i < cnt - 1) {
                    self = self[attr.getter]();
                }
            } else {
                break;
            }
        }
        if (attr && attr.setter) {
            self[attr.setter](value);
        } else if (raiseError) {
            throw "Invalid property: " + prop;
        }
    }
	return this;
};
Base.setProperties = function (props, raiseError) {
    var i, cnt, p;
	if (_isArray(props)) {
		for (i = 0, cnt = props.length; i < cnt; i += 2) {
			this.setProperty(props[i], props[i + 1], raiseError);
		}
	} else if (props) {
        for (p in props) {
            this.setProperty(p, props[p], raiseError);
        }
    }
	return this;
};
Base.toggle = function (prop) {
    return this.setProperty(prop, !this.getProperty(prop));
};
Base._initProps = function (config) {
    if (config) {
        var prop, name;
        for (prop in config) {
            name = "_" + prop;
            if (this.hasOwnProperty(name)) {
                this[name] = config[prop];
            }
        }
    }
};
function $$_getProxy(v) {
	if (_isArray(v)) {
		var i, cnt,
            arr = [];
		for (i = 0, cnt = v.length; i < cnt; i++) {
			arr.push($$_getProxy(v[i]));
		}
		return arr;
	} else if (typeof v.proxy == "function") {
		return v.proxy();
	}
	return v;
}
Base.proxy = function () {
    var p, attr, v,
        attrs = this.constructor.$attrs2,
        obj = {};
    for (p in attrs) {
        attr = attrs[p];
        if (attr.getter && attr.setter) {
            v = this[attr.getter]();
            if (v && v.noProxy) {
            } else {
                if (v) {
                    v = $$_getProxy(v);
                }
                obj[p] = v;
            }
        }
    }
    return obj;
};
Base.as = function (clazz) {
	return this instanceof clazz ? this : null;
};
var EventAware = defineClass(null, null, {
	init: function (nohash) {
		this._super(nohash);
		this._listeners = [];
	},
    findListener: function (callback) {
        var list = this._listeners;
        for (var i = list.length; i--;) {
            if (callback(list[i])) {
                return list[i];
            }
        }
        return null;
    },
	addListener: function (listener) {
		if (listener && this._listeners.indexOf(listener) < 0) {
			this._listeners.push(listener);
		}
		return this;
	},
	removeListener: function (listener) {
		var i;
		if (listener && (i = this._listeners.indexOf(listener)) >= 0) {
			this._listeners.splice(i, 1);
		}
		return this;
	},
	containsListener: function (listener) {
		return this._listeners.indexOf(listener) >= 0;
	},
	fireEvent: function (event) {
		var i, cnt, ls, cb,
            args = _slice.call(arguments, 0),
            listeners = this._listeners;
        args[0] = this;
		for (i = 0, cnt = listeners.length; i < cnt; i++) {
			ls = listeners[i];
			cb = ls[event];
			cb && cb.apply(ls, args);
		}
	},
	fireConfirmEvent: function (event) {
		var i, cnt, listener, callback, ret,
            args = _slice.call(arguments, 0);
		args[0] = this;
		for (i = 0, cnt = this._listeners.length; i < cnt; i++) {
			listener = this._listeners[i];
			callback = listener[event];
			if (callback) {
				ret = callback.apply(listener, args);
				if (typeof ret === "boolean" && !ret) {
					return false;
				}
			}
		}
		return true;
	},
    fireMessageEvent: function (event) {
        var i, cnt, listener, callback, ret,
            args = _slice.call(arguments, 0);
        args[0] = this;
        for (i = 0, cnt = this._listeners.length; i < cnt; i++) {
            listener = this._listeners[i];
            callback = listener[event];
            if (callback) {
                ret = callback.apply(listener, args);
                if (typeof ret === "string" && ret) {
                    return ret;
                }
            }
        }
        return null;
    }
});
var EventAware$ = EventAware.prototype;
var Locale = function (lang) {
    this.lang = lang;
    this.year = "";
    this.months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    this.shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    this.weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    this.shortWeekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    this.thousandSep = ',';
    this.decimalSep = '.';
    this.dateSep = '/';
    this.timeSep = ':';
    this.am = 'AM';
    this.pm = 'PM';
    this.halfs = ['1st Half', '2nd Half'];
    this.quarters = ['Q1', 'Q2', 'Q3', 'Q4'];
    this.dateFormat = 'M/d/yyyy HH:mm:ss';
    this.shortDateFormat = 'M/d/yyyy';
    this.minuteFormat = 'M/d/yyyy HH:mm';
    this.hourFormat = 'M/d/yyyy HH';
    this.monthFormat = 'M/yyyy';
    this.yearFormat = 'yyyy';
    this.untermintatedExpression = "Untermintated expression";                          // ExpressionNodeImple.evaluate
    this.invalidToken = "Invalid token";                                                // ExpressionLexer._equalProc
    this.untermintatedString = "Untermintated string";                                  // ExpressionLexer._stringProc
    this.unknownOperator = "Unknown operator";                                          // ExpressionNodeImple.evaluate
    this.notExpectedTokenKind = "Token is not a expected kind";                         // ExpressionParser._expected
    this.invalidIsOperand = "is operator's operand must be defined, null or empty";     // ExpressionParser._doExpression
    this.unknownToken = "Unknown token"; //ExpressionParser._doFactor()
    this.invalidIdentifierToken = "Token is not a valid Identifier";           // ExpressionRuntime.isIdentifier
    this.invalidIdentifierKey = "Invalid identifier key";                      // ExpressionRuntime.evaluateIdentifier
    this.invalidIdentifierIndexer = "Invalid identifier indexer";              // ExpressionRuntime.evaluateIndexerI, evaluateIndexerS
    this.invalidDateTimeFormat = "Invalid datetime format";                                             // DateTimeParser.$_throwInvalidFormat
    this.invalidDateTimeText = "Invalid date Text: ";                                                   // ISODataTimeParser.parse
    this.invalidDateTimeOutputFormat = "Invalid datetime output format: ";                              // DateTimerWriter._parseDateFormatTokens
    this.invalidDateTimeFormat2 = "Invalid datetime format - 'H' and 'a' can not coexists";             // DateTimeConverter._validateDateFormat
    this.invalidDateTimeFormat3 = "Invalid datetime format - If there is 'h' then 'a' must be exists";  // DateTimeConverter._validateDateFormat
    this.invalidDateTimeInputFormat = "Invalid datetime input format: ";                                // DateTimeConverter._parseDateFormatTokens
    this.invalidColorText = "Invalid color text";                       // Color._parse
    this.invalidLinearGradientText = "Invalid linear gradient text";    // LinearGradient.parse
    this.invalidRadialGradientText = "Invalid radial gradient text";    // RadialGradient.parse
    this.valueIsRequired = "Value is required";                         // ValidationManager.$_validateCell
    this.notImplemeted = "Not Yet implemented";                         // core._throwAbstractError
    this.progressCancel = "Cancel";
    /*
    this.ajaxFailed = "XMLHttpRequest failed: "; //var ajax, var asyncAjax
    this.notSupportedCaller = "Not supported Function.caller"; //function _throwCallerError
    this.invalidMethod = "Method os nott exists: "//function _throwInvalidMethod
    this.nullContainerMessage = "Container is null!"; //UIContainer.init()
    this.invalidContainerMessage = "Invalid grid container element: ";
    this.dialogText = "This is a dialog"; //Dialog._createContent
    this.touchEndMessage = "touch end";//SingleTouchManager.touchEnd
    */
};
Locale.$_callbacks = [];
Locale.addCallback = function (callback) {
    var callbacks = Locale.$_callbacks;
    if (typeof callback == 'function' && callbacks.indexOf(callback) < 0) {
        callbacks.push(callback);
        callback(Locale._currLang);
    }
};
Locale.$_runCallbacks = function () {
    var callbacks = Locale.$_callbacks;
    for (var i = callbacks.length; i--;) {
        callbacks[i](Locale._currLang);
    }
};
Locale.getLocale = function (lang) {
    return Locale[lang] || Locale.en;
};
Locale.setLanguage = function (lang) {
    lang = lang || $_lanugage || 'en';
    if (lang != Locale._currLang) {
        Locale._currLang = lang;
        Locale._default = Locale.getLocale(lang);
        Locale.$_runCallbacks();
    }
};
Locale.setLocale = function (lang, locale) {
    if (lang && _isObject(locale)) {
        Locale[lang] = _extend(new Locale(lang), locale);
        if (Locale[lang] === Locale._default) {
            Locale.$_runCallbacks();
        }
    }
};
Locale.en = _extend(new Locale("en"), {
});
Locale.ko = Locale.kr = _extend(new Locale("ko"), {
    year: "년",
    months: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
    shortMonths: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
    weekDays: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'],
    shortWeekDays: ['일', '월', '화', '수', '목', '금', '토'],
    thousandSep: ',',
    decimalSep: '.',
    dateSep: '/',
    timeSep: ':',
    am: '오전',
    pm: '오후',
    halfs: ['전반기', '후반기'],
    quarters: ['1사분기', '2사분기', '3사분기', '4사분기'],
    dateFormat: 'yyyy-MM-dd HH:mm:ss',
    shortDateFormat: 'yyyy-MM-dd',
    minuteFormat: 'yyyy-MM-dd HH:mm',
    hourFormat: 'yyyy-MM-dd HH',
    monthFormat: 'yyyy-MM',
    yearFormat: 'yyyy',
    untermintatedExpression: "종결되지 않은 수식입니다",
    invalidToken: "잘못된 token 입니다",
    untermintatedString: "종결되지 않은 문자열입니다",
    unknownOperator: "알 수 없는 연산자입니다",
    notExpectedTokenKind: "기대하지 않은 토큰 종류입니다",
    invalidIsOperand: "is 연산자의 피연산자는 defined, null, empty 중 하나여야 합니다",
    unknownToken: "알 수 없는 토큰입니다",
    invalidIdentifierToken: "토큰이 식별자가 아닙니다",
    invalidIdentifierKey: "잘못된 식별자 키입니다",
    invalidIdentifierIndexer: "잘못된 인덱서 식별자입니다",
    invalidDateTimeFormat: "잘못된 날짜 형식입니다",
    invalidDateTimeText: "잘못된 날짜 값입니다",
    invalidDateTimeOutputFormat: "잘못된 날짜 출력 형식입니다",
    invalidDateTimeFormat2: "잘못된 날짜 형식 - 'H'와 'a'가 같이 존재할 수 없습니다",
    invalidDateTimeFormat3: "잘못된 날짜 형식 - 'h'가 있으면 'a'가 반드시 있어야 합니다",
    invalidDateTimeInputFormat: "잘못된 날짜 입력 형식입니다",
    invalidColorText: "잘못된 color 텍스트입니다",
    invalidLinearGradientText: "잘못된 linear gradient 텍스트입니다",
    invalidRadialGradientText: "잘못된 radial gradient 텍스트입니다",
    valueIsRequired: "반드시 요구되는 값입니다",
    notImplemeted: "아직 구현되지 않았습니다"
});
Locale._default = Locale.getLocale($_language);
Locale._currLang = $_language;
var SummaryMode = _enum('SummaryMode', {
    NONE: "none",
    AGGREGATE: "aggregate",
    STATISTICAL: "statistical"
});
var DateTimeScale = _enum('DateTimeScale', {
    SECOND: -3,
    MINUTE: -2,
    HOUR: -1,
    DATE: 1,
    WEEK: 2,
    MONTH: 3,
    QUARTER: 4,
    HALF: 5,
    YEAR: 6
});
var TextCase = _enum('TextCase', {
	NORMAL: 'normal',
	UPPER: 'upper',
	LOWER: 'lower'
});
var Dictionary = function () {
	this._values = {};
	this._keys = {};
};
Dictionary.prototype = {
	constructor: Dictionary,
	containsKey: function (key) {
		return key && this._values.hasOwnProperty(key.$_hash);
	},
	isEmpty: function () {
		for (var v in this._values) {
			return false;
		}
		return true;
	},
	set: function (key, value) {
		if (!key || !key.$_hash) {
			throw "Invalid key";
		}
		this._values[key.$_hash] = value;
		this._keys[key.$_hash] = key;
		return this;
	},
	unset: function (key) {
		if (key && this._values.hasOwnProperty(key.$_hash)) {
			delete this._values[key.$_hash];
			delete this._keys[key.$_hash];
			return true;
		}
		return false;
	},
	clear: function () {
		this._values = {};
		this._keys = {};
		return this;
	},
	get: function (key) {
		return key ? this._values[key.$_hash] : undefined;
	},
	keys: function () {
		var a = [];
		for (var k in this._values) {
			a.push(this._keys[k]);
		}
		return a;
	},
	values: function () {
		var a = [];
		for (var k in this._values) {
			a.push(this._values[k]);
		}
		return a;
	},
	each: function (callback) {
		if (!_isFunction(callback)) return;
		for (var k in this._values) {
			callback(this._keys[k], this._values[k]);
		}
	},
	checkTrue: function (callback) {
		if (!_isFunction(callback)) return;
		for (var k in this._values) {
			if (callback(this._keys[k], this._values[k])) {
				return true;
			}
		}
		return false;
	},
	checkFalse: function (callback) {
		if (!_isFunction(callback)) return;
		for (var k in this._values) {
			if (!callback(null, this._keys[k], this._values[k])) {
				return true;
			}
		}
		return false;
	}
};
function toInt(v, radix) {
    return (v !== UNDEFINED && v !== null) ? parseInt(v, radix || 10) : 0;
}
function toFloat(v) {
    return (v !== UNDEFINED && v !== null) ? parseFloat(v) : 0;
}
function _toFixed(v, scale) {
    var i, s;
    if (!isNaN(v)) {
        if (scale > 0) {
            s = Math.pow(10, scale - 1);
            v = Math.floor(v / s) * s;
        } else if (scale < 0) {
            s = v + '';
            i = s.indexOf('.');
            if (i >= 0) {
                v = parseFloat(s.substr(0, i) + '.' + s.substr(i + 1, -scale));
            }
        }
    }
    return v;
}
function _equalDates (d1, d2) {
    if (!(d1 instanceof Date)) {
        return !(d2 instanceof Date);
    }
    if (!(d2 instanceof Date)) {
        return false;
    }
    return d1.getTime() == d2.getTime();
}
var $$_get_obj = function (source, props) {
	var obj = source;
	for (var i = 0, cnt = props.length - 1; i < cnt; i++) {
		var p = props[i];
		var obj2 = obj[p];
		if (obj2 === UNDEFINED) {
			obj2 = obj[p] = {};
		}
		obj = obj2;
	}
	return obj;
};
var $$_expand_object = function (obj) {
	var list = [];
	for (var p in obj) {
		var i = p.indexOf(".");
		if (i >= 0) {
			list.push(p);
		}
	}
	if (list.length > 0) {
		var obj2 = {};
		for (var p in obj) {
			obj2[p] = obj[p];
		}
		obj = obj2;
		for (var j = list.length; j--;) {
			p = list[j];
			var arr = p.split(".");
			var s = arr[0];
			if (s) {
				obj2 = $$_get_obj(obj, arr);
				obj2[arr[arr.length - 1]] = obj[p]; 
			}
		}
	} 
	return obj;
};
function equalArrays(a, b) {
	if (a === b)
		return true;
	if (a == null || b == null)
		return false;
	var len = a.length;
	if (len != b.length)
		return false;
	for (var i = 0; i < len; ++i) {
		if (a[i] !== b[i])
			return false;
	}	
	return true;
}
function decimalAdjust(type, value, exp) {
	if (typeof exp === 'undefined' || +exp === 0) {
		return Math[type](value);
	}
	value = +value;
	exp = +exp;
	if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
		return NaN;
	}
	value = value.toString().split('e');
	value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
	value = value.toString().split('e');
	return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}
var _round10 = function(value, exp) {
	return decimalAdjust('round', value, exp);
};
var _floor10 = function(value, exp) {
	return decimalAdjust('floor', value, exp);
};
var _ceil10 = function(value, exp) {
	return decimalAdjust('ceil', value, exp);
};
var $$_mobile = undefined;
var $$_setMobile = function (value) {
	$$_mobile = value;
}
var _isMobile = function () {
	if ($$_mobile == undefined) {
		var check = false;
		if (navigator.userAgent.match(/Android/i)
			|| navigator.userAgent.match(/webOS/i)
			|| navigator.userAgent.match(/iPhone/i)
			|| navigator.userAgent.match(/iPad/i)
			|| navigator.userAgent.match(/iPod/i)
			|| navigator.userAgent.match(/BlackBerry/i)
			|| navigator.userAgent.match(/Windows Phone/i)
		) {
            check = true;
        }
		if (!check) {
			(function (a) {
				if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||
					/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
                    check = true;
                }
			})(navigator.userAgent || navigator.vendor || window.opera);
		}
		$$_mobile = check;
	}
	return !!$$_mobile;
};
var _getClipboardText = function (e) {
    var text, data = (e.originalEvent || e).clipboardData;
    if (data) {
        text = data.getData('text/plain');
    } else {
        text = window.clipboardData.getData("text");
    }
    return text;
};
var _setClipboardText = function (e, data) {
    if (_win.clipboardData) {
        _win.clipboardData.setData("Text", data);
    } else {
        e.clipboardData.setData('text/plain', data);
    }
}
var ImageList = function (name, rootUrl) {
    var _name = name;
    var _rootUrl = rootUrl;
    var _urls = [];
    var _listeners = [];
    var _images = [];
    var _map = {};
    this.name = function () {
        return _name;
    };
    this.count = function () {
        return _urls.length;
    };
    this.addListener = function (listener) {
        if (listener && _listeners.indexOf(listener) < 0) {
            _listeners.push(listener);
        }
    };
    this.removeListener = function (listener) {
        var idx = _listeners.indexOf(listener);
        if (idx >= 0) {
            _listener.splice(idx, 1);
        }
    };
	this.getUrl = function (index) {
		return _urls[index];
	};
    this.addUrl = function (url) {
        if (url && _urls.indexOf(url) < 0) {
            _urls.push(url);
            _map[url] = _urls.length - 1;
        }
    };
    this.addUrls = function (urls) {
        if (urls) {
            for (var i = 0; i < urls.length; i++) {
                this.addUrl(urls[i]);
            }
        }
    };
    this.getImage = function (index) {
        if (typeof index === "string") {
            var i = _map[index];
            if (i !== undefined) index = i;
        }
        if (index >= 0 && index < _urls.length) {
            var image = _images[index];
            if (image) {
                return image;
            }
            image = new Image();
            image["index"] = index;
            image["owner"] = this;
            _images[index] = image;
            image.onload = function () {
                this.owner._fireLoaded(this.index);
            }.bind(image);
            image.src = _rootUrl + _urls[index];
        }
        return null;
    };
    this._fireLoaded = function (index) {
        for (var i = 0; i < _listeners.length; i++) {
            _listeners[i].onImageListImageLoaded(this, index);
        }
    };
};
var ImagePool = function () {
    var _listeners = [];
    var _images = {};
    this.addListener = function(listener) {
        if (listener && _listeners.indexOf(listener) < 0) {
            _listeners.push(listener);
        }
    };
    this.removeListener = function(listener) {
        var idx = _listeners.indexOf(listener);
        if (idx >= 0) {
            _listeners.splice(idx, 1);
        }
    };
    this.getImage = function(url) {
        if (url) {
            var image = _images[url];
            if (image) {
                return image;
            }
            image = new Image();
            image["owner"] = this;
            image["url"] = url;
            _images[url] = image;
            image.onload = function() {
                this.owner._fireLoaded(this.url);
                delete image.onload;
            }.bind(image);
            image.src = url;
        }
        return null;
    };
    this._fireLoaded = function(url) {
        for (var i = 0; i < _listeners.length; i++) {
            _listeners[i].onImageLoaded(url);
        }
    };
};
var $$_DEF_NUM_SYMBOLS = ["K", "M", "G", "T", "P", "E", "Z", "Y"];
var NumberScales = defineClass("NumberScales", null, {
    init: function (symbols) {
        this._super();
        this._symbols = $$_DEF_NUM_SYMBOLS;
        this.$_symbols = undefined;
        this.setSymbols(symbols);
    },
    setSymbols: function (value) {
        if (value != this.$_symbols) {
            var i, s;
            this.$_symbols = value;
            this._symbols = [];
            if (_isString(value)) {
                s = value;//.trim();
                if (_equalTexts(s, 'default', true)) {
                    this._symbols = $$_DEF_NUM_SYMBOLS;
                } else if (s) {
                    this._symbols = s.split(',');
                }
            } else if (_isArray(value)) {
                this._symbols = value;
            }
            for (i = this._symbols.length; i < $$_DEF_NUM_SYMBOLS.length; i++) {
                this._symbols.push($$_DEF_NUM_SYMBOLS[i]);
            }
        }
        return this;
    },
    getScaledText: function (value, scale, formatter) {
        var m,
            v = _int(Math.log(value) * Math.LOG10E);
        if (v >= scale) {
            v = _floor(v / scale);
            m = Math.pow(10, v * scale);
            value = value / m;
            if (formatter) {
                value = formatter.format(value);
            }
            return value + this._symbols[v - 1];
        }
        return String(value);
    },
    getText: function (value, formatter) {
        return this.getScaledText(value, 3, formatter);
    }
}, null,
function (f) {
    f.Default = new f(3);
});
var EmptyCommandError = function (command, ret) {
	this.name = 'DataLudi.EmptyCommandError';
	this.message = 'Empty command'
	this.command = command;
	this.ret = ret;
};
EmptyCommandError.prototype = new Error();
EmptyCommandError.prototype.constructor = EmptyCommandError;
var CommmandLockError = function (command, ret) {
	this.name = 'DataLudi.CommmandLockError';
	this.message = "A command is already running";
	this.command = command;
	this.ret = ret;
};
CommmandLockError.prototype = new Error();
CommmandLockError.prototype.constructor = CommmandLockError;
/** @abstract */
var EditCommand = defineClass("EditCommand", null, {
	init: function () {
		this._super();
	},
	undo: function (post) {
	},
	postUndo: function (post) {
	},
	redo: function (redoing, post) {
	},
	postRedo: function (post) {
	},
	execute: function (post) {
		return this.redo(false, post);
	},
	postRun: function (post) {
	},
    rollbackUndo: function () {
    },
    rollbackRedo: function () {
    },
	dispose: function () {
	},
    "set": function (key, value) {
        if (key) {
            this.$_user = this.$_user || {};
            this.$_user[key] = value;
        }
    },
    "get": function (key) {
        return this.$_user && this.$_user[key];
    },
    "unset": function (key) {
        this.$_user && (delete this.$_user[key]);
    },
    _setReady: function () {
        this.ready = true;
    },
	throwEmpty: function (ret) {
		if (this.undoable) throw new EmptyCommandError(this, ret);
		return ret;
	},
    throwPaused: function (source, canceled) {
        throw new CommandPausedError(this, source, canceled);
    }
});
var EditCommandGroup = defineClass("EditCommandGroup", EditCommand, {
	init: function (immediately) {
		this._super();
		this._items = [];
	},
	count: function () {
		return this._items.length;
	},
	add: function (command) {
		if (command) {
            var cmds = command instanceof EditCommandGroup ? command.$_collectItems() : [command];
            var i, cmd, cnt = cmds.length;
            for (i = 0; i < cnt; i++) {
                cmd = cmds[i];
                if (this._immediately) {
                    var post = {};
                    try {
                        cmd.execute(post);
                        this._setReady();
                        cmd.postRun(post);
                        this._items.push(cmd);
                    } catch (e) {
                        if (e instanceof EmptyCommandError) {
                            return e.ret;
                        }
                        if (!cmd.ready) {
                            throw err;
                        }
                    }
                } else {
                    this._items.push(cmd);
                }
            }
		}
		return this;
	},
	dispose: function () {
		for (var i = this._items.length; i--;) {
			this._items[i].dispose();
		}
	},
	undo: function () {
        var i, post, ended, len = this._items.length;
        this._completed = false;
        try {
            for (i = len; i--;) {
                ended = false;
                post = {};
                this._items[i].undo(post);
                ended = true;
                this._items[i].postUndo(post);
            }
            this._completed = true;
        } catch (e) {
            if (ended) {
                this._completed = true;
                this._all = i == 0;
                if (!this._all) {
                    this.$_shrink(i + 1);
                }
            }
            throw e;
        }
	},
	redo: function (redoing) {
        var i, post, ended, len = this._items.length;
        this._completed = false;
        try {
            for (i = 0; i < len; i++) {
                ended = false;
                post = {};
                this._items[i].redo(redoing, post);
                ended = true;
                this._items[i].postRedo(post);
            }
            this._completed = true;
        } catch (e) {
            if (ended) {
                this._completed = true;
                this._all == i == len - 1;
                if (!this._all) {
                    this.$_shrink(i + 1);
                }
            }
            throw e;
        }
	},
	execute: function () {
        var i, cnt, cmd, j, post, ended,
			n = 0,
			errors = [];
        this._completed = false;
		try {
			for (i = 0, cnt = this._items.length; i < cnt; i++) {
                cmd = this._items[i];
                ended = false;
                post = {};
				try {
					cmd.execute(post);
                    ended = true;
                    cmd.postRun(post);
					n++;
				} catch (e) {
					if (e instanceof EmptyCommandError) {
                        errors.push(i);
                    } else {
                        if (!cmd.ready) {
                            this.$_shrink(i);
                            this._completed = n > 0;
                        } else if (ended) {
                            this.$_shrink(i + 1);
                            this._completed = true;
                        }
                        throw e;
                    }
				} finally {
                    cmd.ready && this._setReady();
                }
			}
            this._completed = true;
		} finally {
			for (j = errors.length; j--;) {
				i = errors[j];
				this._items[i].dispose();
				this._items.splice(i, 1);
			}
		}
		if (n < 1) {
			throw new EmptyCommandError(0);
		}
	},
	$_collectItems: function () {
        function _collect(group, list) {
            var i, cmd,
                items = group._items,
                cnt = items.length;
            for (i = 0; i < cnt; i++) {
                cmd = items[i];
                if (cmd instanceof EditCommandGroup) {
                    _collect(group, list);
                } else {
                    list.push(cmd);
                }
            }
            return list;
        }
        return _collect(this, []);
    },
    $_shrink: function (index) {
		if (index >= 0 && index < this._items.length) {
			this._items.splice(index, this._items.length);
		}
	},
});
var EditCommandStack = defineClass("EditCommandStack", null, {
	init: function (owner) {
		this._super();
		this._owner = owner;
		this._commands = [];
		this._current = -1;
        this._status = 0;   // 1: exec, 2: undo, 3: redo
	},
    length: function () {
        return this._commands.length;
    },
    undoing: function () {
        return this._status == 2;
    },
    redoing: function () {
        return this._status == 3;
    },
	canUndo: function () {
		return this._status <= 0 && this._current >= 0;
	},
	canRedo: function () {
		return this._status <= 0 && this._commands.length > this._current + 1;
	},
	undo: function () {
		if (this._status > 0) {
			throw new CommandLockError();
		}
		if (this.canUndo()) {
            var error,
				post = {},
				cmd = this._commands[this._current];
            this._status = this._owner._onStack = 2;
            try {
                try {
                    cmd.undo(post);
                } catch (err) {
                    if (cmd.rollbackUndo()) {
                        throw err.source || err;
                    } else if (cmd instanceof EditCommandGroup && cmd._completed) {
                        if (cmd._all) {
                            error = err;
                        } else {
                            this._shrink(this._current + 1);
                            this._current++;
                            throw err.source || err;
                        }
                    } else {
                        this._shrink(this._current);
                        throw err.source || err;
                    }
                }
                if (error) {
                    throw error.source || error;
                }
                    cmd.postUndo(post);
			} finally {
                this._current = Math.max(this._current - 1, -1);
                this._status = this._owner._onStack = 0;
				this._stateChanged();
			}
		}
		return this;
	},
	redo: function () {
		if (this._status > 0) {
			throw new CommandLockError();
		}
		if (this.canRedo()) {
            var error,
				post = {},
                curr = this._current + 1,
				cmd = this._commands[curr];
            this._status = this._owner._onStack = 3;
            try {
                try {
                    cmd.redo(true, post);
                } catch (err) {
                    if (cmd.rollbackRedo()) {
                        throw err.source || err;
                    } else if (cmd instanceof EditCommandGroup && cmd._completed) {
                        if (cmd._all) {
                            error = err;
                        } else {
                            this._shrink(this._current + 2);
                            throw err.source || err;
                        }
                    } else {
                        this._shrink(curr);
                        curr = Math.max(-1, curr - 1);
                        throw err.source || err;
                    }
                }
                if (error) {
                    throw error.source || error;
                }
                    cmd.postRedo(post);
			} finally {
                this._current = curr;
                this._status = this._owner._onStack = 0;
				this._stateChanged();
			}
		}
		return this;
	},
	execute: function (command) {
		if (command instanceof EditCommand) {
            if (this._status > 1) {
				throw new CommmandLockError();
			}
			if (this._status == 1) {
				return;
			}
			var rslt, i, error,
                post = {};
            this._status = 1;
            command.ready = false;
			try {
				rslt = command.execute(post);
			} catch (err) {
				if (err instanceof EmptyCommandError) {
					return err.ret;
				}
                if (!command.ready) {
                    throw err;
                }
				if (command instanceof EditCommandGroup && command._completed) {
                    error = err;
				} else {
					this._shrink(this._current);
                    throw err.source || err;
				}
			} finally {
                this._status = 0;
            }
            this._commands[++this._current] = command;
			this._shrink(this._current + 1);
			try {
                if (error) {
                    throw error.source || error;
                }
					command.postRun(post);
			} finally {
				this._stateChanged();
			}
            return rslt;
		}
	},
	flush: function () {
		var cmds = this._commands,
		    len = cmds.length;
		if (len > 0) {
			for (; len--;) {
				this._commands[len].dispose();
			}
			this._commands = [];
			this._current = -1;
			this._stateChanged();
		}
	},
    _currCmd: function () {
        return this._commands[this._current];
    },
	_stateChanged: function () {
		this._owner && this._owner.onEditCommandStackChanged(this, this.canUndo(), this.canRedo());
	},
	_shrink: function (index) {
		if (index >= 0 && index < this._commands.length) {
			for (i = this._commands.length - 1; i >= index; i--) {
				this._commands[i].dispose();
			}
			this._commands.length = index;
			this._stateChanged();
		}
	}
});
var _saveToFile = function (data, fileName) {
    if (_isIE || navigator.appVersion.toString().indexOf('.NET') > 0) {
        window.navigator.msSaveBlob(data, fileName);
    } else {
        var a = document.createElement("a");
        document.body.appendChild(a);
        var url = URL.createObjectURL(data);
        a.href = url;
        a.download = fileName;
        a.click();
        document.body.removeChild(a);
    }
};
var _saveTextToFile = function (text, fileName) {
    var data = [text];
    var blob = new Blob(data, {type: "text/plain"});
    _saveToFile(blob, fileName);
};
var _uploadFile = function (url, filename, data) {
    var formtag = '<form name="tempForm" action="' + url + '" method="post">'
        + '<input type="hidden" name="fileName" value = "' + filename + '"/>'
        + '<input type="hidden" name="data" value = "' + data + '"/>'
        + '<input id="ok" type="submit"/>'
        + '</form>';
    var div = document.createElement('div');
    div.innerHTML = formtag;
    document.body.appendChild(div);
    document.getElementById("ok").click();
    document.body.removeChild(div);
}
var _loadTextFile = function (callback) {
    var html = '<input id="dl_kji_file" type="file" style="display: none" onchange="$_kji_upload();">',
        div = document.createElement('div');
    window.$_kji_upload = function() {
        var file, reader, div,
            fileInput = document.getElementById("dl_kji_file");
            length = fileInput.files.length;
        try {
            if (length > 0) {
                file = fileInput.files[0];
                reader = new FileReader();
                reader.onload = function (ev) {
                    callback && callback(ev.target.result);
                };
                reader.onerror = function (evt) {
                    if (callback) {
                        callback(undefined, evet);
                    } else {
                        alert('File load error: ' + evt);
                    }
                };
                reader.readAsText(file);
            }
        } finally {
            div = document.getElementById("dl_kji_div");
            div && document.body.removeChild(div);
        }
    };
    try {
        div.id = 'dl_kji_div';
        div.innerHTML = html;
        document.body.appendChild(div);
        document.getElementById("dl_kji_file").click();
    } catch (err) {
        document.body.removeChild(div);
    }
}
var $_parseCSV = function (line, delimiter) {
    var words = [];
    if (line && line.length > 0) {
        var i, c, d,
            prev = 0,
            q1 = -1,
            q2 = -1,
            q = false,
            qq = false,
            len = line.length,
            w = null;
        for (i = 0; i < len; i++) {
            c = line.charAt(i);
            if (c == delimiter) {
                if (!q) {
                    d = i - prev;
                    if (d <= 0) {
                        w = "";
                    } else if (q2 == i - 1 && q1 == prev) {
                        w = line.substring(q1 + 1, q2);
                        if (qq) {
                            w = w.replace('""', '"');
                        }
                    } else {
                        w = line.substring(prev, i);
                    }
                    words.push(w);
                    q = qq = false;
                    prev = i + 1;
                }
            } else if (c == '"') {
                if (!q) {
                    q1 = i;
                    q2 = -1;
                    q = true;
                } else if (q2 < 0) {
                    q2 = i;
                    q = false;
                } else if (q2 == i - 1) {
                    qq = true;
                    q = true;
                    q2 = -1;
                }
            } /*else {
             w += c;
             }*/
        }
        if (prev < len) {
            if (q2 == len - 1 && q1 == prev) {
                w = line.substring(q1 + 1, q2);
                if (qq) {
                    w = w.replace('""', '"');
                }
            } else {
                w = line.substring(prev, len);
            }
            words.push(w);
        }
    }
    return words;
};
var IEDomNode = function (tag) {
    this._tag = tag;
    this._nodes = null;
    this._attrs = null;
};
var IEDomNodeP = IEDomNode.prototype;
Object.defineProperty(IEDomNodeP, 'textContent', {
    get: function () { return this._value; },
    set: function (value) { this._value = value; }
});
IEDomNodeP.appendChild = function (node) {
    this._nodes = this._nodes || [];
    this._nodes.push(node);
};
IEDomNodeP.setAttribute = function (attr, value) {
    this._attrs = this._attrs || {};
    this._attrs[attr] = value;
};
IEDomNodeP.serialize = function () {
    var attr, v, i, cnt;
    var attrs = this._attrs;
    var nodes = this._nodes;
    var s = '<' + this._tag;
    if (attrs) {
        for (attr in attrs) {
            v = attrs[attr];
            s += ' ' + attr + '="' + v + '"';
        }
    }
    s += '>';
    if (nodes) {
        for (i = 0, cnt = nodes.length; i < cnt; i++) {
            s += nodes[i].serialize();
        }
    }
    v = this._value;
    if (v !== undefined) {
        if (typeof v == 'string' && v) {
            s += v.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
            ;
        } else {
            s += v;
        }
    }
    s += '</' + this._tag + '>';
    return s;
};
var IEDom = function (doc) {
    var elt = doc.documentElement;
    var root = this._root = new IEDomNode(elt.tagName);
    var attrs = elt.attributes;
    for (var i = 0, cnt = attrs.length; i < cnt; i++) {
        root.setAttribute(attrs[i].name, attrs[i].value);
    }
};
var IEDomP = IEDom.prototype;
Object.defineProperty(IEDomP, 'documentElement', {
    get: function () { return this._root; }
});
Object.defineProperty(IEDomP, 'xml', {
    get: function () {
        return this._root.serialize();
    }
})
IEDomP.createElement = function (tag) {
    return new IEDomNode(tag);
};
function _parseXml(source) {
    var doc = null;
    if (window.DOMParser) {
        doc = new DOMParser().parseFromString(source, "text/xml");
    } else { // Internet Explorer
        doc = new ActiveXObject("Microsoft.XMLDOM");
        doc.async = false;
        doc.loadXML(source);
    }
    return doc;
}
function _parseXmlList(source) {
    var doc = _parseXml(source);
    return doc && doc.documentElement.childNodes;
}
function _parseXmlEx(source, proxy) {
    var doc = null;
    try {
        doc = new ActiveXObject("Microsoft.XMLDOM");
        doc.async = false;
        doc.loadXML(source);
    } catch (e) {
        if (doc) throw e;
        doc = new DOMParser().parseFromString(source, "text/xml");
    }
    if (doc && proxy && _isIE) {
        doc = new IEDom(doc);
    }
    return doc;
}
function _xmlToStr(doc) {
    if (doc instanceof IEDom) {
        return doc.xml;
    } else
    if (doc) {
		try {
			return new XMLSerializer().serializeToString(doc);
		} catch (e) {
			return doc.xml;
		}
	}
}
function _getXmlList(xml, tagName) {
	var nodes = [];
	if (xml) {
		var list = xml.childNodes;
		if (list) {
			for (var i = 0, cnt = list.length; i < cnt; i++) {
				var node = list[i];
				if (node.tagName === tagName) {
					nodes.push(node);
				}
			}
		}
	}
	return nodes;
}
function _getNodeValue(xml) {
    return xml && xml.firstChild ? xml.firstChild.nodeValue : undefined;
}
function _getXmlAttr(xml, attr) {
	return xml ? xml.getAttribute(attr) : undefined;
}
function _setXmlAttr(xml, attr, value) {
	xml.setAttribute(attr, value);
}
function _addChildWithAttr(doc, parent, child, attr, value) {
	var node = doc.createElement(child);
	attr && node.setAttribute(attr, value);
	parent.appendChild(node);
	return node;
}
var $$$_TF_DUMMY_PATTERN = /(.*)/;
var $$$_TF_DUMMY_FORMAT = "$1";
var TextFormatter = defineClass("TextFormatter", null, {
    init: function (format) {
        this._super();
        this.$_parse(format);
    },
    format: function (text) {
        return text && text.replace(this._pattern, this._format);
    },
    $_parse: function (fmt) {
        if (fmt) {
            var arr = fmt.trim().split($_colonreg);
            if (arr.length > 1) {
                var p = arr[0].trim();
                var f = arr[1].trim();
                if (p && f) {
                    if (p.charAt(0) == '"') {
                        p = p.substr(1, p.length - 2);
                    }
                    if (p) {
                        if (f.charAt(0) == '"') {
                            f = p.substr(1, f.length - 2);
                        }
                        if (f) {
                            this._pattern = new RegExp(p, arr[2] || '');
                            this._format = f;
                            return;
                        }
                    }
                }
            }
        }
        this._pattern = $$$_TF_DUMMY_PATTERN;
        this._format = $$$_TF_DUMMY_FORMAT;
    }
});
var $$$_SEP = "$&,";
var $$$_MAX_PRECISION = 14;
var $$$_MAX_DIGITS = 14;
var DecimalFormatter = defineClass("DecimalFormatter", null, {
	init : function(format) {
		this._super();
		this._minDigits = 0;
		this._maxDigits = 0;
        this._trim = false;
		this._minInts = 0;
		this._maxInts = 0;
		this._groupPos = 0;
		this._reg = null;
		this._parse(format);
        if (this._maxDigits > 0 && $$$_MAX_PRECISION > 0) {
            this._format = DecimalFormatter.prototype.format;
        } else {
            this.format = DecimalFormatter.prototype.formatInt;
        }
	},
	format: function (value) {
		var v = Number(value);
		if (isNaN(v)) {
			return "";
		} else {
            var s;
            if ($$$_MAX_PRECISION > 0) {
                v = parseFloat(v.toPrecision($$$_MAX_PRECISION));
            }
			if (this._reg) {
				s = v.toFixed(this._maxDigits).replace(this._reg, $$$_SEP);
			} else {
				s = v.toFixed(this._maxDigits);
			}
            if (this._trim) {
                for (var i = s.length - 1; i >= 0; i--) {
                    if (s.charAt(i) != '0') {
                        s = s.substring(0, i + 1);
                        break;
                    }
                }
            }
            return s;
		}
	},
    formatInt: function (value) {
        var v = Number(value);
        if (isNaN(v)) {
            return "";
        } else {
            var s;
            if (this._reg) {
                s = v.toFixed(0).replace(this._reg, $$$_SEP);
            } else {
                s = v.toFixed(0);
            }
            if (this._trim) {
                for (var i = s.length - 1; i >= 0; i--) {
                    if (s.charAt(i) != '0') {
                        s = s.substring(0, i + 1);
                        break;
                    }
                }
            }
            return s;
        }
    },
	_parse: function (format) {
		if (format) {
			format = format.trim();
		}
		if (!format) {
			return;
		}
        var i, c, zero,
		    len = format.length,
		    period = format.indexOf(".");
		if (period >= 0) {
			for (i = period + 1; i < len; i++) {
				if (format.charAt(i) == "0") {
					this._minDigits++;
					this._maxDigits++;
				} else {
					break;
				}
			}
			for (; i < len; i++) {
				if (format.charAt(i) == "#") {
					this._maxDigits++;
				} else {
					break;
				}
			}
            if ($$$_MAX_DIGITS > 0) {
                this._maxDigits = Math.min($$$_MAX_DIGITS, this._maxDigits);
            }
			format = format.substr(0, period);
		}
		if (format) {
			len = format.length;
			if (format.charAt(len - 1) == ",") {
				this._groupPos = 3; // locale default
				format = format.substr(0, len - 1);
			}
		}
		if (format) {
			len = format.length;
			zero = true;
			for (i = len - 1; i >= 0; i--) {
				c = format.charAt(i);
				if (c == "0" && zero) {
					this._minInts++;
					this._maxInts++;
				} else if (this._groupPos == 0 && c == ",") {
					this._groupPos = len - i - 1;
				} else if (c == "#") {
					zero = false;
				} else {
					break;
				}
			}
		}
		if (this._groupPos > 0) {
			this._reg = new RegExp('\\d(?=(\\d{' + this._groupPos + '})+' + (this._maxDigits > 0 ? '\\.' : '$') + ')', 'g');
		}
        this._trim = this._maxDigits > this._minDigits;
	}
});
$$_DecimalFormatter_cache = {};
DecimalFormatter.getFormatter = function (format) {
    if (format) {
        var f = $$_DecimalFormatter_cache[format];
        if (!f) {
            $$_DecimalFormatter_cache[format] = f = new DecimalFormatter(format);
        }
        return f;
    }
    return null;
};
DecimalFormatter.formatNumber = function (format, value) {
	try {
		if (format) {
			return DecimalFormatter.getFormatter(format).format(value);
		}
	} catch (err) {
	}
	return String(value);
};
var BooleanFormatter = defineClass("BooleanFormatter", null, {
	init : function(format) {
		this._super();
		this._format = format;
		this._nullText = '';
		this._trueText = 'true';
		this._falseText = 'false';
		this._parse();
	},
	format: null,
	setFormat: function (value) {
		if (value != this._format) {
			this._format = value;
			this._parse();
		}
	},
	formatValue: function (v) {
		return (v === undefined) ? this._nullText : v ? this._trueText : this._falseText;
	},
	_parse: function () {
		this._falseText = this._trueText = null;
		if (this._format) {
			var arr = this._format.split(/[;\:]/);
			this._falseText = arr[0];
			if (arr.length > 0) {
				this._trueText = arr[1];
			}
			if (arr.length > 1) {
				this._nullText = arr[2];
			}
		}
	}
});
$$_BooleanFormatter_cache = {};
BooleanFormatter.getFormatter = function (format) {
    if (format) {
        var f = $$_BooleanFormatter_cache[format];
        if (!f) {
            $$_BooleanFormatter_cache[format] = f = new BooleanFormatter(format);
        }
        return f;
    }
    return null;
};
var BooleanConverter = function (format) {
	var _format = format;
	var _values = null;
	var _sensitive = true;
	var _trueText = null;
	var _falseText = null;
	this.format = function () {
		return _format;
	};
	this.setFormat = function (value) {
		if (value != _format) {
			_format = value;
			parse(value);
		}
	};
	this.toBool = function (value) {
		if (_values) {
			if (value) {
				var s = _sensitive ? String(value) : String(value).toLowerCase();
				if (s in _values) {
					return _values[s];
				}
			}
		}
		return Boolean(value);
	};
	this.toBoolEx = function (value) {
		var s = _sensitive ? String(value) : String(value).toLowerCase();
		if (_values) {
			if (s in _values) {
				return _values[s];
			}
		}
		return s ? true : undefined;
	};
	this.toBoolStrict = function (value) {
		if (_values) {
			var s = _sensitive ? String(value) : String(value).toLowerCase();
			if (s in _values) {
				return _values[s];
			}
		}
		return undefined;
	};
	this.toText = function (value) {
		return value ? _trueText : _falseText;
	};
	var parse = function (fmt) {
		if (fmt) {
			var s,
				i,
				arr = fmt.split(/[;\:]/),
				falses,
				trues,
				sensitive = true;
			s = arr[0];
			falses = s ? s.split(",") : null;
			if (arr.length > 1) {
				s = arr[1];
				trues = s ? s.split(",") : null;
			}
			if (arr.length > 2) {
				s = trim(arr[2]);
				if (s == "0")
					sensitive = false;
			}
			_values = {};
			_sensitive = sensitive;
			for (i = 0; i < falses.length; i++) {
				s = falses[i];
				_values[sensitive ? s : s.toLowerCase()] = false;
			}
			for (i = 0; i < trues.length; i++) {
				s = trues[i];
				_values[sensitive ? s : s.toLowerCase()] = true;
			}
			_trueText = trues && trues.length > 0 ? trues[0] : "true";
			_falseText = falses && falses.length > 0 ? falses[0] : "false";
		} else {
			_values = {};
			_values["true"] = true;
			_values["false"] = false;
			_trueText = "true";
			_falseText = "false";
		}
	};
	parse(_format);
};
BooleanConverter.$_DefaultFormat = "false,f,0:true,t,1:0";
BooleanConverter.Default = new BooleanConverter(BooleanConverter.$_DefaultFormat);
$$_BooleanConverter_cache = {};
$$_BooleanConverter_cache[BooleanConverter.$_DefaultFormat] = BooleanConverter.Default;
BooleanConverter.getConverter = function (format) {
    if (format) {
        var c = $$_BooleanConverter_cache[format];
        if (!c) {
            $$_BooleanConverter_cache[format] = c = new BooleanConverter(format);
        }
        return c;
    }
    return null;
};
var DATE_SEPARATORS = "./-: ";
var DateTimeParser = defineClass("DateTimeParser", null, {
	init : function(format) {
		this._super();
		this._baseYear = 0;
		this._patterns = [];
		this.setFormat(format);
	},
	format: null,
	baseYear: 2000,
    zoneDelta: 0,
	amText: null,
	pmText: null,
	setFormat: function (value) {
		if (value != this._format) {
			if (!value) {
                this.$_throwInvalidFormat('');
			}
			this.$_parseFormat(value);
			this._format = value;
		}
	},
	setBaseYear: function (value) {
		if (isNaN(value)) value = 2000;
		if (value != this._baseYear) {
			this._baseYear = value;
		}
	},
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
		}
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
		}
	},
	parse: function (str) {
		try {
			var y = 0;
			var m = 1;
			var d = 1;
			var h = 0;
			var n = 0;
			var s = 0;
			var S = 0;
			var am = 0;
			var pm = 0;
			var len = this._patterns.length;
			var i;
			var p = 0;
			var strlen = str.length;
			for (i = 0; i < len && p < strlen; i++) {
				var pattern = this._patterns[i];
				var c = pattern.c;
				var l = pattern.len;
				switch (c) {
					case "y":
						y = _int(str.substr(p, l));
						break;
					case "M":
						m = _int(str.substr(p, l));
						break;
					case "d":
						d = _int(str.substr(p, l));
						break;
					case "a":
						var a;
						if ((a = (this._amText || Locale._default.am)) && str.indexOf(a, p) == p) {
							am = 12;
							l = a.length;
						} else if (((a = this._pmText || Local._default.pm)) && str.indexOf(a, p) == p) {
							pm = 12;
							l = a.length;
						} else {
							return null;
						}
						break;
					case "H":
						h = _int(str.substr(p, l));
						break;
					case "h":
						h = _int(str.substr(p, l));
						break;
					case "m":
						n = _int(str.substr(p, l));
						break;
					case "s":
						s = _int(str.substr(p, l));
						break;
					case "S":
						S = _int(str.substr(p, l));
						break;
					case ".":
					case "/":
					case "-":
					case ":":
					case " ":
						/*
						if (strict) {
							if (str.charAt(p) != c) {
								return null;
							}
						} else*/ if (DATE_SEPARATORS.indexOf(str.charAt(p)) < 0) {
							return null;
						}
						break;
					default:
						return null;
				}
				p += l;
			}
		} catch (err) {
			return null;
		}
		if (y < 100) {
			y += this._baseYear;
		}
		if (am > 0) {
			if (h == 12) {
				h = 0;
			}
		} else if (pm > 0 && h < 12) {
			h += 12;
		}
		return new Date(y, m - 1, d, h, n + this._zoneDelta, s, S);
	},
	$_parseFormat: function (format) {
		var s = format;
		var len = s.length;
		var i = 0;
		var p, c, l;
		this._patterns = [];
		while (i < len) {
			p = i;
			c = s.charAt(i);
			if (_isWhitespace(c)) {
				i++;
				while (i < len && _isWhitespace(s.charAt(i))) {
					i++;
				}
				this._patterns.push({ c: " ", p: p, len: i - p });
			} else {
				l = 0;
				switch (c) {
					case "y":
						l = this.$_getPattern(s, i, c);
						if (l != 4 && l != 2) this.$_throwInvalidFormat(s);
						break;
					case "M":
					case "d":
					case "H":
					case "h":
					case "m":
					case "s":
						l = this.$_getPattern(s, i, c);
						if (l != 2) this.$_throwInvalidFormat(s);
						break;
					case "S":
						l = this.$_getPattern(s, i, c);
						if (l != 3) this.$_throwInvalidFormat(s);
						break;
					case "a":
					case ".":
					case "/":
					case "-":
					case ":":
						l = this.$_getPattern(s, i, c);
						if (l != 1) this.$_throwInvalidFormat(s);
						break;
					default:
						this.$_throwInvalidFormat(s);
				}
				if (l > 0) {
					this._patterns.push({ c: c, p: i, len: l });
					i += l;
				}
			}
		}
	},
	$_throwInvalidFormat: function (format) {
		if ($_debug) debugger;
		throw new Error(Locale._default.invalidDateTimeFormat + ": " + format);
	},
	$_getPattern: function (str, i, c) {
		var len = str.length;
		var cnt = 1;
		while (++i < len && str.charAt(i) == c) {
			cnt++;
		}
		return cnt;
	}
});
var $$_DT_DATE_TOKENS = [
	"yy", "yyyy",
	"M", "MM", "MMM", "MMMM",
	"d", "dd", "ddd", "dddd",
	"a",
	"H", "HH", "h", "hh",
	"m", "mm",
	"s", "ss",
	"S", "SS", "SSS",
    'tt', "TT",
    "'", '"'
];
var $$_DT_DATE_SEPARATORS = [
	".", "/", "-", ":"
];
var U_0 = "0".charCodeAt(0);
var U_9 = "9".charCodeAt(0);
var U_Z = "Z".charCodeAt(0);
var L_Z = "z".charCodeAt(0);
var U_A = "A".charCodeAt(0);
var L_A = "a".charCodeAt(0);
var U_Y = "Y".charCodeAt(0);
var L_Y = "y".charCodeAt(0);
var U_M = "M".charCodeAt(0);
var L_M = "m".charCodeAt(0);
var U_D = "D".charCodeAt(0);
var L_D = "d".charCodeAt(0);
var U_H = "H".charCodeAt(0);
var L_H = "h".charCodeAt(0);
var U_S = "S".charCodeAt(0);
var L_S = "s".charCodeAt(0);
var L_T = 't'.charCodeAt(0);
var U_T = 'T'.charCodeAt(0);
var L_Q = "'".charCodeAt(0);
var DateTimeWriter = function (format) {
	var _format = null;
	var _amText = null;
	var _pmText = null;
	var _baseYear = 2000;
	var _preserveTime = false;
	var _tokens = null;
    var _literals = null;
	var _formatString = null;
	var _parseDateFormatTokens = function (format, literals) {
		if (format) {
			var tok, p, c;
			var str = format.trim();
			var len = str.length;
            var tokens = [];
            var i = 0;
            while (i < len) {
				tok = str.charAt(i);
				if ($$_DT_DATE_SEPARATORS.indexOf(tok) >= 0) {
					tokens.push(tok);
					i++;
				} else {
					p = i++;
					while (i < len && str.charAt(i) == tok) {
						i++;
					}
					tok = str.substring(p, i);
					if ($$_DT_DATE_TOKENS.indexOf(tok) < 0) {
						c = tok.charCodeAt(0);
						if (c >= U_A && c <= U_Z || c >= L_A && c <= L_Z) {
							throw new Error(Locale._default.invalidDateTimeOutputFormat + ": " + format);
						}
					}
                    if (tok === "'" || tok === '"') {
                        var k = i;
                        while (i < len && str.charAt(i) != tok) {
                            i++
                        }
                        if (i >= len) {
                            throw new Error(Locale._default.invalidDateTimeOutputFormat + ": " + format);
                        }
                        literals.push(str.substring(k, i++));
                        tok = "'";
                    }
					tokens.push(tok);
				}
				if (i < len && _isWhitespace(tok = str.charAt(i))) {
					tokens.push(tok);
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
            return tokens;
		}
		return null;
	};
	var _parse = function (fmt) {
        _tokens = null;
        if (typeof fmt === "string") {
            fmt = fmt.trim();
            if (fmt) {
                _format = fmt;
                _tokens = _parseDateFormatTokens(fmt, _literals = []);
            }
        }
	};
	var _pad = function (v) {
		return (v < 10) ? "0" + v : String(v);
	};
	this.format = function () {
		return _format;
	};
	this.formatString = function () {
		return _formatString;
	};
	this.setFormatString = function (value) {
		value = value || DateTimeWriter.$_DefaultFormat;
		if (value != _formatString) {
			_tokens = [];
			_parse(value);
			_formatString = value;
		}
	};
	this.getText = function (d) {
		if (!_tokens) {
			return "";
		}
		var date = d;
		if (!(date instanceof  Date)) {
			date = new Date(d);
		}
        var lang = Locale._default;
        var l = 0;
		var s = "";
        var h;
		for (var i = 0, cnt = _tokens.length; i < cnt; i++) {
			var t = _tokens[i];
			var len = t.length;
			switch (t.charCodeAt(0)) {
				case L_Y:
					s += len > 2 ? date.getFullYear() : _pad(date.getFullYear() % 100);
					break;
				case U_M:
					s += len > 3 ? lang.months[date.getMonth()] : len > 2 ? lang.shortMonths[date.getMonth()] : len > 1 ? _pad(date.getMonth() + 1) : (date.getMonth() + 1);
					break;
				case L_D:
					s += len > 3 ? lang.weekDays[date.getDay()] : len > 2 ? lang.shortWeekDays[date.getDay()] : len > 1 ? _pad(date.getDate()) : date.getDate();
					break;
				case U_H:
					s += len > 1 ? _pad(date.getHours()) : date.getHours();
					break;
				case L_H:
					h = date.getHours();
					if (h == 0) {
						h = 12
					} else if (h > 12) {
						h = h - 12;
					}
					s += len > 1 ? _pad(h) : h;
					break;
				case L_M:
					s += len > 1 ? _pad(date.getMinutes()) : date.getMinutes();
					break;
				case L_S:
					s += len > 1 ? _pad(date.getSeconds()) : date.getSeconds();
					break;
				case U_S:
					s += date.getMilliseconds().toString().substr(0, len);
					break;
				case L_A:
				case U_A:
                case L_T:
                case U_T:
                    if (date.getHours() < 12) {
                        s += lang.am;
                    } else {
                        s += lang.pm;
                    }
                    break;
                case L_Q:
                    s += _literals[l++];
                    break;
				/*
				 case U_Y:
				 break;
				 case U_D:
				 s += day of year
				 break;
				 */
				default:
					s += t;
			}
		}
		return s;
	};
	this.setFormatString(format || DateTimeWriter.$_DefaultFormat);
};
Locale.addCallback(function (lang) {
    var dtw = DateTimeWriter; 
    dtw.$_DefaultFormat = Locale._default.shortDateFormat;
    dtw.Default = new dtw(dtw.$_DefaultFormat);
    dtw.Month = new dtw(Locale._default.monthFormat);
    dtw.Year = new dtw(Locale._default.yearFormat);
    dtw.Second = new dtw(Locale._default.secondFormat);
    dtw.Minute = new dtw(Locale._default.minuteFormat);
    dtw.Hour = new dtw(Locale._default.minuteFormat);
    dtw.Writers = {};
    dtw.Writers[DateTimeScale.YEAR] = dtw.Year;
    dtw.Writers[DateTimeScale.HALF] = dtw.Month;
    dtw.Writers[DateTimeScale.QUARTER] = dtw.Month;
    dtw.Writers[DateTimeScale.MONTH] = dtw.Month;
    dtw.Writers[DateTimeScale.WEEK] = dtw.Default;
    dtw.Writers[DateTimeScale.DATE] = dtw.Default;
    dtw.Writers[DateTimeScale.HOUR] = dtw.Hour;
    dtw.Writers[DateTimeScale.MINUTE] = dtw.Minute;
    dtw.Writers[DateTimeScale.SECOND] = dtw.Second;
});
$$_DateTimeWriter_cache = {};
$$_DateTimeWriter_cache[DateTimeWriter.$_DefaultFormat] = DateTimeWriter.Default;
DateTimeWriter.getWriter = function (format) {
    if (typeof format == "string") {
        var cache = $$_DateTimeWriter_cache;
        var w = cache[format];
        if (!w) {
            cache[format] = w = new DateTimeWriter(format);
        }
        return w;
    }
    return null;
};
var $$_DATE_TOKENS = [
	"yy", "yyyy",
	"M", "MM",
	"d", "dd",
	"a", "A",
	"H", "HH", "h", "hh",
	"m", "mm",
	"s", "ss"
];
var $$_DATE_SEPARATORS = [
	".", "/", "-", ":"
];
var $$_ZERO_CHAR = "0".charCodeAt(0);
var $$_NINE_CHAR = "9".charCodeAt(0);
var DatetimeConverter = function (format) {
	var _formatString = null,
	    _format = null,
	    _amText = null,
	    _pmText = null,
	    _baseYear = 2000,
	    _preserve = false;
	var _splitWords = function (str) {
		var i, p, c, c2,
		    len = str.length,
		    words = [];
		p = i = 0;
		c = str.charAt(i++);
		while (i < len) {
			c2 = str.charAt(i);
			if (c2 != c) {
				words.push(str.substring(p, i));
				c = c2;
				p = i;
			}
			i++;
		}
		if (p < len) {
			words.push(str.substr(p));
		}
		return words;
	};
	var _parseDateFormatTokens = function (format) {
		var str, c, p, s, j, len, i, tokens2,
		    tokens = [];
		if (str = _trim(format)) {
			len = str.length;
			i = 0;
			while (i < len) {
				c = str.charAt(i);
				if ($$_DATE_SEPARATORS.indexOf(c) >= 0) {
					tokens.push(c);
					i++;
				} else {
					p = i++;
					while (i < len && str.charAt(i) == c) {
						i++;
					}
					c = str.substring(p, i);
					if ($$_DATE_TOKENS.indexOf(c) < 0) {
						throw new Error(Locale._default.invalidDateTimeInputFormat + ": " + format);
					}
					tokens.push(c == "A" ? "a" : c);
				}
				if (i < len && _isWhitespace(c = str.charAt(i))) {
					tokens.push(" ");
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
			tokens2 = [];
			len = tokens.length;
			p = 0;
			for (i = 0; i < len; i++) {
				c = tokens[i];
				if (c == "a" || $$_DATE_TOKENS.indexOf(c) < 0) {
					if (p > 1) {
						tokens2.push("E");
					}
					tokens2.push(c);
					p = 0;
				} else {
					if (p == 1) {
						tokens2.splice(tokens2.length - 2, 0, "L");
					}
					tokens2.push(c);
					p++;
				}
			}
			tokens = tokens2;
		}
		return tokens;
	};
	var _parseDateValueTokens = function (date, amStr, pmStr) {
		var str;
		var tokens = [];
		var ampms = ["am", "pm", "AM", "PM", "Am", "Pm", "aM", "pM"];
		amStr && ampms.push(amStr);
		pmStr && ampms.push(pmStr);
		if (str = _trim(date)) {
			var c, p;
			var len = str.length;
			var i = 0;
			while (i < len) {
				c = str.charAt(i);
				if (DATE_SEPARATORS.indexOf(c) >= 0) {
					tokens.push(c);
					i++;
				} else if (c.charCodeAt(0) >= $$_ZERO_CHAR && c.charCodeAt(0) <= $$_NINE_CHAR) {
					p = i++;
					while (i < len && str.charCodeAt(i) >= $$_ZERO_CHAR && str.charCodeAt(i) <= $$_NINE_CHAR) {
						i++;
					}
					c = str.substring(p, i);
					tokens.push(c);
				} else {
					var idx = -1;
					for (var j = 0; j < ampms.length; j++) {
						if (str.indexOf(ampms[j], i) == i) {
							idx = j;
							break;
						}
					}
					if (idx < 0) {
						throw new Error(Locale._default.invalidDateTimeText + ": " + str);
					}
					tokens.push(ampms[j]);
					i += ampms[j].length;
				}
				if (i < len && _isWhitespace(c = str.charAt(i))) {
					tokens.push(" ");
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
		}
		return tokens;
	};
	var _validateDateFormat = function (format) {
		if (format = _trim(format)) {
			var tokens = _parseDateFormatTokens(format);
			var i = 0;
			/*
			 var str:String = StringUtil.trim(format);
			 var arr:Array = str.split(/[\s+|\.|\-|\/|\:]/);
			 for each (var s:String in arr) {
			 if (s && DATE_TOKENS.indexOf(s) < 0) {
			 var words:Array = splitWords(s);
			 var valid:Boolean = true;
			 for each (var w:String in words) {
			 if(DATE_TOKENS.indexOf(w) < 0) {
			 valid = false;
			 break;
			 }
			 }
			 if (!valid) {
			 throw new Error("Invalid datetime read format: " + format);
			 }
			 }
			 }
			 var ampm:Boolean = arr.indexOf("a") >= 0 || arr.indexOf("A") >= 0;
			 */
			var ampm = tokens.indexOf("a") >= 0;
			if (ampm && tokens.indexOf("H") >= 0) {
				throw Locale._default.invalidDateTimeFormat2 + ': ' + format;
			}
			if (tokens.indexOf("h") >= 0 && !ampm) {
				throw Locale._default.invalidDateTimeFormat3 + ': ' + format;
			}
		}
	};
	var _parse = function (fmt) {
        _format = null;
        _amText = 'am';
        _pmText = 'pm';
        _baseYear = 2000;
        _preserve = false;
		if (fmt) {
			var arr = fmt.split(";");
			_format = arr[0] ? arr[0] : _defaultFormat;
			_validateDateFormat(_format);
            if (arr.length > 1) {
                _preserve = arr[1] ? arr[1] == "1" : false;
            }
			if (arr.length > 2 && arr[2]) {
				var ampms = arr[2].split(",");
				if (ampms[0]) _amText = ampms[0];
                if (ampms[1]) _pmText = ampms[1];
			}
            if (arr.length > 3) {
                var v = _int(arr[3]);
                if (!isNaN(v)) _baseYear = v;
            }
		}
	};
	this.formatString = function () {
		return _formatString;
	};
	this.setFormatString = function (value) {
		if (value != _formatString) {
			_formatString = value;
            _parse(value);
		}
	};
	this.format = function () {
		return _format;
	};
	this.getDate = function (str, value) {
		var val = _isDate(value) ? value : null,
            d = null;
		if (str = _trim(str)) {
            var ss, token, v,
                timed = false,
                dated = false,
			    tokens = _parseDateFormatTokens(_format),
			    values = _parseDateValueTokens(str, _amText, _pmText),
			    ampm = tokens.indexOf("a") >= 0 || tokens.indexOf("A") >= 0,
			    len = tokens.length,
			    vlen = values.length,
			    y = 0,
			    m = 1,
			    d = 1,
			    h = 0,
			    n = 0,
			    s = 0,
			    am = 0,
			    pm = 0,
			    i = 0,
			    j = 0;
			while (i < len && j < vlen) {
				token = tokens[i];
				v = values[j];
				switch (token.charAt(0)) {
					case "L":
						ss = String(v);
						i++;
						while (i < len && (str = tokens[i]) != "E") {
							v = ss ? _int(ss.substr(0, str.length)) : -1;
							ss = ss.substr(str.length);
							switch (str.charAt(0)) {
								case "Y":
								case "y":
									y = Math.max(0, v);
									break;
								case "M":
									m = v >= 0 ? v : 1;
									break;
								case "D":
								case "d":
									d = v >= 0 ? v : 1;
									break;
								case "H":
								case "h":
									h = Math.max(0, v);
									break;
								case "m":
									n = Math.max(0, v);
									break;
								case "s":
									s = Math.max(0, v);
									break;
							}
							i++;
						}
						break;
					case "Y":
					case "y":
                        dated = true;
						y = _int(v);
						break;
					case "M":
                        dated = true;
						m = _int(v);
						break;
					case "D":
					case "d":
                        dated = true;
						d = _int(v);
						break;
					case "H":
					case "h":
                        timed = true;
						h = _int(v);
						break;
					case "m":
                        timed = true;
						n = _int(v);
						break;
					case "s":
                        timed = true;
						s = _int(v);
						break;
					case "a":
						str = String(v);
						if (str) {
							str = str.toLowerCase();
							if ((_amText && str == _amText.toLowerCase()) || (str == "am")) {
								am = 12;
							} else if ((_pmText && str == _pmText.toLowerCase()) || (str == "pm")) {
								pm = 12;
							}
						}
						break;
				}
				i++;
				j++;
			}
			if (y < 100 && y >= 0) {
				y += _baseYear;
			}
			/*
			 m = Math.min(12, Math.max(1, m));
			 d = Math.min(31, Math.max(1, d));
			 if (m == 2) {
			 if (d >= 28) {
			 if ((((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)))
			 d = 29;
			 else
			 d = 28;
			 }
			 } else {
			 if (d == 31 && (m == 4 || m == 6 || m == 9 || m == 11)) {
			 d = 30;
			 }
			 }
			 */
            if (dated) {
                if (y < 0 || y > 9999) {
                    return null;
                }
                if (m < 1 || m > 12) {
                    return null;
                }
                if (d < 1 || d > 31) {
                    return null;
                }
                if (m == 2) {
                    if (d > 29) {
                        return null;
                    }
                    if (d == 29) {
                        if (!((y % 4 == 0) && (y % 100 != 0) || (y % 400 == 0)))
                            return null;
                    }
                }
            } else if (_preserve && v) {
                y = val.getFullYear();
                m = val.getMonth() + 1;
                d = val.getDate();
            }
            if (timed) {
                if (h < 0 || h > 24) {
                    return null;
                }
                if ((am > 0 || pm > 0) && h > 12) {
                    return null;
                }
                if (n < 0 || n > 59) {
                    return null;
                }
                if (s < 0 || s > 59) {
                    return null;
                }
                if (am > 0) {
                    h = h % 12;
                } else if (pm > 0) {
                    h = h % 12 + 12;
                }
            } else if (_preserve && _isDate(val)) {
                h = val.getHours();
                n = val.getMinutes();
                s = val.getSeconds();
            }
			d = new Date(y, m - 1, d, h, n, s);
		}
		return d;
	};
    this.getDateNull = function (s) {
        try {
            return this.getDate(s);
        } catch (err) {
        }
        return null;
    };
	this.getText = function (d) {
		var date/*Date*/ = d;
		if (!(date instanceof Date)) {
			date = new Date(d);
		}
		var tokens = _parseDateFormatTokens(_format);
		var ampm = tokens.indexOf("a") >= 0 || tokens.indexOf("A") >= 0;
		var s = "";
		var h;
		for (var i = 0, cnt = tokens.length; i < cnt; i++) {
			var t = tokens[i];
			var len = t.length;
			switch (t.charAt(0)) {
				case "L":
					break;
				case "Y":
				case "y":
					s += len > 2 ? date.getFullYear() : _pad(date.getFullYear() % 100);
					break;
				case "M":
					s += len > 1 ? _pad(date.getMonth() + 1) : date.getMonth() + 1;
					break;
				case "D":
				case "d":
					s += len > 1 ? _pad(date.getDate()) : date.getDate();
					break;
				case "H":
					s += len > 1 ? _pad(date.getHours()) : date.getHours();
					break;
				case "h":
					if (ampm) {
						h = date.getHours();
						if (h == 0) {
							h = 12
						} else if (h > 12) {
							h = h - 12;
						}
						s += len > 1 ? _pad(h) : h;
					} else {
						s += len > 1 ? _pad(date.getHours()) : date.getHours();
					}
					break;
				case "m":
					s += len > 1 ? _pad(date.getMinutes()) : date.getMinutes();
					break;
				case "s":
					s += len > 1 ? _pad(date.getSeconds()) : date.getSeconds();
					break;
				case "A":
				case "a":
					if (date.getHours() < 12) {
						s += _amText;
					} else {
						s += _pmText;
					}
					break;
				default:
					s += t;
			}
		}
		return s;
	};
	this.setFormatString(format);
};
DatetimeConverter.$_DefaultFormat = "yyyy/MM/dd";
DatetimeConverter.Default = new DatetimeConverter(DatetimeConverter.$_DefaultFormat);
var ISODateTimeParser = function () {
};
var $$_zoneOffset = new Date().getTimezoneOffset() * 60 * 1000;
ISODateTimeParser.parse = function (str, check) {
	var finalDate = null;
	try	{
		var t = str.indexOf("T");
		var dateStr = str.substring(0, t);
		var timeStr = str.substring(t + 1);
		var arr = dateStr.split("-");
		var len = arr.length;
		var year = _int(arr[0]);
		var month = len > 1 ? _int(arr[1]) : 1;
		var date = len > 2 ? _int(arr[2]) : 1;
		var multiplier;
		var offsetHours;
		var offsetMinutes;
		var offsetStr;
		if (timeStr.indexOf("Z") != -1) {
			multiplier = 1;
			offsetHours = 0;
			offsetMinutes = 0;
			timeStr = timeStr.replace("Z", "");
		} else if (timeStr.indexOf("+") != -1) {
			multiplier = 1;
			offsetStr = timeStr.substring(timeStr.indexOf("+") + 1, timeStr.length);
			offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
			offsetMinutes = Number(offsetStr.substring(offsetStr.indexOf(":") + 1, offsetStr.length));
			timeStr = timeStr.substring(0, timeStr.indexOf("+"));
		} else if (timeStr.indexOf("-") != -1) {
			multiplier = -1;
			offsetStr = timeStr.substring(timeStr.indexOf("-")+1, timeStr.length);
			offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
			offsetMinutes = Number(offsetStr.substring(offsetStr.indexOf(":") + 1, offsetStr.length));
			timeStr = timeStr.substring(0, timeStr.indexOf("-"));
		} else {
			multiplier = 0;
		}
		var timeArr = timeStr.split(":");
		len = timeArr ? timeArr.length : 0;
		var hour = len > 0 ? _int(timeArr[0]) : 0;
		var minutes = len > 1 ? _int(timeArr[1]) : 0;
		var secondsArr = (len > 2) ? String(timeArr[2]).split(".") : null;
		var seconds = (secondsArr && secondsArr.length > 0) ? _int(secondsArr[0]) : 0;
		var milliseconds = (secondsArr && secondsArr.length > 1) ? 1000 * parseFloat("0." + secondsArr[1]) : 0;
		var utc = Date.UTC(year, month-1, date, hour, minutes, seconds, milliseconds);
		var offset = multiplier ? (((offsetHours * 3600000) + (offsetMinutes * 60000)) * multiplier) : -$$_zoneOffset;
		finalDate = new Date(utc - offset);
		if (check && isNaN(finalDate.getTime())) {
			throw new Error(Locale._default.invalidDateTimeText + ": " + str);
		}
	} catch (e) {
		if (check) {
			var eStr = Locale._default.invalidDateTimeText + ": " + str;
            var s = e.toString();
            if (s.indexOf(Locale._default.invalidDateTimeText) != 0) {
                eStr += "\nError: " + e.toString();
            }
			throw new Error(eStr);
		}
	}
	return finalDate;
};
var $$_drawPlusBox = function (g, r, size, fill) {
	var x = _round(r.x + (r.width - size) / 2);
	var y = _round(r.y + (r.height - size) / 2);
	var s = _round(size / 9.0);
	var pts = [
		x + s * 0, y + s * 0,
		x + s * 0, y + s * 9,
		x + s * 9, y + s * 9,
		x + s * 9, y + s * 0,
	];
	var pts2 = [
	    x + s * 4, y + s * 2,
		x + s * 4, y + s * 4,
		x + s * 2, y + s * 4,
		x + s * 2, y + s * 5,
		x + s * 4, y + s * 5,
		x + s * 4, y + s * 7,
		x + s * 5, y + s * 7,
		x + s * 5, y + s * 5,
		x + s * 7, y + s * 5,
		x + s * 7, y + s * 4,
		x + s * 5, y + s * 4,
		x + s * 5, y + s * 2,
	];
    g.drawHoledPolygonArray(fill, null, pts, pts2);
};
var $$_drawMinusBox = function (g, r, size, fill) {
	var x = _round(r.x + (r.width - size) / 2);
	var y = _round(r.y + (r.height - size) / 2);
	var s = _round(size / 9.0);
	var pts = [
		x + s * 0, y + s * 0,
		x + s * 0, y + s * 9,
		x + s * 9, y + s * 9,
		x + s * 9, y + s * 0,
	];
	var pts2 = [
		x + s * 2, y + s * 4,
		x + s * 2, y + s * 5,
		x + s * 7, y + s * 5,
		x + s * 7, y + s * 4,
	];
    g.drawHoledPolygonArray(fill, null, pts, pts2);
};
var $$_drawCheckMark = function (g, fill, r, checkSize) {
	var x = r.x + (r.width - checkSize) / 2;
	var y = r.y + (r.height - checkSize) / 2 - checkSize / 6.0 + 1;
	var s = checkSize / 10.0;
	var pts = [
		x + s * 0, y + s * 6.573,
		x + s * 4.3915, y + s * 10,
		x + s * 10.1, y + s * 3, //0.91,
		x + s * 8.205, y + s * 2, //0,
		x + s * 3.684, y + s * 6.9425,
		x + s * 1.2, y + s * 5,
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawRightArrow = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 1.75, y + s * 1,
		x + s * 5.25, y + s * 4.5,
		x + s * 1.75, y + s * 8,
		x + s * 2.75, y + s * 9,
		x + s * 7.25, y + s * 4.5,
		x + s * 2.75, y + s * 0,
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawDownArrow = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 0, y + s * 2.75,
		x + s * 4.5, y + s * 7.25,
		x + s * 9, y + s * 2.75,
		x + s * 8, y + s * 1.75,
		x + s * 4.5, y + s * 5.25,
		x + s * 1, y + s * 1.75,
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawItriangle = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 1, y + s * 2,
		x + s * 8, y + s * 2,
		x + s * 4.5, y + s * 7
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawRightTriangle = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 7, y + s * 1,
		x + s * 7, y + s * 7,
		x + s * 1, y + s * 7
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawTriangleRight = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 2, y + s * 1,
		x + s * 7, y + s * 4.5,
		x + s * 2, y + s * 8
	];
	g.drawPolygonArray(fill, null, pts);
};
var ExpressionSyntaxError = _createError('DataLudi.ExpressionSyntaxError', "tokenPos");
function _syntaxError(message, pos) {
	throw new ExpressionSyntaxError(message, pos);
}
var ExpressionEvaluationError = _createError('DataLudi.ExpressionEvaluationError');
var $$_createTokenArray = function () {
	var arr = [];
	for (var i = 0; i < arguments.length; i++) {
		arr[arguments[i]] = true;
	}
	return arr;
};
var TokenKind = {
	Unknown 		: 0,
	Add 			: 1,
	Slash 			: 2,
	Star 			: 3,
	Minus 			: 4,
	Plus 			: 5,
	Identifier 		: 10,
	And 			: 11,
	Not 			: 13,
	Div 			: 14,
	Mod 			: 15,
	Shl 			: 16,
	Shr 			: 17,
	Or 				: 18,
	ToStr 			: 20,
	ToNum 			: 21,
	ToDate 			: 22,
	ToBool 			: 23,
	Length 	     	: 24,
	Is 				: 26,
	IsNot 			: 27,
	BraceClose 		: 30,
	BraceOpen 		: 31,
	Comma 			: 32,
	CRLF 			: 33,
	Null 			: 34,
	Defined 		: 35,
	Empty	 		: 36,
	NaN	 			: 37,
    True            : 38,
    False           : 39,
	Equal 			: 40,
	Greater 		: 41,
	GreaterEqual 	: 42,
	Lower 			: 43,
	LowerEqual 		: 44,
	NotEqual 		: 45,
	Like 			: 46,
	NotLike 		: 47,
	ILike 			: 48,
	NotILike 		: 49,
	Match 			: 50,
	NotMatch 		: 51,
	IMatch 			: 52,
	NotIMatch 		: 53,
	In              : 54,
	NotIn           : 55,
    Rand            : 56,
    Srand           : 57,
    ToUpper         : 58,
    ToLower         : 59,
	String 			: 60,
	StringLiteral 	: 61,
	Ascii 			: 62,
	FloatLiteral 	: 63,
	IntegerLiteral 	: 64,
	Point 			: 65,
	RoundOpen 		: 66,
	RoundClose 		: 67,
	DotDot 			: 68,
	BracketOpen 	: 69,
	BracketClose 	: 70,
	Space 			: 71,
	ToInt			: 72,
	ToNumz			: 73,
	ToIntz			: 74,
	Symbol 			: 80
};
TokenKind.IS_CHECK = $$_createTokenArray(TokenKind.Is, TokenKind.IsNot);
TokenKind.IS_SET = $$_createTokenArray(TokenKind.In, TokenKind.NotIn);
TokenKind.IS_COMPARISON = $$_createTokenArray(TokenKind.Equal, TokenKind.NotEqual, TokenKind.Like, TokenKind.NotLike, TokenKind.ILike, TokenKind.NotILike, TokenKind.Match, TokenKind.NotMatch, TokenKind.IMatch, TokenKind.NotIMatch, TokenKind.Greater, TokenKind.GreaterEqual, TokenKind.Lower, TokenKind.LowerEqual);
TokenKind.IS_LOGICAL = $$_createTokenArray(TokenKind.And, TokenKind.Or);
TokenKind.IS_ADDITIVE = $$_createTokenArray(TokenKind.Minus, TokenKind.Plus);
TokenKind.IS_MULTIPLICATIVE = $$_createTokenArray(TokenKind.Star, TokenKind.Slash, TokenKind.Div, TokenKind.Mod, TokenKind.Shl, TokenKind.Shr);
var ExpressionLexer = function () {
    var i,
        IS_IDENT = [],
        IS_INTEGER = [],
        IS_NUMBER = [],
        IS_WHITE = [],
        IS_END = [],
		IS_SEND = [],
        QUOTATION = 0,
        SQUOTATION = 0,
        Keywords = {};
    for (i = "0".charCodeAt(0); i <= "9".charCodeAt(0); i++) IS_IDENT[i] = true;
    for (i = "a".charCodeAt(0); i <= "z".charCodeAt(0); i++) IS_IDENT[i] = true;
    for (i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) IS_IDENT[i] = true;
    IS_IDENT["_".charCodeAt(0)] = true;
    for (i = "0".charCodeAt(0); i <= "9".charCodeAt(0); i++) IS_INTEGER[i] = true;
    for (i = "a".charCodeAt(0); i <= "f".charCodeAt(0); i++) IS_INTEGER[i] = true;
    for (i = "A".charCodeAt(0); i <= "F".charCodeAt(0); i++) IS_INTEGER[i] = true;
    for (i = "0".charCodeAt(0); i <= "9".charCodeAt(0); i++) IS_NUMBER[i] = true;
    IS_NUMBER[".".charCodeAt(0)] = IS_NUMBER["e".charCodeAt(0)] = IS_NUMBER["E".charCodeAt(0)] = true;
    for (i = 1; i <= 9; i++) IS_WHITE[i] = true;
    for (i = 11; i <= 12; i++) IS_WHITE[i] = true;
    for (i = 14; i <= 32; i++) IS_WHITE[i] = true;
    IS_END[0] = IS_END[10] = IS_END[13] = true;
	IS_SEND[0] = true;
    /*
	for (var i = 0; i < 256; i++) {
		IS_IDENT[i] = (i == "_".charCodeAt(0)) ||
			(i >= "0".charCodeAt(0) && i <= "9".charCodeAt(0)) ||
			(i >= "a".charCodeAt(0) && i <= "z".charCodeAt(0)) ||
			(i >= "A".charCodeAt(0) && i <= "Z".charCodeAt(0));
		IS_INTEGER[i] = 
			(i >= "0".charCodeAt(0) && i <= "9".charCodeAt(0)) ||
			(i >= "a".charCodeAt(0) && i <= "f".charCodeAt(0)) ||
			(i >= "A".charCodeAt(0) && i <= "F".charCodeAt(0));
		IS_NUMBER[i] = 
			(i >= "0".charCodeAt(0) && i <= "9".charCodeAt(0)) ||
			i == ".".charCodeAt(0) || i == "e".charCodeAt(0) || i == "E".charCodeAt(0);
		IS_WHITE[i] = (i >= 1 && i <= 9) || (i == 11) || (i >= 14 && i <= 32);
		IS_END[i] = (i == 0) || (i == 10) || (i == 13);
	}
	*/
	QUOTATION = "\"".charCodeAt(0);
	SQUOTATION = "'".charCodeAt(0);
	Keywords = {};
	Keywords["str"] = TokenKind.ToStr;
	Keywords["num"] = TokenKind.ToNum;
	Keywords["int"] = TokenKind.ToInt;
	Keywords["numz"] = TokenKind.ToNumz;
	Keywords["intz"] = TokenKind.ToIntz;
	Keywords["date"] = TokenKind.ToDate;
	Keywords["bool"] = TokenKind.ToBool;			
	Keywords["not"] = TokenKind.Not;			
	Keywords["len"] = TokenKind.Length;			
	Keywords["and"] = TokenKind.And;
	Keywords["in"] = TokenKind.In;
	Keywords["mod"] = TokenKind.Mod;
	Keywords["or"] = TokenKind.Or;
	Keywords["div"] = TokenKind.Div;
	Keywords["shl"] = TokenKind.Shl;			
	Keywords["shr"] = TokenKind.Shr;			
	Keywords["is"] = TokenKind.Is;
	Keywords["like"] = TokenKind.Like;
	Keywords["ilike"] = TokenKind.ILike;
	Keywords["match"] = TokenKind.Match;
	Keywords["imatch"] = TokenKind.IMatch;
	Keywords["defined"] = TokenKind.Defined;			
	Keywords["null"] = TokenKind.Null;			
	Keywords["empty"] = TokenKind.Empty;
    Keywords["nan"] = TokenKind.NaN;
	Keywords["true"] = TokenKind.True;
    Keywords["false"] = TokenKind.False;
    Keywords["rand"] = TokenKind.Rand;
    Keywords["srand"] = TokenKind.Srand;
    Keywords["lower"] = TokenKind.ToLower;
    Keywords["upper"] = TokenKind.ToUpper;
    var _procs = null,
        _source = null,
        _len = 0,
        _tokenId = 0,
        _run = 0,
        _nextRun = 0,
        _lineNo = 0,
        _linePos = 0,
        _tokenPos = 0;
	function _unkownProc() {
		_tokenId = TokenKind.Unknown;
		_run++;
	}
	function _symbolProc() {
		_tokenId = TokenKind.Symbol;
		_run++;
	}
	function _commaProc() {
		_tokenId = TokenKind.Comma;
		_run++;
	}
	function _crProc() {
		_tokenId = TokenKind.CRLF;
		if (_source.charCodeAt(_run + 1) == 10) {
			_run += 2;
		} else {
			_run++;
		}
		_lineNo++;
		_linePos = _run;
	}
	function _lfProc() {
		_tokenId = TokenKind.CRLF;
		_run++;
		_lineNo++;
		_linePos = _run;
	}
	function _greaterProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.GreaterEqual;
			_run += 2;
		} else {
			_tokenId = TokenKind.Greater;
			_run++;
		}
	}
	function _notProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.NotEqual;
			_run += 2;
		} else {
			_tokenId = TokenKind.Not;
			_run++;
		}
	}
	function _equalProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.Equal;
			_run += 2;
		} else {
			_syntaxError(Locale._default.invalidToken + ' at equalOp', _tokenLoc());
		}
	}
	function _andProc() {
		if (_source.charAt(_run + 1) == "&") {
			_tokenId = TokenKind.And;
			_run += 2;
		} else {
			_syntaxError(Locale._default.invalidToken + ' at andOp', _tokenLoc());
		}
	}
	function _orProc() {
		if (_source.charAt(_run + 1) == "|") {
			_tokenId = TokenKind.Or;
			_run += 2;
		} else {
			_syntaxError(Locale._default.invalidToken + ' at orOp', _tokenLoc());
		}
	}
	function _lowerProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.LowerEqual;
			_run += 2;
		} else {
			_tokenId = TokenKind.Lower;
			_run++;
		}
	}
	function _nextIdent() {
		var i = _run;
		while (i < _len && (!IS_IDENT[_source.charCodeAt(i)])) {
			i++;
		}
		var j = i;
		while (i < _len && (IS_IDENT[_source.charCodeAt(i)])) {
			i++;
		}
		if (i > j) {
			_nextRun = i;
			return _source.substr(j, i - j).toLowerCase();
		} else {
			return null;
		}
	}
	function _identProc() {
		var i = _run;
		while (_run < _len && (IS_IDENT[_source.charCodeAt(_run)] || _source.charCodeAt(_run) > 255)) {
			_run++;
		}
		var s = _source.substr(i, _run - i).toLowerCase();
		if (Keywords.hasOwnProperty(s)) {
			_tokenId = Keywords[s];
			switch (_tokenId) {
                case TokenKind.Not:
                    s = _nextIdent();
                    if (s) {
                        switch (s) {
                            case "in":
                                _tokenId = TokenKind.NotIn;
                                _run = _nextRun;
                                break;
                            case "like":
                                _tokenId = TokenKind.NotLike;
                                _run = _nextRun;
                                break;
                            case "ilike":
                                _tokenId = TokenKind.NotILike;
                                _run = _nextRun;
                                break;
                            case "match":
                                _tokenId = TokenKind.NotMatch;
                                _run = _nextRun;
                                break;
                            case "imatch":
                                _tokenId = TokenKind.NotIMatch;
                                _run = _nextRun;
                                break;
                        }
                    }
                    break;
                case TokenKind.Is:
                    s = _nextIdent();
                    if (s == "not") {
                        _tokenId = TokenKind.IsNot;
                        _run = _nextRun;
                    }
                    break;
            }
		}
		else {
			_tokenId = TokenKind.Identifier;
		}
	}
	function _integerProc() {
		_tokenId = TokenKind.IntegerLiteral;
		_run++;
		while (_run < _len && IS_INTEGER[_source.charCodeAt(_run)]) {
			_run++;
		}
	}
	function _numberProc() {
		_tokenId = TokenKind.IntegerLiteral;
		_run++;
		while (_run < _len && IS_NUMBER[_source.charCodeAt(_run)]) {
			if (_source.charAt(_run) == ".") {
				if (_source.charAt(_run + 1) == ".") {// dotdot에서 처리함.
					break;
				}
				_tokenId = TokenKind.FloatLiteral;
			}
			_run++;
		}
	}
	function _minusProc() {
		_tokenId = TokenKind.Minus;
		_run++;
	}
	function _plusProc() {
		_tokenId = TokenKind.Plus;
		_run++;
	}
	function _pointProc() {
		var s = _source.charAt(_run + 1);
		if (s == ".") {
			_tokenId = TokenKind.DotDot;
			_run += 2;
		} else {
			_tokenId = TokenKind.Point;
			_run++;
		}
	}
	function _roundOpenProc() {
		_tokenId = TokenKind.RoundOpen;
		_run++;
	}
	function _roundCloseProc() {
		_tokenId = TokenKind.RoundClose;
		_run++;
	}
	function _slashProc() {
		_tokenId = TokenKind.Slash;
		_run++;
	}
	function _spaceProc() {
		_tokenId = TokenKind.Space;
		_run++;
		while (_run < _len && IS_WHITE[_source.charCodeAt(_run)]) {
			_run++;
		}
	}
	function _bracketOpenProc() {
		_tokenId = TokenKind.BracketOpen;
		_run++;
	}
	function _bracketCloseProc() {
		_tokenId = TokenKind.BracketClose;
		_run++;
	}
	function _starProc() {
		_tokenId = TokenKind.Star;
		_run++;
	}
	function _modProc() {
		_tokenId = TokenKind.Mod;
		_run++;
	}
	function _stringProc() {
		_tokenId = TokenKind.StringLiteral;
		do {
			var c = _source.charCodeAt(_run);
			if (IS_SEND[c]) {
				_syntaxError(Locale._default.untermintatedString, _tokenLoc());
			}
			/*
			if (c == QUOTATION) {
				while (_run < _len - 1 && _source.charCodeAt(_run) == QUOTATION && _source.charCodeAt(_run + 1) == QUOTATION) {
					_run += 2;
				}
			}
			*/
			_run++;
		} while (_run < _len && _source.charCodeAt(_run) != QUOTATION);
		_run++;
	}
	function _smallStringProc() {
		_tokenId = TokenKind.StringLiteral;
		do {
			var c = _source.charCodeAt(_run);
			if (IS_SEND[c]) {
				_syntaxError(Locale._default.untermintatedString, _tokenLoc());
			}
			/*
			if (c == SQUOTATION) {
				while (_run < _len - 1 && _source.charCodeAt(_run) == SQUOTATION && _source.charCodeAt(_run + 1) == SQUOTATION)
					_run += 2;
			}
			*/
			_run++;
		} while (_run < _len && _source.charCodeAt(_run) != SQUOTATION);
		_run++;
	}
	function _initProcs() {
		var i;
		_procs = [];
		for (i = 1; i <= 255; i++) {
			_procs[i] = _symbolProc;
		}
		for (i = 1; i <= 32; i++) {
			_procs[i] = _spaceProc;
		}
		_procs[10] = _lfProc;
		_procs[13] = _crProc;
		_procs["$".charCodeAt(0)] = _integerProc;
		_procs[QUOTATION] = _stringProc;
		_procs[SQUOTATION] = _smallStringProc;
		for (i = 0; i <= 9; i++) {
			_procs["0".charCodeAt(0) + i] = _numberProc;
		}
		for (i = "A".charCodeAt(0); i <= "Z".charCodeAt(); i++) {
			_procs[i] = _identProc;
		}
		for (i = "a".charCodeAt(0); i <= "z".charCodeAt(); i++) {
			_procs[i] = _identProc;
		}
		_procs["_".charCodeAt(0)] = _identProc;
		_procs["(".charCodeAt(0)] = _roundOpenProc;
		_procs[")".charCodeAt(0)] = _roundCloseProc;
		_procs["*".charCodeAt(0)] = _starProc;
		_procs["+".charCodeAt(0)] = _plusProc;
		_procs[",".charCodeAt(0)] = _commaProc;
		_procs["-".charCodeAt(0)] = _minusProc;
		_procs[".".charCodeAt(0)] = _pointProc;
		_procs["/".charCodeAt(0)] = _slashProc;
		_procs["%".charCodeAt(0)] = _modProc;
		_procs["!".charCodeAt(0)] = _notProc;
		_procs["=".charCodeAt(0)] = _equalProc;
		_procs["&".charCodeAt(0)] = _andProc;
		_procs["|".charCodeAt(0)] = _orProc;
		_procs["<".charCodeAt(0)] = _lowerProc;
		_procs[">".charCodeAt(0)] = _greaterProc;
		_procs["[".charCodeAt(0)] = _bracketOpenProc;
		_procs["]".charCodeAt(0)] = _bracketCloseProc;
	}
	function _next() {
		if (_run < _len) {
			var c = _source.charCodeAt(_run);
			_tokenPos = _run;
			if (c < 256) {
				_procs[c]();
			} else {
				_identProc();
			}
			return true;
		}
		return false;
	}
	this.source = function () {
		return _source;
	};
	this.tokenId = function () {
		return _tokenId;
	};
	var _tokenLoc = function () {
		var loc = { x: _tokenPos - _linePos, y: _lineNo };
		var s;
		try { s = _source.substr(_tokenPos, _run - _tokenPos); } catch (e) {}
		s && (loc.expr = s.substr(0, 20));
		return loc;
	};
	this.tokenLoc = _tokenLoc;
	this.tokenLen = function () {
		return _run - _tokenPos;
	};
	this.token = function () {
		return _source.substr(_tokenPos, this.tokenLen());
	};
	this.isSpace = function () {
		return _tokenId == TokenKind.Space;
	};
	this.init = function (source) {
		_source = source;
		_len = source.length;
		_lineNo = 0;
		_linePos = 0;
		_tokenPos = 0;
		_run = 0;
		_tokenId = 0;
	};
    /*
	this.charAhread = function () {
		_runAhead = _run;
		while (_runAhead < _len && _source.charCodeAt(_runAhead) > 0 && _source.charCodeAt(_runAhead) <= 32) {
			_runAhead++;
		}
		return _source.charCodeAt(this._runAhead);
	};
	*/
	this.isEnd = function () {
		return _run >= _len;
	};
	this.nextId = function (tokenId) {
		do {
			_next();
		} while (_run < _len && _tokenId != tokenId);
	};
	this.nextNoSpace = function () {
		do {
			if (_next() && !this.isSpace()) {
				return true;
			}
		} while (_run < _len);
		return false;
	};
	this.isFirstInLine = function () {
		if (_tokenPos == 0) {
			return true;
		}
		var c;
		var runBack = _tokenPos;
		runBack--;
		while (runBack > 0 && IS_WHITE[_source.charCodeAt(runBack)]) {
			runBack--;
		}
		if (runBack == 0) {
			return true;
		}
		c = _source.charCodeAt(runBack);
		if (c == 10 || c == 13) {
			return true;
		}
		return false;
	};
	_initProcs();
};
var /* abstract */ ExpressionNode = defineClass("ExpressionNode", null, {
	init: function () {
		this._super();
	},
	_asLiteral: function () {
		return null;
	},
	evaluate: function (/*runtime*/) {
		_throwAbstractError();
	},
	toString: function () {
		return String(this);
	}
});
var EmptyExpressionNode = defineClass("EmptyExpressionNode", ExpressionNode, {
    init: function () {
        this._super();
    },
    _asLiteral: function () {
        return null;
    },
    evaluate: function (/*runtime*/) {
        return undefined;
    },
    toString: function () {
        return "";
    }
}, null, function (f) {
    f.Default = new f();
});
var CheckableNode = defineClass("DefinedNode", ExpressionNode, {
	init: function() {
		this._super();
	}
});
var DefinedNode = defineClass("DefinedNode", CheckableNode, {
	init: function() {
		this._super();
	},
	value: function() {
		return UNDEFINED;
	},
	_asLiteral: function() {
		return this;
	},
	evaluate: function(runtime) {
		return UNDEFINED;
	},
	toString: function() {
		return "defined";
	}
});
var EmptyNode = defineClass("EmptyNode", CheckableNode, {
	init: function() {
		this._super();
	},
	value: function() {
		return UNDEFINED;
	},
	_asLiteral: function() {
		return this;
	},
	evaluate: function(runtime) {
		return UNDEFINED;
	},
	toString: function() {
		return "empty";
	}
});
var NullNode = defineClass("NullNode", CheckableNode, {
	init : function() {
		this._super();
	},
	value : function() {
		return null;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate : function(runtime) {
		return null;
	},
	toString : function() {
		return "null";
	}
});
var NanNode = defineClass("NanNode", CheckableNode, {
	init: function () {
		this._super();
	},
	value: function () {
		return NaN;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate: function (runtime) {
		return NaN;
	},
	toString: function () {
		return "NaN";
	}
});
var CheckNode = defineClass("CheckNode", ExpressionNode, {
	init: function (leftExpr, op, literal) {
		this._super();
		this.leftExpr = leftExpr;
		this.operator = op;
		this._isNot = op == TokenKind.IsNot;
		this._value = -1;
		if (literal instanceof DefinedNode) {
			this._value = CheckNode.DEFINED;
		} else if (literal instanceof NullNode) {
			this._value = CheckNode.NULL;
		} else if (literal instanceof EmptyNode) {
			this._value = CheckNode.EMPTY;
		} else if (literal instanceof NanNode) {
			this._value = CheckNode.NAN;
		}
	},
    isIdentifier: function(value) {
        return this.leftExpr.isIdentifier(value);
    },
	_prepareValue: function () {
		this.leftExpr._prepareValue();
		this._literal = this.leftExpr._getLiteral();
	},
	_getLiteral: function () {
		return null;
	},
	evaluate: function (runtime) {
		var v = this._literal ? this._literal.value() : this.leftExpr.evaluate(runtime);
		var r;
		switch (this._value) {
		case CheckNode.DEFINED:
			r = (v !== undefined);
			break;
		case CheckNode.NULL:
			r = (v === undefined || v === null);
			break;
		case CheckNode.EMPTY:
			r = (v === undefined || v === null || String(v).length == 0);
			break;
		case CheckNode.NAN:
			r = (v === null || isNaN(v));
			break;
		default:
			return undefined;
		}
		return this._isNot ? !r : r;
	},
	toString: function () {
		var s = "<<ERROR>>";
		switch (this._value) {
			case CheckNode.DEFINED:
				s = "defined";
				break;
			case CheckNode.NULL:
				s = "null";
				break;
			case CheckNode.EMPTY:
				s = "empty";
				break;
			case CheckNode.NAN:
				s = "NaN";
				break;
		}
		return "(" + ((this._isNot ? "is not " : "is ") + s) + ")";
	}
}, {
	DEFINED	: 0,
	NULL	: 1,
	EMPTY	: 2,
	NAN		: 3
});
var FloatLiteralNode = defineClass("FloatLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = Number(literal);
	},
	value : function() {
		return this._value;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return String(this._value);
	}
});
var IntegerLiteralNode = defineClass("IntegerLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = parseInt(literal);
	},
	value : function() {
		return this._value;
	},
	_asLiteral : function() {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return String(this._value);
	}
});
var BooleanLiteralNode = defineClass("BooleanLiteralNode", ExpressionNode, {
    init : function(literal) {
        this._super();
        this._value = literal == "true" ? true : false;
    },
    value : function() {
        return this._value;
    },
    _asLiteral : function() {
        return this;
    },
    evaluate : function(runtime) {
        return this._value;
    },
    toString : function() {
        return String(this._value);
    }
});
var StringLiteralNode = defineClass("StringLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = literal.substr(1, literal.length - 2);
	},
	value : function() {
		return this._value;
	},
	_asLiteral : function() {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return this._value;
	}
});
var IdentifierNode = defineClass("IdentifierNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._literal = literal;
		this._idKey = -830710;
	},
	identifier: function () {
		return this._literal;
	},
	evaluate : function(runtime) {
		if (this._idKey == -830710) {
			this._idKey = runtime.isIdentifier(this._literal);
		}
		return runtime.evaluateIdentifier(this._idKey);
	},
	toString : function() {
		return this._literal;
	}
});
var IndexerNode = defineClass("IndexerNode", ExpressionNode, {
	init : function(ident, expression) {
		this._super();
		this._ident = ident;
		this._indexer = expression;
		this._idKey = -1490313;
		this._intIndex = NaN;
		this._strIndex = null;
	},
	_prepareValue: function () {
		var vnode = null;
		var lit = this._indexer._asLiteral();
		if (!lit) {
			vnode = this._indexer._prepareValue && this._indexer;
			if (vnode) {
				vnode._prepareValue();
				lit = vnode._getLiteral();
			}
		}
		if (lit) {
			var v = lit.value();
			if (typeof v === "string") {
				this._strIndex = v;
			} else {
				this._intIndex = parseInt(v);
			}
		}
	},
	_getLiteral: function () {
		return null;
	},
	evaluate : function(runtime) {
		if (this._idKey == -1490313) {
			this._idKey = runtime.isIdentifier(this._ident);
		}
		if (this._strIndex) {
			return runtime.evaluateIndexerS(this._idKey, this._strIndex);
		} else if (!isNaN(this._intIndex)) {
			return runtime.evaluateIndexerI(this._idKey, this._intIndex);
		} else {
			var index = this._indexer.evaluate(runtime);
			if (typeof index === "string") {
				return runtime.evaluateIndexerS(this._idKey, index);
			} else {
				return runtime.evaluateIndexerI(this._idKey, index);
			}
		}
	},
	toString : function() {
		var s = this._ident + "[" + this._indexer.toString() + "]";
		return s;
	}
});
var /* abstract */ UnaryNode = defineClass("UnaryNode", ExpressionNode, {
	init : function(factor) {
		this._super();
		this._factor = factor;
		this._literal = null;
	},
	_prepareValue: function () {
		this._literal  = this._factor._asLiteral();
		if (!this._literal && this._factor._prepareValue) {
			this._factor._prepareValue();
			this._literal = this._factor._getLiteral();
		}
	},
	_getLiteral: function () {
		return null;
	}
});
var LenNode = defineClass("LenNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function (runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v ? v.length : 0;
	},
	toString: function () {
		return "(len " + this._factor + ")";
	}
});
var RandNode = defineClass("RandNode", UnaryNode, {
    init: function(factor) {
        this._super(factor);
    },
    evaluate: function (runtime) {
        var v = parseInt(this._literal ? this._literal.value() : this._factor.evaluate(runtime));
        return isNaN(v) || v <= 0 ? 0 : (Math.floor(Math.random() * v));
    },
    toString: function () {
        return "(rand " + this._factor + ")";
    }
});
var $$_chars = [
    'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
    'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
];
var SrandNode = defineClass("SrandNode", UnaryNode, {
    init: function(factor) {
        this._super(factor);
    },
    evaluate: function (runtime) {
        var v = parseInt(this._literal ? this._literal.value() : this._factor.evaluate(runtime));
        if (isNaN(v) || v <= 0) {
            return '';
        } else {
            var s = '';
            var l = $$_chars.length;
            for (var i = 0; i < v; i++) {
                s += $$_chars[Math.floor(Math.random() * l)];
            }
            return s;
        }
    },
    toString: function () {
        return "(srand " + this._factor + ")";
    }
});
var LowerNode = defineClass("LowerNode", UnaryNode, {
    init: function(factor) {
        this._super(factor);
    },
    evaluate: function (runtime) {
        var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
        return typeof v === 'string' ? v.toLowerCase() : v;
    },
    toString: function () {
        return "(lower " + this._factor + ")";
    }
});
var UpperNode = defineClass("UpperNode", UnaryNode, {
    init: function(factor) {
        this._super(factor);
    },
    evaluate: function (runtime) {
        var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
        return typeof v === 'string' ? v.toUpperCase() : v;
    },
    toString: function () {
        return "(upper " + this._factor + ")";
    }
});
var MinusNode = defineClass("MinusNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return -v;
	},
	toString: function() {
		return "-" + this._factor;
	}
});
var PlusNode = defineClass("PlusNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v;
	},
	toString: function() {
		return "+" + this._factor;
	}
});
var NotNode = defineClass("NotNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return !v;
	},
	toString: function() {
		return "(!" + this._factor + ")";
	}
});
var ToBoolNode = defineClass("ToBoolNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return Boolean(v);
	},
	toString: function() {
		return "(bool " + this._factor + ")";
	}
});
var ToNumberNode = defineClass("ToNumberNode", UnaryNode, {
	init: function(factor, zero) {
		this._super(factor);
		this._zero = zero;
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		v = Number(v);
		return (this._zero && isNaN(v)) ? 0 : v;
	},
	toString: function() {
		return (this.zero ? "(numz " : "(num ") + this._factor + ")";
	}
});
var ToIntegerNode = defineClass("ToIntegerNode", UnaryNode, {
	init: function(factor, zero) {
		this._super(factor);
		this._zero = zero;
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		v = Number(v);
		return (this._zero && isNaN(v)) ? 0 : Math.floor(v);
	},
	toString: function() {
		return (this.zero ? "(intz " : "(int ") + this._factor + ")";
	}
});
var ToDateNode = defineClass("ToDateNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return new Date(v);
	},
	toString: function() {
		return "(date " + this._factor + ")";
	}
});
var ToStringNode = defineClass("ToStringNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return String(v);
	},
	toString: function() {
		return "(str " + this._factor + ")";
	}
});
var TermNode = defineClass("TermNode", ExpressionNode, {
	init: function() {
		this._super();
		this._factors = []; // ExpressionNode
		this._operators = [];
		this._literal = null;
	},
	addFactor: function (factor) {
		this._factors.push(factor);
	},
	addOperator: function (tokenId) {
		this._operators.push(tokenId);
	},
	isIdentifier: function (value) {
		return this._factors.length == 1 && this._factors[0] instanceof IdentifierNode && 
			this._factors[0].identifier() == value;
	},
	_prepareValue: function () {
		var factor;
		for (var i = 0, cnt = this._factors.length; i < cnt; i++) {
			factor = this._factors[i]; 
			if (factor._prepareValue) {
				factor._prepareValue();
			}
		}
		if (this._operators.length == 0) {
			factor = this._factors[0];
			this._literal = factor._asLiteral();
			if (!this._literal && factor._prepareValue) {
				this._literal = factor._getLiteral();
			}
		}
	},
	_getLiteral: function () {
		return this._literal;
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		}
		var len = this._factors.length;
		var v1 = this._factors[0].evaluate(runtime);
		for (var i = 1; i < len; i++) {
			var v2 = this._factors[i].evaluate(runtime);
			switch (this._operators[i - 1]) {
				case TokenKind.Star:
					v1 = v1 * v2;
					break;
				case TokenKind.Slash:
					v1 = v1 / v2;
					break;
				case TokenKind.Div:
					v1 = _int(_int(v1) / _int(v2));
					break;
				case TokenKind.Mod:
					v1 = v1 % v2;
					break;
				case TokenKind.Shl:
					v1 = v1 << v2;
					break;
				case TokenKind.Shr:
					v1 = v1 >> v2;
					break;
			}
		}
		return v1;
	},
	toString: function() {
		var s = "";
		var len;
		if (this._literal) {
			s = this._literal.toString();
		} else if ((len = this._factors.length) == 1) {
			s = this._factors[0].toString();
		} else {
			s = "(" + this._factors[0].toString();
			for (var i = 1; i < len; i++) {
				switch (this._operators[i - 1]) {
					case TokenKind.Star:
						s += " * ";
						break;
					case TokenKind.Slash:
						s += " / ";
						break;
					case TokenKind.Div:
						s += " / ";
						break;
					case TokenKind.Mod:
						s += " mod ";
						break;
					case TokenKind.Shl:
						s += " shl ";
						break;
					case TokenKind.Shr:
						s += " shr ";
						break;
				}
				s += this._factors[i].toString();
			}
			s += ")";
		}
		return s;
	}
});
var SimpleExpressionNode = defineClass("SimpleExpressionNode", ExpressionNode, {
	init: function() {
		this._super();
		this._terms = []; // TermNode
		this._operators = [];
		this._literal = null;
	},
	addTerm: function (term) {
		this._terms.push(term);
	},
	addOperator: function (tokenId) {
		this._operators.push(tokenId);
	},
	isIdentifier: function (value) {
		return this._terms.length == 1 && this._terms[0].isIdentifier(value);
	},
	_prepareValue: function () {
		for (var i = 0, cnt = this._terms.length; i < cnt; i++) {
			this._terms[i]._prepareValue();
		}
		if (this._operators.length == 0) {
			this._literal = this._terms[0]._getLiteral();
		}
	},
	_getLiteral: function () {
		return this._literal;
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		}
		var len = this._terms.length;
		var v1 = this._terms[0].evaluate(runtime);
		for (var i = 1; i < len; i++) {
			var v2 = this._terms[i].evaluate(runtime);
			switch (this._operators[i - 1]) {
			case TokenKind.Minus:
				v1 = v1 - v2;
				break;
			case TokenKind.Plus:
				v1 = v1 + v2;
				break;
			}
		}
		return v1;
	},
	toString: function() {
		var s = "";
		var len;
		if (this._literal) {
			s = this._literal.toString();
		} else if ((len = this._terms.length) == 1) {
			s = this._terms[0].toString();
		} else {
			s = "(" + this._terms[0].toString();
			for (var i = 1; i < len; i++) {
				switch (this._operators[i - 1]) {
					case TokenKind.Minus:
						s += " - ";
						break;
					case TokenKind.Plus:
						s += " + ";
						break;
					default:
						s += " <<ERROR>> ";
				}
				s += this._terms[i].toString();
			}
			s += ")";
		}
		return s;
	}
});
var ListNode = defineClass("ListNode", ExpressionNode, {
	init: function () {
		this._super();
		this._exprs = [];
	},
	evaluateIn: function (runtime, value) {
		var exprs = this._exprs;
		for (var i = 0; i < exprs.length; i++) {
			if (value == exprs[i].evaluate(runtime)) {
				return true;
			}
		}
		return false;
	},
	_prepareValue: function () {
		for (var i = this._exprs.length; i--;) {
			this._exprs[i]._prepareValue();
		}
	},
	toString: function () {
		var exprs = this._exprs;
		var len = exprs.length - 1;
		var s = '(';
		for (var i = 0; i < len; i++) {
			s += exprs[i].toString() + ', ';
		}
		if (len == 0) {
			s += exprs[len].toString();
		}
		return s + ')';
	}
});
var SetNode = defineClass("SetNode", ExpressionNode, {
	init: function(leftExpr) {
		this._super();
		this.leftExpr = leftExpr;
		this.listNode = null;
		this.operator = TokenKind.Unknown;
		this._literal = null;
	},
	isIdentifier: function (value) {
		return !this.listNode && this.leftExpr.isIdentifier(value);
	},
	_prepareValue: function () {
		this.leftExpr._prepareValue();
		if (this.listNode) {
			this.listNode._prepareValue();
		} else {
			this._literal = this.leftExpr._getLiteral();
		}
	},
	_getLiteral: function() {
		return this._literal;
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		}
		var v = this.leftExpr.evaluate(runtime);
		if (this.listNode) {
			if (this.operator == TokenKind.NotIn) {
				v = !this.listNode.evaluateIn(runtime, v);
			} else {
				v = this.listNode.evaluateIn(runtime, v);
			}
		}
		return v;
	},
	toString: function() {
		var s = "";
		if (this._literal) {
			s = this._literal.toString();
		} else if (this.listNode) {
			s = '(' + this.leftExpr.toString() + ' in ' + this.listNode.toString() + ')';
		} else {
			s = this.leftExpr.toString();
		}
		return s;
	}
});
var ComparisonNode = defineClass("ComparisonNode", ExpressionNode, {
    init: function() {
        this._super();
        this.leftExpr = null;
        this.rightExpr = null;
        this.operator = TokenKind.Unknown;
        this._literal = null; // LiteralNode
    },
	isIdentifier: function(value) {
		return !this.rightExpr && this.leftExpr.isIdentifier(value);
	},
    evaluate: function(runtime) {
        if (this._literal) {
            return this._literal.value();
        } else if (this.rightExpr) {
            var v1 = this.leftExpr.evaluate(runtime);
            var v2 = this.rightExpr.evaluate(runtime);
            switch (this.operator) {
                case TokenKind.Equal:
                    if (v1 instanceof Date && v2 instanceof Date) {
                        return v1.getTime() == v2.getTime();
                    }
                    return v1 == v2;
                case TokenKind.NotEqual:
                    if (v1 instanceof Date && v2 instanceof Date) {
                        return v1.getTime() != v2.getTime();
                    }
                    return v1 != v2;
                case TokenKind.Greater:
                    return v1 > v2;
                case TokenKind.GreaterEqual:
                    return v1 >= v2;
                case TokenKind.Lower:
                    return v1 < v2;
                case TokenKind.LowerEqual:
                    return v1 <= v2;
                /*
                 * case TokenKind.Is: case TokenKind.IsNot:
                 */
                case TokenKind.Like:
                    return this._calcLike(v1, v2, false);
                case TokenKind.NotLike:
                    return !this._calcLike(v1, v2, false);
                case TokenKind.ILike:
                    return this._calcLike(v1, v2, true);
                case TokenKind.NotILike:
                    return !this._calcLike(v1, v2, true);
                case TokenKind.Match:
                    return this._calcMatch(v1, v2, false);
                case TokenKind.NotMatch:
                    return !this._calcMatch(v1, v2, false);
                case TokenKind.IMatch:
                    return this._calcMatch(v1, v2, true);
                case TokenKind.NotIMatch:
                    return !this._calcMatch(v1, v2, true);
                default:
                    throw new ExpressionEvaluationError(Locale.unknownOperator + ': ' + this.operator);
            }
        } else {
            return this.leftExpr.evaluate(runtime);
        }
    },
    toString: function() {
        var s = "";
        if (this._literal) {
            s = this._literal.toString();
        } else if (this.rightExpr) {
            var s1 = this.leftExpr.toString();
            var s2 = this.rightExpr.toString();
            var op;
            switch (this.operator) {
                case TokenKind.Equal:
                    op = "==";
                    break;
                case TokenKind.NotEqual:
                    op = "!=";
                    break;
                case TokenKind.Greater:
                    op = ">";
                    break;
                case TokenKind.GreaterEqual:
                    op = ">=";
                    break;
                case TokenKind.Lower:
                    op = "<";
                    break;
                case TokenKind.LowerEqual:
                    op = "<=";
                    break;
                case TokenKind.Like:
                    op = "like";
                    break;
                case TokenKind.NotLike:
                    op = "not like";
                    break;
                case TokenKind.ILike:
                    op = "ilike";
                    break;
                case TokenKind.NotILike:
                    op = "not ilike";
                    break;
                case TokenKind.Match:
                    op = "match";
                    break;
                case TokenKind.NotMatch:
                    op = "not match";
                    break;
                case TokenKind.IMatch:
                    op = "imatch";
                    break;
                case TokenKind.NotIMatch:
                    op = "not imatch";
                    break;
                default:
                    op = "<<ERROR>>";
                    break;
            }
            s = "(" + s1 + " " + op + " " + s2 + ")";
        } else {
            s = this.leftExpr.toString();
        }
        return s;
    },
    _prepareValue: function() {
        this.leftExpr._prepareValue();
        if (this.rightExpr) {
			this.rightExpr._prepareValue();
        } else {
			this._literal = this.leftExpr._getLiteral();
        }
    },
    _getLiteral: function() {
        return this._literal;
    },
    _calcLike: function(v1, v2, ignoreCase) {
        var s1 = String(v1);
        var s2 = String(v2);
        if (s1 && s2) {
            if (ignoreCase) {
                s1 = s1.toLowerCase();
                s2 = s2.toLowerCase();
            }
            var len = s2.length;
            if (len > 1) {
                var first = s2.charAt(0) == "%";
                var last = s2.charAt(len - 1) == "%";
                if (first && last) {
                    s2 = s2.substr(1, len - 2);
                    return s1.indexOf(s2, 0) >= 0;
                } else if (first) {
                    s2 = s2.substr(1, len - 1);
                    len = s1.length;
                    return s1.lastIndexOf(s2, len - 1) == len - 1;
                } else if (last) {
                    s2 = s2.substr(0, len - 1);
                    return s1.indexOf(s2, 0) == 0;
                } else {
                    return s1 == s2;
                }
            } else if (s2 == "%") {
                return false;
            } else {
                return s1 == s2;
            }
        }
        return false;
    },
    _calcMatch: function(v1, v2, ignoreCase) {
        var exp = new RegExp(v2, "m" + (ignoreCase ? "i" : ""));
        return exp.test(v1);
    }
});
var LogicalNode = defineClass("LogicalNode", ExpressionNode, {
    init: function() {
        this._super();
        this.leftExpr = null;
        this.rightExpr = null;
        this.operator = TokenKind.Unknown;
        this._literal = null; // LiteralNode
    },
    evaluate: function(runtime) {
        if (this._literal) {
            return this._literal.value();
        } else if (this.rightExpr) {
            var v1 = this.leftExpr.evaluate(runtime);
            var v2 = this.rightExpr.evaluate(runtime);
            switch (this.operator) {
                case TokenKind.And:
                    return v1 && v2;
                case TokenKind.Or:
                    return v1 || v2;
                default:
                    throw new ExpressionEvaluationError(Locale.unknownOperator + ': ' + this.operator);
            }
        } else {
            return this.leftExpr.evaluate(runtime);
        }
    },
    toString: function() {
        var s = "";
        if (this._literal) {
            s = this._literal.toString();
        } else if (this.rightExpr) {
            var s1 = this.leftExpr.toString();
            var s2 = this.rightExpr.toString();
            var op;
            switch (this.operator) {
                case TokenKind.And:
                    op = " and ";
                    break;
                case TokenKind.Or:
                    op = " or ";
                    break;
                default:
                    op = "<<ERROR>>";
                    break;
            }
            s = "(" + s1 + " " + op + " " + s2 + ")";
        } else {
            s = this.leftExpr.toString();
        }
        return s;
    },
    isIdentifier: function(value) {
        return !this.rightExpr && this.leftExpr.isIdentifier(value);
    },
    _prepareValue: function() {
        this.leftExpr._prepareValue();
        if (this.rightExpr) {
			this.rightExpr._prepareValue();
        } else {
			this._literal = this.leftExpr._getLiteral();
        }
    },
    _getLiteral: function() {
        return this._literal;
    }
});
var ExpressionParser = function () {
	var	_lexer = new ExpressionLexer();
    var _factors = [];
    _factors[TokenKind.StringLiteral    ] = _doCharString;
    _factors[TokenKind.RoundOpen        ] = _doRoundOpen;
    _factors[TokenKind.Identifier       ] = _doIdentifier;
    _factors[TokenKind.IntegerLiteral   ] = _doInteger;
    _factors[TokenKind.FloatLiteral     ] = _doNumber;
    _factors[TokenKind.Minus            ] = _doMinus;
    _factors[TokenKind.Plus             ] = _doPlus;
    _factors[TokenKind.Not              ] = _doNot;
    _factors[TokenKind.Defined          ] = _doDefined;
    _factors[TokenKind.Null             ] = _doNull;
    _factors[TokenKind.Empty            ] = _doEmpty;
    _factors[TokenKind.NaN              ] = _doNaN;
    _factors[TokenKind.True             ] = _doBoolean;
    _factors[TokenKind.False            ] = _doBoolean;
    _factors[TokenKind.ToBool           ] = _doToBool;
    _factors[TokenKind.ToNum            ] = _doToNumber;
	_factors[TokenKind.ToNumz           ] = _doToNumberz;
	_factors[TokenKind.ToInt            ] = _doToInteger;
	_factors[TokenKind.ToIntz           ] = _doToIntegerz;
    _factors[TokenKind.ToDate           ] = _doToDate;
    _factors[TokenKind.ToStr            ] = _doToString;
    _factors[TokenKind.Length           ] = _doLength;
    _factors[TokenKind.Rand             ] = _doRand;
    _factors[TokenKind.Srand            ] = _doSrand;
    _factors[TokenKind.ToLower          ] = _doLower;
    _factors[TokenKind.ToUpper          ] = _doUpper;
    var _node = null;
	function _expected(tokenId) {
		if (tokenId != _lexer.tokenId()) {
			_syntaxError(Locale._default.notExpectedTokenKind + " [" + tokenId + "]: " + _lexer.tokenId(), _lexer.tokenLoc());
		}
		_nextToken();
	}
	function _expected2(tokenId1, tokenId2) {
		var t = _lexer.tokenId();
		if (tokenId1 != t && tokenId2 != t) {
			_syntaxError(Locale._default.notExpectedTokenKind + " [" + tokenId1 + ", " + tokenId2 + "]: " + _lexer.tokenId(), _lexer.tokenLoc());
		}
		_nextToken();
	}
	function _nextToken(check) {
		var t = _lexer.nextNoSpace();
		if (!t && check) {
			_syntaxError(Locale._default.untermintatedExpression + _lexer.source(), _lexer.tokenLoc());
		}
		return t;
	}
	function _doExpression() {
		var left = _doCompareExpression();
		var expr, right, check, op;
        /*
		if (TokenKind.IS_CHECK[op = _lexer.tokenId()]) {
			_nextToken();
			right = _doCompareExpression();
			right._prepareValue();
			check = _cast(right._getLiteral(), CheckableNode);
			if (check) {
				expr = new CheckNode(left, op, check);
			} else {
				throw new ExpressionSyntaxError("is operator's operand must be defined, null or empty: " + _lexer.tokenId());
			}
		} else {
			expr = new LogicalNode();
			expr.leftExpr = left;
			if (TokenKind.IS_LOGICAL[_lexer.tokenId()]) {
				expr.operator = _lexer.tokenId();
				_nextToken();
				expr.rightExpr = _doCompareExpression();
			}
		}
		*/
        expr = new LogicalNode();
        expr.leftExpr = left;
        if (TokenKind.IS_LOGICAL[(op = _lexer.tokenId())]) {
            expr.operator = _lexer.tokenId();
            _nextToken(true);
            expr.rightExpr = _doExpression();
        }
		return expr;
	}
    function _doCompareExpression() {
        var expr = new ComparisonNode();
        var op, right, check;
        expr.leftExpr = _doSimpleExpression();
        if (TokenKind.IS_CHECK[op = _lexer.tokenId()]) {
			_nextToken(true);
			right = _doSimpleExpression();
			right._prepareValue();
			check = _cast(right._getLiteral(), CheckableNode);
			if (check) {
				expr = new CheckNode(expr, op, check);
			} else {
				_syntaxError(Locale._default.invalidIsOperand + ": " + _lexer.tokenId(), _lexer.tokenLoc());
			}
		} else if (TokenKind.IS_SET[op]) {
			expr = new SetNode(expr.leftExpr);
			expr.operator = _lexer.tokenId();
			_nextToken(true);
			expr.listNode = _doList();
        } else if (TokenKind.IS_COMPARISON[op]) {
            expr.operator = _lexer.tokenId();
            _nextToken(true);
            expr.rightExpr = _doSimpleExpression();
        }
        return expr;
    }
	function _doList() {
		var list = new ListNode();
		_expected(TokenKind.RoundOpen);
		while (true) {
			var t = _lexer.tokenId();
			if (t == TokenKind.RoundClose) {
				_nextToken();
				break;
			}
			var node = _doSimpleExpression();
			list._exprs.push(node);
			_expected2(TokenKind.Comma, TokenKind.RoundClose);
		}
		return list;
	}
	function _doSimpleExpression() {
		var expr = new SimpleExpressionNode();
		var op;
		expr.addTerm(_doTerm());
		while (TokenKind.IS_ADDITIVE[op = _lexer.tokenId()]) {
			expr.addOperator(op);
			_nextToken(true);
			expr.addTerm(_doTerm());
		}
		return expr;
	}
	function _doTerm() {
		var term = new TermNode();
		var op;
		term.addFactor(_doFactor());
		while (TokenKind.IS_MULTIPLICATIVE[op = _lexer.tokenId()]) {
			term.addOperator(op);
			_nextToken(true);
			term.addFactor(_doFactor());
		}
		return term;
	}
	function _doFactor() {
        var proc = _factors[_lexer.tokenId()];
        if (proc) {
            return proc();
        } else {
			_syntaxError(Locale._default.unknownToken + ": " + _lexer.tokenId(), _lexer.tokenLoc());
        }
    }
    function _doFactor2() {
		var tokenId = _lexer.tokenId();
		switch (tokenId) {
			case TokenKind.StringLiteral:
				return _doCharString();
			case TokenKind.RoundOpen:
				return _doRoundOpen();
			case TokenKind.Identifier:
				return _doIdentifier();
			case TokenKind.IntegerLiteral:
				return _doInteger();
			case TokenKind.FloatLiteral:
				return _doNumber();
			case TokenKind.Minus:
				return _doMinus();
			case TokenKind.Plus:
				return _doPlus();
			case TokenKind.Not:
				return _doNot();
			case TokenKind.Defined:
				return _doDefined();
			case TokenKind.Null:
				return _doNull();
			case TokenKind.Empty:
				return _doEmpty();
            case TokenKind.NaN:
				return _doNaN();
            case TokenKind.True:
            case TokenKind.False:
                return _doBoolean();
			case TokenKind.ToBool:
				return _doToBool();
			case TokenKind.ToNum:
				return _doToNumber();
			case TokenKind.ToNumz:
				return _doToNumberz();
			case TokenKind.ToInt:
				return _doToInteger();
			case TokenKind.ToIntz:
				return _doToIntegerz();
			case TokenKind.ToDate:
				return _doToDate();
			case TokenKind.ToStr:
				return _doToString();
			case TokenKind.Length:
				return _doLength();
		}
		_syntaxError(Locale._default.unknownToken + ": " + tokenId, _lexer.tokenLoc());
	}
	function _doCharString() {
		var literal = _lexer.token();
		_nextToken();
		return new StringLiteralNode(literal);
	}
	function _doRoundOpen() {
		_nextToken();
		var node = _doExpression();
		_expected(TokenKind.RoundClose);
		return node;
	}
	function _doIdentifier() {
		var literal = _lexer.token();
		_nextToken();
		if (_lexer.tokenId() == TokenKind.BracketOpen) {
			_nextToken();
			var node = _doExpression();
			_expected(TokenKind.BracketClose);
			return new IndexerNode(literal, node);
		} else {
			return new IdentifierNode(literal);
		}		
	}
	function _doNumber() {
		var literal = _lexer.token();
		_nextToken();
		return new FloatLiteralNode(literal);
	}	
	function _doInteger() {
		var literal = _lexer.token();
		_nextToken();
		return new IntegerLiteralNode(literal);
	}
	function _doMinus() {
		_nextToken();
		return new MinusNode(_doFactor());
	}
	function _doPlus() {
		_nextToken();
		return new PlusNode(_doFactor());
	}
	function _doNot() {
		_nextToken();
		return new NotNode(_doFactor());
	}
	function _doDefined() {
		_nextToken();
		return new DefinedNode();
	}
	function _doNull() {
		_nextToken();
		return new NullNode();
	}
	function _doEmpty() {
		_nextToken();
		return new EmptyNode();
	}
	function _doNaN() {
		_nextToken();
		return new NanNode();
	}
    function _doBoolean() {
        var literal = _lexer.token();
        _nextToken();
        return new BooleanLiteralNode(literal)
    }
	function _doToBool() {
		_nextToken();
		return new ToBoolNode(_doFactor());
	}
	function _doToNumber() {
		_nextToken();
		return new ToNumberNode(_doFactor());
	}
	function _doToNumberz() {
		_nextToken();
		return new ToNumberNode(_doFactor(), true);
	}
	function _doToInteger() {
		_nextToken();
		return new ToIntegerNode(_doFactor());
	}
	function _doToIntegerz() {
		_nextToken();
		return new ToIntegerNode(_doFactor(), true);
	}
	function _doToDate() {
		_nextToken();
		return new ToDateNode(_doFactor());
	}
	function _doToString() {
		_nextToken();
		return new ToStringNode(_doFactor());
	}
	function _doLength() {
		_nextToken();
		return new LenNode(_doFactor());
	}
    function _doRand() {
        _nextToken();
        return new RandNode(_doFactor());
    }
    function _doSrand() {
        _nextToken();
        return new SrandNode(_doFactor());
    }
    function _doLower() {
        _nextToken();
        return new LowerNode(_doFactor());
    }
    function _doUpper() {
        _nextToken();
        return new UpperNode(_doFactor());
    }
	this.parse = function (source) {
		if (!source)
			return null;
			_lexer.init(source);
			_nextToken();
			var expr = _doExpression();
			if (!_lexer.isEnd()) {
				var node = _doIdentifier();
				if (node) _syntaxError("Invalid token: " + node._literal);
				_syntaxError(Locale._default.untermintatedExpression + ": " + source, _lexer.tokenLoc());
			}
			if (expr) {
				expr._prepareValue();
			}
			return expr;
	};
	this.evaluate = function (source, runtime) {
		var expr = this.parse(source);
		return expr.evaluate(runtime);
	};
};
ExpressionParser.Default = new ExpressionParser();
/** @abstract */
var ExpressionRuntime = defineClass("ExpressionRuntime", null, {
	init: function () {
		this._super();
	},
	scope: function () {
		return null;
	},
	isIdentifier: function (token) {
		throw new ExpressionSyntaxError(Locale._default.invalidIdentifierToken + ": " + token);
	},
	evaluateIdentifier: function (idKey) {
		throw new ExpressionEvaluationError(Locale._default.invalidIdentifierKey + ": " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		throw new ExpressionEvaluationError(Locale._default.invalidIdentifierIndexer + ": " + idKey);
	},
	evaluateIndexerS: function (idKey, index) {
		throw new ExpressionEvaluationError(Locale._default.invalidIdentifierIndexer + ": " + idKey);
	}
});
var $$_XML_HEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var _excelColCaption = function (col) {
	if (col >= 26) {
		col -= 26;
		return String.fromCharCode(_int(col / 26) + 65) + String.fromCharCode(_int(col % 26) + 65);
	} else {
		return String.fromCharCode(col + 65);
	}
};
var ExcelStrings = defineClass("ExcelStrings", null, {
	init: function (workbook) {
		this._super();
		this._workbook = workbook;
		this._nextId = 0;
		this._count = 0;
		this._stringMap = {};
		this._strings = [];
	},
	count: function () { return this._count; },
	uniqueCount: function () { return this._nextId; },
	add: function (text) {
		this._count++;
		var id = this._stringMap[text];
		if (id === undefined) {
			id = this._nextId++;
			this._stringMap[text] = id;
			this._strings[id] = text;
		}
		return id;
	},
	getIndex: function (text) {
		return this._stringMap[text];
	},
	createPart: function () {
        var i, node, child,
		    s = '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"></sst>',
		    doc = _parseXmlEx(s, true),
		    root = doc.documentElement,
            strings = this._strings,
            cnt = strings.length,
            elts = new Array(cnt);
		root.setAttribute("count", this._count);
		root.setAttribute("uniqueCount", this._nextId);
		for (i = 0; i < cnt; i++) {
			elts[i] = node = doc.createElement("si");
			child = doc.createElement("t");
            child.textContent = strings[i];
            node.appendChild(child);
		}
        for (i = 0; i < cnt; i++) {
            root.appendChild(elts[i]);
        }
		s = _xmlToStr(doc);
		return $$_XML_HEAD + s;
	},
    createPart2: function () {
        var i,
            s = $$_XML_HEAD,
            strings = this._strings,
            cnt = strings.length;
        s += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"'
        s += ' count="' + this._count + '" ';
        s += ' uniqueCount="' + this._nextId + '">';
        for (i = 0; i < cnt; i++) {
            s += '<si>';
            s += '<t>' + strings[i] + '</t>';
            s += '</si>';
        }
        s += '</sst>';
        return s;
    }
});
var ExcelFont = function () {
	this.id = undefined;
	this.name = "Tahoma";
	this.size = 10;
	this.color = "ff000000";
	this.bold = false;
	this.italic = false;
	this.scheme = undefined;
};
ExcelFont.prototype.serialize = function (doc, node) {
	_addChildWithAttr(doc, node, "sz", "val", this.size || 10);
	_addChildWithAttr(doc, node, "name", "val", this.name || "Calibri");
	_addChildWithAttr(doc, node, "color", "rgb", this.color || "ff000000");
	_addChildWithAttr(doc, node, "b", "val", this.bold ? "true" : "false");
	_addChildWithAttr(doc, node, "i", "val", this.italic ? "true" : "false");
};
ExcelFont.equals = function (f1, f2) {
    return f1.name == f2.name && f1.size == f2.size && f1.color == f2.color &&
        f1.bold == f2.bold && f1.italic == f2.italic && f1.scheme == f2.scheme;
};
var ExcelFill = function () {
	this.id = undefined;
	this.patternType = "none";
	this.color = undefined;
	this.gradient = undefined;
	this.color2 = undefined;
	this.degree = "90";
	this.tint = 0;
	this.serialize = function (doc, node) {
		var color;
		if (this.gradient == "linear") {
			var gradient = doc.createElement("gradientFill");
			node.appendChild(gradient);
			gradient.setAttribute("degree", this.degree);
			var stop = doc.createElement("stop");
			gradient.appendChild(stop);
			stop.setAttribute("position", "0");
			color = doc.createElement("color");
			stop.appendChild(color);
			color.setAttribute("rgb", this.color);
			color.setAttribute("tint", this.tint);
			stop = doc.createElement("stop");
			gradient.appendChild(stop);
			stop.setAttribute("position", "1");
			color = doc.createElement("color");
			stop.appendChild(color);
			color.setAttribute("rgb", this.color2);
			color.setAttribute("tint", this.tint);
		} else {
			var pattern = doc.createElement("patternFill");
			node.appendChild(pattern);
			pattern.setAttribute("patternType", this.patternType);
			if (this.patternType != "none") {
				color = doc.createElement("fgColor");
				pattern.appendChild(color);
				color.setAttribute("rgb", this.color);
				color.setAttribute("tint", this.tint);
				/*
				 color = doc.createElement("bgColor");
				 pattern.appendChild(color);
				 color.setAttribute("rgb", "ffffffff");
				 color.setAttribute("tint", "0");
				 */
			}
		}
	}
};
ExcelFill.equals = function (f1, f2) {
    return f1.patternType == f2.patternType &&
        f1.color == f2.color &&
        f1.gradient == f2.gradient &&
        f1.color2 == f2.color2 &&
        f1.degree == f2.degree &&
        f1.tint == f2.tint;
};
var ExcelBorder = function () {
	this.id = undefined;
	this.left = undefined;
	this.right = undefined;
	this.top = undefined;
	this.bottom = undefined;
};
ExcelBorder.prototype.serialize = function (doc, node) {
	this.serializeBorder(doc, node, "left");
	this.serializeBorder(doc, node, "right");
	this.serializeBorder(doc, node, "top");
	this.serializeBorder(doc, node, "bottom");
};
ExcelBorder.prototype.serializeBorder = function (doc, parent, border) {
	var node = doc.createElement(border);
	parent.appendChild(node);
	border = this[border];
	if (border) {
		node.setAttribute("style", "thin");
		var color = doc.createElement("color");
		node.appendChild(color);
		color.setAttribute("rgb", border._color.toColorHex());
	}
};
var $$_xl_equal_border = function (b1, b2) {
    return (!b1 == !b2) || b1 && b2 && (b1._color.toColorHex() == b2._color.toColorHex());
}
ExcelBorder.equals = function (b1, b2) {
    return $$_xl_equal_border(b1.left, b2.left) &&
        $$_xl_equal_border(b1.right, b2.right) &&
        $$_xl_equal_border(b1.top, b2.top) &&
        $$_xl_equal_border(b1.bottom, b2.bottom);
}
var ExcelStyle = function () {
	this.id = undefined;
	this.horzAlign = ExcelStyle.ALIGN_NEAR;
	this.vertAlign = ExcelStyle.VALIGN_CENTER;
	this.wrapText = false;
	this.formatId = 0;
	this.font = null;		// ExcelFont
	this.fill = null;		// ExcelFill
	this.border = null;		// ExcelBorder
	this.xfId = 0; 			// first cellStyleXf
    this.$ref = 0;
};
ExcelStyle.ALIGN_NEAR = "left";
ExcelStyle.ALIGN_CENTER = "centerContinuous"; // "center"
ExcelStyle.ALIGN_FAR = "right";
ExcelStyle.VALIGN_NEAR = "top";
ExcelStyle.VALIGN_CENTER = "center"; // "center"
ExcelStyle.VALIGN_FAR = "bottom";
ExcelStyle.prototype.clone = function () {
	var es = new ExcelStyle();
	for (var p in this) {
		if (this.hasOwnProperty(p)) {
			es[p] = this[p];
		}
	}
	return es;
};
ExcelStyle.prototype.serialize = function (doc, node) {
	node.setAttribute("borderId", this.border ? this.border.id :"0");
	node.setAttribute("fillId", this.fill ? this.fill.id : "0");
	node.setAttribute("fontId", this.font ? this.font.id : "0");
	node.setAttribute("numFmtId", this.formatId);
	node.setAttribute("xfId", "0");
	var align = doc.createElement("alignment");
	node.appendChild(align);
	align.setAttribute("horizontal", this.horzAlign);
	align.setAttribute("vertical", this.vertAlign);
	this.wrapText && align.setAttribute("wrapText", "1");
};
ExcelStyle.equals = function (s1, s2) {
    return s1.horzAlign == s2.horzAlign &&
        s1.vertAlign == s2.vertAlign &&
        s1.wrapText == s2.wrapText &&
        s1.formatId == s2.formatId &&
        (!s1.font && !s2.font || s1.font && s2.font && s1.font.id == s2.font.id) &&
        (!s1.fill && !s2.fill || s1.fill && s2.fill && s1.fill.id == s2.fill.id) &&
        (!s1.border && !s2.border || s1.border && s2.border && s1.border.id == s2.border.id) &&
        s1.xfId == s2.xfId;
};
var $$_EXCEL_NUMFMT_START = 200;
var ExcelStyles = defineClass("ExcelStyles", null, {
	init: function (workbook) {
		this._super();
		this._book = workbook;
		this._fonts = [];
		this._fills = [];
		this._borders = [];
		this._numFormats = [];
		this._pivot = 0;
		this._xfs = [];
        this._dynxfs = [];
		this._cached = true;
		var fill = new ExcelFill();
		this._fills.push(fill, fill);
		var border = new ExcelBorder();
		this._borders.push(border);
		var style = new ExcelStyle();
		this._xfs.push(style);
	},
	setPivot: function () {
		this._pivot = this._xfs.length > 0 ? this._xfs.length - 1 : 0;
	},
	addFont: function (font) {
		if (font) {
            var fonts = this._fonts;
			if (this._cached) {
				for (var i = fonts.length; i--;) {
					if (ExcelFont.equals(fonts[i], font)) {
						return fonts[i];
					}
				}
			}
			fonts.push(font);
			font.id = fonts.length - 1;
		}
		return font;
	},
	addFill: function (fill) {
        if (fill) {
            var fills = this._fills;
			if (this._cached) {
				for (var i = fills.length - 1; i > 1; i--) {
					if (ExcelFill.equals(fills[i], fill)) {
						return fills[i];
					}
				}
			}
			fills.push(fill);
			fill.id = fills.length - 1;
		}
		return fill;
	},
	addBorder: function (border) {
		if (border) {
            var borders = this._borders;
			if (this._cached) {
				for (var i = borders.length - 1; i > 0; i--) {
					if (ExcelBorder.equals(borders[i], border)) {
						return borders[i];
					}
				}
			}
			borders.push(border);
			border.id = borders.length - 1;
		}
		return border;
	},
	addNumberFormat: function (format) {
		var idx = this._numFormats.indexOf(format);
		if (idx < 0) {
			this._numFormats.push(format);
			idx = this._numFormats.length - 1;
		}
		return $$_EXCEL_NUMFMT_START + idx;
	},
	add: function (style) {
		if (style) {
            var xfs = this._xfs;
			if (this._cached) {
				for (var i = xfs.length - 1; i > this._pivot; i--) {
					if (ExcelStyle.equals(xfs[i], style)) {
						xfs[i].$ref++;
						return xfs[i];
					}
				}
			}
			xfs.push(style);
			style.id = xfs.length - 1;
		}
		return style;
	},
	createPart: function () {
		var s = '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"></styleSheet>';
		var doc = _parseXmlEx(s, true);
		var root = doc.documentElement;
		if (this._numFormats.length > 0) {
			var numFmts = doc.createElement("numFmts");
			root.appendChild(numFmts);
			this.$_createNumberFormats(doc, numFmts);
		}
		var fonts = doc.createElement("fonts");
		root.appendChild(fonts);
		this.$_createFonts(doc, fonts);
		var fills = doc.createElement("fills");
		root.appendChild(fills);
		this.$_createFills(doc, fills);
		var borders = doc.createElement("borders");
		root.appendChild(borders);
		this.$_createBorders(doc, borders);
		var defXfs = doc.createElement("cellStyleXfs");
		root.appendChild(defXfs);
		this.$_createDefXfs(doc, defXfs);
		var xfs = doc.createElement("cellXfs");
		root.appendChild(xfs);
		this.$_createXfs(doc, xfs);
		s = _xmlToStr(doc);
		return $$_XML_HEAD + s;
	},
	$_createNumberFormats: function (doc, parent) {
		for (var i = 0, cnt = this._numFormats.length; i < cnt; i++) {
			var node = doc.createElement("numFmt");
			_setXmlAttr(node, 'formatCode', this._numFormats[i]);
			_setXmlAttr(node, 'numFmtId', $$_EXCEL_NUMFMT_START + i);
			parent.appendChild(node);
		}
	},
	$_createFonts: function (doc, parent) {
		if (this._fonts.length < 1) {
			var f = new ExcelFont();
			this._fonts.push(f);
		}
		for (var i = 0, cnt = this._fonts.length; i < cnt; i++) {
			var node = doc.createElement("font");
			this._fonts[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._fonts.length);
	},
	$_createFills: function (doc, parent) {
		if (this._fills.length < 1) {
			var f = new ExcelFill();
			this._fills.push(f);
		}
		for (var i = 0, cnt = this._fills.length; i < cnt; i++) {
			var node = doc.createElement("fill");
			this._fills[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._fills.length);
1	},
	$_createBorders: function (doc, parent) {
		if (this._borders.length < 1) {
			var b = new ExcelBorder();
			this._borders.push(b);
		}
		for (var i = 0, cnt = this._borders.length; i < cnt; i++) {
			var node = doc.createElement("border");
			this._borders[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._borders.length);
	},
	$_createDefXfs: function (doc, parent) {
		var node = doc.createElement("xf");
		parent.appendChild(node);
		node.setAttribute("borderId", 0);
		node.setAttribute("fillId", 0);
		node.setAttribute("fontId", 0);
		node.setAttribute("numFmtId", 0);
		parent.setAttribute("count", 1);
	},
	$_createXfs: function (doc, parent) {
		if (this._xfs.length < 1) {
			var f = new ExcelStyle();
			this._xfs.push(f);
		}
		for (var i = 0, cnt = this._xfs.length; i < cnt; i++) {
			var xf = this._xfs[i];
			var node = doc.createElement("xf");
			xf.serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._xfs.length);
	}
});
var ExcelColumn = function () {
	this.index = undefined;
	this.width = 10;
	this.style = null;	// ExcelStyle
	this.serialize = function (doc, node) {
		node.setAttribute("min", this.index);
		node.setAttribute("max", this.index);
		node.setAttribute("width", this.width);
		this.style && node.setAttribute("style", this.style.id);
	}
};
var ExcelSheet = defineClass("ExcelSheet", null, {
	init: function (workbook) {
		this._super();
		this._book = workbook;
        this._legacy = workbook._legacy;
		this._columns = null;
		this._doc = null;
		this._viewRoot = null;
		this._dataRoot = null;
		this._mergeRoot = null;
		this._rows = [];
		this._mergeCount = 0;
		this._outlineLevel = 0;
		this.$_preparePart();
	},
	colCount: function () {
		return this._columns.length;
	},
	rowCount: function () {
		return this._rows.length;
	},
	setColumns: function (columns) {
		this._columns = columns;
	},
	addRow: function (r) {
		var row = this._rows[r];
		if (!row) {
			var row = this._doc.createElement("row");
			row.setAttribute("r", r + 1);
			this._rows[r] = row;
		}
		return row;
	},
	setRowLevel: function (r, level) {
		if (level >= 0) {
			var row = this._rows[r];
			if (row) {
				!this._legacy && row.setAttribute("outlineLevel", level);
				this._outlineLevel = Math.max(level, this._outlineLevel);
			}
		}
	},
	addBlank: function (r, c, s) {
		var row = this.addRow(r);
		var cell = this._doc.createElement("c");
		cell.setAttribute("r", _excelColCaption(c) + (r + 1));
		s && cell.setAttribute("s", s.id);
		row.appendChild(cell);
	},
	addMerge: function (r, c, rows, cols) {
		var range = _excelColCaption(c) + (r + 1) + ":" + _excelColCaption(c + cols - 1) + (r + rows);
		var cell = this._doc.createElement("mergeCell");
		cell.setAttribute("ref", range);
		this._mergeRoot.appendChild(cell);
		this._mergeCount++;
	},
	$_addCell: function (r, c, t, value, s) {
		var row = this.addRow(r);
		var cell = this._doc.createElement("c");
		cell.setAttribute("r", _excelColCaption(c) + (r + 1));
		cell.setAttribute("t", t);
		s && cell.setAttribute("s", s.id);
        row.appendChild(cell);
		var v = this._doc.createElement("v");
        v.textContent = value;
		cell.appendChild(v);
	},
	addText: function (r, c, value, style, rowSpan, colSpan) {
		var s = (value !== undefined && value !== null) ? value : "";
		s = this._book.addString(s);
		this.$_addCell(r, c, "s", s, style);
	},
	addNumber: function (r, c, value, style, rowSpan, colSpan) {
		var s = isNaN(value) ? "" : String(value);
		this.$_addCell(r, c, "n", s, style);
	},
	addBool: function (r, c, value, style, rowSpan, colSpan) {
		this.$_addCell(r, c, "b", value ? 1 : 0, style);
	},
	addDate: function (r, c, value, style, rowSpan, colSpan) {
		if (value) {
			var d = this.$_dateToStr(value);
            this.$_addCell(r, c, "n", d, style);
		} else {
			this.$_addCell(r, c, "s", "", style);
		}
	},
	createPart: function () {
		var i, rows,
            doc = this._doc,
		    root = doc.documentElement,
            dataRoot = this._dataRoot;
		/*
		var views = doc.createElement("sheetViews");
		root.appendChild(views);
		var view = doc.createElement("sheetView");
		views.appendChild(view);
		view.setAttribute("tabSelected", "1");
		view.setAttribute("workbookViewId", "0");
		var pane = doc.createElement("pane");
		view.appendChild(pane);
		pane.setAttribute("state", "forzen");
		pane.setAttribute("activePane", "bottomLeft");
		pane.setAttribute("topLeftCell", "A2");
		pane.setAttribute("ySplit", "1");
		var sel = doc.createElement("selection");
		view.appendChild(sel);
		sel.setAttribute("pane", "bottomLeft");
		*/
		if (!this._legacy && this._outlineLevel > 0) {
			var fmtPtr = doc.createElement("sheetFormatPtr");
			root.appendChild(fmtPtr);
			fmtPtr.setAttribute("outlineLevelRow", this._outlineLevel);
		}
        /*
        var fmtPr = doc.createElement("sheetFormatPr");
        root.appendChild(fmtPr);
        fmtPr.setAttribute("defaultRowHeight", "15.0");
        */
		if (this._columns) {
			var cols = doc.createElement("cols");
			root.appendChild(cols);
			this.$_createCols(doc, cols);
		}
        rows = this._rows;
        for (i = 0; i < rows.length; i++) {
			dataRoot.appendChild(rows[i]);
        }
		root.appendChild(this._dataRoot);
		if (this._mergeCount > 0) {
			root.appendChild(this._mergeRoot);
			this._mergeRoot.setAttribute("count", this._mergeCount);
		}
		var s = _xmlToStr(doc);
		return $$_XML_HEAD + s;
	},
	$_preparePart: function () {
		var s = '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"></worksheet>';
		var doc = this._doc = _parseXmlEx(s, true);
        /*
        var dim = doc.createElement("dimension");
        doc.documentElement.appendChild(dim);
        dim.setAttribute("ref", "A1");
        */
		var views = doc.createElement("sheetViews");
		doc.documentElement.appendChild(views);
		var view = this._viewRoot = doc.createElement("sheetView");
		views.appendChild(view);
		view.setAttribute("workbookViewId", "0"); // required attr.
		view.setAttribute("tabSelected", "1");
		view.setAttribute("showOutlineSymbols", "true"); // 기본값이 true.
		this._dataRoot = doc.createElement("sheetData");
		this._mergeRoot = doc.createElement("mergeCells");
	},
	$_createCols: function (doc, elt) {
		var cols = this._columns;
		for (var i = 0, cnt = cols.length; i < cnt; i++) {
			var col = cols[i];
			var node = doc.createElement("col");
			col.serialize(doc, node);
			elt.appendChild(node);
		}
	},
	$_dateToStr: function (d) {
        var returnDateTime = 25569.0 + ((d.getTime() - (d.getTimezoneOffset() * 60 * 1000)) / (1000 * 60 * 60 * 24));
        return returnDateTime.toString().substr(0,20);
	}
});
var ExcelWorkbook = defineClass("ExcelWorkbook", null, {
	init: function (legacy) {
		this._super();
        this._legacy = legacy;
		this._parts = {};
		this._sst = new ExcelStrings(this);
		this._styles = new ExcelStyles(this);
		this._sheet = new ExcelSheet(this);
		this.$_preapreTemplateParts();
	},
	parts: function () {
		return this._parts;
	},
	sheet: function () {
		return this._sheet;
	},
	addString: function (s) {
        return this._sst.add(s);
	},
	addNumberFormat: function (format) {
		return this._styles.addNumberFormat(format);
	},
	addFill: function (fill) {
		return this._styles.addFill(fill);
	},
	addBorder: function (border) {
		return this._styles.addBorder(border);
	},
	addFont: function (font) {
		return this._styles.addFont(font);
	},
	setCachedStyle: function (value) {
		this._styles._cached = value;
	},
	setStylePivot: function () {
		this._styles.setPivot();
	},
	addStyle: function (style) {
		return this._styles.add(style);
	},
	createParts: function () {
		var parts = this._parts;
		parts['xl/sharedStrings.xml'] = this._sst.createPart();
		parts['xl/styles.xml'] = this._styles.createPart();
		parts['xl/worksheets/sheet1.xml'] = this._sheet.createPart();
		return parts;
	},
	$_preapreTemplateParts: function () {
		var parts = this._parts;
		parts['[Content_Types].xml'] = $$_XML_HEAD + '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/></Types>';
		parts['_rels/.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/></Relationships>';
		parts['docProps/app.xml'] = $$_XML_HEAD + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"><Application>DataLudi DUI</Application><AppVersion>1.0</AppVersion></Properties>';
		parts['docProps/core.xml'] = $$_XML_HEAD + '<coreProperties xmlns="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dcterms:created xsi:type="dcterms:W3CDTF">2014-12-25T03:06:34Z</dcterms:created><dc:creator>DataLudi</dc:creator></coreProperties>';
		parts['xl/workbook.xml'] = $$_XML_HEAD + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><workbookPr date1904="false"/><bookViews><workbookView activeTab="0"/></bookViews><sheets><sheet name="Sheet1" r:id="rId3" sheetId="1"/></sheets></workbook>';
		parts['xl/_rels/workbook.xml.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/></Relationships>';
	}
});
var $$_SCROLL_SIZE = 17;
var Dom = defineClass("Dom", null, {
	init: function (element) {
		this._super();
		this._element = element;
	},
	x: function () {
		return this._element.offsetLeft;
	},
	y: function () {
		return this._element.offsetTop;
	},
	size: function () {
		return Dom.getSize(this._element);
	},
	element: function () {
		return this._element;
	},
    attached: function () {
        return !!this._element.parentNode;
    },
	detach: function () {
		if (this._element.parentNode) {
			this._element.parentNode.removeChild(this._element);
			return true;
		}
	},
	clearChildren: function () {
        Dom.clearChildren(this._element);
	},
	addChild: function (child) {
		Dom.addChild(this._element, child);
	},
	setStyles: function (styles, attrs) {
		Dom.setStyles(this._element, styles, attrs);
	},
	getBounds: function () {
		return Dom.getBounds(this._element);
	},
	getOffset: function () {
		return Dom.getOffset(this._element);
	},
	move: function (x, y) {
		Dom.move(this._element, x, y);
	},
	disableSelection: function () {
		Dom.disableSelection(this._element);
	},
	isAncestorOf: function (element) {
		var p = element.parentElement;
		while (p) {
			if (p == this._element) {
				return true;
			}
		}
		return false;
	}
}, {
	createElement: function (elementType, styles, attrs) {
		var attr,
            elt = document.createElement(elementType);
		styles && Dom.setStyles(elt, styles);
        if (attrs) {
            for (attr in attrs) {
                elt[attr] = attrs[attr];
            }
        }
		return elt;
	},
	setStyles: function (element, styles, attrs) {
		var p, css;
		if (styles) {
			css = element.style;
			for (p in styles) {
				css[p] = styles[p];
			}
		}
		if (attrs) {
			for (p in attrs) {
				element.setAttribute(p, attrs[p]);
			}
		}
	},
	addWindowListener: function (event, callback) {
		_win.addEventListener(event, callback);
	},
	removeWindowListener: function (event, callback) {
		_win.removeEventListener(event, callback);
	},
	getSize: function (element) {
		var r = element.getBoundingClientRect();
		return { width: r.width, height: r.height };
	},
	setSize: function (element, w, h) {
		var css = element.style;
		css.width = w + "px";
		css.height = h + "px";
	},
	getBounds: function (element) {
		var r = element.getBoundingClientRect();
		/*
		*/
		r.cx = element.offsetLeft;
		r.cy = element.offsetTop;
		return r;
	},
	setBounds: function (element, x, y, w, h) {
		var style = element.style;
		style.left = x + "px";
		style.top = y + "px";
		style.width = w + "px";
		style.height = h + "px";
	},
	getScrolled: function () {
		var body = document.body,
		    docElem = document.documentElement;
		return {
			sx: window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
			sy: window.pageYOffset || docElem.scrollTop || body.scrollTop
		};
	},
	getOffset: function (element) {
		var box = element.getBoundingClientRect(),
		    body = document.body,
		    docElem = document.documentElement,
		    scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
		    scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
		    clientTop = docElem.clientTop || body.clientTop || 0,
		    clientLeft = docElem.clientLeft || body.clientLeft || 0,
		    x = box.left + scrollLeft - clientLeft,
		    y = box.top + scrollTop - clientTop;
		return { x: Math.round(x), y: Math.round(y) }
	},
	move: function (element, x, y) {
		element.style.left = x + "px";
		element.style.top = y + "px";
	},
	disableSelection: function (element) {
		element.style["-moz-user-select"] = "-moz-none";
		element.style["-khtml-user-select"] = "none";
		element.style["-webkit-user-select"] = "none";
		element.style["-o-user-select"] = "none";
		element.style["-ms-user-select"] = "none";
		element.style["user-select"] = "none";
		/*
		if (typeof element.onselectstart !== 'undefined') {
			element.onselectstart = function() { return false; };
		} else if (typeof element.style.MozUserSelect !== 'undefined') {
			element.style.MozUserSelect = 'none';
		} else {
			element.onmousedown = function() { return false; };
		}
		*/
	},
	addChild: function (element, child) {
		if (element && child && child.parentNode !== element) {
			element.appendChild(child);
			return true;
		}
		return false;
	},
	removeChild: function (element, child) {
		if (element && child && child.parentNode === element) {
			element.removeChild(child);
			return true;
		}
		return false;
	},
    clearChildren: function (element) {
        var elt = element;
        while (elt.lastChild) {
            elt.removeChild(elt.lastChild);
        }
    },
	visitChildren: function (element, callback) {
        var childs, i;
		if (callback) {
			childs = element.childNodes;
			for (i = 0; i < childs.length; i++) {
				if (callback(element, childs[i]) === false) {
					return;
				}
			}
		}
	},
	getChildIndex: function (element) {
        if (element) {
            var parent = element.parentNode;
            if (parent) {
                var childs = parent.childNodes;
                for (var i = 0; i < childs.length; i++) {
                    if (childs[i] === element) {
                        return i;
                    }
                }
            }
        }
		return -1;
	},
    getRadioGroupValue: function (groupName) {
        var items = document.getElementsByName(groupName);
        if (items) {
            for (var i = items.length; i--;) {
                if (items[i].checked) {
                    return items[i].value;
                }
            }
        }
        return undefined;
    },
	htmlEncode: function (text) {
		return document.createElement('a').appendChild(document.createTextNode(text)).parentNode.innerHTML;
	},
	getClipRect: function (r) {
		return "rect(" + r.y + "px," + (r.x + r.width) + "px," + (r.y + r.height) + "px," + r.x + "px)";
	},
    createSimpleSpan: function (parent) {
        var span = document.createElement("span");
        span.style.position = "absolute";
        span.style.display = 'inline-block';
        parent.appendChild(span);
        return span;
    },
    renderText: function (span, font, fill, text, x, y) {
		var css = span.style;
		if (fill && text !== null && text !== undefined && (text = String(text))) {
            span.innerHTML = text;
            css.display = "inline-block";
			if (font) {
				css.font = font.font
				css.textDecoration = font.deco;
			} else {
				css.font = DEF_FONT;
				css.textDecoration = 'none';
			}
            css.color = fill.css();
            css.lineHeight = 1.1;
            css.whiteSpace = "nowrap";
            css.left = x + "px";
            css.top = y + "px";
            if (_ieLeg) {
            } else if (_ieOld) {
                css.msTransform = "none";
            } else {
                css.transform = "none";
                css.WebkitTransform = "none";
            }
        }
    },
	renderTextRect: function (span, font, fill, text, r, align, valign, wrap) {
		Dom.renderTextBounds(span, font, fill, text, r.x, r.y, r.width, r.height, align, valign, wrap);
	},
	renderTextBounds: function (span, font, fill, text, x, y, w, h, align, valign, wrap) {
		var hline, css, wrapped;
		if (fill && text !== null && text !== undefined && (text = String(text))) {
            hline = 1.1;
			css = span.style;
			css.width = w + 'px';
			if (font) {
				css.font = font.font
				css.textDecoration = font.deco;
			} else {
				css.font = DEF_FONT;
			}
			css.color = fill.css();
			if (wrap == "explicit") {
                css.whiteSpace = "nowrap";
                css.wordWrap = "";
                wrapped = true;
			} else if (wrap == "normal") {
				css.whiteSpace = "normal";
				css.wordWrap = "break-word";
                wrapped = true;
			} else {
				css.whiteSpace = "nowrap";
				css.wordWrap = "";
			}
            css.lineHeight = hline;
            text = text.replace($$_htmlreg, $$_htmlrep);
            wrapped && (text = text.replace($_linebrreg, $_linebr));
            span.innerHTML = text;
            css.left = x + "px";
			css.textAlign = align;
			/*
			switch (valign) {
				case TextLayout.TOP:
					css.top = y + "px";
					break;
				case TextLayout.BOTTOM:
					css.top = (y + h - span.offsetHeight) + 'px';
					break;
				case TextLayout.MIDDLE:
				default:
					css.top = (y + (h - span.offsetHeight) / 2) + "px";
			}
			return;
			*/
			switch (valign) {
				case TextLayout.TOP:
					css.top = y + "px";
                    if (_ieLeg) {
                    } else if (_ieOld) {
                        css.msTransform = "none";
                    } else {
                        css.transform = "none";
                        css.WebkitTransform = "none";
                    }
					break;
				case TextLayout.BOTTOM:
                    css.top = (y + h) + 'px';// "100%";
                    if (_ieLeg) {
                    } else if (_ieOld) {
                        css.msTransform = "translateY(-100%)";
                    } else {
                        css.transform = "translateY(-100%)";
						css.WebkitTransform = "translateY(-100%)";
                    }
					break;
				case TextLayout.MIDDLE:
				default:
                    css.top = Math.round(y + h / hline / 2) + 'px';//  "50%";;
                    if (_ieLeg) {
                    } else if (_ieOld) {
                        css.msTransform = "translateY(-50%)";
                    } else {
                        css.transform = "translateY(-50%)";
						css.WebkitTransform = "translateY(-50%)";
                    }
					break;
			}
		}
	},
	getTextWidth: function (font, text) {
		var div, css,
			w = 0;
		if (text) {
			div = document.createElement('div');
			css = div.style;
			div.innerHTML = text;
			css.position = 'absolute';
			css.whiteSpace = 'nowrap';
			css.visibility = 'hidden';
			css.font = font ? font.font : DEF_FONT;
			document.body.appendChild(div);
			w = div.offsetWidth;
			document.body.removeChild(div);
		}
		return w;
	},
	getTextWidth2: function (span, font, text) {
		var css, w = 0;
		if (text) {
			css = span.style;
			span.textContent = text;
			css.display = "inline";//-block";
			css.maxWidth = '';
			css.font = font ? font.font : DEF_FONT;
			css.textDecoration = 'none';
			css.whiteSpace = "nowrap";
			css.wordWrap = "";
			css.textAlign = "left";
			w = span.offsetWidth;
		}
		return w;
	},
    calcTextBounds: function (span, font, text, x, y, w, h, align, valign, wrap, r) {
        var hline, css, wrapped;
		r = r || new Rectangle();
        r.x = x;
        r.y = y;
        if (text) {
            hline = 1.1;
            css = span.style;
            css.display = "inline-block";
            css.maxWidth = w + 'px';
			if (font) {
				css.font = font.font
				css.textDecoration = font.deco;
			} else {
				css.font = DEF_FONT;
			}
            css.lineHeight = 1.1;
            if (wrap == "explicit") {
                css.whiteSpace = "nowrap";
                css.wordWrap = "";
				wrapped = true;
            } else if (wrap == "normal") {
                css.whiteSpace = "normal";
                css.wordWrap = "break-word";
				wrapped = true;
            } else {
                css.whiteSpace = "nowrap";
                css.wordWrap = "";
            }
			text = text.replace($$_htmlreg, $$_htmlrep);
			wrapped && (text = text.replace($_linebrreg, $_linebr));
            span.innerHTML = text;
            css.textAlign = align;
			css.maxWidth = '';
            r.width = span.offsetWidth;
            r.height = span.offsetHeight;
            switch (align) {
                case TextAlign.LEFT:
                    break;
                case TextAlign.CENTER:
                    r.x = _int(x + (w - r.width) / 2);
                    break;
                case TextAlign.RIGHT:
                    r.x = x + w - r.width;
                    break;
            }
            switch (valign) {
                case TextLayout.TOP:
                    break;
                case TextLayout.BOTTOM:
                    r.y = y + h - r.height;
                    break;
                case TextLayout.MIDDLE:
                default:
                    r.y = Math.round(y + (h - r.height / hline) / 2);
                    break;
            }
        }
        return r;
    },
	isAncestorOf: function (elt, child) {
		var p = child.parentElement;
		while (p) {
			if (p == elt) {
				return true;
			}
			p = p.parentElement;
		}
		return false;
	}
});
var _stopEvent = function (e) {
    if (e.preventDefault) {
        e.preventDefault();
        e.stopImmediatePropagation && e.stopImmediatePropagation();
    } else {
        e.returnValue = false;
    }
};
var _ignoreEvent = function (e) {
    e.$$_ignored = true;
};
(function () {
    var div = document.createElement('div');
    var err = false;
    var cr;
    try {
        cr = div.getBoundingClientRect();
    } catch (e) {
        err = true;
    }
    if (err || isNaN(cr.width)) {
        Element.prototype.getBoundingClientRect2 = function () {
            var cr = Element.prototype.getBoundingClientRect.call(this);
            return {
                left: cr.left,
                right: cr.right,
                width: cr.right - cr.left,
                top: cr.top,
                bottom: cr.bottom,
                height: cr.bottom - cr.top
            }
        };
    } else {
        Element.prototype.getBoundingClientRect2 = Element.prototype.getBoundingClientRect;
    }
    try {
        div.style.background = "rgba(0, 0, 0, 1)";
    } catch (e) {
        _norgba = true;
    }
})();
if (Object.defineProperty && Object.getOwnPropertyDescriptor &&
    Object.getOwnPropertyDescriptor(Element.prototype, "textContent") &&
    !Object.getOwnPropertyDescriptor(Element.prototype, "textContent").get) {
    (function () {
        var innerText = Object.getOwnPropertyDescriptor(Element.prototype, "innerText");
        Object.defineProperty(Element.prototype, "textContent", {
            get: function () {
                return innerText.get.call(this)
            },
            set: function (x) {
                return innerText.set.call(this, x)
            }
        });
    })();
}
var _getBrowserSize = function () {
    return {
        width: _win.innerWidth || _doc.documentElement.clientWidth || _doc.body.clientWidth,
        height: _win.innerHeight || _doc.documentElement.clientHeight || _doc.body.clientHeight
    };
};
var $_checkSize = undefined;
var _getCheckSize = function (check) {
    if (!$_checkSize) {
        (function () {
            var chk = document.createElement('input');
            chk.type = "checkbox";
            chk.style.padding = "0px";
            chk.style.margin = "0px";
            document.body.appendChild(chk);
            $_checkSize = chk.getBoundingClientRect2();
            document.body.removeChild(chk);
        })();
    }
    return $_checkSize;
};
var $$_DOM = {};
var $_validated = 0;
var $_toolValidated = 0;
var _egam_ = Image;
var $_mobileEnabled = true;
var UIContainer = defineClass("UIContainer", EventAware, {
    init: function (dom, containerId, popupOwner) {
        this._super();
        dom = !!dom;
        this.$_dom = dom ? $$_DOM : null;
        this.$_rich = !dom;
        if (!containerId) {
            throw "container is null!";
        }
        this._containerDiv = containerId instanceof HTMLElement ? containerId : document.getElementById(containerId);
        if (!this._containerDiv) {
            throw "Invalid grid container element: " + containerId;
        }
        this._popupOwner = _cast(popupOwner, HTMLElement);
        this._canvas = this._container = document.createElement("div");
        this._containerDiv.appendChild(this._container);
        var css = this._container.style;
        css.position = "relative"; // 이 것 때문에...
        css.boxSizing = "border-box";
        css.width = "100%";
        css.height = "100%";
        css.borderStyle = "none";
        css.borderWidth = "0px";
        css.overflow = "hidden";
        this._width = this._container.clientWidth;
        this._height = this._container.clientHeight;
        this._updateRequested = false;
        this._layoutNeeded = false;
        this._invalidated = false;
        this._nextLayoutNeeded = false;
        this._nextInvalidated = false;
        this._defaultTool = new VisualTool(this);
        this._activeTool = this._defaultTool;
        this._domMouse = false;
        this._captured = false;
        this._focusing = false;
        this._focusingTarget = null;
        this._hovered = null;
        this._currentX = 0;
        this._currentY = 0;
        this._rendered = 0;
        this._defaultCursor = Cursor.AUTO;
        this._drawing = false;
        this._offsetX = 0;
        this._offsetY = 0;
        this._clicked = 0;
        this._clicket = 0;
        this._children = [];
        this._rootElement = this._createRootElement(this.$_dom);
        this._feedbackRoot = this._createFeedbackRoot(this.$_dom);
        /*
        this._fragment = document.createDocumentFragment();
        this._fragment.appendChild(this._rootElement._dom);
        this._fragment.style.display = "none";
        */
        this._containerRender = this._render.bind(this);
        /*
        this.$_prepareContextMenu();
        this._popupMenuManager = new PopupMenuManager(this).addListener(this);
        this._contextMenu = null;
        this.onContextMenuItemClicked = null;
        */
        if (this.$_dom) {
            var s = this.$_textMeasurer = document.createElement('span');
            s.style.poistion = 'absolute';
            s.style.visibility = 'hidden';
            s.style.whiteSpace = 'nowrap';
            s.style.margin = s.style.padding = 0;
            this._container.appendChild(s);
            this._svgPool = document.createElementNS(SVGNS, "svg");
            this._svgPool.style.pointerEvents = "none";
            this._svgDefs = document.createElementNS(SVGNS, 'defs');
            this._svgPool.appendChild(this._svgDefs);
            this._container.appendChild(this._svgPool);
            this.$_getLinearGradient = function (fill) {
                var doc = document;
                var svg = this._svgPool;
                var defs = this._svgDefs;
                var id = 'lg' + fill.$_hash;
                var g = doc.getElementById(id);
                if (!g) {
                    g = doc.createElementNS(SVGNS, 'linearGradient');
                    g.setAttribute("id", id);
                    if (fill._angle == 90) {
                        g.setAttributeNS(null, "x1", "0%");
                        g.setAttributeNS(null, "y1", "0%");
                        g.setAttributeNS(null, "x2", "0%");
                        g.setAttributeNS(null, "y2", "100%");
                    }
                    var stop1 = doc.createElementNS(SVGNS, "stop");
                    stop1.setAttributeNS(null, "offset", "0%");
                    stop1.setAttributeNS(null, "style", "stop-color:" + fill._colors[0].value());
                    g.appendChild(stop1);
                    var stop2 = doc.createElementNS(SVGNS, "stop");
                    stop2.setAttributeNS(null, "offset", "100%");
                    stop2.setAttributeNS(null, "style", "stop-color:" + fill._colors[1].value());
                    g.appendChild(stop2);
                    defs.appendChild(g);
                }
                return "url(#" + id + ")";
            };
        }
    },
    _registerEventHandlers: function (canvas) {
        canvas.style.cursor = this._defaultCursor;
        if (_win.addEventListener) {
            _win.addEventListener("resize", this._resizeHandler.bind(this), false);
            canvas.addEventListener("keydown", this._keyDownHandler.bind(this), false);
            canvas.addEventListener("keyup", this._keyUpHandler.bind(this), false);
            canvas.addEventListener("click", this._clickHandler.bind(this), false);
            canvas.addEventListener("dblclick", this._dblclickHandler.bind(this), false);
            canvas.addEventListener("mousedown", this._mouseDownHandler.bind(this), false);
            _win.addEventListener("mousemove", this._mouseMoveHandler.bind(this), false);
            _win.addEventListener("mouseup", this._mouseUpHandler.bind(this), false);
            canvas.addEventListener("mouseenter", this._mouseEnterHandler.bind(this), false);
            canvas.addEventListener("mouseleave", this._mouseLeaveHandler.bind(this), false);
            canvas.addEventListener("mouseover", this._mouseOverHandler.bind(this), false);
            if (_isFirefox) {
                canvas.addEventListener("DOMMouseScroll", this._mouseScrollHandler.bind(this), false);
            } else {
                canvas.addEventListener("mousewheel", this._mouseWheelHandler.bind(this), false);
            }
            canvas.addEventListener("focus", this._focusHandler.bind(this), false);
            canvas.addEventListener("blur", this._blurHandler.bind(this), false);
            if ($_mobileEnabled) {
                canvas.addEventListener("touchstart", this._touchStartHandler.bind(this), false);
                canvas.addEventListener("touchmove", this._touchMoveHandler.bind(this), false);
                canvas.addEventListener("touchend", this._touchEndHandler.bind(this), false);
                canvas.addEventListener("touchcancel", this._touchCancelHandler.bind(this), false);
                canvas.addEventListener("touchleave", this._touchLeaveHandler.bind(this), false);
            }
            _win.addEventListener("focus", this._focusHandlerFireFox.bind(this), true);
            _win.addEventListener("focusin", this._focusinHandler.bind(this), true);
            if (_isChrome) {
            }
        } else {
            _win.attachEvent ("onresize", this._resizeHandler.bind(this), false);
            canvas.attachEvent("onkeydown", this._keyDownHandler.bind(this), false);
            canvas.attachEvent("onkeyup", this._keyUpHandler.bind(this), false);
            canvas.attachEvent("onclick", this._clickHandler.bind(this), false);
            canvas.attachEvent("ondblclick", this._dblclickHandler.bind(this), false);
            canvas.attachEvent("onmousedown", this._mouseDownHandler.bind(this), false);
            _win.attachEvent("onmousemove", this._mouseMoveHandler.bind(this), false);
            _win.attachEvent("onmouseup", this._mouseUpHandler.bind(this), false);
            canvas.attachEvent("onmouseenter", this._mouseEnterHandler.bind(this), false);
            canvas.attachEvent("onmouseleave", this._mouseLeaveHandler.bind(this), false);
            canvas.attachEvent("onmouseover", this._mouseOverHandler.bind(this), false);
            if (_isFirefox) {
                canvas.attachEvent("onDOMMouseScroll", this._mouseScrollHandler.bind(this), false);
            } else {
                canvas.attachEvent("onmousewheel", this._mouseWheelHandler.bind(this), false);
            }
            canvas.attachEvent("onfocus", this._focusHandler.bind(this), false);
            canvas.attachEvent("onblur", this._blurHandler.bind(this), false);
            if ($_mobileEnabled) {
                canvas.attachEvent("ontouchstart", this._touchStartHandler.bind(this), false);
                canvas.attachEvent("ontouchmove", this._touchMoveHandler.bind(this), false);
                canvas.attachEvent("ontouchend", this._touchEndHandler.bind(this), false);
                canvas.attachEvent("ontouchcancel", this._touchCancelHandler.bind(this), false);
                canvas.attachEvent("ontouchleave", this._touchLeaveHandler.bind(this), false);
            }
        }
    },
    containerElement: function () {
        return this._container;
    },
    visible: function () {
        return this._container.style.visibility != "hidden";
    },
    /** @deprecated use visible instead. */
    isVisible: function () {
        return this.visible();
    },
    setVisible: function (value) {
        this._container.style.visibility = value ? "visible" : "hidden";
    },
    width: function () {
        return this._width;
    },
    height: function () {
        return this._height;
    },
    defaultTool: function () {
        return this._defaultTool;
    },
    setDefaultTool: function (tool) {
        var old = this._defaultTool;
        if (tool !== old) {
            this._defaultTool = tool;
            if (this._activeTool === old) {
                this.setActiveTool(tool);
            }
        }
        return this;
    },
    activeTool: function () {
        return this._activeTool;
    },
    setActiveTool: function (tool) {
        if (tool !== this._activeTool) {
            if (this._activeTool) {
                this._activeTool.deactivate();
            }
            this._activeTool = tool;
            if (this._activeTool) {
                this._activeTool.activate();
            }
        }
        return this;
    },
    mouseX: function () {
        return this._currentX;
    },
    mouseY: function () {
        return this._currentY;
    },
    popupMenuManager: function () {
        return this._popupMenuManager;
    },
    contextMenu: function () {
        return this._contextMenu;
    },
    setContextMenu: function (value) {
        if (value != this._contextMenu) {
            if (value instanceof PopupMenu) {
                this._contextMenu = value;
            } else if (value) {
                this._contextMenu = new PopupMenu("gridContextMenu", this, value);
            } else {
                this._contextMenu = null;
            }
        }
    },
    addChild: function (control) {
        if (control && this._children.indexOf(control) < 0) {
            this._children.push(control);
            control.attached(this);
        }
        return control;
    },
    removeChild: function (control) {
        var i;
        if (control && (i = this._children.indexOf(control)) >= 0) {
            this._children.splice(i, 1);
            control.detached();
        }
    },
    addElement: function (element, context) {
        return this._rootElement.addElement(element, context);
    },
    removeElement: function (element) {
        this._rootElement.removeElement(element);
    },
    addFeedback: function (element, context) {
        this._feedbackRoot.addElement(element, context);
    },
    removeFeedback: function (element) {
        this._feedbackRoot.removeElement(element);
    },
    findElementAt: function (x, y, hitTesting) {
        return this._feedbackRoot.findChildAt(x - this._rootElement._x, y - this._rootElement._y, hitTesting)
                || this._rootElement.findChildAt(x - this._rootElement._x, y - this._rootElement._y, hitTesting);
    },
    setFocus: function () {
        this._setFocusAndScroll(this._canvas);
    },
    updateNow: function () {
        this._render(_getTimer());
    },
    invalidateLayout: function () {
        if (this._drawing) {
            this._nextLayoutNeeded = true;
        } else {
            this._layoutNeeded = true;
        }
        this.invalidate(true);
    },
    invalidate: function (force) {
        if ((!this._updateRequested || !this._invalidated) && (force || !this._drawing)) {
            window && window.requestAnimationFrame(this._containerRender);
            /*
            self = this;
            setTimeout(function () {
                self._containerRender();
            }, 0);
            */
            this._updateRequested = true;
            if (this._drawing) {
                this._nextInvalidated = true;
            } else {
                this._invalidated = true;
            }
        }
    },
    setDefaultCursor: function (cursor) {
        this._defaultCursor = cursor || Cursor.AUTO;
    },
    setCursor: function (cursor) {
        this._canvas.style.cursor = cursor || this._defaultCursor;
    },
    restoreCursor: function (cursor) {
        this._canvas.style.cursor = this._defaultCursor;
    },
    _setDomMouse: function (value) {
        return this._domMouse = value;
    },
    _createChildren: function (containerElement) {
    },
    _layoutChildren: function (bounds) {
    },
    _createRootElement: function (dom) {
        return null;
    },
    _createFeedbackRoot: function (dom) {
        return null;
    },
    _render: function (timestamp) {
        this._updateRequested = false;
        this.resetSize();
        this._offsetX = this._canvas.offsetLeft;
        this._offsetY = this._canvas.offsetTop;
        var op = this._canvas.offsetParent;
        while (op) {
            this._offsetX += op.offsetLeft;
            this._offsetY += op.offsetTop;
            op = op.offsetParent;
        }
        this._drawing = true;
        try {
            this.$_dom ? this.$$_renderHtml_in(timestamp, null, 0, 0) : this.$$_render(timestamp, null, 0, 0);
        } finally {
            this._drawing = false;
            this._invalidated = this._nextInvalidated;
            this._layoutNeeded = this._nextLayoutNeeded;
            this._nextInvalidated = this._nextLayoutNeeded = false;
        }
    },
    $$_render: function (timestamp, scrollRect, scrollX, scrollY) {
    },
    $$_renderHtml_in: function (timestamp, scrollRect, scrollX, scrollY) {
        var d = _document.createDocumentFragment();
        d.appendChild(this._rootElement._dom);
        try {
            this.$$_renderHtml(timestamp, null, 0, 0);
        } finally {
            this._container.appendChild(d);
            this._rootElement.drawHtml();
        }
    },
    $$_renderHtml: function (timestamp, scrollRect, scrollX, scrollY) {
    },
    _setFocusAndScroll: function (target) {
        if (target) {
            if (!this._focusing) {
                this._focusing = true;
                this._focusingTarget = target;
                try {
                    var x = _win.pageXOffset;
                    var y = _win.pageYOffset;
                    target.setFocus ? target.setFocus() : target.focus();
                    if (_win.pageXOffset != x || _win.pageYOffset != y) {
                        _win.scrollTo(x, y);
                    }
                } finally {
                    this._focusing = false;
                    this._focusingTarget = null;
                }
            } else if (target != this._focusingTarget) {
                target.setFocus ? target.setFocus() : target.focus();
            }
        }
    },
    checkClicked: function (x, y) {
        if ($_debug) {
            var dx = this._width - x, dy = this._height - y, t = getTimer();
            if (dx < 3 && dy < 3) {
                if (t < this._clicket + 300) {
                    this._clicked++;
                    if (this._clicked == 3) {
                        _alert(this);
                        if ($_debug) throw this;
                    }
                } else {
                    this._clicked = 0;
                }
            }
            this._clicket = t;
        }
    },
    toOffset: function (event) {
        /*
         event.mouseX = event.clientX - _offsetX;
         event.mouseY = event.clientY - _offsetY;
         */
        var elt = this._canvas; // event.target; // canvas로 간주하면 window로 이벤트 핸들링을 해도 동일하게 적용된다.
        var r = elt.getBoundingClientRect();
        event.mouseX = event.clientX - r.left;
        event.mouseY = event.clientY - r.top;
        return event;
    },
    toScreen: function (r) {
        r.x += this._offsetX;
        r.y += this._offsetY;
        return r;
    },
    _resizeHandler: function (event) {
    },
    _keyDownHandler: function (event) {
        if (event.$$_ignored) return;
        if (event.defaultPrevented) return;
        if (this._activeTool) {
            var ctrl = _isMac && event.metaKey || !_isMac && event.ctrlKey;
            if (this._activeTool.keyDown(event.keyCode, event.ctrlKey, event.shiftKey, event.altKey)) {
                _stopEvent(event);
            }
        }
    },
    _keyUpHandler: function (event) {
        if (event.$$_ignored) return;
        if (event.defaultPrevented) return;
        if (this._activeTool) {
            var ctrl = _isMac && event.metaKey || !_isMac && event.ctrlKey;
            if (this._activeTool.keyUp(event.keyCode, event.ctrlKey, event.shiftKey, event.altKey)) {
                _stopEvent(event);
            }
        }
    },
    _clickHandler: function (event) {
        if (event.$$_ignored) return;
        this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
        if (this._activeTool) {
            this._activeTool.click(this.toOffset(event));
        }
    },
    _dblclickHandler: function (event) {
        if (event.$$_ignored) return;
        this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
        if (this._activeTool) {
            this._activeTool.dblclick(this.toOffset(event));
        }
    },
    $$_isIE: function (event) {
        return (_ieTen || _ieOld || this._domMouse) && this._container.contains(event.target);
    },
    _mouseDownHandler: function (event) {
        if (event.$$_ignored) return;
        if (event.target === this._canvas || this.$$_isIE(event)) {
            this._canvas.setAttribute('tabindex', '0');
            this._captured = true;
            this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
            this.toOffset(event);
            this._currentX = event.mouseX;
            this._currentY = event.mouseY;
            if (this._activeTool) {
                this._activeTool.mouseDown(event);
            }
            /*
            _stopEvent(event);
            */
            if (_isIE && (!this._activeTool || this._activeTool.isEditing())) {
                _stopEvent(event);
            }
        }
    },
    _mouseMoveHandler: function (event) {
        if (event.$$_ignored) return;
        if (!this._captured && event.target !== this._canvas && !this.$$_isIE(event)) {
            if (this._hovered) {
                this._hovered.setHovered(false);
                this._hovered = null;
            }
            if (this._activeTool) {
                this._activeTool.mouseOutside();
            }
            return;
        }
        this.toOffset(event);
        var x = event.mouseX;
        var y = event.mouseY;
        if (x != this._currentX || y != this._currentY) { // 같은 위치여도 발생하고 있다.
            this._currentX = x;
            this._currentY = y;
            if (!this._activeTool || !this._activeTool.isDragging()) {
                var elt = this.findElementAt(x, y, true);
                if ((elt == null || elt.canHover()) && elt != this._hovered ) {
                    if (this._hovered) {
                        this._hovered.setHovered(false);
                    }
                    this._hovered = elt;
                    if (this._hovered && this._hovered._mouseEnabled) {
                        this._hovered.setHovered(true);
                    }
                }
            }
        }
        if (this._activeTool) {
            this._activeTool.mouseMove(event);
        }
    },
    _mouseUpHandler: function (event) {
        if (event.$$_ignored) return;
        if (!this._captured && event.target !== this._canvas && !this.$$_isIE(event)) {
            return;
        }
        this._captured = false;
        if (this._activeTool) {
            this._activeTool.mouseUp(this.toOffset(event));
        }
    },
    _mouseEnterHandler: function (event) {
        if (event.$$_ignored) return;
        if (this._activeTool) {
            this._activeTool.mouseEnter(this.toOffset(event));
        }
    },
    _mouseLeaveHandler: function (event) {
        if (event.$$_ignored) return;
        if (this._hovered) {
            this._hovered.setHovered(false);
        }
        if (this._activeTool) {
            this._activeTool.mouseLeave(this.toOffset(event));
        }
    },
    _mouseOverHandler: function (event) {
        if (event.$$_ignored) return;
        if (this._activeTool) {
            this._activeTool.mouseLeave(this.toOffset(event));
        }
    },
    _mouseWheelHandler: function (event) {
        if (event.$$_ignored) return;
        if (this._activeTool) {
            if (this._activeTool.mouseWheel(this.toOffset(event))) {
                _stopEvent(event);
                return true;
            }
        }
        return false;
    },
    _mouseScrollHandler: function (event) {
        if (event.$$_ignored) return;
        if (this._activeTool) {
            event.wheelDelta = -event.detail;
            if (this._activeTool.mouseWheel(this.toOffset(event))) {
                _stopEvent(event);
            }
        }
    },
    _focusHandler: function (event) {
    },
    _blurHandler: function (event) {
    },
    _focusinHandler: function (event) {
        if (event.target === this._canvas) {
            this._activeTool && this._activeTool.setFocus();
        }
    },
    _focusHandlerFireFox: function (event) {
        if (event.target === this._canvas) {
            this._activeTool && this._activeTool.setFocus();
        }
    },
    _focusoutHandler: function (event) {
    },
    _touchStartHandler: function (event) {
        if (event.touches.length > 1 || event.changedTouches.length > 1 || event.targetTouches.length > 1) {
            if (this._activeTool) {
                try {
                    this._activeTool.touchCancel(event);
                } catch (e) {
                }
            }
            return;
        }
        if (this._activeTool) {
            if (this._activeTool.touchStart(event)) {
                event.preventDefault();
            } else {
                try {
                    this._activeTool.touchCancel(event);
                } catch (e) {
                }
            }
        }
    },
    _touchMoveHandler: function (event) {
        if (event.touches.length > 1 || event.changedTouches.length > 1 || event.targetTouches.length > 1) {
            if (this._activeTool) {
                try {
                    this._activeTool.touchCancel(event);
                } catch (e) {
                }
            }
            return;
        }
        if (this._activeTool) {
            if (this._activeTool.touchMove(event)) {
                event.preventDefault();
            } else {
                try {
                    this._activeTool.touchCancel(event);
                } catch (e) {
                }
            }
        }
    },
    _touchEndHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchEnd(event);
        }
    },
    _touchCancelHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchCancel(event);
        }
    },
    _touchLeaveHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchEnd(event);
        }
    },
    onMenuItemClick: function (menuItem) {
        this.onContextMenuItemClicked && this.onContextMenuItemClicked(this, menuItem);
        this.fireEvent(UIContainer.CONTEXT_MENU_ITEM_CLICKED, menuItem);
    }
});
UIContainer.CONTEXT_MENU_ITEM_CLICKED = "onUIContainerContextMenuItemClicked";
var EditMaskItem = function (key, callback, tocase) {
    this.key = key;
    this.callback = callback;
    this.case = tocase;  // 9: password, 1: upper, -1: lower
    this.get = function (tocase) {
        return tocase > 1 ? this.toPass : tocase > 0 ? this.toUpper : tocase < 0 ? this.toLower : this;
    }
};
var _editMaskItem = function (key, callback) {
    var item = new EditMaskItem(key, callback, 0);
    item.toPass = new EditMaskItem(key, callback, 9);
    item.toUpper = new EditMaskItem(key, callback, 1);
    item.toLower = new EditMaskItem(key, callback, -1);
    return item;
};
var SeparatorMaskItem = function (key, localeKey) {
    this.key = key;
    this.localeKey = localeKey;
    this.get = function (tocase) { return this; };
    this.value = function () {
        return Locale._default[this.localeKey] || key;
    };
};
var _separatorMaskItem = function (key, prop) {
    return new SeparatorMaskItem(key, prop);
};
var EditMask = defineClass("EditMask", null, {
    init: function (format) {
        this._super();
        this._items = [];
        this._values = [];
        this._source = [];
        this.setFormat(format);
    },
    format: null,
    placeHolder: '_',
    passwoardChar: '*',
    setFormat: function (value) {
        if (value != this._format) {
            this._format = value;
            this.$_parse(value);
        }
        return this;
    },
    length: function () {
        return this._items.length;
    },
    valueLength: function () {
        return this._values.length;
    },
    getItem: function (p) {
        return this._items[p];
    },
    getValue: function (p) {
        return this._values[p];
    },
    isLiteral: function (p) {
        var i = this._items[p];
        return _isString(i) || (i instanceof SeparatorMaskItem);
    },
    getLiteral: function (p) {
        var i = this._items[p];
        if (_isString(i)) {
            return i;
        } else if (i instanceof SeparatorMaskItem) {
            return i.value();
        }
        return null;
    },
    isValid: function (p, c) {
        var cb = this._items[p].callback;
        return !cb || cb(c);
    },
    isValidValue: function (p, c) {
        var cb = this._values[p].callback;
        return !cb || cb(c);
    },
    checkValid: function (text) {
        var i, cb,
            items = this._items,
            cnt = items.length;
        for (i = 0; i < cnt; i++) {
            cb = items[i].callback;
            if (cb && !cb(text[i] || ' ')) {
                return false;
            }
        }
        return true;
    },
    getValuePos: function (p) {
        var items = this._items,
            cnt = Math.min(items.length, p),
            p1 = 0,
            i = 0;
        while (i < cnt) {
            if (!this.isLiteral(i++)) {
                p1++;
            }
        }
        return p1;
    },
    getValueRange: function (p1, p2) {
        var len = this._items.length,
            cnt = this._values.length,
            i, p;
        p = 0;
        i = 0;
        while (i < len && i < p1) {
            if (!this.isLiteral(i++)) {
                p++;
            }
        }
        p1 = p;
        while (i < len && i < p2) {
            if (!this.isLiteral(i++)) {
                p++;
            }
        }
        p2 = p;
        return { p1: p1, p2: p2};
    },
    getItemPos: function (valuePos) {
        var i, p,
            items = this._items,
            cnt = items.length;
        i = p = 0;
        while (i < cnt) {
            while (!(items[i] instanceof EditMaskItem)) i++;
            if (p == valuePos) break;
            i++;
            p++;
        }
        return i;
    },
    getTemplate: function (p, len) {
        var k, p2,
            items = this._items,
            s = '';
        p = arguments.length > 0 ? p : 0;
        p2 = arguments.length > 1 ? Math.min(p + len, items.length) : items.length;
        for (; p < p2; p++) {
            k = items[p];
            if (k instanceof EditMaskItem) {
                s += this.$_getHolder(p);
            } else if (k instanceof SeparatorMaskItem) {
                s += k.value();
            } else {
                s += k;
            }
        }
        return s;
    },
    strip: function (text) {
        var i,
            items = this._items,
            cnt = Math.min(items.length, text.length),
            s = '';
        for (i = 0; i < cnt; i++) {
            if (!this.isLiteral(i)) {
                s += text.charAt(i);
            }
        }
        return s;
    },
    mask: function (value) {
        var i, p, k, h, c, d,
            items = this._items,
            len = value.length,
            cnt = items.length,
            s = '';
        for (i = 0, p = 0; i < cnt; i++) {
            k = items[i];
            d = '';
            if (k instanceof EditMaskItem) {
                h = this.$_getHolder(i);
                c = (p < len && (d = value.charAt(p)) != ' ' && this.isValidValue(p, d)) ? d : h;
                switch (k.case) {
                    case 9:
                        if (i < len && d == '*' || (d != h && d == c)) {
                            s += '*';
                        } else {
                            s += c;
                        }
                        break;
                    case 1:
                        s += c.toUpperCase();
                        break;
                    case -1:
                        s += c.toLowerCase();
                        break;
                    default:
                        s += c;
                        break;
                }
                p++;
            } else if (k instanceof SeparatorMaskItem) {
                s += k.value();
            } else {
                s += k;
            }
        }
        return s;
    },
    clearSource: function (start, end) {
        end = arguments.length > 1 ? end : start + 1;
        for (var i = start; i < end; i++) {
            this._source[i] = undefined;
        }
    },
    initSource: function (value, fromEnd) {
        var i,
            vals = value ? value.split('') : [],
            cnt = this._values.length - vals.length;
        if (fromEnd) {
            for (i = 0; i < cnt; i++) {
                vals.splice(0, 0, '');
            }
        }
        this._source = vals;
    },
    setSource: function (p, c) {
        this._source[p] = c;
    },
    getText: function (text, start, end, trim) {
        var i, c, n,
            items = this._items,
            s = '';
        n = this.getValueRange(start, start).p1;
        end = Math.min(end, text.length);
        for (i = start; i < end; i++) {
            c = text.charAt(i);
            if (c == this.$_getHolder(i) && !this.isLiteral(i)) {
                s += ' ';
            } else if (items[i].case == 9) {
                s += this._source[n];
            } else {
                s += c;
            }
            if (!this.isLiteral(i)) n++;
        }
        return trim ? s.trim() : s;
    },
    unmask: function (txt, includeSeparators, includeLiterals, stripLeft, stripRight, stripInner) {
        var i, k, c, n,
            items = this._items,
            cnt = Math.min(items.length, txt ? txt.length : 0),
            s = '';
        for (i = 0, n = 0; i < cnt; i++) {
            k = items[i];
            c = txt[i];
            if (k instanceof EditMaskItem) {
                s += k.case == 9 ? this._source[n] : this.isValid(i, c) ? c : ' ';
            } else if (k instanceof SeparatorMaskItem) {
                s += includeSeparators ? k.value() : '';
            } else { // literal
                s += includeLiterals ? c : '';
            }
            if (!this.isLiteral(i)) n++;
        }
        if (stripLeft) s = _trimLeft(s);
        if (stripRight) s = _trimRight(s);
        if (stripInner) s = _strip(s);
        return s;
    },
    $_parse: function (f) {
        var i, c, k, item,
            escape = false,
            tocase = 0,
            keys = EditMask.KEYS,
            len = f ? f.length : 0,
            items = this._items,
            values = this._values;
        items.length = values.length = 0;
        for (i = 0; i < len; i++) {
            c = f.charAt(i);
            if (escape) {
                if (c == '\\') {
                    escape = false;
                } else {
                    items.push(c);
                }
            } else {
                switch (c) {
                    case '\\':
                        escape = true;
                        break;
                    case '{':
                        tocase = 9;
                        break;
                    case '}':
                        tocase = 0;
                        break;
                    case '>':
                        tocase = tocase > 0 ? 0 : 1;
                        break;
                    case '<':
                        tocase = tocase < 0 ? 0 : -1;
                        break;
                    default:
                        item = null;
                        for (k in keys) {
                            if (c == k) {
                                item = keys[k].get(tocase);
                                break;
                            }
                        }
                        items.push(item || c);
                        (item instanceof EditMaskItem) && values.push(item);
                        break;
                }
            }
        }
    },
    $_getHolder: function (p) {
        return this._placeHolder// ||  ' ';
    }
}, {
    DIGIT: _editMaskItem('0', function (c) {
        return c >= '0' && c <= '9';
    }),
    DIGIT_SPACE: _editMaskItem('9', function (c) {
        return c >= '0' && c <= '9' || c == ' ';
    }),
    DIGIT_SIGN: _editMaskItem('#', function (c) {
        return c >= '0' && c <= '9' || c == '-' || c == '+' || c == ' ';
    }),
    LETTER: _editMaskItem('L', function (c) {
        return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z';
    }),
    LETTER_SPACE: _editMaskItem('?', function (c) {
        return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == ' ';
    }),
    LETTER_DIGIT: _editMaskItem('A', function (c) {
        return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c >= '0' && c <= '9';
    }),
    LETTER_DISIT_SPACE: _editMaskItem('a', function (c) {
        return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c == ' ';
    }),
    /* locale separators */
    DECIMAL_SEP: _separatorMaskItem('.', 'decimalSep'),
    DATE_SEP: _separatorMaskItem('/', 'dateSep'),
    TIME_SEP: _separatorMaskItem(':', 'timeSep')
}, function (f, statics) {
    var keys = f.KEYS = {};
    for (var k in statics) {
        key = statics[k];
        keys[key.key] = key;
    }
});
var MaskEditor = defineClass("MaskEditor", EventAware, {
    init: function (editor, inline) {
        this._super();
        this._editor = editor;
        this._mask = null;
        if (!inline) {
            var self = this;
            editor.onkeydown = function (ev) {
                if ((ev.keyCode == 229 || ev.keyCode == 197/* opera? */)) {
                    _stopEvent(e);
                    return false;
                }
                switch (ev.keyCode) {
                    case Keys.DELETE:
                        self._doDelete();
                        _stopEvent(ev);
                        return false;
                    case Keys.BACK:
                        self._doBack();
                        _stopEvent(ev);
                        return false;
                }
                return true;
            };
            editor.onkeypress = function (ev) {
                if (self._doChar(ev.key, ev.which || ev.keyCode)) {
                    _stopEvent(ev);
                    return true;
                }
            };
            editor.oncopy = function (ev) {
                self._doCopy(ev);
                _stopEvent(ev);
            };
            editor.oncut = function (ev) {
                self._doCut(ev);
                _stopEvent(ev);
            };
            editor.onpaste = function (ev) {
                self._doPaste(ev);
                _stopEvent(ev);
            };
        }
    },
    format: null,
    insertMode: true,
    includeSeparators: true,
    includeLiterals: false,
    stripBegin: false,
    stripEnd: false,
    stripInner: false,
    fitToSeparators: true,
    trimWhenCopy: true,
    changeCallback: null,
    setFormat: function (value) {
        value = !value || value.trim();
        if (value != this._format) {
            this._format = value;
            var mask = this._mask = value ? new EditMask(value) : null;
            this._editor.value = mask ? mask.getTemplate() : '';
            this._editor.maxLength = mask ? mask.length() : -1;
        }
    },
    setIncludeSeparators: function (value) {
        if (value != this._includeSeparators) {
            this._includeSeparators = value;
        }
    },
    setFitToSeparators: function (value) {
        if (value != this._fitToSeparators) {
            this._fitToSeparators = value;
        }
    },
    editor: function () {
        return this._editor;
    },
    checkValid: function () {
        if (this._mask) {
            var s = this.getText(this._editor.value);
            return this._mask.checkValid(s);
        }
        return true;
    },
    initValue: function (value, fromEnd) {
        if (this._mask) {
            this._mask.initSource(value, fromEnd);
            value = this.seiveText(value, fromEnd);
            value = this._mask.mask(value);
            this._editor.value = value;
        }
    },
    seiveText: function (text, fromEnd) {
        if (this._mask) {
            var i, p, c,
                mask = this._mask,
                cnt = text ? text.length : 0,
                vlen = mask._values.length,
                s = '';
            if (fromEnd) {
                for (i = cnt - 1, p = vlen - 1; i >= 0 && p >= 0; i--) {
                    c = text.charAt(i);
                    if (mask.isValidValue(p, c)) {
                        s = c + s;
                        p--;
                    }
                }
                for (i = 0; i < vlen - cnt; i++) {
                    s = ' ' + s;
                }
            } else {
                for (i = 0, p = 0; i < cnt && p < vlen; i++) {
                    c = text.charAt(i);
                    if (mask.isValidValue(p, c)) {
                        s += c;
                        p++;
                    }
                }
            }
            return s;
        }
        return text;
    },
    unmaskText: function (text) {
        if (this._mask) {
            text = arguments.length > 0 ? text : this._editor.value;
            var s = this._mask.unmask(text, this._includeSeparators, this._includeLiterals, this._stripBegin, this._stripEnd, this._stripInner);
            return s;
        }
        return text;
    },
    getText: function (text) {
        if (this._mask) {
            text = arguments.length > 0 ? text : this._editor.value;
            return this._mask.getText(text, 0, MAX_INT);
        }
        return text;
    },
    _changed: function () {
        this._changeCallback && this._changeCallback(this);
    },
    _setValue: function (value, noEvent) {
        var old = this._editor.value;
        if (value != old) {
            this._editor.value = value;
            !noEvent && this._changeCallback && this._changeCallback(this);
        }
    },
    _doDelete: function () {
        var s, s2,
            slen = this.$_getSelLength(),
            editor = this._editor,
            mask = this._mask,
            p = this.$_getCaretPos();
        if (!mask || p >= mask.length() && slen < 1) {
            return;
        }
        s = mask.strip(editor.value);
        rng = mask.getValueRange(editor.selectionStart, editor.selectionEnd);
        if (this._insertMode) {
            if (slen > 0) {
                if (rng.p2 > rng.p1) {
                    s = s.substr(0, rng.p1) + s.substr(rng.p2);
                    mask.clearSource(rng.p1, rng.p2);
                    s2 = s;
                }
            } else if (!mask.isLiteral(p)) {
                s = s.substr(0, rng.p1) + s.substr(rng.p1 + 1);
                mask.clearSource(rng.p1);
                s2 = s;
            }
        } else {
            if (slen > 0) {
                s = _replaceChar(s, rng.p1, rng.p2, ' ');
                mask.clearSource(rng.p1, rng.p2);
                p += slen - 1;
                s2 = s;
            } else if (!mask.isLiteral(p)) {
                s = _replaceChar(s, rng.p1, rng.p1 + 1, ' ');
                mask.clearSource(rng.p1);
                s2 = s;
            }
            p++;
        }
        s2 !== undefined && this._setValue(mask.mask(s2));
        this.$_moveCaret(p);
        return true;
    },
    _doBack: function () {
        var s, s2, p1,
            editor = this._editor,
            mask = this._mask,
            p = this.$_getCaretPos();
        if (!mask || p <= 0 && this.$_getSelLength() < 1) {
            return;
        }
        s = mask.strip(editor.value);
        rng = mask.getValueRange(editor.selectionStart, editor.selectionEnd);
        if (this._insertMode) {
            if (this.$_getSelLength() > 0) {
                if (rng.p2 > rng.p1) {
                    s = s.substr(0, rng.p1) + s.substr(rng.p2);
                    mask.clearSource(rng.p1, rng.p2);
                    s2 = s;
                    p = mask.getItemPos(rng.p1);
                }
            } else if (mask.isLiteral(p - 1)) {
                p--;
            } else {
                p1 = rng.p1 - 1;
                s = s.substr(0, p1) + s.substr(p1 + 1);
                mask.clearSource(p1);
                s2 = s;
                p = mask.getItemPos(p1);
            }
        } else {
            if (this.$_getSelLength() > 0) {
                if (rng.p2 > rng.p1) {
                    s = _replaceChar(s, rng.p1, rng.p2, ' ');
                    mask.clearSource(rng.p1, rng.p2);
                    s2 = s;
                    p = mask.getItemPos(rng.p1);
                }
            } else if (mask.isLiteral(p - 1)) {
                p--;
            } else {
                p1 = rng.p1 - 1;
                s = _replaceChar(s, p1, p1 + 1, ' ');
                mask.clearSource(p1);
                s2 = s;
                p = mask.getItemPos(p1);
            }
        }
        s2 !== undefined && this._setValue(mask.mask(s2));
        this.$_moveCaret(p);
        return true;
    },
    _doChar: function (key, code, noEvent) {
        var rng, p, p1, p2,
            mask = this._mask,
            editor = this._editor,
            s = editor.value;
        if (!mask || code < ' '.charCodeAt(0) && code != Keys.SPACE) {
            return;
        }
        s = mask.strip(s);
        p1 = editor.selectionStart;
        p2 = editor.selectionEnd;
        rng = mask.getValueRange(p1, p2);
        if (rng.p1 >= mask.valueLength()) {
            return true;
        }
        if (!mask.isValidValue(rng.p1, key)) {
            return true;
        }
        mask.clearSource(rng.p1, rng.p2);
        mask.setSource(rng.p1, key);
        if (this._insertMode) {
            s = s.substr(0, rng.p1) + key + s.substr(rng.p2);
        } else {
            s = _replaceChar(s, rng.p1, rng.p2, ' ');
            s = s.substr(0, rng.p1) + key + s.substr(rng.p1 + 1);
        }
        s = s.substr(0, mask.valueLength());
        p = rng.p1 + 1;
        this._setValue(mask.mask(s), noEvent);
        p = mask.getItemPos(p);
        this.$_moveCaret(p);
        return true;
    },
    _doCopy: function (ev) {
        if (this._mask && this.$_getSelLength() > 0) {
            var editor = this._editor,
                s = this._mask.getText(editor.value, editor.selectionStart, editor.selectionEnd, this._trimWhenCopy);
            _setClipboardText(ev, s);
            return true;
        }
    },
    _doCut: function (ev) {
        if (this._mask && this.$_getSelLength() > 0) {
            var editor = this._editor,
                s = this._mask.getText(editor.value, editor.selectionStart, editor.selectionEnd, this._trimWhenCopy);
            _setClipboardText(ev, s);
            this._doDelete();
            return true;
        }
    },
    _doPaste: function (ev) {
        var i,
            editor = this._editor,
            s = _getClipboardText(ev);
        if (this._mask && s.length > 0) {
            for (i = 0; i < s.length; i++) {
                this._doChar(s.charAt(i), undefined, true);
            }
            this._changed();
            return true;
        }
    },
    $_getSelLength: function () {
        return this._editor.selectionEnd - this._editor.selectionStart;
    },
    $_getCaretPos: function () {
        return this._editor.selectionStart;
    },
    $_moveCaret: function (p) {
        var s = this._editor.value;
        p = s ? Math.min(this._editor.value.length, p) : 0;
        this._editor.setSelectionRange(p, p, 'none');
    },
    $_beep: (function () {
        var snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");
        return function () {
        }
    })()
}, {
    HANDLED: {}
});
var PopupMenuItem = defineClass("PopupMenuItem", null, {
	init : function (parent, source) {
		this._super();
		this._parent = parent;
		this._children = null;
		if (source) {
			this.assign(source);
		}
	},
    visible: true,
    enabled: true,
	label: null,
	type: null,
	group: null,
	checked: false,
	tag: undefined,
	children: null,
	callback: null,			// function (menuItem);
    displayCallback: null,	// function (menuItem): Boolean
    checkedCallback: null,	// function (menuItem): Boolean
	parent: function () {
		return this._parent;
	},
	setChildren: function (value) {
	},
	isSeparator: function () {
		return this._label == "-";
	},
    setCallback: function (value) {
        if (value !== this._callback) {
            this._callback = _createCallback(value);
        }
    },
    setDisplayCallback: function (value) {
        if (value !== this._displayCallback) {
            this._displayCallback = _createCallback(value);
        }
    },
    setCheckedCallback: function (value) {
        if (value !== this._checkedCallback) {
            this._checkedCallback = _createCallback(value);
        }
    },
	getVisible: function () {
		var cb = this._displayCallback;
		return cb ? cb(this) : this._visible;
	},
	getData: function () {
		return {
			label: this._label,
			checked: this._checked,
			enabled: this._enabled,
			tag: this._tag
		};
	},
	click: function () {
		if (this._type == "check") {
			this._checked = !this._checked;
		}
		this._parent._itemClicked(this);
	}
});
/* 	menu = [{
  		label: "menu label", // "-" 면 separator
  		type: "radio | check | normal | separator",
  		group: "",
  		enabled: true | false,
  		checked: true | false,
  		tag: "",
  		children: [
  		],
  		callback: function (data) {}
  		action: "",
  		actionTarget: DLBase object
		labels: [] // boolean, enum
  		}, {
  	}];
*/
var PopupMenu = defineClass("PopupMenu", EventAware, {
	init: function (name, parent, source) {
		this._super();
		this._name = name;
		this._parent = parent;
		this._items = this._load(source);
	},
    visible: true,
	displayCallback: null,	// function (menu): Boolean
	checkedCallback: null,	// function (menu): Boolean
	childrenCallback: null,	// function (menu): [MenuItem]
	enabled: true,
	name: null,
	label: null,
	setDisplayCallback: function (value) {
		if (value !== this._displayCallback) {
			this._displayCallback = _createCallback(value);
		}
	},
	setCheckedCallback: function (value) {
		if (value !== this._checkedCallback) {
			this._checkedCallback = _createCallback(value);
		}
	},
	setChildrenCallback: function (value) {
		if (value !== this._childrenCallback) {
			this._childrenCallback = _createCallback(value);
		}
	},
	manager: function () {
		var p = this._parent;
		while (p) {
			if (p.popupMenuManager && p.popupMenuManager() instanceof PopupMenuManager) {
				return p.popupMenuManager();
			}
			if (p instanceof PopupMenuManager) {
				return p;
			}
			p = p._parent;
		}
		return null;
	},
	items: function () {
		return this._items;
	},
	count: function () {
		return this._items ? this._items.length : 0;
	},
	getVisible: function () {
		var cb = this._displayCallback;
		return cb ? cb(this.proxy()) : this._visible;
	},
	getItems: function () {
		var items, i,
			cb = this._childrenCallback;
		if (cb) {
			items = this._load(cb(this.proxy())) || [];
		} else {
			items = this.items();
		}
		return items;
	},
    getItem: function (index) {
        return this._items[index];
    },
    getItemsByLabel: function (label) {
        return this.$_getItemsByProp("label", label);
    },
    getItemsByTag: function (tag) {
        return this.$_getItemsByProp("tag", tag);
    },
    getItemsByGroup: function(group) {
        return this.$_getItemsByProp("group", group);
    },
	isDescendant: function (menu) {
		var p = menu;
		while (p) {
			if (p == this) {
				return true;
			}
			p = p._parent;
		}
		return false;
	},
	_load: function (source) {
		var i, src, menu, item,
            items = [];
		if (source) {
			source = _makeArray(source);
			for (i = 0; i < source.length; i++) {
				src = source[i];
				if (src) {
					if (src.childrenCallback || _isArray(src.children) && src.children.length > 0) {
						menu = new PopupMenu(null, this, src.children);
						menu._label = src.label;
                        if (menu.setCallback) {
                            src.callback && menu.setCallback(src.callback);
                        }
						src.displayCallback && menu.setDisplayCallback(src.displayCallback);
						src.childrenCallback && menu.setChildrenCallback(src.childrenCallback);
						src.checkedCallback && menu.setCheckedCallback(src.checkedCallback);
						items.push(menu);
					} else {
						if (src.action) {
							item = this.$_createActionMenu(src);
						} else if (!_isEmpty(src.label)) {
							item = new PopupMenuItem(this, src);
						}
						item && items.push(item);
					}
				}
			}
		}
		return items;
	},
	_itemClicked: function (menuItem) {
        var group, i, mi;
        if (!menuItem.isSeparator()) {
            if (menuItem.parent() == this && menuItem.type() == "radio") {
                group = menuItem.group();
                if (group) {
                    for (i = 0; i < this._items.length; i++) {
                        mi = this._items[i];
                        if (mi instanceof PopupMenuItem && mi.type() == "radio" && mi.group() == group) {
                            mi.setChecked(false);
                        }
                    }
                    menuItem.setChecked(true);
                }
            }
            if (menuItem._callback) {
                menuItem._callback(menuItem.proxy());
            } else if (this._parent instanceof PopupMenuManager) {
                this._parent._doMenuItemClick(menuItem.proxy());
            } else if (this._parent.onMenuItemClick) {
                this._parent.onMenuItemClick(menuItem.proxy());
            } else {
                this._parent._itemClicked(menuItem);
            }
        }
	},
	$_createActionMenu: function (src) {
		function getLabel(action) {
			var i,
                path = action.split('.');
			for (i = 0; i < path.length; i++) {
				path[i] = _capitalize(path[i]);
			}
			return path.slice(0, path.length - 1).join('.') + ' ' + path[path.length - 1];
		}
		var attr, en, v, item, items, p, i,
            action = src.action,
		    target = src.target || this.manager().actionTarget();
		if (action && target) {
			attr = target.getAttribute(action);
			if (attr) {
				en = attr.attr.$enum;
				v = attr.attr.value;
				if (en) {
					items = [];
                    for (p in en.$DOMAIN) {
						/*
						item = new PopupMenuItem();
						item._label = _capitalize(p);
						item._type = "radio";
						item._group = en.$ENUM;
						item._checked = p == v;
						item._tag = p;
						item._callback = function (item) {
							attr.target.setProperty(attr.prop, item.tag);
						};
						*/
						item = {};
						item.label = _capitalize(p);
						item.type = "radio";
						item.group = en.$ENUM;
						item.checked = p == v;
						item.tag = p;
						item.callback = function (item) {
							attr.target.setProperty(attr.prop, item.tag);
						};
						items.push(item);
					}
					item = new PopupMenu(null, this, items);
					for (i = items.length; i--;) {
						items[i]._parent = item;
					}
				} else {
					if (typeof v === "boolean") {
						item = new PopupMenuItem(this);
						item._type = "check";
						item._checked = attr.target.getProperty(attr.prop);
						item._callback = function (item) {
							attr.target.setProperty(attr.prop, !attr.target.getProperty(attr.prop));
						};
					}
				}
				if (item) {
					item._label = src.label || getLabel(action);
				}
				return item;
			}
		}
		return null;
	},
    $_getItemsByProp: function (prop, value) {
        var i, items = null;
        for (i = 0; i < this._items.length; i++) {
            if (this._items[i].getProperty(prop) == value) {
                items = items || [];
                items.push(this._items[i]);
            }
        }
        return items;
    }
});
PopupMenu.CLICKED = "onPopupMenuClicked";
var PopupMenuView = defineClass("PopupMenuView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._containerElement = null;
		this._parentView = null;
		this._dom = new Dom(this._element = this._createElement());
        this._element.addEventListener("contextmenu", function (e) {
            e.preventDefault();
        });
        this._element.class = '$dl_popupmenu';
		this._currDiv = null;
		this._menu = null;
		this._childView = null;
		this._showing = false;
		this._timer = undefined;
		this.$_downhandler = null;
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	manager: function () {
		return this._menu.manager();
	},
	menu: function () {
		return this._menu;
	},
	show: function (containerElement, parentView, menuModel, x, y, width) {
		if (!this._showing) {
			this._showing = true;
			try {
				this._containerElement = containerElement;
				this._parentView = parentView;
				this._menu = menuModel;
				this.$_show(containerElement, this._menu, x, y, width);
			} finally {
				this._showing = false;
			}
		}
	},
	$_show: function (containerElement, menu, x, y, width) {
		var elt = this._element;
		if (!elt) {
			return;
		}
        var br, pr, cr, w, h, r, sx, sy,
            css = elt.style;
		this._menu = menu;
		css.position = "absolute";
		css.float = "none";
		css.minWidth = "60px";
		css.overflow = "hidden";
		css.zIndex = 3000;
		css.background = "rgb(247, 247, 247)";// "rgb(233, 233, 233)";
		css.border = "1px solid rgb(150, 150, 150)";//"1px solid rgb(200, 200, 200)";
		css.boxShadow = "rgba(0, 0, 0, 0.5) 2px 2px 2px";
		css.fontFamily = "Tahoma";
		css.fontStyle = "normal";
		css.fontVariant = "normal";
		css.fontWeight = "normal";
		css.fontSize = "10pt";
		css.padding = "4px 0px";
		css.margin = "0px";
		this._dom.clearChildren();
		PopupMenuView.$_buildItems(this, this._element, menu);
		Dom.disableSelection(elt);
		_doc.documentElement.appendChild(elt);
        br = _getBrowserSize();
        pr = Dom.getBounds(_doc.documentElement);
		cr = Dom.getBounds(containerElement); // grid.container;
        w = br.width;
        h = br.height;
        r = this._dom.getBounds();
        sx = window.pageXOffset || _doc.documentElement.scrollLeft;
        sy = window.pageYOffset || _doc.documentElement.scrollTop;
        if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
            h -= 18;
        }
        if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
            w -= 18;
        }
		if (!this._parentView) {
            x += cr.left - pr.left;
            y += cr.top - pr.top;
		}
        if (y + r.height >= h + sy - 3) {
            y = y - (r.height - 23) - 3;
            if (y < 0) {
                y = Math.max(0, h - r.height - 3);
            }
        }
        if (x + r.width >= w + sx - 3) {
			x = Math.max(0, w - r.width - 3);
		} else if (width !== undefined) {
			if (r.width < width) {
				x += width - r.width;
			}
		}
        this._dom.move(Math.max(0, x), Math.max(0, y));
		this.$_downhandler = _win.onmousedown;
		this.$_keyhandler = _win.onkeydown;
		_win.onmousedown = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._element || p.menuItem) {
					return;
				}
				p = p.parentNode;
			}
			this.manager().close();
		}.bind(this);
	},
	hide: function (recursive) {
		_win.onkeydown = this.$_keyhandler;
		this.$_keyhandler = null;
		_win.onmousedown = this.$_downhandler;
		this.$_downhandler = null;
		if (recursive && this._parentView) {
			this._parentView.hide(true);
		} else {
			this.$_hideChildView();
			var elt = this._element;
			if (elt && elt.parentNode) {
				_doc.documentElement.removeChild(elt);
			}
		}
	},
	_createElement: function () {
		var element = _doc.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		return element;
	},
	_showChild: function (menuDiv) {
        var menuItem, r, x, y;
		if (this != this.manager()._showingView) {
			return;
		}
		if (this._childView && this._childView._menu === menuDiv.menuItem || this._currDiv !== menuDiv) {
			return;
		}
		this.$_hideChildView();
		menuItem = menuDiv.menuItem;
		r = this._element.getBoundingClientRect();
		x = this._element.offsetLeft + r.width - 4;
		y = this._element.offsetTop + menuDiv.offsetTop;
        this._childView = PopupMenuView._borrowView();
		this._childView.show(this._containerElement, this, menuItem, x, y);
	},
	$_hideChildView: function () {
		this.manager()._showingView = null;
		if (this._childView) {
			this._childView.$_hideChildView();
			this._childView._element && _doc.documentElement.removeChild(this._childView._element);
			PopupMenuView._returnView(this._childView);
			this._childView = null;
		}
	},
	$_setSelected: function (div, selected) {
        if (div) {
            var enabled = div.menuItem.enabled();
            if (selected) {
                if (enabled) {
                    Dom.setStyles(div, {
                        background: "#555",
                        color: "#fff"
                    });
                }
            } else {
                Dom.setStyles(div, {
                    background: "",
                    color: enabled ? "#111" : "#aaa"
                });
            }
        }
	}
}, {
	$_menuId: 0,
	$_views: [],
	_borrowView: function () {
		var view = PopupMenuView.$_views.pop();
		if (!view) {
			view = new PopupMenuView();
		}
		return view;
	},
	_returnView: function (view) {
		if (view._children) {
			for (var i = 0; i < view._children.length; i++) {
				PopupMenuView.returnView(view[i]);
			}
		}
		PopupMenuView.$_views.push(view);
	},
	$_getIcon: function (type, hovered) {
		var url = _getAsset("menu_" + type + (hovered ? "_hover" : "") + ".png");
		return url;
	},
	$_buildItems: function (menuView, parent, menu) {
		var i, cnt, menuItem, css, div, hr, check, span, cb,
			items = menu.getItems(),
			n = 0;
		menuView.$_divs = [];
		for (i = 0, cnt = items.length; i < cnt; i++) {
			menuItem = items[i];
			if (!menuItem.getVisible()) continue;
			div = _doc.createElement("div");
			div.$_idx = n;
			menuView.$_divs.push(div);
			div.menuView = menuView;
			div.menuItem = menuItem;
			Dom.setStyles(div, {
				position: "relative",
				float: "none",
				width: "100%",
				paddingTop: "2px",
				paddingBottom: "2px",
				cursor: "default"
			});
			if (menuItem instanceof PopupMenuItem && menuItem.isSeparator()) {
				hr = _doc.createElement("hr");
				Dom.setStyles(hr, {
					height: "1px",
					border: "0px",
					margin: "2px",
					color: "#777",
					backgroundColor: "#777"
				});
				div.appendChild(hr);
				div.onmouseover = function (e) {
					if (div.menuView && div.menuView._childView) {
						div.menuView.$_hideChildView();
					}
				}
			} else {
				div.style.color = menuItem.enabled() ? "#111" : "#aaa";
				div.style.whiteSpace = "pre";
				div.onclick = function (e) {
					var div = e.currentTarget,
						menuItem = div.menuItem;
					if (menuItem instanceof PopupMenu) {
						if (menuItem.enabled()) {
							this._showChild(div);
						}
					} else if (menuItem) {
						this.hide(true);
						if (menuItem.enabled()) {
							menuItem.click();
						}
					} else {
						this.$_hideChildView();
					}
				}.bind(menuView);
				div.onmousedown = function (e) {
					e.stopImmediatePropagation();
					e.preventDefault && e.preventDefault();
				};
				div.onmouseover = function (e) {
					var oldDiv = this._currDiv,
                        div = this._currDiv = e.currentTarget,
						menuItem = div.menuItem,
						enabled = menuItem.enabled();
                    this.$_setSelected(oldDiv, false);
					this.$_setSelected(div, true);
					if (menuItem.checked && menuItem.checked()) {
						div.$_check.style.backgroundImage = PopupMenuView.$_getIcon(menuItem.group() ? "radio" : "check", enabled);
					} else if (menuItem instanceof PopupMenu) {
						div.$_arrow.style.backgroundImage = PopupMenuView.$_getIcon('expander', enabled);
					}
					if (menuItem instanceof PopupMenu) {
						menuView.manager()._showingView = div.menuView;
						this.timer = setTimeout(function () {
							div.menuView._showChild(div);
						}, 200);
					} else {
						if (div.menuView && div.menuView._childView) {
							div.menuView.$_hideChildView();
						}
					}
				}.bind(menuView);
				div.onmouseout = function (e) {
					var div = e.currentTarget,
						menuItem = div.menuItem;
					this.$_setSelected(div, false);
					if (menuItem.checked && menuItem.checked()) {
						div.$_check.style.backgroundImage = PopupMenuView.$_getIcon(menuItem.group() ? "radio" : "check");
					} else if (menuItem instanceof PopupMenu) {
						div.$_arrow.style.backgroundImage = PopupMenuView.$_getIcon('expander');
					}
				}.bind(menuView);
				check = _doc.createElement("span");
				Dom.setStyles(check, {
					display: "inline-block",
					width: "20px",
					minHeight: "7px",
					verticalAlign: "middle"
				});
				check.innerHTML = "";
				cb = menuItem._checkedCallback;
				if (cb ? cb(menuItem.proxy()) : (menuItem.checked && menuItem.checked())) {
					Dom.setStyles(check, {
						backgroundImage: PopupMenuView.$_getIcon(menuItem.group() ? "radio" : "check"),
						backgroundRepeat: "no-repeat",
						backgroundPosition: "center center"
					});
				}
				check.tabIndex = -1;
				Dom.disableSelection(check);
				div.appendChild(check);
				div.$_check = check;
				span = _doc.createElement("span");
				span.id = "$popupMenu_item_" + PopupMenuView.$_menuId++;
                span.style.fontFamily = "Tahoma";
                span.style.fontStyle = "normal";
                span.style.fontVariant = "normal";
                span.style.fontWeight = "normal";
                span.style.fontSize = "10pt";
                span.style.paddingRight = "24px";
				span.innerHTML = menuItem.label();
				span.tabIndex = -1;
				Dom.disableSelection(span);
				div.appendChild(span);
				if (menuItem instanceof PopupMenu) {
					var arrow = _doc.createElement("span");
					Dom.setStyles(arrow, {
						position: "absolute",
						right: "0px",
						width: "24px",
						height: (13 + 2 + 2) + "px", // 13: 10pt
						backgroundImage: PopupMenuView.$_getIcon("expander"),
						backgroundRepeat: "no-repeat",
						backgroundPosition: "center center"
					});
					check.style.verticalAlign = "middle";
					arrow.innerHTML = " ";
					arrow.tabIndex = -1;
					Dom.disableSelection(arrow);
					div.appendChild(arrow);
					div.$_arrow = arrow;
				}
			}
			Dom.disableSelection(div);
			parent.appendChild(div);
			n++;
		}
		menuView.$_cnt = n;
	}
});
var PopupMenuManager = defineClass("PopupMenuManager", EventAware, {
	init: function (visualContainer, actionTarget) {
		this._super();
		this._container = visualContainer;
		this._actionTarget = actionTarget;
		this._menus = {};
		this._mainView = null;
		this._showingView = null;
        this.$_keyhandler = null;
	},
	actionTarget: null,
	showing: function () {
		if (this._mainView) {
			var elt = this._mainView._element;
			return _doc.documentElement.contains(elt);
		}
	},
	getMenu: function (name) {
		if (name) {
			return this._menus[name];
		}
		return undefined;
	},
	addMenu: function (name, menuItems, overwrite) {
		if (!_isWhiteSpace(name)) {
            var menu = this._menus[name];
            if (!menu || overwrite) {
                if (menuItems instanceof PopupMenu) {
					menu._parent = this;
                    menu = menuItems;
                } else {
                    menu = new PopupMenu(name, this, menuItems);
                }
                this._menus[name] = menu;
            }
            return menu;
        }
        return null;
	},
	removeMenu: function (name) {
		if (name) {
			delete this._menus[name];
		}
	},
	clearMenus: function () {
		this._menus = {};
	},
	show: function (menu, targetView, offsetX, offsetY, cancelCallback) {
		if (!this._mainView) {
			if (menu = this.$_getMenu(menu)) {
				var r = targetView.boundsByContainer();
				offsetX = isNaN(offsetX) ? 0 : offsetX;
				offsetY = isNaN(offsetY) ? 0 : offsetY;
				this._mainView = PopupMenuView._borrowView();
				this._mainView.show(this._container._container, null, menu, r.x + offsetX, r.bottom() + offsetY, r.width);
			}
		}
        if (this._mainView) {
			if (cancelCallback) this._cancelCallback = cancelCallback;
            this.$_addKeyHandler();
        }
	},
	showAt: function (menu, x, y, width, cancelCallback) {
		if (!this._mainView) {
			if (menu = this.$_getMenu(menu)) {
				this._mainView = PopupMenuView._borrowView();
				this._mainView.show(this._container._container, null, menu, x, y, width);
			}
		}
        if (this._mainView) {
			if (cancelCallback) this._cancelCallback = cancelCallback;
            this.$_addKeyHandler();
        }
	},
    showContext: function (menu, x, y) {
        if (menu && !this._mainView) {
            this._mainView = PopupMenuView._borrowView();
            this._mainView.show(this._container._container, null, menu, x, y, 0);
        }
        if (this._mainView) {
            this.$_addKeyHandler();
        }
    },
	close: function () {
		if (this._mainView) {
            this.$_removeKeyHandler();
			this._mainView.hide();
			PopupMenuView._returnView(this._mainView);
			this._mainView = null;
			return true;
		}
	},
	$_getMenu: function (menu) {
		if (typeof menu === "string") {
			return this.getMenu(menu);
		} else 	if (!(menu instanceof PopupMenu)) {
			return new PopupMenu(null, this, menu);
		}
		return menu;
	},
	_doMenuItemClick: function (menuItem) {
		this.fireEvent(PopupMenuManager.MENU_ITEM_CLICKED, menuItem);
	},
    $_findActiveView: function () {
        var v = this._mainView._childView;
        while (v) {
            if (v._childView) {
                v = v._childView;
            }
            return v;
        }
    },
    $_isEnabledItem: function (div) {
        if (div) {
            var item = div.menuItem;
            return item && item.enabled() && (!item.isSeparator || !item.isSeparator());
        }
    },
    $_isPopupMenu: function (div) {
        return div && div.menuItem && div.menuItem.enabled() && div.menuItem instanceof PopupMenu;
    },
    $_findNextItem: function (view) {
        var div = view._currDiv,
            idx = div ? div.$_idx : -1,
            cnt = view.$_cnt;
        idx = Math.max(0, idx + 1);
        while (idx < cnt) {
            div = view.$_divs[idx];
            if (this.$_isEnabledItem(div)) {
                return div;
            }
            idx++;
        }
		div = view.$_divs[0];
        return this.$_isEnabledItem(div) ? div : view._currDiv;
    },
    $_findPrevItem: function (view) {
        var div = view._currDiv,
            idx = div ? div.$_idx : -1,
            cnt = view.$_cnt;
        idx = Math.max(0, idx - 1);
        while (idx >= 0) {
            div = view.$_divs[idx];
            if (this.$_isEnabledItem(div)) {
                return div;
            }
            idx++;
        }
		div = view.$_divs[cnt - 1];
		return this.$_isEnabledItem(div) ? div : view._currDiv;
    },
    $_addKeyHandler: function () {
        _win.onkeydown = function (e) {
            var newDiv,
                k = e.keyCode,
                view = this.$_findActiveView() || this._mainView,
                div = view._currDiv,
                cnt = view.$_cnt;
            if (cnt > 0) {
                switch (k) {
					case Keys.ESC:
						this.close();
						this._cancelCallback && this._cancelCallback();
						break;
                    case Keys.ENTER:
                        if (div) {
                            this.close();
                            div.menuItem.click();
                        }
                        break;
                    case Keys.DOWN:
                        newDiv = this.$_findNextItem(view);
                        break;
                    case Keys.UP:
                        newDiv = this.$_findPrevItem(view);
                        break;
                    case Keys.RIGHT:
                        if (this.$_isPopupMenu(div)) {
                            this._showingView = view;
                            view._showChild(div, true);
                        }
                        break;
                    case Keys.LEFT:
                        if (div) {
                            view._parentView && view._parentView.$_hideChildView();
                        }
                        break;
                }
                if (newDiv && newDiv != div) {
                    view.$_setSelected(div, false);
                    view._currDiv = newDiv;
                    view.$_setSelected(newDiv, true);
                }
                _stopEvent(e);
                return true;
            }
        }.bind(this);
    },
    $_removeKeyHandler: function () {
        _win.onkeydown = null;
    }
});
PopupMenuManager.MENU_ITEM_CLICKED = "onPopupMenuManagerMenuItemClicked";
var Progress = defineClass("Progress", EventAware, {
    init: function () {
        this._super();
        this._view = new ProgressView();
        this._runner = null;
        this._next = 0;
        this._completed = false;
        this._timer = undefined;
    },
    min: 0,
    max: 100,
    step: 1,
    execute: function (runner) {
        if (runner) {
            this._runner = runner;
            this._next = this._min;
            if (runner.container instanceof HTMLElement) {
                this._view.setProperties(this._min, this._max, this._min);
                this._view.show(runner.container);
            }
            this.$_runNext();
        }
    },
    $_runNext: function () {
        if (this._next < this._max) {
            var msg = this._runner.run(this._next);
            this._next += this._step;
            this._view.setPosition(this._next, msg);
            _console && _trace("P R O G R E S S : " + this._min + " > " + this._next + " > " + this._max);
            if (this._next < this._max) {
                setTimeout(function () {
                    this.$_runNext();
                }.bind(this), 0)
                return;
            }
        }
        !this.$_completed && this.$_complete();
    },
    $_complete: function () {
        try {
            this._runner.complete && this._runner.complete();
        } finally {
            _console && _trace("P R O G R E S S : " + "completed : " + +this._min + " > " + this._next + " > " + this._max);
            this.$_completed = true;
            this._view.close();
        }
    }
});
var ProgressView = defineClass("ProgressView", null, {
    init: function () {
        this._super();
        this._container = null;
        this._dom = new Dom(this.$_createElement());
        this._mask = new Dom(this.$_createMask());
        this._canceler = undefined;
        this._min = 0;
        this._max = 0;
        this._pos = 0;
    },
    title: "Load Data",
    message: "...",
    position: function () {
        return this._pos;
    },
    setPosition: function (value, message) {
        value = Math.max(this._min, Math.min(this._max, value));
        if (value != this._pos) {
            this._pos = value;
            this._message = message;
            this.$_refreshView();
        }
    },
    visible: function () {
        return this._dom.attached();
    },
    setProperties: function (min, max, pos, message, refresh) {
        this._min = min;
        this._max = Math.max(min, max);
        if (this._max == this._min) this._max = this._min + 1;
        this._pos = Math.max(this._min, Math.min(this._max, pos));
        this._message = message;
        refresh && this.$_refreshView();
    },
    show: function (container, title, modal, canceler) {
        var r, sz,
            dom = this._dom,
            elt = dom.element(),
            c = elt.$_cancel;
        this._container = container;
        this._canceler = _asFunction(canceler);
        title && this.$_setTitle(title);
        c.style.display = this._canceler ? "block" : "none";
        c.style.color = "#400";
        modal && container.appendChild(this._mask.element());
        container.appendChild(elt);
        r = container.getBoundingClientRect();
        sz = dom.size();
        dom.move((r.width - sz.width) / 2, (r.height - sz.height) / 3);
    },
    close: function () {
        this._dom.detach();
        this._mask.detach() && this._container instanceof UIComponent && this._container.setFocus();
    },
    $_createElement: function () {
        var div = Dom.createElement("div", {
            position: "absolute",
            zIndex: 3001,
            minWidth: "250px",
            padding: "4px 10px 12px 8px",
            backgroundColor: "rgba(245, 250, 255, 0.92)",// "rgba(0, 111, 245, 0.05)",
            border: "1px solid #113",
            borderRadius: "4px",
            fontFamily: "Trebuchet MS, Helvetica, sans-serif",
            color: "#111"
        });
        div.appendChild(div.$_title = this.$_createTitle());
        div.appendChild(div.$_bar = this.$_createBar());
        div.appendChild(div.$_msg = this.$_createMsg());
        div.appendChild(div.$_cancel = this.$_createCancel());
        return div;
    },
    $_createMask: function () {
        var div = Dom.createElement("div", {
            position: "absolute",
            zIndex: 3000,
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            border: "none",
            width: "100%",
            height: "100%"
        });
        return div;
    },
    $_createTitle: function () {
        var div = Dom.createElement("div", {
            width: "100%",
            minHeight: "15px",
            marginBottom: "10px"
        });
        var span = Dom.createElement("span", {
            color: "#321",
            fontSize: "15px",
        });
        span.innerHTML = this._title;
        div.appendChild(div.$_span = span);
        return div;
    },
    $_createBar: function () {
        var div = Dom.createElement("div", {
            width: "100%",
            height: "9px",
            background: "#ddd", //"linear-gradient(#aaa, #ccc)",
            border: "1px solid #555"//,
        });
        var led = Dom.createElement("div", {
            height: "100%",
            width: "0px",
            background: "#fff",// "linear-gradient(#fff, #ddd)",
            borderRight: "none"// "1px solid #555"
        });
        div.appendChild(led);
        div.$_led = led;
        return div;
    },
    $_createMsg: function () {
        var div = Dom.createElement("div", {
            width: "100%",
            textAlign: "center"
        });
        var span = Dom.createElement("span", {
            fontSize: "13px",
            color: "#000"
        });
        div.appendChild(div.$_span = span);
        span.innerHTML = this._message;
        return div;
    },
    $_createCancel: function () {
        var div = Dom.createElement("div", {
            float: "right",
            textAlign: "right",
            fontSize: "13px",
            fontWeight: "bold",
            fontStyle: "italic",
            textDecoration: "underline",
            color: "#400"
        })
        div.innerHTML = Locale._default.progressCancel || "Cancel";
        div.style.cursor = "pointer";
        div.onmouseover = function (e) {
            e.target.style.color = "#d00";
        };
        div.onmouseout = function (e) {
            e.target.style.color = "#400";
        };
        div.onclick = function () {
            if (this._canceler && this._canceler() === true) {
                this.close();
            }
        }.bind(this);
        return div;
    },
    $_refreshView: function () {
        var elt = this._dom.element();
        var bar = elt.$_bar;
        var led = bar.$_led;
        var msg = elt.$_msg.$_span;
        msg.innerHTML = Dom.htmlEncode(this._message);
        led.style.borderRight = (this._pos > this._min && this._pos < this._max) ? "1px solid #555" : "none";
        var r = Dom.getSize(bar);
        led.style.width = Math.min(r.width - 1, _int(r.width * (this._pos - this._min) / (this._max - this._min))) + "px";
    },
    $_setMessage: function (s) {
        var msg = this._dom.element().$_msg.$_span;
        msg.innerHTML = Dom.htmlEncode(this._message);
    },
    $_setTitle: function (s) {
        var title = this._dom.element().$_title.$_span;
        this.setTitle(s);
        title.innerHTML = Dom.htmlEncode(this._title);
    }
});
var ProgressManager = defineClass("ProgressManager", null, {
    init: function (container) {
        this._super();
        this._container = container;
        this._title = null;
        this._view = null;
    },
    show: function (container, title, modal, canceler) {
        if (!this._view) {
            this._view = new ProgressView();
        }
        this._view.show(container || this._container, _pickStr(title, "Load data"), modal, canceler);
    },
    close: function () {
        this._view && this._view.close();
    },
    setProperties: function (min, max, pos, message) {
        message = message || ProgressManager.getMessage(min, max, pos);
        this._view && this._view.setProperties(min, max, pos, message, true);
    }
}, {
    getMessage: function (min, max, pos) {
        var fmt = DecimalFormatter.getFormatter('#,##0');
        var message = "";
        if (max > min) {
            message += "" + fmt.format(pos) + " / " + fmt.format(max) + " (" + parseInt((pos - min) * 100 / (max - min)) + "%)";
        }
        return message;
    }
});
var TextAlign = _enum('TextAlign', {
	LEFT : "left",
	CENTER : "center",
	RIGHT : "right"
});
var TextLayout = _enum('TextLayout', {
	TOP : "top",
	MIDDLE : "middle",
	BOTTOM : "bottom"
});
var Rectangle = function(x, y, width, height) {
	if (typeof x === "undefined" || x === null) {
		this.x = this.y = this.width = this.height = 0;
	} else {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}
};
Rectangle.prototype = {
	constructor: Rectangle,
	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},
	getInner: function () {
		return new Rectangle(0, 0, this.width, this.height);
	},
	equals: function(r) {
		return r === this
			|| r && this.x === r.x && this.y === r.y && this.width === r.width && this.height === r.height;
	},
	toString: function() {
		return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
	},
	left: function () {
		return this.x;
	},
	setLeft: function (value) {
		var dx = value - this.x;
		this.x += dx;
		this.width -= dx;
		return this;
	},
	leftBy: function(delta) {
		this.x += delta;
		this.width -= delta;
		return this;
	},
	right: function () {
		return this.x + this.width;
	},
	setRight: function (value) {
		var dx = value - (this.x + this.width);
		this.width += dx;
		return this;
	},
	rightBy: function(delta) {
		this.width += delta;
		return this;
	},
	top: function () {
		return this.y;
	},
	setTop: function (value) {
		var dy = value - this.y;
		this.y += dy;
		this.height -= dy;
		return this;
	},
	topBy: function(delta) {
		this.y += delta;
		this.height -= delta;
		return this;
	},
	bottom: function () {
		return this.y + this.height;
	},
	setBottom: function (value) {
		var dy = value - (this.y + this.height);
		this.height += dy;
		return this;
	},
	bottomBy: function(delta) {
		this.height += delta;
		return this;
	},
    setSize: function (w, h) {
        this.width = w;
        this.height = h;
    },
	shrink: function (dx, dy) {
		this.width -= dx;
		this.height -= dy;
		return this;
	},
	expand: function (dx, dy) {
		this.width += dx;
		this.height += dy;
		return this;
	},
	contains: function(x, y) {
		return x >= this.x && x <= this.x + this.width
			&& y >= this.y && y <= this.y + this.height;
	},
	isEmpty: function() {
		return this.width <= 0 || this.height <= 0;
	},
	setEmpty: function() {
		this.width = this.height = 0;
		return this;
	},
	"set": function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},
    setBy: function (dx, dy, dw, dh) {
        this.x += dx;
        this.y += dy;
        this.width += dw;
        this.height += dh;
        return this;
    },
	copy: function (r) {
		this.x = r.x;
		this.y = r.y;
		this.width = r.width;
		this.height = r.height;
		return this;
	},
	copyHorz: function (r) {
		this.x = r.x;
		this.width = r.width;
		return this;
	},
	copyVert: function (r) {
		this.y = r.y;
		this.height = r.height;
		return this;
	},
	inflate: function(left, top, right, bottom) {
		top = arguments.length > 1 ? top : 0;
		right = arguments.length > 2 ? right : left;
		bottom = arguments.length > 3 ? bottom : top;
		if (left) this.setLeft(this.x - left);
		if (top) this.setTop(this.y - top);
		if (right) this.setRight(this.right() + right);
		if (bottom) this.setBottom(this.bottom() + bottom);
		return this;
	},
	offset: function (dx, dy) {
		this.x += dx;
		this.y += dy;
		return this;
	},
	round : function() {
		var r = this.clone();
		r.x >>>= 0;
		r.y >>>= 0;
		r.width >>>= 0;
		r.height >>>= 0;
		return r;
	},
	union: function (r) {
		var r2 = this.clone();
		r2.setLeft(Math.min(this.x, r.x));
		r2.setRight(Math.max(this.right(), r.right()));
		r2.setTop(Math.min(this.y, r.y));
		r2.setBottom(Math.max(this.bottom(), r.bottom()));
		return r2;
	},
	normalize: function () {
		if (this.width < 0) {
			this.x -= this.width;
			this.width *= -1;
		}
		if (this.height < 0) {
			this.y -= this.height;
			this.height *= -1;
		}
		return this;
	}
};
var Size = function (width, height) {
	if (arguments.length == 0) {
		this.width = this.height = 0;
	} else {
		this.width = width;
		this.height = height;
	}
};
Size.EMPTY = new Size();
Size.empty = function () {
	return new Size();
};
Size.create = function (w, h) {
	return new Size(w, h);
};
Size.prototype = {
	constructor: Size,
	clone: function() {
		return new Size(this.width, this.height);
	},
	equals: function(sz) {
		return sz === this
			|| sz && this.width === sz.width && this.height === sz.height;
	},
	toString: function() {
		return "{width: " + this.width + ", height: " + this.height + "}";
	},
	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},
	setEmpty: function() {
		this.width = this.height = 0;
		return this;
	},
	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},
	round : function() {
		var sz = this.clone();
		sz.width >>>= 0;
		sz.height >>>= 0;
		return sz;
	}
};
var Point = function (x, y) {
	if (arguments.length == 0) {
		this.x = this.y = 0;
	} else {
		this.x = x;
		this.y = y;
	}
};
Point.EMPTY = new Point();
Point.empty = function () {
	return new Point();
};
Point.create = function (w, h) {
	return new Point(w, h);
};
Point.prototype = {
	constructor: Size,
	clone: function() {
		return new Point(this.x, this.y);
	},
	equals: function(pt) {
		return pt === this
			|| pt && this.width === pt.width && this.height === pt.height;
	},
	toString: function() {
		return "{x: " + this.x + ", y: " + this.y + "}";
	},
	isEmpty: function() {
		return this.x === 0 || this.y === 0;
	},
	setEmpty: function() {
		this.x = this.y = 0;
		return this;
	},
	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},
	round : function() {
		var pt = this.clone();
		pt.x >>>= 0;
		pt.y >>>= 0;
		return pt;
	}
};
var SideRectangles = function () {
	this.left = new Rectangle();
	this.right = new Rectangle();
	this.top = new Rectangle();
	this.bottom = new Rectangle();
};
SideRectangles.prototype = {
	constructor: SideRectangles,
	clear: function () {
		this.left.setEmpty();
		this.right.setEmpty();
		this.top.setEmpty();
		this.bottom.setEmpty();
	},
	setLeft: function (x, y, w, h) {
		this.left.set(x, y, w, h);
	},
	setRight: function (x, y, w, h) {
		this.right.set(x, y, w, h);
	},
	setTop: function (x, y, w, h) {
		this.top.set(x, y, w, h);
	},
	setBottom: function (x, y, w, h) {
		this.bottom.set(x, y, w, h);
	}
};
var RelativeSize = function (size, fixed) {
	this._size = size;
	this._fixed = fixed;
};
RelativeSize.prototype = {
	constructor: RelativeSize,
	clone: function () {
		return new RelativeSize(this._size, this._fixed);
	},
	getSize: function (targetSize) {
		return this._fixed ? this._size : targetSize * this._size;
	}
};
RelativeSize.Empty = new RelativeSize(0, false);
RelativeSize.createFrom = function (value) {
	var v = 0;
	var f = false;
	if (value) {
		var s = String(value).trim();
		var len = s.length;
		if (len > 0) {
			if (len > 2 && s.lastIndexOf("px") == len - 2) {
				f = true;
				s = s.substr(0, len - 3);
			}
			if (s) {
				v = parseFloat(s);	
			}
		}
	}
	return new RelativeSize(v, f);
};
RelativeSize.equals = function (v1, v2) {
	return v1 instanceof RelativeSize && v2 instanceof RelativeSize && v1._size === v2.size && v1._precentage === v2._precentage;
};
var PercentSize = function (size, fixed) {
	this._size = size;
	this._fixed = fixed;
};
PercentSize.prototype = {
	constructor: PercentSize,
	clone: function () {
		return new PercentSize(this._size, this._fixed);
	},
    size: function () {
        return this._size;
    },
	getSize: function (orgSize, denominator) {
		return this._fixed ? this._size : orgSize * this._size / (denominator || 100.0);
	}
};
PercentSize.Empty = new PercentSize(0, true);
PercentSize.createFrom = function (value) {
    if (value === undefined) {
        return value;
    } else if (typeof value === "number") {
        return new PercentSize(value, true);
    } else if (value) {
        var s = String(value).trim();
        var len = s.length;
        if (len > 0) {
            var v = 0;
            var f = true;
            if (len > 1 && s.lastIndexOf("%") == len - 1) {
                f = false;
                s = s.substr(0, len - 1).trim();
            }
            if (s) {
                v = parseFloat(s);
            }
            return new PercentSize(v, f);
        }
    }
    return null;
};
PercentSize.equals = function (v1, v2) {
	return v1 instanceof PercentSize && v2 instanceof PercentSize && v1._size === v2.size && v1._fixed === v2._fixed;
};
PercentSize.getFixed = function (size) {
	return size instanceof PercentSize && size._fixed ? size._size : 0;
};
PercentSize.getFixedI = function (size) {
	return size instanceof PercentSize && size._fixed ? _int(size._size) : 0;
};
var SizeF = function (width, height) {
	this.width = width;
	this.height = height;
};
SizeF.prototype = {
	constructor: SizeF,
	clone: function () {
		return new SizeF(this.width, this.height);
	},
	set: function (width, height) {
		this.width = parseFloat(width);
		this.height = parseFloat(height);
	}
};
SizeF.createFrom = function (value) {
	var w = 0, h = 0;
	if (value) {
		var arr = String(value).split(",");
		if (arr.length > 0 ) {
			w = h = parseFloat(arr[0]);
		}
		if (arr.length > 1) {
			h = parseFloat(arr[1]);
		}
	}
	return new SizeF(w, h);
};
var Color = function (v, strict) {
	if (typeof v === "string") {
		Color._parse(v, this, strict, false, false);// true);
	} else if (v instanceof Color) {
		this._r = v._r;
		this._g = v._g;
		this._b = v._b;
		this._a = v._a;
	} else if (!isNaN(v)) {
		this._a = (v >>> 24) / 255;
		this._r = (v & 0x00ff0000) >> 16;
		this._g = (v & 0x0000ff00) >> 8;
		this._b = v & 0x000000ff;
	} else {
		this._r = this._g = this._b = 0;
		this._a = strict ? NaN : 1;
	}
};
var ColorProto = Color.prototype;
Color._ERROR = new Color(UNDEFINED, true);
Color._ERROR.error = true;
Color.createFrom = function (s, strict, noInt) {
	var colorObj = Color._parse(s, $_tempColor, strict, noInt, false);
	if (colorObj) {
		return (typeof colorObj === "object") ? colorObj : $_tempColor.clone();
	} else {
		return null;
	}
};
Color.createWithArgb = function (a, r, g, b) {
    var c = new Color();
    c._a = a;
    c._r = r;
    c._g = g;
    c._b = b;
    return c;
};
Color._parse = function (val, col, strict, noInt, throwError) {
	var s = String(val);
	if (s) {
        var len = s.length;
        var v;
		s = s.trim().toLowerCase();
		if (s.charAt(0) == "#") {
			s = s.substr(1);
			len--;
			if (len >= 6 && len <= 8) {
				col._b = toInt(s.substr(len - 2, 2), 16);
				col._g = toInt(s.substr(len - 4, 2), 16);
				col._r = toInt(s.substr(len - 6, 2), 16);
				col._a = (len == 6) ? (strict ? NaN : 1) : (toInt(s.substr(0, len - 6), 16) / 255.0);
			} else if (len == 3) {
				col._r = toInt(s.charAt(0) + s.charAt(0), 16);
				col._g = toInt(s.charAt(1) + s.charAt(1), 16);
				col._b = toInt(s.charAt(2) + s.charAt(2), 16);
				col._a = strict ? NaN : 1;
			} else if (throwError) {
				throw new Error(Locale._default.invalidColorText + ": " + val);
			} else {
                col._r = col._g = col._b = 0;
                col._a = strict ? 0 : 1;
				return false;
			}
		} else if (s.indexOf("rgba(") == 0 && s.charAt(len - 1) == ")") {
			s = s.substring(5, len - 1);
			v = s.split(",");
			col._r = toInt(v[0]);
			col._g = toInt(v[1]);
			col._b = toInt(v[2]);
			col._a = v[3];
		} else if (s.indexOf("rgb(") == 0 && s.charAt(len - 1) == ")") {
			s = s.substring(4, len - 1);
			v = s.split(",");
			col._r = toInt(v[0]);
			col._g = toInt(v[1]);
			col._b = toInt(v[2]);
			col._a = strict ? NaN : 1;
		} else if (strict && StrictColors.hasOwnProperty(s)) {
			return StrictColors[s];
		} else if (!strict && Colors.hasOwnProperty(s)) {
			return Colors[s];
		} else {
            if (!noInt) {
                v = parseInt(s);
                if (!isNaN(v)) {
                    col._a = (val >>> 24) / 255;
                    col._r = (val & 0x00ff0000) >> 16;
                    col._g = (val & 0x0000ff00) >> 8;
                    col._b = val & 0x000000ff;
                    return true;
                }
            }
			if (throwError) {
                throw new Error(Locale._default.invalidColorText + ": " + val);
			}
			col._a = col._r = col._g = col._b = 0;
			return false;
		}
		return true;
	}
	return false;
};
Color.getColorStringArray = function (value) {
	return value.trim().split(/\s+|(rgba\(.*\))|(rgb\(.*\))|(pal\(.*\))/).filter(Boolean);
};
Color.getColorCsvArray = function (value) {
	return value.trim().split(/\s*,\s*|\s+|(rgba\(.*\))|(rgb\(.*\))|(pal\(.*\))/).filter(Boolean);
};
Color.getColorStopCsvArray = function (value) {
	return value.trim().split(/\s*,\s*|\s+|(rgba\(.*\))|(rgb\(.*\))|(pal\(.*\))|(stops\(.*\))/).filter(Boolean);
};
ColorProto.clone = function () {
	return new Color(this);
};
ColorProto.copy = function (source, alpha) {
	if (source) {
		this._r = source._r;
		this._g = source._g;
		this._b = source._b;
		this._a = isNaN(source._a) ? Number(alpha) : source._a;
	} else {
		this._a = Number(alpha);
	}
	return this;
};
var $$_addBrightness = function (color, brightness, rgb, target) {
    var r = color._r,
        g = color._g,
        b = color._b,
        br = Number(brightness);
    if (!isNaN(br) && br != 1) {
        r = _floor(Math.max(0, Math.min(0xff, r * br)));
        g = _floor(Math.max(0, Math.min(0xff, g * br)));
        b = _floor(Math.max(0, Math.min(0xff, b * br)));
        if (r == 0xff && color._r < 0xff) {
            r = _floor((0xff + color._r) / 2);
        }
        if (g == 0xff && color._g < 0xff) {
            g = _floor((0xff + color._g) / 2);
        }
        if (b == 0xff && color._b < 0xff) {
            b = _floor((0xff + color._b) / 2);
        }
    }
    if (rgb) {
        return "rgba(" + c.r + "," + c.g + "," + c.b + "," + color._a + ")";
    } else {
        target = target || new Color();
        target._r = r;
        target._g = g;
        target._b = b;
        return target;
    }
};
ColorProto.a = function () {
    return this._a;
};
ColorProto.r = function () {
    return this._r;
};
ColorProto.g = function () {
    return this._g;
};
ColorProto.b = function () {
    return this._b;
};
ColorProto.value = function () {
	return "rgba(" + this._r + "," + this._g + "," + this._b + "," + this._a + ")";
};
ColorProto.valueWithBrightness = function (brightness) {
    return $$_addBrightness(this, brightness, true);
};
ColorProto.argb = function () {
	return (_floor(this._a * 255) * (1 << 24)) + (this._r << 16) + (this._g << 8) + this._b;
};
ColorProto.rgb = function () {
	return (this._r << 16) | (this._g << 8) | this._b;
};
/*
 ColorProto.set = function (a, r, g, b) {
	this._a = a;
	this._r = r;
	this._g = g;
	this._b = b;
};
 ColorProto.setRgb = function (a, r, g, b) {
	this._a = 1.0;
	this._r = r;
	this._g = g;
	this._b = b;
};
 ColorProto.setValue = function (color, alpha) {
	this._r = (color & 0x00ff0000) >> 16;
	this._g = (color & 0x0000ff00) >> 8;
	this._b = color & 0x000000ff;
	this._a = alpha;
};
*/
ColorProto.extractAlpha = function () {
	var alpha = this._a;
	this._a = NaN;
	return alpha;
};
ColorProto.forceAlpha = function (a) {
    if (isNaN(this._a)) this._a = a;
    return this;
};
ColorProto.toHex = function () {
	return "" + hex(_floor(this._a * 255)) + hex(this._r) + hex(this._g) + hex(this._b);
};
ColorProto.toColorHex = function () {
	return "" + hex(this._r) + hex(this._g) + hex(this._b);
};
ColorProto.toString = function () {
	return "#" + hex(_floor(this._a * 255)) + hex(this._r) + hex(this._g) + hex(this._b);
};
ColorProto.toColorString = function () {
	return "#" + hex(this._r) + hex(this._g) + hex(this._b);
};
ColorProto.css = _norgba ? function () {
	return "#" + hex(this._r) + hex(this._g) + hex(this._b);
} : function () {
	return "rgba(" + this._r + "," + this._g + "," + this._b + "," + this._a + ")";
};
ColorProto.svg = _norgba ? function (target) {
    target.style.fill = "#" + hex(this._r) + hex(this._g) + hex(this._b);
} : function (target) {
    target.style.fill = "rgba(" + this._r + "," + this._g + "," + this._b + "," + this._a + ")";
};
Color.areEqual = function (c1, c2) {
	return c1 && c2 && c1._r == c2._r && c1._g == c2._g && c1._b == c2._b && c1._a == c2._a;
};
var $_tempColor = new Color();
var $_tempColors = [new Color(), new Color()];
var Colors = {
	transparent: new Color(0),
	aqua: new Color(0xff00ffff),
	black: new Color(0xff000000),
	blue: new Color(0xff0000ff),
	fuchsia: new Color(0xffff00ff),
	gray: new Color(0xff808080),
	green: new Color(0xff008000),
	lime: new Color(0xff00ff00),
	maroon: new Color(0xff800000),
	navy: new Color(0xff000080),
	olive: new Color(0xff808000),
	orange: new Color(0xffffa500),
	purple: new Color(0xff800080),
	red: new Color(0xffff0000),
	silver: new Color(0xffc0c0c0),
	teal: new Color(0xff008080),
	white: new Color(0xffffffff),
	yellow: new Color(0xffffff00),
	dimGray: new Color(0xff696969),
	ltGray: new Color(0xffd3d3d3),
    silver: new Color(0xffc0c0c0),
    darkGray: new Color(0xffa9a9a9)
};
var StrictColors = {
	transparent: new Color("#00000000"),
	aqua: new Color("#00ffff", true),
	black: new Color("#000000", true),
	blue: new Color("#0000ff", true),
	fuchsia: new Color("#ff00ff", true),
	gray: new Color("#808080", true),
	green: new Color("#008000", true),
	lime: new Color("#00ff00", true),
	maroon: new Color("#800000", true),
	navy: new Color("#000080", true),
	olive: new Color("#808000", true),
	orange: new Color("#ffa500", true),
	purple: new Color("#800080", true),
	red: new Color("#ff0000", true),
	silver: new Color("#c0c0c0", true),
	teal: new Color("#008080", true),
	white: new Color("#ffffff", true),
	yellow: new Color("#ffff00", true),
	dimGray: new Color("#696969", true),
	ltGray: new Color("#d3d3d3", true),
    silver: new Color("#c0c0c0", true),
    darkGray: new Color("#a9a9a9", true)
};
var SolidBrush = function (color) {
	this._color = new Color(color);
};
_extend(SolidBrush.prototype, {
	color: function () {
		return this._color;
	},
	alpha: function () {
		return this._color._a;
	},
	opaque: function () {
		return this._color._a >= 1;
	},
	applyTo: function (g) {
		g.setFill(this._color.value());
		return true;
	},
	toText: function () {
		return this._color.toString();
	},
	toColorText: function () {
		return this._color.toColorString();
	},
	css: _norgba ? function () {
        if (!this._css) {
            this._css = this._color.toColorString();
        }
        return this._css;
	} : function () {
        if (!this._css) {
            this._css = this._color.value();
        }
        return this._css;
	},
	applyToCss: function (css) {
		if (this._color._a < 1) {
			var c = this._color.toString();
			c = "progid:DXImageTransform.Microsoft.gradient(startColorstr=" + c + ",endColorstr=" + c + ")";
			css.filter = c;
			css.background = "";
		} else {
			css.filter = "";
			css.background = this._color.toColorString();
		}
	},
	svg: _norgba ? function (target) {
		target.style.fill = this._color.toColorString();
	} : function (target) {
		target.style.fill = this._color.value();
	}
});
var $SB = SolidBrush;
_extend($SB, {
	WHITE: new $SB(Colors.white),
	BLACK: new $SB(Colors.black),
	GRAY: new $SB(Colors.gray),
	DIMGRAY: new $SB(Colors.dimGray),
	LTGRAY: new $SB(Colors.ltGray),
	SILVER: new $SB(Colors.silver),
	DKGRAY: new $SB(Colors.darkGray),
	RED: new $SB(Colors.red),
	YELLOW: new $SB(Colors.yellow),
	GREEN: new $SB(Colors.green),
	BLUE: new $SB(Colors.blue),
	SCROLL: new $SB(0xfff0f0f0),
	SCROLLINDENT: new $SB(0xfff8f8f8),
	NULL: {
		applyTo: function (g, x, y, w, h) {
			g.setFill("rgba(0, 0, 0, 0)");
			return true;
		}
	},
	areEqual: function (b1, b2) {
		if (b1 === b2) return true;
		if (b1 && b2) {
			return Color.areEqual(b1._color, b2._color);
		}
		return !b1 == !b2;
	}
});
$SB.Null = $SB.NULL;
var FillGradient = defineClass("FillGradient", null, {
	init: function (source) {
		this._super();
		var s = /*this._source =*/ source ? source.trim().toLowerCase() : null;
		this.parse(s);
	},
	parse: function (source) {
	},
    proxy: function () {
        return this; // this._source;
    }
});
FillGradient.createFrom = function (value) {
	if (value) {
		var s = value.trim().toLowerCase();
		if (s.indexOf("linear") == 0) {
			return new LinearGradient(s);
		} else if (s.indexOf("radial") == 0) {
			return new RadialGradient(s);
		} else if (s.indexOf("glass") == 0) {
			return new GlassGradient(s);
		}
	}
	return null;
};
var LinearGradient = defineClass("LinearGradient", FillGradient, {
	init: function (source) {
		this._super(source);
		this._context = null;
	},
	parse: function (source) {
		var arr, cnt, stops, i, s, color, inc, r, r2;
		this._colors = [];
		this._ratios = [];
		this._angle = 1;
		if (source) {
			arr = Color.getColorStopCsvArray(source);
			cnt = arr.length - 1;
			stops = arr[cnt];
			if (stops.indexOf('stops(') != 0) {
				stops = null;
				cnt++;
			}
			if (cnt < 2 || arr[0] != "linear") {
				throw new Error(Locale._default.invalidLinearGradientText + ": " + source);
			}
			i = 1;
			while (i < cnt) {
				s = String(arr[i]);
				color = Color.createFrom(s, false, true);
				if (color) {
					this._colors[i - 1] = color;
				} else {
					break;
				}
				i++;
			}
			if (i < cnt) {
				this._angle = parseFloat(arr[i]);
			}
			if (this._colors.length == 1) {
				this._colors[1] = this._colors[0].clone();
			}
			cnt = this._colors.length;
			inc = 0xff / (cnt - 1);
			this._ratios = [r = 0];
			if (stops) {
				s = stops.substring(6, stops.length - 1);
				stops = s.split(',');
				r2 = 0;
				for (i = 1; i < cnt - 1; i++) {
					r = stops[i - 1] / 100.0;
					if (isNaN(r)) r = r2;
					this._ratios.push(r);
					r2 = r;
				}
			} else {
				for (i = 1; i < cnt - 1; i++) {
					r += inc;
					this._ratios.push(r / 255.0);
				}
			}
			this._ratios.push(1);
		}
	},
	clone: function () {
		var gradient = new LinearGradient(null);
		gradient._colors = this._colors.slice();
		gradient._ratios = this._ratios.slice();
		gradient._angle = this._angle;
		return gradient;	
	},
    color: function () {
        return this._colors[0];
    },
	opaque: function () {
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			if (this._colors[i]._a < 1) return false;
		}
		return true;
	},
	prepare: function (styles) {
		this._context = styles;
	},
	applyTo: function (g, x, y, w, h) {
		var gradient;
		switch (this._angle) {
		case 90:
			gradient = g.createLinearGradient(x, y, x, y + h);
			break;
		case 45:
			gradient = g.createLinearGradient(x, y, x + w, y + h);
			break;
		case 0:
		default:
			gradient = g.createLinearGradient(x, y, x + w, y);
		}
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._colors[i].value();
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	applyToEx: function (g, alpha, brightness, x, y, w, h) {
		var gradient;
		switch (this._angle) {
		case 90:
			gradient = g.createLinearGradient(x, y, x, y + h);
			break;
		case 45:
			gradient = g.createLinearGradient(x, y, x + w, y + h);
			break;
		case 0:
		default:
			gradient = g.createLinearGradient(x, y, x + w, y);
		}
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._context.getColorValue(this._colors[i], alpha, brightness);
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	applyShadowTo: function (g) {
	},
	toText: function () {
		var s = "linear";
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			s += "," + this._colors[i].toString();
		}
		return s + "," + this._angle;
	},
	css: _norgba ? function () {
		return this._colors[0].toColorString();
	} : function () {
		var s = "linear-gradient(" + "180deg" + "," + this._colors[0].value() + "," + this._colors[1].value() + ")";
		return s;
	},
	applyToCss: function (css) {
		var c1 = this._colors[0].toString();
		var c2 = this._colors[1].toString();
		var c = "progid:DXImageTransform.Microsoft.gradient(startColorstr=" + c1 + ",endColorstr=" + c2 + ")";
		css.filter = c;
		css.background = "";
	},
	svg: _norgba ? function (target) {
		target.style.fill = this._colors[0].toColorString();
	} : function (target) {
		target.setAttributeNS(null, "fill", target.ownerSVGElement.$_svgPool.$_getLinearGradient(this))
	}
});
LinearGradient.areEqual = function (g1, g2) {
	var v = g1 && g2;
	if (v) {
		v = g1._colors.length == g2._colors.length;
		if (v) {
			for (var i = 0; i < g1._colors.length; i++) {
				v = Color.areEqual(g1._colors[i], g2._colors[i]);
				if (!v) break;
			}
		}
		if (v) {
			v = g1._ratios.length == g2._ratios.length;
			if (v) {
				for (var i = 0; i < g1._ratios.length; i++) {
					if (g1._ratios[i] != g2._ratios[i]) break;
				}
			}
			if (v) {
				v = g1._angle == g2._angle;
			}
		}
	}
	return v;
};
var RadialGradient = defineClass("RadialGradient", FillGradient, {
	init: function (source) {
		this._super(source);
	},
	parse: function (source) {
		this._colors = [];
		this._ratios = [];
		if (source) {
			var arr = Color.getColorStringArray(source);
			var cnt = arr.length;
			if (cnt < 2 || arr[0] != "radial") {
                throw new Error(Locale._default.invalidRadialGradientText + ": " + source);
			}
			var i = 1;
			while (i < cnt) {
				var s = String(arr[i]);
				var color = Color.createFrom(s, false, true);
				if (color) {
					this._colors[i - 1] = color;
				} else {
					break;
				}
				i++;
			}
			if (i < cnt) {
				this._angle = parseFloat(arr[i]);
			}
			if (this._colors.length == 1) {
				this._colors[1] = this._colors[0].clone();
			}
			cnt = this._colors.length;
			var inc = 0xff / (cnt - 1);
			var r = 0;
			this._ratios = [0];
			for (i = 1; i < cnt - 1; i++) {
				r += inc;
				this._ratios.push(r / 255.0);
			}
			this._ratios.push(1);
		}
	},
	clone: function () {
		var gradient = new RadialGradient(null);
		gradient._colors = this._colors.slice();
		gradient._ratios = this._ratios.slice();
		return gradient;	
	},
	prepare: function (styles) {
	},
	applyTo: function (g, x, y, w, h) {
		var gradient = g.createRadialGradient(x, y, x + w, y + h);
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._colors[i].value();
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	applyToEx: function (g, alpha, brightness, x, y, w, h) {
		var gradient = g.createRadialGradient(x, y, x + w, y + h);
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var tcolor = $_tempColors[i] || incArray($_tempColors, new Color());
			tcolor.copy(this._colors[i], alpha);
			gradient.addColorStop(this._ratios[i], tcolor.valueWithBrightness(brightness));
		}
		g.setFill(gradient);
		return true;
	}
});
var GlassGradient = defineClass("GlassGradient", FillGradient, {
	init: function (source) {
		this._super();
	},
	parse: function (source) {
	}
});
var SolidPen = function (color, width, dash) {
	this._color = new Color(color);
	this._width = width !== undefined ? Math.max(0, parseInt(width)) : 1;
	if (dash) this._dash = dash;
};
_extend(SolidPen.prototype, {
	applyTo: function (g) {
		g.setStroke(this._color.value(), this._width, this._dash);
		return true;
	},
    color: function () {
        return this._color;
    },
	width: function () {
		return this._width;
	},
	opaque: function () {
		return this._color._a >= 1;
	},
	toText: function () {
		return this._color.toString() + "," + this._width + "px";
	},
	css: _norgba ? function () {
        if (!this._css) {
            this._css = this._width + "px " + (this._dash ? "dashed " : "solid ") + this._color.toColorString();
        }
        return this._css;
	} : function () {
        if (!this._css) {
            this._css = this._width + "px " + (this._dash ? "dashed " : "solid ") + this._color.value();
        }
        return this._css;
	},
	svg: _norgba ? function (target) {
		var style = target.style;
		style.stroke = this._color.toColorString();
		style.strokeWidth = this._width;
		this._dash && (style.strokeDasharray = '2,2');// this._dash.join(','));
	} : function (target) {
		var style = target.style;
		style.stroke = this._color.value();
		style.strokeWidth = this._width;
		this._dash && (style.strokeDasharray = '2,2');// this._dash.join(','));
	}
});
var $SP = SolidPen;
_extend($SP, {
	WHITE: new $SP(Colors.white),
	BLACK: new $SP(Colors.black),
	GRAY: new $SP(Colors.gray),
	DIMGRAY: new $SP(Colors.dimGray),
	LTGRAY: new $SP(Colors.ltGray),
	SILVER: new $SP(Colors.silver),
	DKGRAY: new $SP(Colors.darkGray),
	RED: new $SP(Colors.red),
	GREEN: new $SP(Colors.green),
	BLUE: new $SP(Colors.blue),
	FOCUS: new $SP(Colors.gray, 1, [1, 1]),
	areEqual: function (p1, p2) {
		var v = p1 && p2 && Color.areEqual(p1._color, p2._color) && p1._width == p2._width;
		if (v) {
			v = !p1._dash == !p2._dash;
			if (v && p1._dash) {
				for (var i = p1._dash.length; i--;) {
					if (p1._dash[i] != p2._dash[i]) break;
				}
			}
		}
		return v;
	},
	fromFill: function (fill) {
		return fill ? new SolidPen(fill.color()) : null;
	}
});
var _fillToCss = function (fill, css) {
	if (_norgba) {
		new $SP(fill).applyToCss(css);
	} else {
		css.background = fill;
	}
};
/* @abstract */
var Palette = defineClass("Palette", null, {
	init: function (owner, items, alpha) {
		this._super();
		this._owner = owner;
		this._items = [];
        if (!isNaN(alpha)) {
            this._alpha = Math.max(0, Math.min(1.0, alpha));
        } else {
            this._alpha = 1.0;
        }
		this._nextItem = 0;
        items && this.addItems(items);
	},
	owner: function () {
		return this._owner;
	},
	getNext: function () {
		var len = this._items.length;
		if (len > 0) {
			return this._items[this._nextItem++ % len];
		}
		return null;
	},
    getRandomItem: function () {
        var len = this._items.length;
        if (len > 0) {
            return this._items[_int(Math.random() * len)];
        }
        return null;
    },
    reset: function (startIndex) {
        this._nextItem = isNaN(startIndex) ? 0 : startIndex;
    },
	getItem: function (index) {
		var len = this._items.length;
		if (len > 0) {
			return this._items[index % len];
		}
		return null;
	},
	addItem: function (item) {
		item = this._createItem(item);
		if (this._items.indexOf(item) < 0) {
			this._items.push(item);
			this._changed();
			return item;
		}
		return null;
	},
    addItems: function (items) {
        if (_isString(items)) {
            items = items.split(',');
        }
        if (_isArray(items)) {
            for (var i = 0, len = items.length; i < len; i++) {
                this.addItem(items[i]);
            }
        }
    },
	removeItem: function (item) {
		var i = this._items.indexOf(item);
		if (i >= 0) {
			this._items.splice(i, 1);
			this._changed();
		}
	},
	_changed: function () {
		this._owner  && this._owner._paletteChanged && this._owner._paletteChanged(this);
	},
	_createItem: function (source) {
		return undefined;
	}
});
var FillPalette = defineClass("FillPalette", Palette, {
	init: function (owner, items, alpha) {
        this._super(owner, items, alpha);
    },
	_createItem: function (source) {
		var fill = _createFillEx(source, this._alpha);
		return (fill instanceof SolidBrush || fill instanceof FillGradient) ? fill : null;
	}
});
var StrokePalette = defineClass("StrokePalette", Palette, {
	init: function (owner, items, width, alpha) {
        if (!isNaN(width) && width >= 1) {
            this._width = _floor(width);
        } else {
            this._width = 1;
        }
        this._super(owner, items, alpha);
    },
	_createItem: function (source) {
		var stroke = _createStrokeEx(source, this._width, this._alpha);
		return (stroke instanceof SolidPen) ? stroke : null;
	}
});
var FontPalette = defineClass("FontPalette", Palette, {
	init: function (owner, items) {
		FontPalette.Base.init.call(this, owner, items);
	},
	_createItem: function (source) {
		return _createFont(source) || null;
	}
});
var PaletteManager = defineClass("PaletteManager", null, {
    init: function (owner) {
        this._super();
        this._owner = owner;
        this._palettes = {};
    },
	"get": function (name) {
		return this._palettes[name];
	},
	clear: function (noEvent) {
		if (this._palettes.length > 0) {
			this._palettes = {};
			!noEvent && this._changed();
		}
	},
    addFill: function (name, fills, alpha, noEvent) {
		var fill;
        if (name && fills && !this._palettes.hasOwnProperty(name)) {
            fill = this._palettes[name] = new FillPalette(this, fills, alpha);
			!noEvent && this._changed();
        }
		return fill;
    },
    addStroke: function (name, strokes, width, alpha, noEvent) {
		var stroke;
        if (name && strokes && !this._palettes.hasOwnProperty(name)) {
            stroke = this._palettes[name] = new StrokePalette(this, strokes, width, alpha);
			!noEvent && this._changed();
        }
		return stroke;
    },
    addPalettes: function (palettes, noEvent) {
        if (_isArray(palettes) && palettes.length > 0) {
            for (var i = palettes.length; i--;) {
                this.add(palettes[i], true);
            }
			!noEvent && this._changed();
        }
    },
	add: function (palette, noEvent) {
		var items,
            p = palette;
		if (p && p.name) {
			items = p.fills;
            if (_isArray(items) || _isString(items)) {
				return this.addFill(p.name, items, p.alpha, noEvent);
			}
            items = p.strokes;
            if (_isArray(items) || _isString(items)) {
				return this.addStroke(p.name, items, p.width, p.alpha, noEvent);
			}
		}
		return undefined;
	},
    remove: function (name, noEvent) {
        var idx = this._palettes.indexOf(name);
        if (idx >= 0) {
            this._palettes.splice(idx, 1);
			!noEvent && this._changed();
			return true;
        }
		return false;
    },
    _paletteChanged: function () {
        this._changed();
    },
    _changed: function () {
        this._owner.onPaletteChanged(this);
    }
});
var PaletteItem = defineClass("PaletteItem", null, {
	init: function (source, scope) {
		this._super(source);
		this._scope = scope;
        this._num = false;
        this._any = false;
        this.assign(source);
	},
	fetch: function (scope) {
        var s = scope || this._scope,
            pal = s.getPalette(this._palette);
        if (pal) {
            if (this._restart !== undefined) {
                pal.reset(this._restart);
            }
            if (this._num) {
                return pal.getItem(this._index);
            } else if (this._any) {
                return pal.getRandomItem();
            } else if (this._index) {
                return pal.getItem(s.getPaletteIndex(this._index));
            } else {
                return pal.getNext();
            }
        }
		return undefined;
	},
    assign: function (source) {
        if (source instanceof PaletteItem) {
            this._palette = source._palette;
            this._index = source._index;
            this._restart = source._restart;
        } else if (source) {
            var s = String(source).trim();
            if (s.indexOf('p(') == 0 && s.lastIndexOf(')') == s.length - 1) {
                var arr = s.substring(2, s.length - 1).split(':');
                this._palette = arr[0].trim();
                s = arr.length > 1 ? arr[1].trim() : undefined;
                if (s) {
                    this._index = _int(s);
                    if (isNaN(this._index)) {
                        this._any = s == '?';
                        this._index = this._any ? undefined : s;
                        this._num = false;
                    } else {
                        this._num = true;
                        this._any = false;
                    }
                } else {
                    this._index = undefined;
                    this._num = false;
                    this._any = false;
                }
                s = arr.length > 2 ? arr[2].trim() : undefined;
                if (s) {
                    this._restart = _int(s);
                    if (isNaN(this._restart)) this._restart = undefined;
                } else {
                    this._restart = undefined;
                }
            } else {
                throw "Invalid palette item value: " + source;
            }
        }
    }
});
var FillCollection = defineClass("FillCollection", null, {
	init: function (source, scope) {
		this._super();
		if (_isArray(source)) {
			var i,
				cnt = source.length,
				fills = new Array(cnt);
			for (i = 0; i < cnt; i++) {
				fills[i] = _createFill(source[i], scope);
			}
			this._fills = fills;
		} else {
			this._fills = [];
		}
	},
	count: function () {
		return this._fills.length;
	},
	getItem: function (index) {
		var fill = this._fills[index];
		return fill && fill.fetch ? fill.fetch(this._scope) : fill;
	}
});
var StrokeCollection = defineClass("StrokeCollection", null, {
	init: function (source, scope) {
		this._super();
		if (_isArray(source)) {
			var i,
				cnt = source.length,
				strokes = new Array(cnt);
			for (i = 0; i < cnt; i++) {
				strokes[i] = _createstroke(source[i], scope);
			}
			this._strokes = strokes;
		} else {
			this._strokes = [];
		}
	},
	count: function () {
		return this._strokes.length;
	},
	getItem: function (index) {
		var stroke = this._strokes[index];
		return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	}
});
var $_fillCtors = {
	'#': SolidBrush,
	'l': LinearGradient,
	'r': RadialGradient,
	'g': GlassGradient,
	'p': PaletteItem
};
var _createFill = function (v, scope) {
	var t = typeof v;
	if (t === "string") {
        if (v) {
            if (v.charAt(0) == '#') {
                return new SolidBrush(v);
            } else if (v.indexOf('linear') == 0) {
                return new LinearGradient(v);
            } else if (v.indexOf('p(') == 0) {
                return new PaletteItem(v, scope);
            } else if (v.indexOf('radial') == 0) {
                return new RadialGradient(v);
            } else if (v.indexOf('glass') == 0) {
                return new GlassGradient(v);
            } else {
                return new SolidBrush(v);
            }
        }
        return null;
	} else if (t === "number") {
		return new SolidBrush(v);
	}
	return v;
};
var _createFillEx = function (v, alpha) {
    var c,
        t = typeof v;
    if (t === "string") {
        if (v) {
            if (v.charAt(0) == '#') {
                c = new Color(v, true).forceAlpha(alpha);
                return new SolidBrush(c);
            } else if (v.indexOf('linear') == 0) {
                return new LinearGradient(v);
            } else if (v.indexOf('p(') == 0) {
                return new PaletteItem(v, scope);
            } else if (v.indexOf('radial') == 0) {
                return new RadialGradient(v);
            } else if (v.indexOf('glass') == 0) {
                return new GlassGradient(v);
            } else {
                c = new Color(v, true).forceAlpha(alpha);
                return new SolidBrush(c);
            }
        }
        return null;
    } else if (t === "number") {
        c = new Color(v, true).forceAlpha(alpha);
        return new SolidBrush(c);
    }
    return v;
};
var _createFills = function (v, scope) {
	var arr = v;
	if (_isString(v)) {
		v = v.trim();
		if (v) {
			arr = v.split(',');
		}
	}
	if (_isArray(arr) && arr.length > 0) {
		return new FillCollection(arr, scope);
	}
	return null;
};
var _createStroke = function (v, scope) {
	var arr, s, c,
        t = typeof v;
	if (t === "string") {
        if (v.indexOf('p(') == 0) {
            return new PaletteItem(v, scope);
        } else if (v) {
			arr = v.trim().split(',');
            if (arr.length > 2) {
				s = arr[2];
                if (s) {
					s = s.trim();
					switch (s) {
						case 'dotted':
							return new SolidPen(arr[0], arr[1], [2, 1]);
						case 'dashed':
							return new SolidPen(arr[0], arr[1], [4, 3]);
						default:
							return new SolidPen(arr[0], arr[1]);
					}
				}
			}
			return new SolidPen(arr[0], arr[1]);
		}
		return null;
	} else if (t === "number") {
		return new SolidPen(v, 1);
	}
	return v;
};
var _createStrokeEx = function (v, width, alpha) {
    var arr, s, w, c,
        t = typeof v;
    if (t === "string") {
        if (v) {
            arr = v.trim().split(',');
            w = parseInt(arr[1]);
            if (isNaN(w) || w < 1) {
                w = width;
            }
            if (arr.length > 2) {
                s = arr[2];
                if (s) {
                    s = s.trim();
                    switch (s) {
                        case 'dotted':
                            return new SolidPen(arr[0], w, [2, 1]);
                        case 'dashed':
                            return new SolidPen(arr[0], w, [4, 3]);
                        default:
                            return new SolidPen(arr[0], w);
                    }
                }
            }
            c = new Color(v, true).forceAlpha(alpha);
            return new SolidPen(c, w);
        }
        return null;
    } else if (t === "number") {
        c = new Color(v, true).forceAlpha(alpha);
        return new SolidPen(c, w);
    }
    return v;
};
var _createStrokes = function (v, scope) {
	var arr = v;
	if (_isString(v)) {
		v = v.trim();
		if (v) {
			arr = v.split(',');
		}
	}
	if (_isArray(arr) && arr.length > 0) {
		return new StrokeCollection(arr, scope);
	}
	return null;
};
var _createFont = function (v) {
	var font = [];
	var s = String(v);
	var arr, len;
	var sz = DEF_FONT_SIZE;
	if (s) {
		arr = s.split($$_FONT_REG);
		len = arr.length;
		var family = null;
		var bold = false;
		var italic = false;
		if (len > 0 && arr[0]) {
			family = arr[0];
		}
		if (len > 1 && arr[1]) {
			sz = Number(arr[1]);
		}
		for (var i = 2; i < len; i++) {
			s = arr[i];
			if (s) {
				switch (s) {
					case "bold":
						bold = true;
						break;
					case "italic":
						italic = true;
						break;
					default:
						break;
				}
			}
		}
		if (italic) {
			font.push("italic");
		}
		if (bold) {
			font.push("bold");
		}
		font.push(sz + "px");
		family && font.push(family);
	}
	s = font.join(" ");
	return { font: s, size: sz };
};
var _createShadow = function (v) {
	if (typeof v === "string") {
		var arr = v.trim().split(',');
		if (arr.length > 0) {
			var s = arr[0];
			if (s) {
				v = Color.createFrom(s);
				if (v) {
					var shadow = {
						color: v,
						horz: 1,
						vert: 1,
						blur: 1
					};
					if (arr.length > 1) {
						v = parseInt(arr[1]);
						if (!isNaN(v)) shadow.horz = v;
						if (arr.length > 2) {
							v = parseInt(arr[2]);
							if (!isNaN(v)) shadow.vert = v;
						}
						if (arr.length > 3) {
							v = parseInt(arr[3]);
							if (!isNaN(v)) shadow.blur = v;
						}
					}
					return shadow;
				}
			}
		}
	} else if (v && v.color instanceof Color) {
		return v;
	}
	return null;
};
	var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                              window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
	window.requestAnimationFrame = requestAnimationFrame || function (render) { setTimeout(render, 10); };
var DEF_FONT_FAMILY = "Tahoma";
var DEF_FONT_SIZE = 12;
var DEF_FONT = DEF_FONT_SIZE + "px " + DEF_FONT_FAMILY;
var $_TEXT_OFF = 0;
var Graphics = function (context) {
	var ctx = context;
	!("imageSmoothingEnabled" in ctx) && (ctx.webkitImageSmoothingEnabled = true);
	ctx.mozImageSmoothingEnabled = true;
	ctx.oImageSmoothingEnabled = true;
    ctx.imageSmoothingEnabled = true;
	ctx.setLineDash = ctx.setLineDash || function(){};
    this.LINES_REG = new RegExp('\\n|\\r\\n?');
	this.save = function () {
		ctx.save();
        return this;
	};
	this.restore = function() {
		ctx.restore();
        return this;
	};
	this.setCompositionOp = function (op) {
		ctx.globalCompositeOperation = op;
        return this;
	};
	this.translate = function (dx, dy) {
		ctx.translate(dx, dy);
        return this;
	};
	this.scale = function (sw, sh) {
		ctx.scale(sw, sh);
        return this;
	};
	this.rotate = function (angle) {
		ctx.rotate(angle);
        return this;
	};
	this.rotateAt = function (angle, x, y) {
		ctx.translate(x, y);
		ctx.rotate(angle);
		ctx.translate(-x, -y);
        return this;
	},
	this.clear = function (x, y, w, h) {
		ctx.clearRect(x, y, w, h);
        return this;
	};
	this.clip = function () {
		ctx.clip();
        return this;
	};
	this.clipRect = function (r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width, r.height);
		ctx.clip();
        return this;
	};
	this.clipRectEx = function (r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width + 1, r.height + 1);
		ctx.clip();
        return this;
	};
	this.clipBounds = function (x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		ctx.clip();
        return this;
	};
	this.clipBoundsEx = function (x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w + 1, h + 1);
		ctx.clip();
        return this;
	};
	this.clipRoundRect = function (r, topLeft, topRight, bottomLeft, bottomRight, edge) {
		var x = r.x,
			y = r.y,
			x2 = r.right() + (edge || 0),
			y2 = r.bottom() + (edge || 0);
		ctx.beginPath();
		ctx.moveTo(x + topLeft, y);
		ctx.lineTo(x2 - topRight, y);
		ctx.quadraticCurveTo(x2, y, x2, y + topRight);
		ctx.lineTo(x2, y2 - bottomRight);
		ctx.quadraticCurveTo(x2, y2, x2 - bottomRight, y2);
		ctx.lineTo(x + bottomRight, y2);
		ctx.quadraticCurveTo(x, y2, x, y2 - bottomRight);
		ctx.lineTo(x, y + topLeft);
		ctx.quadraticCurveTo(x, y, x + topLeft, y);
		ctx.clip();
		return this;
	},
	this.containsPoint = function (x, y) {
		return ctx.isPointInPath(x, y);
	};
	/*
	this.copy = function (x, y, width, height) {
		octx.clearRect(x, y, width, height);
		octx.drawImage(ctx.canvas, x, y, width, height, 0, 0, width, height);
	};
	this.paste = function (x, y, width, height) {
		ctx.drawImage(octx.canvas, 0, 0, width, height, x, y, width, height);
	};
	*/
	this.setAlpha = function (alpha) {
		ctx.globalAlpha = alpha;
        return this;
	};
	this.setFill = function (fill) {
		ctx.fillStyle = fill;
        return this;
	};
	this.setStroke = function (stroke, width, dash) {
		ctx.strokeStyle = stroke;
		ctx.lineWidth = width;
		ctx.setLineDash(dash || []);
        return this;
	};
	this.setShadow = function (color, blur, offset) {
		ctx.shadowColor = color;
		ctx.shadowBlur = blur;
		ctx.shadowOffsetX = ctx.shadowOffsetY = offset;
        return this;
	};
	this.$_applyShadow = function (shadow) {
		ctx.shadowColor = shadow.color.value();
		ctx.shadowOffsetX = shadow.horz;
		ctx.shadowOffsetY = shadow.vert;
		ctx.shadowBlur = shadow.blur;
		return this;
	};
	this.applyShadow = function (shadow) {
		shadow && this.$_applyShadow(shadow);
        return this;
	},
	this.clearShadow = function () {
		ctx.shadowColor = "transparent";
        return this;
	};
	this.createLinearGradient = function (x, y, w, h) {
		return ctx.createLinearGradient(x, y, w, h);
	};
	this.createRadialGradient = function (x, y, w, h) { //, cx, cy) {
		var cx = w / 2;
		var cy = h / 2;
		var rd = Math.min(cx, cy);
		return ctx.createRadialGradient(cx, cy, 0, cx, cy, rd);
	};
    this.setCompositeOp = function (op) {
        var save = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = op;
        return save;
    };
    this.getValue = function (x, y) {
        var c = ctx.getImageData(x, y, 1, 1).data;
        return (c[3] * (1 << 24)) + (c[0] << 16) + (c[1] << 8) + c[2];
    };
    this.getColor = function (x, y) {
        var c = ctx.getImageData(x, y, 1, 1).data;
        return new Color((c[3] * (1 << 24)) + (c[0] << 16) + (c[1] << 8) + c[2]);
    };
	this.drawBounds = function(fill, stroke, x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		if (fill) {
			fill.applyTo(this, x, y, w, h);
			ctx.fill();
		}
		if (stroke) {
			stroke.applyTo(this);
			ctx.stroke();
		}
        return this;
	};
	this.drawBoundsI = function(fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0;
		x += d;
		y += d;
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		fill && fill.applyTo(this, x, y, w, h) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawRect = function(fill, stroke, r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width, r.height);
		if (fill) {
			fill.applyTo(this, r.x, r.y, r.width, r.height);
			ctx.fill();
		}
		if (stroke) {
			stroke.applyTo(this);
			ctx.stroke();
		}
        return this;
	};
	this.fillAndClear = function () {
		ctx.fill();
		ctx.shadowColor = "transparent";
        return this;
	};
	this.drawRectI = function(fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0;
		var x = r.x + d;
		var y = r.y + d;
		ctx.beginPath();
		ctx.rect(x, y, r.width, r.height);
		fill && fill.applyTo(this, x, y, r.width, r.height) && this.fillAndClear();
		stroked && ctx.stroke();
        return this;
	};
	this.drawRoundRectI = function (fill, stroke, r, topLeft, topRight, bottomLeft, bottomRight, edge) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0,
			x = r.x + d,
			y = r.y + d,
			x2 = r.right() + d + (edge || 0),
			y2 = r.bottom() + d + (edge || 0);
		ctx.beginPath();
		ctx.moveTo(x + topLeft, y);
		ctx.lineTo(x2 - topRight, y);
		ctx.quadraticCurveTo(x2, y, x2, y + topRight);
		ctx.lineTo(x2, y2 - bottomRight);
		ctx.quadraticCurveTo(x2, y2, x2 - bottomRight, y2);
		ctx.lineTo(x + bottomRight, y2);
		ctx.quadraticCurveTo(x, y2, x, y2 - bottomRight);
		ctx.lineTo(x, y + topLeft);
		ctx.quadraticCurveTo(x, y, x + topLeft, y);
		ctx.closePath();
		fill && fill.applyTo(this, x, y, r.width, r.height) && this.fillAndClear();
		stroked && ctx.stroke();
        return this;
	};
	this.drawRoundRectIWith = function (fill, stroke, r, borders, edge) {
		this.drawRoundRectI(fill, stroke, r, borders.topLeft, borders.topRight,
				borders.bottomLeft, borders.bottomRight, edge);
        return this;
	};
	this.drawCircle = function (fill, stroke, x, y, radius) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2);
		fill && fill.applyTo(this, x - radius, y - radius, radius * 2, radius * 2) && ctx.fill();
		stroked && ctx.stroke();
        ctx.closePath();
        return this;
	};
	this.drawCircleBounds = function (fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = x + w / 2;
		var cy = y + h / 2;
		var rd = Math.min(w, h) / 2;
		ctx.beginPath();
		ctx.arc(cx, cy, rd, 0, Math.PI * 2);
		fill && fill.applyTo(this, x - rd, y - rd, rd * 2, rd * 2) && ctx.fill();
		stroked && ctx.stroke();
        ctx.closePath();
        return this;
	};
	this.drawCircleRect = function (fill, stroke, r) {
		this.drawCircleBounds(fill, stroke, r.x, r.y, r.width, r.height);
        return this;
	};
	this.drawEllipse = function (fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var kappa = .5522848,
	      ox = (w / 2) * kappa, // control point offset horizontal
	      oy = (h / 2) * kappa, // control point offset vertical
	      xe = x + w,           // x-end
	      ye = y + h,           // y-end
	      xm = x + w / 2,       // x-middle
	      ym = y + h / 2;       // y-middle
		ctx.beginPath();
		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
		ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
		ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
		ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
		ctx.closePath();
		fill && fill.applyTo(this, x, y, w, h) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawTriangle = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		ctx.beginPath();
		ctx.moveTo(cx, r.y);
		ctx.lineTo(r.right(), r.bottom());
		ctx.lineTo(r.x, r.bottom());
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawDiamond = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		var cy = r.y + r.height / 2;
		ctx.beginPath();
		ctx.moveTo(cx, r.y);
		ctx.lineTo(r.right(), cy);
		ctx.lineTo(cx, r.bottom());
		ctx.lineTo(r.x, cy);
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawCross = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		var cy = r.y + r.height / 2;
		var w = Math.max(1.5, r.width / 5);
		var h = Math.max(1.5, r.height / 5);
		ctx.beginPath();
		ctx.moveTo(cx - w, r.y);
		ctx.lineTo(cx + w, r.y);
		ctx.lineTo(cx + w, cy - h);
		ctx.lineTo(r.right(), cy - h);
		ctx.lineTo(r.right(), cy + h);
		ctx.lineTo(cx + w, cy + h);
		ctx.lineTo(cx + w, r.bottom());
		ctx.lineTo(cx - w, r.bottom());
		ctx.lineTo(cx - w, cy + h);
		ctx.lineTo(r.x, cy + h);
		ctx.lineTo(r.x, cy - h);
		ctx.lineTo(cx - w, cy - h);
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawDounut = function (fill, stroke, x, y, radius, width) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		ctx.beginPath();
		(radius > 0) && ctx.arc(x, y, radius, 0, Math.PI * 2, true);
		(radius > width) && ctx.arc(x, y, radius - width, 0, Math.PI * 2, false);
		ctx.closePath();
		fill && fill.applyTo(this, x - radius, y - radius, radius * 2, radius * 2) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawArcSector = function (fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
        var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		startAngle += Math.PI * 3 / 2 + orgAngle;
		ctx.beginPath();
		ctx.moveTo(x, y);
		(radiusX > 0) && ctx.arc(x, y, radiusX, startAngle, startAngle + angle);
		ctx.lineTo(x, y);
		fill && fill.applyTo(this, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawArcSector2 = function (fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		startAngle += Math.PI * 3 / 2 + orgAngle;
		ctx.beginPath();
		(innerRadiusX > 0) && ctx.arc(x, y, innerRadiusX, startAngle, startAngle + angle);
		(radiusX > 0) && ctx.arc(x, y, radiusX, startAngle + angle, startAngle, true);
		ctx.closePath();
		fill && fill.applyTo(this, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2) && ctx.fill();
		stroked && ctx.stroke();
        return this;
	};
	this.drawLine = function (stroke, x1, y1, x2, y2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}
        return this;
	};
	this.drawLineI = function (stroke, x1, y1, x2, y2) {
		if (stroke && stroke.applyTo(this)) {
			var d = (stroke.width() % 2) / 2;
			ctx.beginPath();
			if (x1 == x2) {
				ctx.moveTo(x1 + d, y1);
				ctx.lineTo(x2 + d, y2);
			} else if (y1 == y2) {
				ctx.moveTo(x1, y1 + d);
				ctx.lineTo(x2, y2 + d);
			}
			ctx.stroke();
		}
        return this;
	};
	this.drawHorzLine = function (stroke, x1, x2, y) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
        return this;
	};
	this.drawHorzLineI = function (stroke, x1, x2, y) {
		if (stroke && stroke.applyTo(this)) {
			y += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
        return this;
	};
	this.drawHLine = function (stroke, y, x1, x2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
        return this;
	};
	this.drawHLineI = function (stroke, y, x1, x2) {
		if (stroke && stroke.applyTo(this)) {
			y += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
        return this;
	};
	this.drawVertLine = function (stroke, y1, y2, x) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
        return this;
	};
	this.drawVertLineI = function (stroke, y1, y2, x) {
		if (stroke && stroke.applyTo(this)) {
			x += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
        return this;
	};
	this.drawVLine = function (stroke, x, y1, y2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
        return this;
	};
	this.drawVLineI = function (stroke, x, y1, y2) {
		if (stroke && stroke.applyTo(this)) {
			x += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
        return this;
	};
	this.drawLines = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			var rendered = false;
			if (_isArray(pts) && pts.length >= 2) {
				ctx.beginPath();
				ctx.moveTo(pts[0].x, pts[0].y);
				for (var i = 1; i < pts.length; i++) {
					ctx.lineTo(pts[i].x, pts[i].y);
				}
				rendered = true;
			} else if (arguments.length >= 5) {
				ctx.beginPath();
				ctx.moveTo(arguments[1], arguments[2]);
				for (var i = 3; i < arguments.length - 1; i += 2) {
					ctx.lineTo(arguments[i], arguments[i + 1]);
				}
				rendered = true;
			}
			if (rendered) {
				ctx.stroke();
			}
		}
        return this;
	};
	this.drawLinesI = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			var d = (stroke.width() % 2) / 2;
			var i, len;
			var rendered = false;
			if (isArray(pts) && pts.length >= 2) {
				ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
				for (i = 1; i < pts.length; i++) {
					ctx.lineTo(pts[i].x, pts[i].y);
				}
				rendered = true;
			} else if (arguments.length >= 5) {
				var pts2 = [];
				for (i = 1, len = arguments.length; i < len; i++) {
					pts2[i] = arguments[i] + d;
				}
				ctx.beginPath();
				ctx.moveTo(pts2[1], pts2[2]);
				for (i = 3; i < len - 1; i += 2) {
					ctx.lineTo(pts2[i], pts2[i + 1]);
				}
				rendered = true;
			}
			if (rendered) {
				ctx.stroke();
			}
		}
        return this;
	};
    this.drawLinesArray = function (stroke, pts) {
        if (stroke && pts && pts.length >= 4 && stroke.applyTo(this)) {
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (var i = 1; i < pts.length / 2; i++) {
                ctx.lineTo(pts[i * 2], pts[i * 2 + 1]);
            }
            ctx.stroke();
        }
        return this;
    };
    this.drawLinesArrayI = function (stroke, pts) {
        if (stroke && pts && pts.length >= 4 && stroke.applyTo(this)) {
            var d = (stroke.width() % 2) / 2;
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (var i = 1; i < pts.length / 2; i++) {
                ctx.lineTo(pts[i * 2] + d, pts[i * 2 + 1] + d);
            }
            ctx.stroke();
        }
        return this;
    };
    this.drawQuadratic = function (stroke, x1, y1, x2, y2, x3, y3) {
        if (stroke && stroke.applyTo(this)) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(x2, y2, x3, y3);
            ctx.stroke();
        }
        return this;
    };
	this.drawCurve = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			drawCurvedLines(ctx, pts, 0, pts.length - 1);
			ctx.stroke();
		}
        return this;
	};
	this.drawPolygon = function (fill, stroke, points) {
		var i, cnt, r;
		if (points && (cnt = points.length) > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points[0].x, points[0].y);
			for (i = 1; i < cnt; i++) {
				ctx.lineTo(points[i].x, points[i].y);
			}
			ctx.closePath();
			if (fill) {
				r = getPointsRect(points);
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
	this.drawPolygonArray = function (fill, stroke, points) {
		var i, cnt, r;
		if (points && (cnt = points.length) > 2) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points[0], points[1]);
			cnt /= 2;
			for (i = 1; i < cnt; i++) {
				ctx.lineTo(points[i * 2], points[i * 2 + 1]);
			}
			ctx.closePath();
			if (fill) {
				r = getPointArrayRect(points);
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
    this.drawHoledPolygonArray = function (fill, stroke, points, hole) {
        var save = ctx.globalCompositeOperation;
        this.drawPolygonArray(fill, stroke, points);
        ctx.globalCompositeOperation = 'destination-out';
        this.drawPolygonArray(SolidBrush.BLACK, null, hole);
        ctx.globalCompositeOperation = save;
        return this;
    },
	this.drawRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points1[0].x, points1[0].y);
			for (var i = 1, cnt = points1.length; i < cnt; i++) {
				ctx.lineTo(points1[i].x, points1[i].y);
			}
			for (var i = points2.length - 1; i >= 0; i--) {
				ctx.lineTo(points2[i].x, points2[i].y);
			}
			ctx.closePath();
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
	this.drawCurvedRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			drawCurvedLines(ctx, points1, 0, points1.length - 1, true);
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			drawCurvedLines(ctx, points2, points2.length - 1, 0, false);
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
	this.drawCurvedStraightRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			drawCurvedLines(ctx, points1, 0, points1.length - 1, true);
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			for (var i = points2.length - 2; i >= 0; i--) {
				ctx.lineTo(points2[i].x, points2[i].y);
			}
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
	this.drawStraightCurvedRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			for (var i = 0; i < points1.length; i++) {
				ctx.lineTo(points1[i].x, points1[i].y);
			}
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			drawCurvedLines(ctx, points2, points2.length - 1, 0, false);
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
        return this;
	};
	this.drawText = function(font, fill, text, x, y, align, layout) {
		if (text && fill && fill.applyTo(this)) {
			ctx.beginPath();
			ctx.font = font ? font.font : DEF_FONT;
			ctx.textAlign = (align == TextAlign.CENTER) ? "center" : (align == TextAlign.RIGHT) ? "end" : "start";
			ctx.textBaseline = layout ? layout : "top";
			ctx.fillText(text, x, y);
		}
        return this;
	};
	this.drawTextSh = function(font, fill, shadow, text, x, y, align, layout) {
		if (text && fill) {
			shadow && this.$_applyShadow(shadow);
			this.drawText(font, fill, text, x, y, align, layout);
		}
        return this;
	};
	this.drawTextRect = function(font, fill, text, r, align, layout) {
		this.drawTextBounds(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
        return this;
	};
	this.drawTextBounds = function (font, fill, text, x, y, w, h, align, layout) {
		if (text && fill && fill.applyTo(this)) {
			var xSave = x;
			var ySave = y;
			var sz = DEF_FONT_SIZE;
			ctx.beginPath();
			if (font) {
				ctx.font = font.font;
				sz = font.size;
			} else {
				ctx.font = DEF_FONT;
			}
			var ta = "start";
			if (align === TextAlign.CENTER) {
				x += w / 2;
				ta = "center";
			} else if (align === TextAlign.RIGHT) {
				x = x + w;
				ta = "end";
			}
			/*
			switch (layout) {
			case "top":
				break;
			case "bottom":
				y = r.bottom();
				break;
			default:
				y += r.height  / 2;
				break;
			}
			y = _floor(y);
			x = _floor(x);
			ctx.textAlign = ta;
			ctx.textBaseline = layout ? layout : "middle";
			ctx.fillText(text, x, y);
			*/
			if (h != sz) {
				switch (layout) {
				case "top":
					break;
				case "bottom":
					y = y + h - sz;
					break;
				case "middle":
				default:
					y += (h - sz + $_TEXT_OFF) / 2;
					break;
				}
			}
			y = y + sz / 2;
			ctx.textAlign = ta;
			ctx.textBaseline = "middle";
			ctx.fillText(text, x, y);
			if (font) {
				var y2 = -1000;
				switch (font.deco) {
					case "underline":
						y2 = _int(y + sz / 2 + 1) + 0.5;
						break;
					case "line-through":
						y2 = _int(y + 1) + 0.5;
						break;
					case "overline":
						y2 = _int(y - sz / 2) - 1.5;
						break;
				}
				if (y2 > -1000) {
					ctx.beginPath();
					this.setStroke((font.line || fill._color).value(), 1)
					w = _int(ctx.measureText(text).width);
					if (align === TextAlign.CENTER) {
						x -= _int(w / 2);
					} else if (align === TextAlign.RIGHT) {
						x -= w;
					}
					ctx.moveTo(x, y2);
					ctx.lineTo(x + w, y2);
					ctx.stroke();
				}
			}
			/*
			var t = _getTimer();
			var len = 0;
			for (var i = 0; i < 1000; i++) {
				len += ctx.measureText("text" + i + text).width;
			}
			t = _getTimer() - t;
			 _console && _trace(t);
			*/
			/*
			 var t = _getTimer();
			 var len = 0;
			 for (var i = 0; i < 1000; i++) {
			 	len += ("text" + i + text).indexOf("\n");
			 }
			 t = _getTimer() - t;
			 _console && _trace(t);
			debugger;
			 */
		}
        return this;
	};
	this.drawTextRectSh = function(font, fill, shadow, text, r, align, layout) {
		if (text && fill) {
			shadow && this.$_applyShadow(shadow);
			this.drawTextBounds(font, fill, text, r.x, r.y, r.w, r.h, align, layout);
		}
        return this;
	};
	this.drawTextBoundsSh = function (font, fill, shadow, text, x, y, w, h, align, layout) {
		if (text && fill) {
			shadow && this.$_applyShadow(shadow);
			this.drawTextBounds(font, fill, text, x, y, w, h, align, layout);
		}
        return this;
	};
    this.getTextRect = function(font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle();
        }
        if (text) {
            var sz = DEF_FONT_SIZE;
            if (font) {
                ctx.font = font.font;
                sz = font.size;
            } else {
                ctx.font = DEF_FONT;
            }
            r.width = ctx.measureText(text).width;
            r.height = sz;
            r.x = x;
            r.y = y;
            if (align === TextAlign.CENTER) {
                r.x += (w - r.width) / 2;
            } else if (align === TextAlign.RIGHT) {
                r.x += w - r.width;
            }
            switch (layout) {
                case "top":
                    break;
                case "bottom":
                    r.y = r.bottom() - sz;
                    break;
                case "middle":
                default:
                    r.y += (h - sz) / 2;
                    break;
            }
        }
        return r;
    };
	this.drawTextRectExplicit = function(font, fill, text, r, align, layout) {
		this.drawTextBoundsExplicit(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
        return this;
	};
	this.drawTextBoundsExplicit = function (font, fill, text, x, y, w, h, align, layout) {
		if (!text || !fill) {
			return;
		}
		var wh = w * h;
		if (isNaN(wh) || wh <= 0) {
			return;
		}
		var lines = typeof text == "string" ? text.split(/\n|\r\n?/) : text;
		if (lines.length <= 1) {
			this.drawTextBounds(font, fill, lines[0], x, y, w, h, align, layout);
			return;
		}
        if (fill.applyTo(this)) {
			var hline = DEF_FONT_SIZE;
			ctx.beginPath();
			if (font) {
				ctx.font = font.font;
				hline = font.size;
			} else {
				ctx.font = DEF_FONT;
			}
			var hline2 = hline + 1;
			ctx.textBaseline = "middle";
			var i, ta, x2, y2;
			var htotal = hline2 * lines.length;
			var cnt = Math.min(lines.length, Math.ceil(h / hline2));
			if (layout == "top" || htotal >= h) {
			} else {
				switch (layout) {
					case "bottom":
						y = y + h - htotal;
						break;
					case "middle":
					default:
						y += (h - htotal) / 2;
						break;
				}
			}
			for (i = 0; i < cnt; i++) {
				ta = "start";
				if (align === TextAlign.CENTER) {
					x2 = x + w / 2;
					ta = "center";
				} else if (align === TextAlign.RIGHT) {
					x2 = x + w;
					ta = "end";
				} else {
					x2 = x;
				}
				y2 = y + hline2 * i;
				y2 = y2 + hline / 2;
				ctx.textAlign = ta;
				ctx.fillText(lines[i], x2, y2);
				if (font) {
					var y3 = -1000;
					switch (font.deco) {
						case "underline":
							y3 = _int(y2 + hline / 2 + 1) + 0.5;
							break;
						case "line-through":
							y3 = _int(y2 + 1) + 0.5;
							break;
						case "overline":
							y3 = _int(y2 - hline / 2) - 0.5;
							break;
					}
					if (y3 > -1000) {
						ctx.beginPath();
						this.setStroke((font.line || fill._color).value(), 1)
						w = _int(ctx.measureText(lines[i]).width);
						if (align === TextAlign.CENTER) {
							x -= _int(w / 2);
						} else if (align === TextAlign.RIGHT) {
							x -= w;
						}
						ctx.moveTo(x, y3);
						ctx.lineTo(x + w, y3);
						ctx.stroke();
					}
				}
			}
		}
        return this;
	};
    this.getExplicitTextRect = function (font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle(x, y, 0, 0);
        }
        if (!text) {
            return r;
        }
        var lines = typeof text == "string" ? text.split(this.LINES_REG) : text;
        if (lines.length == 1) {
            return this.getTextRect(font, lines[0], x, y, w, h, align, layout, r);
        }
        var hline = DEF_FONT_SIZE;
        if (font) {
            ctx.font = font.font;
            hline = font.size;
        } else {
            ctx.font = DEF_FONT;
        }
        var hline2 = hline + 1;
        ctx.textBaseline = "middle";
        var htotal = hline2 * lines.length;
        var cnt = Math.min(lines.length, Math.ceil(h / hline2));
        var i, s, x2, y2, cw;
        if (layout == "top" || htotal >= h) {
        } else {
            switch (layout) {
                case "bottom":
                    y = y + h - htotal;
                    break;
                case "middle":
                default:
                    y += (h - htotal) / 2;
                    break;
            }
        }
        r.y = y;
        r.height = hline2 * cnt;
        for (i = 0; i < cnt; i++) {
            s = lines[i];
            cw = ctx.measureText(s).width;
            if (align === TextAlign.CENTER) {
                x2 = x + (w - cw) / 2;
            } else if (align === TextAlign.RIGHT) {
                x2 = x + w - cw;
            } else {
                x2 = x;
            }
            if (r.width == 0) {
                r.x = x2;
                r.width = cw;
            } else {
                r.setLeft(Math.min(r.x, x2));
                r.setRight(Math.max(r.right(), x2 + cw));
            }
        }
        return r;
    };
	this.drawTextRectWrap = function(font, fill, text, r, align, layout) {
		this.drawTextBoundsWrap(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
        return this;
	};
	this.drawTextBoundsWrap = function (font, fill, text, x, y, w, h, align, layout) {
		if (!text || !fill) {
			return;
		}
		var wh = w * h;
		if (isNaN(wh) || wh <= 0) {
			return;
		}
		var hline = DEF_FONT_SIZE;
		if (font) {
			ctx.font = font.font;
			hline = font.size;
		} else {
			ctx.font = DEF_FONT;
		}
        var texts = typeof text == "string" ? text.split(this.LINES_REG) : text;
		if (texts.length <= 1 && ctx.measureText(texts[0]).width <= w) {
			this.drawTextBounds(font, fill, texts[0], x, y, w, h, align, layout);
			return;
		}
		if (fill.applyTo(this)) {
			var i, j, k, words, x2, s, s2, line, w2, ta, y2, cnt;
			var hline2 = hline + 1;
			var nLine = Math.min(texts.length, Math.ceil(h / hline2));
			var lines = [];
			var htotal = 0;
			var first = true;
			for (i = 0; i < nLine && htotal <= h; i++) {
				x2 = 0;
				line = "";
				words = texts[i].split(/(\s+)/);
				for (j = 0; j < words.length && htotal <= h;) {
					s = words[j];
					if (first) {
						first = false;
						s = s.trim();
						if (!s) {
							if ((w2 = ctx.measureText(s).width) > w) {
								htotal += hline2;
								lines.push(s);
							} else {
								line = s;
								x2 = w2;
							}
							s = words[++j];
						}
					}
					if (x2 + (w2 = ctx.measureText(s).width) <= w) {
						line += s;
						x2 += w2;
					} else {
						s = s.trim();
						if (s)  {
							if (line) {
								lines.push(line);
								htotal += hline2;
								line = "";
							}
							if (w2 > w) {
								while (s && htotal <= h) {
									for (k = 2; k <= s.length; k++) {
										s2 = s.substr(0, k);
										if (ctx.measureText(s2).width > w) {
											lines.push(s.substr(0, k - 1));
											htotal += hline2;
											s = s.substr(k - 1);
											break;
										}
									}
									if (!s || s.length == 1 || ctx.measureText(s).width <= w) {
										lines.push(s);
										htotal += hline2;
										break;
									}
								}
							} else {
								line = s;
								x2 = 0;
							}
						}
					}
					j++;
				}
				if (line) {
					lines.push(line);
					htotal += hline2;
				}
			}
			cnt = Math.min(lines.length, Math.ceil(h / hline2));
			htotal = lines.length * hline2;
			ctx.beginPath();
			ctx.textBaseline = "middle";
			if (layout == "top" || htotal >= h) {
			} else {
				switch (layout) {
					case "bottom":
						y = y + h - htotal;
						break;
					case "middle":
					default:
						y += (h - htotal) / 2;
						break;
				}
			}
			for (i = 0; i < cnt; i++) {
				ta = "start";
				x2 = x;
				if (align === TextAlign.CENTER) {
					x2 += w / 2;
					ta = "center";
				} else if (align === TextAlign.RIGHT) {
					x2 = x + w;
					ta = "end";
				}
				y2 = y + hline2 * i;
				y2 = y2 + hline / 2;
				ctx.textAlign = ta;
				ctx.fillText(lines[i], x2, y2);
				if (font) {
					var y3 = -1000;
					switch (font.deco) {
						case "underline":
							y3 = _int(y2 + hline / 2 + 1) + 0.5;
							break;
						case "line-through":
							y3 = _int(y2 + 1) + 0.5;
							break;
						case "overline":
							y3 = _int(y2 - hline / 2) - 0.5;
							break;
					}
					if (y3 > -1000) {
						ctx.beginPath();
						this.setStroke((font.line || fill._color).value(), 1)
						w = _int(ctx.measureText(lines[i]).width);
						if (align === TextAlign.CENTER) {
							x -= _int(w / 2);
						} else if (align === TextAlign.RIGHT) {
							x -= w;
						}
						ctx.moveTo(x, y3);
						ctx.lineTo(x + w, y3);
						ctx.stroke();
					}
				}
			}
		}
        return this;
	};
    this.getWrapTextRect = function (font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle(x, y, 0, 0);
        }
        if (!text) {
            return r;
        }
        var hline = DEF_FONT_SIZE;
        if (font) {
            ctx.font = font.font;
            hline = font.size;
        } else {
            ctx.font = DEF_FONT;
        }
        var texts = typeof text == "string" ? text.split(/\n|\r\n?/) : text;
        if (texts.length == 1 && ctx.measureText(texts[0]).width <= w) {
            return this.getTextRect(font, texts[0], x, y, w, h, align, layout, r);
        }
        var hline2 = hline + 1;
        var nLine = Math.min(texts.length, Math.ceil(h / hline2));
        var lines = [];
        var htotal = 0;
        var first = true;
        var i, j, k, words, x2, s, s2, line, w2, y2, cnt;
        for (i = 0; i < nLine && htotal <= h; i++) {
            x2 = 0;
            line = "";
            words = texts[i].split(/(\s+)/);
            for (j = 0; j < words.length && htotal <= h;) {
                s = words[j];
                if (first) {
                    first = false;
                    s = s.trim();
                    if (!s) {
                        if ((w2 = ctx.measureText(s).width) > w) {
                            htotal += hline2;
                            lines.push(s);
                        } else {
                            line = s;
                            x2 = w2;
                        }
                        s = words[++j];
                    }
                }
                if (x2 + (w2 = ctx.measureText(s).width) <= w) {
                    line += s;
                    x2 += w2;
                } else {
                    s = s.trim();
                    if (s)  {
                        if (line) {
                            lines.push(line);
                            htotal += hline2;
                            line = "";
                        }
                        if (w2 > w) {
                            while (s && htotal <= h) {
                                for (k = 2; k <= s.length; k++) {
                                    s2 = s.substr(0, k);
                                    if ((w2 = ctx.measureText(s2).width) > w) {
                                        lines.push(s.substr(0, k - 1));
                                        htotal += hline2;
                                        s = s.substr(k - 1);
                                        break;
                                    }
                                }
                                if (!s || s.length == 1 || (w2 = ctx.measureText(s).width) <= w) {
                                    lines.push(s);
                                    htotal += hline2;
                                    break;
                                }
                            }
                        } else {
                            line = s;
                            x2 = 0;
                        }
                    }
                }
                j++;
            }
            if (line) {
                lines.push(line);
                htotal += hline2;
            }
        }
        cnt = Math.min(lines.length, Math.ceil(h / hline2));
        htotal = lines.length * hline2;
        if (layout == "top" || htotal >= h) {
        } else {
            switch (layout) {
                case "bottom":
                    y = y + h - htotal;
                    break;
                case "middle":
                default:
                    y += (h - htotal) / 2;
                    break;
            }
        }
        r.y = y;
        r.height = htotal;
        for (i = 0; i < cnt; i++) {
            var cw = ctx.measureText(lines[i]).width;
            if (align === TextAlign.CENTER) {
                x2 = x + (w - cw) / 2;
            } else if (align === TextAlign.RIGHT) {
                x2 = x + w - cw;
            } else {
                x2 = x;
            }
            if (r.width == 0) {
                r.x = x2;
                r.width = cw;
            } else {
                r.setLeft(Math.min(r.x, x2));
                r.setRight(Math.max(r.right(), x2 + cw));
            }
        }
        return r;
    };
	this.drawTextRectA = function(font, fill, text, r, angle) {
		this.drawTextBoundsA(font, fill, text, r.x, r.y, r.width, r.height, angle);
        return this;
	};
	this.drawTextBoundsA = function(font, fill, text, x, y, w, h, angle) {
		if (fill && fill.applyTo(this)) {
			ctx.beginPath();
			ctx.save();
			ctx.translate(x + w / 2, y + h / 2);
			ctx.rotate(angle);
            ctx.font = font ? font.font : DEF_FONT;
            ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(text, 0, 0); // (0, 0)에서 그리도룍 해야한다!
			ctx.restore();
		}
        return this;
	};
    this.drawTextRectASh = function(font, fill, shadow, text, r, angle) {
        shadow && this.$_applyShadow(shadow);
        this.drawTextBoundsA(font, fill, text, r.x, r.y, r.width, r.height, angle);
        return this;
    };
	this.getTextWidth = function (font, text) {
		if (text) {
			ctx.font = font ? font.font : DEF_FONT;
			return ctx.measureText(text).width;
		}
		return 0;
	};
    this.getLinesWidth = function (font, text) {
        ctx.font = font ? font.font : DEF_FONT;
        var texts = text.split(/\n|\r\n?/);
        var len = texts.length;
        if (len <= 1) {
            return ctx.measureText(text).width;
        } else {
            var w = ctx.measureText(texts[0]).width;
            for (var i = 1; i < len; i++) {
                w = Math.max(ctx.measureText(texts[0]).width);
            }
            return w;
        }
    };
	this.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		try {
			ctx.drawImage.apply(ctx, arguments);
		} catch (err) {
		}
	};
    this.drawImageAlpha = function (image, alpha, sx, sy, sw, sh, dx, dy, dw, dh) {
        arguments = _slice.call(arguments, 1);
        arguments[0] = image;
        var save = ctx.globalAlpha;
        try {
            ctx.globalAlpha = alpha;
            ctx.drawImage.apply(ctx, arguments);
        } catch (err) {
        } finally {
            ctx.globalAlpha = save;
        }
        return this;
    };
    this.drawImageI = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
        arguments[1] = Math.floor(arguments[1]);
        arguments[2] = Math.floor(arguments[2]);
        try {
            ctx.drawImage.apply(ctx, arguments);
        } catch (err) {
        }
        return this;
    };
    this.drawImageAlphaI = function (image, alpha, sx, sy, sw, sh, dx, dy, dw, dh) {
        arguments = _slice.call(arguments, 1);
        arguments[0] = image;
        arguments[1] = Math.floor(arguments[1]);
        arguments[2] = Math.floor(arguments[2]);
        var save = ctx.globalAlpha;
        try {
            ctx.globalAlpha = alpha;
            ctx.drawImage.apply(ctx, arguments);
        } catch (err) {
        } finally {
            ctx.globalAlpha = save;
        }
        return this;
    };
	this.aL = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		try {
			ctx.drawImage.apply(ctx, arguments);
		} catch (err) {
		}
        return this;
	};
};
function getPointsRect(pts) {
	var x1 = pts[0].x;
	var y1 = pts[0].y;
	var x2 = x1;
	var y2 = y1;
	for (var i = 1, cnt = pts.length; i < cnt; i++) {
		var p = pts[i];
		x1 = Math.min(x1, p.x);
		y1 = Math.min(y1, p.y);
		x2 = Math.max(x2, p.y);
		y2 = Math.max(y2, p.y);
	}
	return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
}
function getPointArrayRect(pts) {
	var i, x, y;
	var cnt = pts.length / 2;
	var x1 = pts[0];
	var y1 = pts[1];
	var x2 = x1;
	var y2 = y1;
	for (i = 1; i < cnt; i++) {
		x = pts[i * 2];
		y = pts[i * 2 + 1];
		x1 = Math.min(x1, x);
		y1 = Math.min(y1, y);
		x2 = Math.max(x2, x);
		y2 = Math.max(y2, y);
	}
	return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
}
function drawCurvedLines(ctx, pts, start, end, moving) {
	if (start == end) return;
	var reverse = start > end;
	var delta = reverse ? -1 : 1;
	var p = start;
	if (moving || moving === undefined) {
		ctx.moveTo(pts[p].x, pts[p].y);
	}
	if (Math.abs(end - start) == 2) {
		ctx.lineTo(pts[p + delta].x, pts[p + delta].y);
		return;
	}
	var tension = 0.25;
	var tanLeft = { x: 0, y: 0 };
	var tanRight = { x: 0, y: 0 };
	var v1 = { x: 0, y: 0 };
	var v2 = { x: pts[p + delta].x - pts[p].x, y: pts[p + delta].y - pts[p].y };
	var tan = { x: 0, y: 0 };
	var p1 = { x: 0, y: 0 };
	var p2 = { x: 0, y: 0 };
	var mp = { x: 0, y: 0 };
	var len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
	v2.x /= len;
	v2.y /= len;
	var tanLenFactor = pts[p + delta].x - pts[p].x;
	var prevX = pts[p].x;
	var prevY = pts[p].y;
	for (p += delta; p != end; p += delta) {
		v1.x = -v2.x;
		v1.y = -v2.y;
		v2.x = pts[p + delta].x - pts[p].x;
		v2.y = pts[p + delta].y - pts[p].y;
		len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
		v2.x /= len;
		v2.y /= len;
		if (v2.x < v1.x) {
			tan.x = v1.x - v2.x;
			tan.y = v1.y - v2.y;
		} else {
			tan.x = v2.x - v1.x;
			tan.y = v2.y - v1.y;
		}
		var tanlen = Math.sqrt(tan.x * tan.x + tan.y * tan.y);
		tan.x /= tanlen;
		tan.y /= tanlen;
		if (v1.y * v2.y >= 0)
			tan = { x: 1, y: 0 };
		tanLeft.x = -tan.x * tanLenFactor * tension;
		tanLeft.y = -tan.y * tanLenFactor * tension;
		if (p == (delta + start)) {
			ctx.quadraticCurveTo(pts[p].x + tanLeft.x, pts[p].y + tanLeft.y, pts[p].x, pts[p].y);
		} else {
			p1.x = prevX + tanRight.x;
			p1.y = prevY + tanRight.y;
			p2.x = pts[p].x + tanLeft.x;
			p2.y = pts[p].y + tanLeft.y;
			mp.x = (p1.x + p2.x) / 2;
			mp.y = (p1.y + p2.y) / 2;
			ctx.quadraticCurveTo(p1.x, p1.y, mp.x, mp.y);
			ctx.quadraticCurveTo(p2.x, p2.y, pts[p].x, pts[p].y);
		}
		tanLenFactor = pts[p + delta].x - pts[p].x;
		tanRight.x = tan.x * tanLenFactor * tension;
		tanRight.y = tan.y * tanLenFactor * tension;
		prevX = pts[p].x;
		prevY = pts[p].y;
	}		
	ctx.quadraticCurveTo(prevX + tanRight.x, prevY + tanRight.y, pts[p].x, pts[p].y);
};
Graphics.getEllipsePoint = function (x, y, radiusX, radiusY, angle, orgAngle, clockwise) {
	angle = angle + orgAngle;
	var dir = clockwise ? -1 : 1;
	var p = {};
	p.x = x + Math.cos(angle * dir) * radiusX;
	p.y = y + Math.sin(-angle * dir) * radiusY;
	return p;
};
Graphics.getArcPoint = function (x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise, rate) {
	if (Math.abs(angle) > 2 * Math.PI) {
		angle = 2 * Math.PI;
	}
	if (rate === UNDEFINED) {
		rate = 0.5;
	}
	startAngle += Math.PI * 3 / 2 + orgAngle;
	var dir = clockwise ? -1 : 1;
	angle = startAngle - angle * dir * rate;
	var p = {};
	p.x = x + Math.cos(angle * dir) * radiusX;
	p.y = y + Math.sin(-angle * dir) * radiusY;
	return p;
};
var Drawings = function () {
	var _g = null;
	var _funcs = [];
	var _args = [];
	this._render = function () {
		for (var i = 0, cnt = _funcs.length; i < cnt; i++) {
			_funcs[i].apply(_g, _args[i]);
		}
	};
	this.clear = function (graphics) {
		_g = graphics;
		_funcs = [];
		_args = [];
	};
	this.clipRect = function (r) {
		_funcs.push(_g.clipBounds);
		_args.push([r.x, r.y, r.width, r.height]);
	};
	this.clipRectEx = function (r) {
		_funcs.push(_g.clipBoundsEx);
		_args.push([r.x, r.y, r.width, r.height]);
	};
	this.setAlpha = function (alpha) {
		_funcs.push(_g.setAlpha);
		_args.push([alpha]);
	};
	this.drawBounds = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawBounds);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawBoundsI = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawBoundsI);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawRect = function (fill, stroke, r) {
		_funcs.push(_g.drawBounds);
		_args.push([fill, stroke, r.x, r.y, r.width, r.height]);
	};
	this.drawRectI = function (fill, stroke, r) {
		_funcs.push(_g.drawBoundsI);
		_args.push([fill, stroke, r.x, r.y, r.width, r.height]);
	};
	this.drawRoundRectI = function (fill, stroke, r, topLeft, topRight, bottomLeft, bottomRight, edge) {
		_funcs.push(_g.drawRoundRectI);
		_args.push([fill, stroke, r.clone(), topLeft, topRight, bottomLeft, bottomRight, edge]);
	};
	this.drawRoundRectIWith = function (fill, stroke, r, borders, edge) {
		_funcs.push(_g.drawRoundRectIWith);
		_args.push([fill, stroke, r.clone(), borders, edge]);
	};
	this.drawCircle = function (fill, stroke, x, y, radius) {
		_funcs.push(_g.drawCircle);
		_args.push([fill, stroke, x, y, radius]);
	};
	this.drawEllipse = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawEllipse);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawCircleRect = function (fill, stroke, r) {
		_funcs.push(_g.drawCircleRect);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawTriangle = function (fill, stroke, r) {
		_funcs.push(_g.drawTriangle);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawDiamond = function (fill, stroke, r) {
		_funcs.push(_g.drawDiamond);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawArcSector = function (fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		_funcs.push(_g.drawArcSector);
		_args.push([fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise]);
	};
	this.drawArcSector2 = function (fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		_funcs.push(_g.drawArcSector2);
		_args.push([fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise]);
	};
	this.drawLine = function (stroke, x1, y1, x2, y2) {
		_funcs.push(_g.drawLine);
		_args.push([stroke, x1, y1, x2, y2]);
	};
	this.drawLineI = function (stroke, x1, y1, x2, y2) {
		_funcs.push(_g.drawLineI);
		_args.push([stroke, x1, y1, x2, y2]);
	};
	this.drawHorzLine = function (stroke, x1, x2, y) {
		_funcs.push(_g.drawHorzLine);
		_args.push([stroke, x1, x2, y]);
	};
	this.drawHorzLineI = function (stroke, x1, x2, y) {
		_funcs.push(_g.drawHorzLineI);
		_args.push([stroke, x1, x2, y]);
	};
	this.drawVertLine = function (stroke, y1, y2, x) {
		_funcs.push(_g.drawVertLine);
		_args.push([stroke, y1, y2, x]);
	};
	this.drawVertLineI = function (stroke, y1, y2, x) {
		_funcs.push(_g.drawVertLineI);
		_args.push([stroke, y1, y2, x]);
	};
	this.drawLines = function (stroke, pts) {
		_funcs.push(_g.drawLines);
		_args.push([stroke, pts]);
	};
	this.drawLinesI = function (stroke, pts) {
		_funcs.push(_g.drawLinesI);
		_args.push([stroke, pts]);
	};
	this.drawCurve = function (stroke, pts) {
		_funcs.push(_g.drawCurve);
		_args.push([stroke, pts]);
	};
	this.drawPolygon = function (fill, stroke, points) {
		_funcs.push(_g.drawPolygon);
		_args.push([fill, stroke, points]);
	};
	this.drawPolygonArray = function (fill, stroke, points) {
		_funcs.push(_g.drawPolygonArray);
		_args.push([fill, stroke, points]);
	};
	this.drawText = function(font, fill, text, x, y, align, layout) {
		_funcs.push(_g.drawText);
		_args.push([font, fill, text, x, y, align, layout]);
	};
	this.drawTextBounds = function (font, fill, text, x, y, w, h, align, layout) {
		_funcs.push(_g.drawTextBounds);
		_args.push([font, fill, text, x, y, w, h, align, layout]);
	};
	this.drawTextRect = function(font, fill, text, r, align, layout) {
		_funcs.push(_g.drawTextBounds);
		_args.push([font, fill, text, r.x, r.y, r.width, r.height, align, layout]);
	};
	this.drawTextRectA = function(font, fill, text, r, angle) {
		_funcs.push(_g.drawTextBoundsA);
		_args.push([font, fill, text, r.x, r.y, r.width, r.height, angle]);
	};
	this.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		_funcs.push(_g.drawImage);
		_args.push([image, sx, sy, sw, sh, dx, dy, dw, dh]);
	};
	this.getTextWidth = function (font, text) {
		return _graphics.gtTextWidth(font, text);
	};
};
var ShapeDrawing = defineClass("ShapeCellRenderer", null, {
	init: function() {
		this._super();
	},
	draw: function (g, r, fill, stroke, rotate) {
		if (fill || stroke) {
			var rot = parseFloat(rotate);
			if (!isNaN(rot)) {
				rot = (rot % 360) * Math.PI / 180;
			} else {
				rot = 0;
			}
			this._doDraw(g, r, fill, stroke, rot);
		}
	},
	_doDraw: function (g, r, fill, stroke, rotate) {
	}
}, {
	getShape: function (target, type) {
		var shape = null;
		if (type) {
			type = type.toLowerCase();
			if (type == "empty") {
				shape = EmptyShape.Default;
			} else if (type == "ellipse" || type == "circle") {
				shape = target._ellipse || (target._ellipse = new EllipseShape());
			} else if ($$_polygonShapes.hasOwnProperty(type)) {
				shape = target._polygon || (target._polygon = new PolygonShape());
				target._polygon.setShape(type);
			}
		}
		return shape;
	}});
var PolygonShape = defineClass("PolygonShape", ShapeDrawing, {
	init: function(shape) {
		this._super();
		this.setShape(shape);
	},
	shape: null,
	setShape: function (value) {
		this._shape = value ? value.toLowerCase() : null;
	},
	_doDraw: function (g, r, fill, stroke, rotate) {
		var	shape = this._shape;
		var pts, points, i, cnt;
		if ($$_polygonShapes.hasOwnProperty(shape)) {
		 	pts = $$_polygonShapes[shape];
			if (pts) {
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				if (rotate) {
					g.save();
					g.rotateAt(rotate, r.x + r.width / 2, r.y + r.height / 2)
				}
				g.drawPolygonArray(fill, stroke, pts);
				if (rotate) {
					g.restore();
				}
			}
		} else if ($$_pairShapes.hasOwnProperty(shape)) {
			points = $$_pairShapes[shape];
			if (points) {
				if (rotate) {
				}
				pts = points[0];
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				g.drawPolygonArray(fill, stroke, pts);
				pts = points[1];
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				g.drawPolygonArray(fill, stroke, pts);
				if (rotate) {
				}
			}
		}
	}
}, {
	EMPTY: "empty",
	RECTANGLE: "rectangle",
	TRIANLGE: "triangle",
	INVERTED_TRIANLGE: "itriangle",
	DIAMOND: "diamond",
	UP_ARROW: "uparrow",
	DOWN_ARROW: "downarrow",
	LEFT_ARROW: "leftarrow",
	RIGHT_ARROW: "rightarrow",
	PLUS: "plus",
	MINUS: "minus",
	EQUAL: "equal",
	STAR: "star",
	PENTAGON: "pentagon"
});
var $$_polygonShapes = {
	empty: null,
	rectangle: [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0],
	triangle: [0.5, 0.0, 0.0, 1.0, 1.0, 1.0],
	itriangle: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
	diamond: [0.5, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5],
	uparrow: [0.5, 0.0, 0.0, 0.5, 0.3, 0.5, 0.3, 1.0, 0.7, 1.0, 0.7, 0.5, 1.0, 0.5],
	downarrow: [0.3, 0.0, 0.3, 0.5, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.7, 0.5, 0.7, 0.0],
	leftarrow: [0.0, 0.5, 0.5, 1.0, 0.5, 0.7, 1.0, 0.7, 1.0, 0.3, 0.5, 0.3, 0.5, 0.0],
	rightarrow: [0.0, 0.3, 0.0, 0.7, 0.5, 0.7, 0.5, 1.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.3],
	plus: [0.3, 0.0, 0.3, 0.3, 0.0, 0.3, 0.0, 0.7, 0.3, 0.7, 0.3, 1.0, 0.7, 1.0, 0.7, 0.7, 1.0, 0.7, 1.0, 0.3, 0.7, 0.3, 0.7, 0.0],
	minus: [0.0, 0.3, 0.0, 0.7, 1.0, 0.7, 1.0, 0.3],
	/*for (var i = 0; i <= 2 * 5; ++i) {
        var a = i * Math.PI / 5 - Math.PI / 2;
        var r = i % 2 == 0 ? 0.5 : 0.191;
        context.lineTo(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a));
    }*/
	star: [0.5, 0, 0.6122, 0.3454, 0.9755, 0.3454, 0.6816, 0.5590, 0.7938, 0.9045, 0.5, 0.6910, 0.2061, 0.9045, 0.3183, 0.5590, 0.02447, 0.3454, 0.3877, 0.3454],
    pentagon: [0.5, 0, 0.9755, 0.3454, 0.7938, 0.9045, 0.2061, 0.9045, 0.0244, 0.3454],
    hexagon: [0.75, 0.0669, 1, 0.5, 0.75, 0.9330, 0.25, 0.9330, 0, 0.5, 0.25, 0.0669],
    octagon: [0.6913, 0.0380, 0.9619, 0.3086, 0.9619, 0.6913, 0.6913, 0.9619, 0.3086, 0.9619, 0.0380, 0.6913, 0.0380, 0.3086, 0.3086, 0.0380],
    trapezium: [0.3333, 0, 0.6666, 0, 1, 1, 0, 1],
    parallelogram: [0.25, 0, 1, 0, 0.75, 1, 0, 1]
};
var $$_pairShapes = {
	equal: [[0.0, 0.2, 0.0, 0.4, 1.0, 0.4, 1.0, 0.2], [0.0, 0.6, 0.0, 0.8, 1.0, 0.8, 1.0, 0.6]]
};
var EllipseShape = defineClass("EllipseShape", ShapeDrawing, {
	init: function(shape) {
		this._super();
	},
	_doDraw: function (g, r, fill, stroke) {
		g.drawEllipse(fill, stroke, r.x, r.y, r.width, r.height);
	}
});
var EmptyShape = defineClass("EmptyShape", ShapeDrawing, {
	init: function() {
		this._super();
	},
	_doDraw: function (g, r, fill, stroke) {
	}
}, null, function (f) {
	f.Default = new f();
});
/** @abstract */
var VisualContext = defineClass("VisualContext", EventAware, {
	init : function() {
		this._super();
	}
});
var CanvasContext = defineClass("CanvasContext", VisualContext, {
	init : function(name, opaque) {
		this._super();
		this._name = name;
        this._opaque = opaque;
		this._canvas = document.createElement("canvas");
		this._ctx = this._canvas.getContext('2d');
		this._graphics = new Graphics(this._ctx);
		this._dirty = false;
		this._buffer = null;
		this._bufferCtx = null;
		if (!opaque) {
			this._backBuff = this._backCtx = null;
		}
	},
    name: function () {
        return this._name;
    },
    isOpaque: function () {
        return this._opaque;
    },
	isDirty: function () {
		return this._dirty;
	},
	resize: function (w, h) {
		if (w * _DPPX > this._canvas.width) {
			this._canvas.width = w * _DPPX;
		}
		if (h * _DPPX > this._canvas.height) {
			this._canvas.height = h * _DPPX;
		}
	},
	saveBack: function (source, r) {
        var w = r.width;
        var h = r.height;
        var w2 = Math.max(0, w * _DPPX);
		var h2 = Math.max(0, h * _DPPX);
        var buff = this._backBuff;
        if (w2 * h2 == 0) return;
        if (!buff) {
            buff = this._backBuff = _doc.createElement("canvas");
            this._backCtx = this._backBuff.getContext("2d");
        }
        if (w2 > buff.width) {
            buff.width = w2;
        }
        if (h2 > buff.height) {
            buff.height = h2;
        }
        if (w2 > 0 && h2 > 0) {
            this._backCtx.clearRect(0, 0, w2, h2);
            this._backCtx.drawImage(source, r.x * _DPPX, r.y * _DPPX, w2, h2, 0, 0, w2, h2);
        }
	},
	prepare: function (bounds, scrollX, scrollY, clear) {
		if (bounds && (scrollX || scrollY)) {
			var r = bounds;
            var x = r.x;
            var y = r.y;
            var w = Math.max(0, r.width);
            var h = Math.max(0, r.height);
            var buff = this._buffer;
			if (!buff) {
				this._buffer = buff = _doc.createElement("canvas");
				this._bufferCtx = buff.getContext("2d");
			}
			if (w > buff.width) {
				buff.width = w;
			}
			if (h > buff.height) {
				buff.height = h;
			}
            if (w > 0 && h > 0) {
                this._bufferCtx.drawImage(this._canvas, x, y, w, h, 0, 0, w, h);
            }
			clear && this._graphics.clear(0, 0, this._canvas.width, this._canvas.height);
			if (scrollX > 0) {
				r.x += scrollX;
				w -= scrollX;
			} else if (scrollX < 0) {
				x -= scrollX;
				w += scrollX;
			}
			if (scrollY > 0) {
				r.y += scrollY;
				h -= scrollY;
			} else if (scrollY < 0) {
				y -= scrollY;
				h += scrollY;
			}
            if (w > 0 && h > 0) {
                this._ctx.drawImage(this._buffer, x, y, w, h, r.x, r.y, w, h);
            }
			this._dirty = true;
		} else if (clear) {
			this._graphics.clear(0, 0, this._canvas.width, this._canvas.height);
		}
        this._graphics.save();
        (_DPPX > 1) && this._graphics.scale(_DPPX, _DPPX);
	},
	restore: function () {
		if (this._dirty) {
			this._dirty = false;
		}
        this._graphics.restore();
	},
	invalidate: function (element) {
		this._dirty = true;
	}
});
var $$_layout_total = 0;
var $$_render_total = 0;
var UIComponent = defineClass("UIComponent", UIContainer, {
	init: function (dom, containerId) {
		this._super(dom, containerId);
        var canvas, css,
            container = this._container;
        if (dom) {
            this._createChildren(container);
            this.invalidateLayout();
            this._registerEventHandlers(container);
        } else {
            canvas = this._canvas = _document.createElement("canvas");
            this._ctx = canvas.getContext('2d');
            container.appendChild(canvas);
            canvas.width = container.clientWidth * _DPPX;
            canvas.height = container.clientHeight * _DPPX;
            canvas.innerText = "Your browser does not support HTML5 Canvas.";
            css = canvas.style;
            css.position = "absolute";
            css.left = "0px";
            css.top = "0px";
            css.width = "100%";
            css.height = "100%";
            css.background = "#fff"; // 이렇게 하지 않으면 상위 div의 값을 따라간다.
            css.borderStyle = "none";
            css.borderWidth = "0px";
            css["-webkit-transform"] = "translateZ(0)";
            this._defContext = new CanvasContext("defaultContext");
            this._defContext.resize(this._width, this._height);
            this._contexts = null;
            this._createChildren(container);
            this.invalidateLayout();
            this._registerEventHandlers(canvas);
        }
        this._imagePool = new ImagePool();
        this._imagePool.addListener(this);
        this._forceValidation = false;
		/*
		setInterval(function () {
			this.resetSize();
		}.bind(this), 100);
		*/
	},
    onImageLoaded: function (url) {
        var img = this._imagePool.getImage(url);
        $_debug && _console && trace("Image loaded at " + url + " [" + img.width + "," + img.height + "]");
        this.invalidateLayout();
    },
    getCanvasImage: function () {
        return this._canvas && this._canvas.toDataURL();
    },
    getContext: function (contextName) {
        if (this._contexts) {
            for (var i = this._contexts.length; i--;) {
                if (this._contexts[i].name() == contextName) {
                    return this._contexts[i];
                }
            }
        }
        return null;
    },
	addContext: function (context) {
		if (context) {
			if (!this._contexts) {
				this._contexts = [];
			}
			if (this._contexts.indexOf(context) < 0) {
				this._contexts.push(context);
				context.resize(this._width, this._height);
			}
		}
	},
    getImage: function (url) {
        return this._imagePool.getImage(url);
    },
	measureText: function (font, text) {
        if (text) {
            if (this.$_dom) {
                var span = this.$_textMeasurer;
                span.textContent = text;
                span.style.font = font ? font.font : DEF_FONT;
                return span.offsetWidth;
            } else {
                this._ctx.font = font ? font.font : "";
                return this._ctx.measureText(text).width + 1;
            }
        }
        return 0;
	},
    measureTextRect: function (font, text, x, y, w, h, align, valign, wrap) {
        if (this.$_dom) {
            var span = this.$_textMeasurer;
            return Dom.calcTextBounds(span, font, text, x, y, w, h, align, valign, wrap);
        } else {
            var r;
            switch (wrap) {
                case TextWrap.EXPLICIT:
                    r = this._defContext._graphics.getExplicitTextRect(font, text, x, y, w, h, align, valign);
                    break;
                case TextWrap.NORMAL:
                    r = this._defContext._graphics.getWrapTextRect(font, text, x, y, w, h, align, valign);
                    break;
                default:
                    r = this._defContext._graphics.getTextRect(font, text, x, y, w, h, align, valign);
                    break;
            }
            r.width++;
            return r;
        }
    },
	invalidateElement: function (element) {
        if (!element._dom) {
            var ctx = element._elementContext;
            if (ctx) {
                ctx.invalidate(element);
                this._defContext._dirty = true;
            } else {
                ctx = element._context || this._defContext;
                ctx.invalidate(element);
            }
        }
		if (!this._drawing && !this._updateRequested) {
			window.requestAnimationFrame(this._containerRender);
			this._updateRequested = true;
		}
	},
	validateElement: function (element) {
	},
	scroll: function (bounds, deltaX, deltaY) {
		this.$$_render(_getTimer(), bounds, deltaX, deltaY);
	},
	resetSize: function (force, noZero) {
        var w = this._container.clientWidth,
            h = this._container.clientHeight;
        if (force || (!noZero || w > 0 && h > 0) && (this._width != w || this._height != h)) {
            this._width = w;
            this._height = h;
            if (this._defContext) {
                this._canvas.width = w * _DPPX;
                this._canvas.height = h * _DPPX;
                this._defContext.resize(w, h);
                if (this._contexts) {
                    for (var i = 0; i < this._contexts.length; i++) {
                        this._contexts[i].resize(w, h);
                    }
                }
            } else { // for dom
            }
			this.invalidateLayout();
            (_isIE || _isFirefox || _isSafari) && this.$$_render();
		}
	},
    isInvalidSize: function (ignoreZero) {
        var c = this._container;
        return (!ignoreZero && (c.clientWidth == 0 || c.clientHeight == 0)) ||
            this._width != c.clientWidth || this._height != c.clientHeight;
    },
    adjustSize: function (duration, delay) {
        duration = isNaN(duration) ? 1000 : Math.max(0, parseInt(duration));
        delay = isNaN(delay) ? 50 : Math.max(0, parseInt(delay));
        var _adjust = function () {
            var c = this._container;
            _dlog('### ADJSUT GRID SIZE (' + c.clientWidth + ', ' + c.clientHeight +
                    '), (' + this._width + ', ' + this._height + ') at (' +
                    this.$_adjusting + ', ' + this.$_adjustDelay + ')');
            if (this.isInvalidSize()) {
                this.resetSize(false, true);
            }
            if (this.$_adjusting > 0 && this.isInvalidSize()) {
                this.$_adjustDelay = this.$_adjustDelay > 0 ? delay : 20;
                this.$_adjusting -= this.$_adjustDelay;
                setTimeout(_adjust, this.$_adjustDelay);
            } else {
                this.$_adjusting = 0;
                this.$_adjustDelay = 0;
            }
        }.bind(this);
        this.resetSize(false, true);
        if (this.isInvalidSize()) {
            var can = isNaN(this.$_adjusting) || this.$_adjusting <= 0;
            if (can) {
                this.$_adjusting = duration || 1000;
                this.$_adjsutDelay = 0;
                setTimeout(_adjust);
            }
        }
    },
	_createRootElement: function (dom) {
        if (dom) {
            var elt = new RootElement(dom, "root", this);
            this._container.appendChild(elt._dom);
            return elt;
        } else {
            return new RootElement(false, "root", this, this._defContext);
        }
	},
    _createFeedbackRoot: function (dom) {
        if (dom) {
            var elt = new RootLayerElement(dom, "feedbackRoot", this);
            this._container.appendChild(elt._dom);
            return elt;
        } else {
            return new RootLayerElement(false, "feedbackRoot", this, this._defContext);
        }
    },
	$_validateChildren: function (element) {
		var elts = element._elements;
		if (elts) {
			for (var i = elts.length; i--;) {
				var elt = elts[i];
				elt._dirty = elt._nodraw = false;
				this.$_validateChildren(elt);
			}
		}
	},
    _setForceValidation: function (value) {
        this._forceValidation = value;
    },
	_doLayout: function (r) {
	},
    _doPrepareRender: function (r) {
    },
	_beforeRender: function (bounds) {
	},
    _afterRender: function () {
    },
	_doRender: function (bounds) {
        var g = this._defContext._graphics;
        if (this._defContext._dirty) {
            this._drawElement(this._rootElement, null, this._invalidated || this._forceValidation);
        }
        if (this._contexts) {
            for (var i = 0, cnt = this._contexts.length; i < cnt; i++) {
                if (this._contexts[i]._dirty) {
                    this._drawElement(this._rootElement, this._contexts[i], true);
                }
            }
        }
        if (this._defContext._dirty) {
            this._drawElement(this._feedbackRoot, null, true);//(this._invalidated || this._forceValidation);
        }
        this.$_validateChildren(this._rootElement);
        this.$_validateChildren(this._feedbackRoot);
        this._doDrawBorder(g, bounds);
	},
    _doRenderHtml: function (bounds) {
        this._drawElementHtml(this._rootElement, this._invalidated || this._forceValidation);
        this._drawElementHtml(this._feedbackRoot, this._invalidated || this._forceValidation);
        this.$_validateChildren(this._rootElement);
        this.$_validateChildren(this._feedbackRoot);
        this._doDrawBorderHtml(bounds);
    },
    _doDrawBorder: function (g, bounds) {
    },
    _doDrawBorderHtml: function (bounds) {
    },
	_drawElement: function (element, context, force) {
        if (element._nodraw) {
            return;
        }
        var i, cnt, elt, r;
        /*if (element._dom) {
            element.drawHtml(force);
            for (i = 0, cnt = element.childCount(); i < cnt; i++) {
                elt = element.getChild(i);
                if (elt.visible()) {
                    this._drawElement(elt, null, force);
                }
            }
        } else {*/
            var ctx = element._elementContext;
            var g = context ? context._graphics : this._defContext._graphics;
            var x = element.x();
            var y = element.y();
            g.save();
            g.translate(x, y);
            if (ctx && !context) {
                var w = Math.max(0, Math.min(this._width, element.width()));
                var h = Math.max(0, Math.min(this._height, element.height()));
                var w2 = w * _DPPX;
                var h2 = h * _DPPX;
                var xoff = element.contextOffsetX();
                var yoff = element.contextOffsetY();
                var eg = ctx._graphics;
                ctx.resize(w, h);
                if (!ctx._opaque) {
                    if (this._invalidated) {
                        r = element.boundsByContainer();
                        ctx.saveBack(this._defContext._canvas, r)
                    } else if (w2 > 0 && h2 > 0) {
                        g.clear(0, 0, w2, h2);
                        if (ctx._backBuff) {
                            g.drawImage(ctx._backBuff, 0, 0, w2, h2, 0, 0, w, h);
                        }
                    }
                }
                if (ctx.isDirty()) {//} || force //|| this._invalidated) {
                    eg.save();
                    try {
                        eg.scale(_DPPX, _DPPX);
                        if (!ctx._opaque && w > 0 && h > 0) {
                            eg.clear(0, 0, w, h);
                        }
                        eg.translate(-x - xoff, -y - yoff);
                        this._drawContextedElement(element, eg, force);
                    } finally {
                        eg.restore();
                        ctx._dirty = false;
                    }
                }
                element.clip(g);
                g.save();
                try {
                    g.translate(xoff, yoff);
                    if (w2 > 0 && h2 > 0) {
                        g.drawImage(ctx._canvas, 0, 0, w2, h2, 0, 0, w, h);
                    }
                } finally {
                    g.restore();
                }
            } else {
                var mask = element._mask;
                if (mask) {
                    if (mask instanceof UIElement) {
                        mask._doDraw(g);
                        g.clip();
                    } else if (mask instanceof Rectangle) {
                        g.clipRect(mask);
                    }
                } else {
                    element.clip(g);
                }
                g.setAlpha(element._alpha);
                if (element._context == context && (force || element._dirty)) {
                    element._graphics = g;
                    element.draw(g, !this._invalidated);
                }
                var elts = element._elements;
                if (elts) {
                    for (i = 0, cnt = elts.length; i < cnt; i++) {
                        elt = elts[i];
                        if (elt._visible) {
                            this._drawElement(elt, context, force);
                        }
                    }
                }
            }
            g.restore();
	},
    _drawContextedElement: function (element, g, force) {
        var i, cnt, elt, elts;
        /*if (element._dom) {
            element.draw();
            for (i = 0, cnt = element.childCount(); i < cnt; i++) {
                elt = element.getChild(i);
                if (elt.visible()) {
                    this._drawElement(elt, g, force);
                }
            }
        } else*/ {
            g.save();
            g.translate(element.x(), element.y());
            if (element._mask) {
                if (element._mask instanceof UIElement) {
                    element._mask._doDraw(g);
                    g.clip();
                } else if (element._mask instanceof Rectangle) {
                    g.clipRect(element._mask);
                }
            } else {
                element.clip(g);
            }
            g.setAlpha(element._alpha);
            if (force || element._dirty) {
                element._graphics = g;
                element.draw(g, element._elementContext._opaque && !this._invalidated);
            }
            elts = element._elements;
            if (elts) {
                for (i = 0, cnt = elts.length; i < cnt; i++) {
                    elt = elts[i];
                    if (elt._visible) {
                        this._drawContextedElement(elt, g, force);
                    }
                }
            }
            g.restore();
        }
    },
    _drawElementHtml: function (element, force) {
        var i, cnt, elt;
        if (force || element._dirty) {
            element.drawHtml();
        }
        for (i = 0, cnt = element.childCount(); i < cnt; i++) {
            elt = element.getChild(i);
            if (elt.visible()) {
                if (elt._dom instanceof SvgSprite) {
                    this._drawElementSvg(elt, force);
                } else {
                    this._drawElementHtml(elt, force);
                }
            }
        }
    },
    _drawElementSvg: function (element, force) {
        var s, defs, g, i, cnt, elt;
        if (force || element._dirty) {
            s = element.$_svgElt = _document.createElementNS(SVGNS, "g");
            defs = _document.createElementNS(SVGNS, "defs");
            element._parent.$_svgElt.appendChild(element.$_svgElt, defs);
            s.setAttributeNS(null, "transform", "translate(" + element._x + "," + element._y + ")");
            g = new SvgGraphics(this._dom, defs);
            g.renderOpen(element.$_svgElt);
            element.drawSvg(g);
        }
        for (i = 0, cnt = element.childCount(); i < cnt; i++) {
            elt = element.getChild(i);
            if (elt.visible()) {
                this._drawElementSvg(elt, force);
            }
        }
    },
    $_clearRenderTotals: function () {
        $$_layout_total = $$_render_total = 0;
    },
    $_getLayoutTotal: function () {
        return $$_layout_total;
    },
    $_getRenderTotal: function () {
        return $$_render_total;
    },
	$$_render: function (timestamp, scrollRect, scrollX, scrollY) {
		var t = $_debug ? _getTimer() : undefined;
		var w = this._width;
		var h = this._height;
        var r = new Rectangle(0, 0, w, h);
        var i, cnt;
		this._layoutChildren(r);
		if ($_debug) {
			_dlog("rendering[" + ++this._rendered + "] at " + timestamp);
			t = getTimer();
		}
        r = new Rectangle(0, 0, w, h);
		if (this._layoutNeeded) {
			this._layoutNeeded = false;
			this._doLayout(r);
			if ($_debug) {
				$$_layout_total += t = _getTimer() - t;
                _dlog("## layouted in [" + this._rendered + ', ' + t + "]");
			}
		} else {
            this._doPrepareRender(r);
        }
		if ($_debug) {
			t = _getTimer();
		}
        if (!this._defContext) {
            return
        }
		if (this._invalidated) {
            this._defContext._dirty = true;
            if (this._contexts) {
                for (i = 0, cnt = this._contexts.length; i < cnt; i++) {
                    this._contexts[i]._dirty = true;
                }
            }
		}
		this._defContext.prepare(scrollRect, scrollX, scrollY, this._invalidated);
		if (this._contexts) {
			for (i = 0; i < this._contexts.length; i++) {
				this._contexts[i].prepare(null, 0, 0, this._contexts[i]._dirty);
			}
		}
		try {
			$_validated = 0;
			r = new Rectangle(0, 0, w, h);
			this._beforeRender(r);
			this._doRender(r);
            this._afterRender();
			if (w > 0 && h > 0) {
                w *= _DPPX;
                h *= _DPPX;
                this._ctx.clearRect(0, 0, w, h);
                this._ctx.drawImage(this._defContext._canvas, 0, 0, w, h, 0, 0, w, h);
				if (this._contexts) {
					for (i = 0; i < this._contexts.length; i++) {
						this._ctx.drawImage(this._contexts[i]._canvas, 0, 0, w, h, 0, 0, w, h);
					}
				}
			}
		} finally {
			if (this._contexts) {
				for (i = 0; i < this._contexts.length; i++) {
					this._contexts[i].restore();
				}
			}
			this._defContext.restore();
		}
		if ($_debug) {
			$$_render_total += t = _getTimer() - t;
            _dlog("rendered elements[" + $_validated + "] in [" + t + "]");
		}
		for (i = 0, cnt = this._children.length; i < cnt; i++) {
			var c = this._children[i];
			if (c._visible && c._width > 0 && c._height > 0) {
				c.resize();
				c.layoutContent();
				if (c._dirty) {
					c.draw();
				}
				this._ctx.drawImage(c._canvas, 0, 0, c._width, c._height, c._x, c._y, c._width, c._height);
			}
		}
	},
    $$_renderHtml: function (timestamp, scrollRect, scrollX, scrollY) {
        var t = $_debug ? _getTimer() : undefined;
        var w = this._width;
        var h = this._height;
        var i;
        this._layoutChildren(new Rectangle(0, 0, w, h));
        this._drawing = true;
        try {
            if ($_debug) {
                trace("rendering[" + ++this._rendered + "] at " + timestamp);
                t = getTimer();
            }
            if (this._layoutNeeded) {
                this._layoutNeeded = false;
                trace("layout...");
                this._doLayout(new Rectangle(0, 0, w, h));
                if ($_debug) {
                    $$_layout_total += t = _getTimer() - t;
                    _dlog("## layouted in [" + this._rendered + ', ' + t + "]");
                }
            }
            if ($_debug) {
                t = getTimer();
            }
            $_validated = 0;
            var r = new Rectangle(0, 0, w, h);
            this._beforeRender(r);
            this._doRenderHtml(r);
            this._afterRender();
            if ($_debug) {
                $$_render_total += t = _getTimer() - t;
                _dlog("rendered elements[" + $_validated + "] in [" + t + "]");
            }
        } finally {
            this._drawing = false;
        }
        /*
         for (var i = 0, cnt = this._children.length; i < cnt; i++) {
         var c = this._children[i];
         if (c._visible && c._width > 0 && c._height > 0) {
         c.resize();
         c.layoutContent();
         if (c._dirty) {
         c.draw();
         }
         this._ctx.drawImage(c._canvas, 0, 0, c._width, c._height, c._x, c._y, c._width, c._height);
         }
         }
         */
    },
	_resizeHandler: function (event) {
        this.resetSize();
	}
});
var UIElement = defineClass("UIElement", EventAware, {
	init: function (dom, name) {
		this._super();
        this._name = name;
        this._parent = null;
        this._elements = null;
        this._dirty = false;
        this._mouseEnabled = true;
        this._hovered = false;
        this._mask = null;
        this._nodraw = false;
        if (dom) {
            if (dom instanceof SvgSprite) {
                this._dom = dom;
            } else {
                this._dom = _document.createElement("div");
                this._dom.$_owner = this;
                this._dom.$_name = name;
                this._css = this._dom.style;
                this._css.boxSizing = "border-box";
                this._css.position = "absolute";
                this._css.padding = "0px";
                this._css.margin = "0px";
                this._css["-webkit-print-color-adjust"] = "exact"; // for chrome printing
            }
        } else {
            this._context = null;
            this._graphics = null;
        }
	},
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	rotation: 0,
	visible: true,
	alpha: 1,
    clickable: false,
	renderCallback: null,
	right: function () {
		return this._x + this._width;
	},
	bottom: function () {
		return this._y + this._height;
	},
	setWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._width) {
			this._width = value;
			this.invalidate();
		}
        return this;
	},
	setHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._height) {
			this._height = value;
			this.invalidate();
		}
        return this;
	},
	setVisible: function (value) {
		if (value != this._visible) {
			this._visible = value;
			/*value &&*/ this.invalidate(true);
            if (this._css) {
                this._css.display = value ? "block" : "none";
            } else {
            }
		}
        return this;
	},
	name: function () {
		return this._name;
	},
	setName: function (value) {
		this._name = value;
	},
	container: function() {
		return this._parent && this._parent.container();
	},
	parent: function () {
		return this._parent;
	},
    /** @deprecated use count instead */
    childCount: function () {
        return this._elements ? this._elements.length : 0;
    },
    count: function () {
        return this._elements ? this._elements.length : 0;
    },
    visibleCount: function () {
        var elts = this._elements;
        var cnt = 0;
        if (elts) {
            for (var i = elts.length; i--;) {
                if (elts[i]._visible) cnt++;
            }
        }
        return cnt;
    },
	isSingleton: function () {
		return this._parent && this._parent.childCount() == 1;
	},
	position: function () {
		return { x: this._x, y: this._y };
	},
	bounds: function() {
		return new Rectangle(this._x, this._y, this._width, this._height);
	},
	clientRect: function() {
		return new Rectangle(0, 0, this._width, this._height);
	},
	mouseX: function () {
		var container = this.container();
		if (container) {
			var x = container._currentX;
			var p = this;
			while (p && p !== UNDEFINED) {
				x -= p._x;
				p = p._parent;
			}
			return x;
		} else {
			return NaN;
		}
	},
	mouseY: function () {
		var container = this.container();
		if (container) {
			var y = container._currentY;
			var p = this;
			while (p && p !== UNDEFINED) {
				y -= p._y;
				p = p._parent;
			}
			return y;
		} else {
			return NaN;
		}
	},
	mask: function () {
		return this._mask;
	},
	setMask: function (value) {
		this._mask = value ? value.clone() : null;
	},
	isLayer: function () {
		return false;
	},
	setMouseEnabled: function (value) {
		this._mouseEnabled = value;
	},
    canHover: function () {
        return true;
    },
    /** @deprecated Use hovered() instead. */
    isHovered: function () {
        return this._hovered;
    },
    hovered: function () {
        return this._hovered;
    },
	setHovered: function (value) {
		if (value != this._hovered) {
			this._hovered = value;
			if (this._hoveredChanged) {
				this._hoveredChanged();
			}
		}
	},
    contextOffsetX: function () {
        return 0;
    },
    contextOffsetY: function () {
        return 0;
    },
    scrollLeft: function () {
        return this._dom ? this._dom.scrollLeft : 0;
    },
    scrollTop: function () {
        return this._dom ? this._dom.scrollTop : 0;
    },
    setElementContext: function (value, opaque) {
        opaque = arguments.length > 1 ? opaque : true;
        function checkChildren(p) {
            for (var i = p.childCount(); i--;) {
                p._elements[i]._elementContext = p._elementContext;
                checkChildren(p._elements[i])
            }
        }
        if (!value != !this._elementContext) {
            if (value) {
                this._elementContext = new CanvasContext('elementContext', opaque);
            } else {
                this._elementContext = undefined;
            }
            checkChildren(this);
        }
    },
	getChildren: function () {
		return this._elements ? this._elements.concat() : null;
	},
	getChild: function (index) {
		return this._elements ? this._elements[index] : null;
	},
	getChildIndex: function (child) {
		return this._elements ? this._elements.indexOf(child) : -1;
	},
	contains: function (child) {
		return this._elements ? this._elements.indexOf(child) >= 0 : false;
	},
    getVisibleChild: function (index) {
        var elts = this._elements;
        if (elts) {
            var n = 0;
            for (var i = 0, cnt = elts.length; i < cnt; i++) {
                if (elts[i]._visible) {
                    if (n++ == index) {
                        return elts[i];
                    }
                }
            }
        }
        return null;
    },
    getVisibleChildren: function () {
        var elts = this._elements;
        if (elts) {
            var list = [];
            for (var i = 0, cnt = elts.length; i < cnt; i++) {
                if (elts[i]._visible) {
                    list.push(elts[i]);
                }
            }
            return list;
        }
        return null;
    },
	addChild: function (child, context) {
        this.$_insertChild(-1, child, context);
        return child;
	},
    $_setElementContext: function (ctx) {
        this._elementContext = ctx;
        if (this._elements) {
            for (var i = this._elements.length; i--;) {
                this._elements[i].$_setElementContext(ctx);
            }
        }
    },
    insertChild: function (index, child, context) {
        this.$_insertChild(index, child, context);
        return child;
    },
    $_insertChild: function (index, child, context) {
		if (child instanceof UIElement && !this.contains(child)) {
			if (!this._elements) {
				this._elements = [];
			}
            var dom = this._dom;
			if (index < 0) {
                if (dom) {
                    if (dom instanceof SvgSprite || child._dom instanceof SvgSprite) {
                    } else {
                        dom.appendChild(child._dom);
                    }
                } else if (this._elementContext) {
                    child.$_setElementContext(this._elementContext);
                } else {
                    child._context = context;
                }
                this._elements.push(child);
            } else {
                if (dom) {
                    if (dom instanceof SvgSprite || this._dom instanceof SvgSprite) {
                    } else {
                        this._elements.length > index ? dom.insertBefore(child._dom, this._elements[index]._dom) : this._dom.appendChild(child._dom);
                    }
                } else if (this._elementContext) {
                    child._elementContext = this._elementContext;
                } else {
                    child._context = context;
                }
                this._elements.splice(index, 0, child);
            }
			child._parent = this;
			child.$_attached(this);
            return true;
		}
		return false;
	},
    addChildren: function (childs, context) {
        if (_isArray(childs)) {
            for (var i = 0, cnt = childs.length; i < cnt; i++) {
                this.$_insertChild(-1, childs[i], context);
            }
        }
    },
    insertChildren: function (index, childs, context) {
        if (_isArray(childs)) {
            for (var i = 0, cnt = childs.length; i < cnt; i++) {
                this.$_insertChild(index, childs[i], context) && index++;
            }
        }
    },
    addElement: function (child, context) {
        return this.addChild(child, context);
    },
	insertElement: function (index, child, context) {
		return this.insertChild(index, child, context);
	},
	removeChild: function (child) {
		if (child && this._elements) {
			var i = this._elements.indexOf(child);
			if (i >= 0) {
				return this.removeChildAt(i);
			}
		}
		return null;
	},
	removeElement: function (child) {
		return this.removeChild(child);
	},
	removeChildAt: function (index) {
		if (index >= 0 && index < this.childCount()) {
			var child = this._elements[index]; 
			this._elements.splice(index, 1);
            if (child._dom) {
                if (this._dom instanceof SvgSprite) {
                } else {
                    this._dom.removeChild(child._dom);
                }
            } else {
                child._context = null;
            }
			child._parent = null;
            child._dirty = false;
			child.$_detached(this);
			return child;
		}
		return null;
	},
	removeElementAt: function (index) {
		return this.removeChildAt(index);
	},
	clear: function () {
		var i,
            dom = this._dom,
            elts = this._elements,
		    cnt = elts ? elts.length : 0;
		if (cnt > 0) {
			for (i = 0; i < cnt; i++) {
				elts[i]._parent = null;
				elts[i].$_detached(this);
			}
            if (dom) {
                if (this._dom instanceof SvgSprite) {
                } else {
                    for (i = 0; i < cnt; i++) {
                        dom.removeChild(elts[i]._dom);
                    }
                }
            }
            this._elements = [];
			this.invalidate();
		}
	},
	hideAll: function () {
		var	elts = this._elements;
		var	cnt = elts ? elts.length : 0;
        var i;
        if (this._dom) {
            for (i = 0; i < cnt; i++) {
                elts[i].setVisible(false);
            }
        } else {
            for (i = 0; i < cnt; i++) {
                elts[i]._visible = false;
            }
        }
	},
	setTool: function (tool) {
		var elts = this._elements;
		var cnt = elts ? elts.length : 0;
        var i;
		if (tool) {
			this.$_tool = true;
			for (i = 0; i < cnt; i++) {
				elts[i].setTool(true);
			}
		} else if (this.$_tool) {
			this.$_tool = false;
			for (i = 0; i < cnt; i++) {
				elts[i].setTool(false);
			}
		}
	},
	invalidate: function (force, invalidateChildren) {
		if (force || !this._dirty) {
			var container = this.container();
			if (container) {
				container.invalidateElement(this);
				this._dirty = true;
			}
		}
		if (invalidateChildren) {
			var elts = this._elements;
            if (elts) {
                for (var i = elts.length; i--;) {
                    elts[i].invalidate(force, true);
                }
            }
		}
	},
	validate: function () {
		if (this._dirty) {
			this._dirty = false;
			var container = this.container();
			if (container) {
				container.validateElement(this);
			}
		}
	},
	invalidateLayout: function () {
		var container = this.container();
		if (container) {
			container.invalidateLayout();
		}
	},
	clip: function (g) {
	},
	getBounds: function(r) {
		if (!r) {
			return new Rectangle(this._x, this._y, this._width, this._height);
		} else {
			return r.set(this._x, this._y, this._width, this._height);
		}
	},
	getClientRect: function(r) {
		if (!r) {
			return new Rectangle(0, 0, this._width, this._height);
		} else {
			return r.set(0, 0, this._width, this._height);
		}
	},
	containsInBounds: function (x, y) {
		return (x >= this._x && x < this._x + this._width && y >= this._y && y < this._y + this._height);
	},
	containsInClient: function (x, y) {
		return (x >= 0 && x < this._width && y >= 0 && y < this._height);
	},
	parentToElement: function (parent, x, y) {
		var p = this;
		while (p && p != parent) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	translateBy: function (descendant, r) {
		var p = descendant;
		if (!r) {
			r = new Rectangle(0, 0, this._width, this._height);
		}
		while (p && p !== this) {
			r.x -= p._x;
			r.y -= p._y;
			p = p._parent;
		}
		return r;
	},
    topBy: function (parent, top) {
        var y = this._y + top;
        var p = this._parent;
        while (p && p !== parent) {
            y += p._y;
            p = p._parent;
        }
        return y;
    },
	boundsBy: function (parent, r) {
		var x = this._x;
		var y = this._y;
		var p = this._parent;
		if (r) {
			x += r.x;
			y += r.y;
		}
		while (p && p !== parent) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return r ? new Rectangle(x, y, r.width, r.height) : new Rectangle(x, y, this._width, this._height);
	},
	boundsByContainer: function (r) {
		var p,
            x = this._x,
		    y = this._y;
		if (r) {
			x += r.x;
			y += r.y;
		}
		p = this._parent;
		while (p && p._x !== undefined) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return r ? new Rectangle(x, y, r.width, r.height) : new Rectangle(x, y, this._width, this._height);
	},
    pointByContainer: function (pt) {
        var p = this;
        pt = pt || { x: 0, y: 0 };
        do {
            pt.x += p._x;
            pt.y += p._y;
            p = p._parent;
        } while (p && p._x !== undefined);
        return pt;
    },
	boundsByScreen: function (r) {
		r = this.boundsByContainer(r);
		r = this.container().toScreen(r);
		return r;
	},
    pointByScreen: function (p) {
        var r = p ? new Rectangle(p.x, p.y) : null;
        r = this.boundsByScreen(r);
        return { x: r.x, y: r.y };
    },
	containerToElement: function (x, y, pt) {
		var p = this;
		while (p) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		if (pt) {
            pt.x = x;
            pt.y = y;
            return pt;
        } else {
            return {x: x, y: y};
        }
	},
    clientRectByChild: function (view, r) {
        var p = view;
        r = this.getClientRect(r);
        do {
            r.x -= p.x();
            r.y -= p.y();
            p = p._parent;
        } while (p != this) ;
        return r;
    },
	move: function (x, y) {
		this.setX(x);
		this.setY(y);
	},
    setPosition: function (x, y) {
        this.setX(x);
        this.setY(y);
    },
	resize: function (width, height) {
		this.setWidth(width);
		this.setHeight(height);
	},
	setSize: function (width, height) {
		this.setWidth(width);
		this.setHeight(height);
	},
	setBounds: function (x, y, width, height) {
		this.setX(x);
		this.setY(y);
		this.setWidth(width);
		this.setHeight(height);
	},
	setBoundsI: function (x, y, width, height) {
		/*
		this.setX(x >>> 0);
		this.setY(y >>> 0);
		this.setWidth(width >>> 0);
		this.setHeight(height >>> 0);
		*/
		this.setX(x >> 0);
		this.setY(y >> 0);
		this.setWidth(width >> 0);
		this.setHeight(height >> 0);
	},
    setBoundsHtml: function (x, y, width, height) {
        var css = this._css;
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
        css.left = x + 'px';
        css.top = y + 'px';
        css.width = width + 'px';
        css.height = height + 'px';
    },
	setRect: function (r) {
		this.setX(r.x);
		this.setY(r.y);
		this.setWidth(r.width);
		this.setHeight(r.height);
	},
	setRectI: function (r) {
		this.setX(_floor(r.x));
		this.setY(_floor(r.y));
		this.setWidth(_floor(r.width));
		this.setHeight(_floor(r.height));
	},
	draw: function (g, needOpaque) {
        this._dirty = false;
        this._renderCallback ? this._renderCallback(g) : this._doDraw(g, needOpaque);
        $_validated++;
	},
    drawHtml: function () {
        this._dirty = false;
        this._css.left = this._x + "px";
        this._css.top = this._y + "px";
        this._css.width = this._width + "px";
        this._css.height = this._height + "px";
        this._doClearHtml();
        this._doDrawHtml();
        $_validated++;
    },
    drawSvg: function (g) {
        this._dirty = false;
        this._renderCallback ? this._renderCallback(g) : this._doDrawSvg(g);
        $_validated++;
    },
	moveDom: function () {
		this._css.left = this._x + "px";
		this._css.top = this._y + "px";
		this._css.width = this._width + "px";
		this._css.height = this._height + "px";
	},
	hitTest: function (x, y) {
		return x >= 0 && x < this._width && y >= 0 && y < this._height;
	},
	containerToLocal: function (pt) {
		var x = pt.x,
		    y = pt.y,
		    p = this;
        while (p) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	localToContainer: function (pt) {
		var x = pt.x,
		    y = pt.y,
		    p = this;
		while (p) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	findChildAt: function (x, y, hitTesting) {
		var i, elt, cx, cy, child,
            elts = this._elements,
		    cnt = elts ? elts.length : 0;
		if (cnt > 0) {
			for (i = cnt - 1; i >= 0; i--) {
				elt = elts[i];
				if (elt.visible()) {
					cx = x - elt._x;
					cy = y - elt._y;
					if (hitTesting || elt._mouseEnabled) {
						if (elt.isLayer() || elt.hitTest(cx, cy)) {
							child = elt.findChildAt(cx, cy, hitTesting);
							if (child) { 
								return child;
							}
							if (!elt.isLayer() && elt._mouseEnabled) {
								return elt;
							}
						}
					}
				}
			}
		}
		return null;
	},
    getParentAs: function (clazz) {
        var p = this;
        while (p) {
            if (p instanceof clazz) {
                return p;
            }
            p = p._parent;
        }
        return null;
    },
    isAncestorOf: function (element) {
        var p = element;
        if (p) {
            do {
                if (p === this) return true;
            } while (p = p.parent());
        }
        return false;
    },
    propertyChanged: function (prop, newValue) {
        this.invalidate();
    },
	$_attached: function (parent) {
		this._doAttached(parent);
	},
	_doAttached: function (parent) {
	},
	$_detached: function (parent) {
		this._doDetached(parent);
	},
	/*
	_setContexted: function () {
		this._contexted = true;
	},
	*/
	_doDetached: function (parent) {
	},
	_doDraw: function (g, needOpaque) {
	},
    _doClearHtml: function () {
    },
    _doDrawHtml: function () {
    },
    _doDrawSvg: function (g) {
        this._doDraw(g, false);
    },
	_hoveredChanged: function () {
	},
    $_setCssFill: function (fill) {
        if (_norgba) {
            if (fill) {
                fill.applyToCss(this._css);
            } else {
                this._css.background = ""
                this._css.filter = "";
            }
        } else {
            if (fill instanceof LinearGradient) {
                fill.applyToCss(this._css);
            } else {
                this._css.background = fill ? fill.css() : "";
                this._css.filter = "";
            }
        }
    },
    $_getGraphics: function (clear, r, before) {
        var svg = this._svg;
        if (!svg) {
            svg = this._svg = new SvgSprite(null, this.container());
            if (before) {
                this._dom.insertBefore(svg._svg, before);
            } else {
                this._dom.appendChild(svg._svg);
            }
        }
        svg._svg.style.visibility = 'visible';
        return svg.getGraphics(clear, r);
    }
}, {
    addChild: function (parent, child) {
        parent.addChild(child);
    }
	/*
	addChild: function (parent, child, context) {
		if (child instanceof UIElement && !parent.contains(child)) {
			if (!parent._elements) {
				parent._elements = [];
			}
			parent._elements.push(child);
			child._parent = parent;
			child._context = context;
			if (child._contexted) {
     UIElement.$_setContexted(child);
			}
			child.$_attached(this);
		}
		return child;
	},
	$_setContexted: function (element) {
		var elts = element._elements;
		if (elts) {
			for (var i = elts.length; i--;) {
				elts[i]._context = element._context;
     UIElement.$_setContexted(elts[i]);
			}
		}
	}
	*/
});
var RootElement = defineClass("RootElement", UIElement, {
	init: function (dom, name, container, context) {
		this._super(dom, name);
		this._container = container;
		this._context = context;
	},
	container: function () {
		return this._container;
	}
});
var RootLayerElement = defineClass("RootLayerElement", UIElement, {
    init: function (dom, name, container, context) {
        this._super(dom, name);
        this._container = container;
        this._context = context;
    },
    container: function () {
        return this._container;
    },
    isLayer: function () {
        return true;
    },
});
var MaskElement = defineClass("MaskElement", UIElement, {
	init: function (name, target, render) {
		this._super(false, name);
		this._target = target;
		this._render = render;
	},
	_doDraw: function (g) {
		if (this._render) {
			this._render(g, this._target);
		}
	}
});
var LayerElement = defineClass("LayerElement", UIElement, {
	init: function (dom, name, clip) {
		this._super(dom, name);
        if (dom) {
            if (this._css) {
                this._css.pointerEvents = "none";
            }
        } else {
            this._clip = clip;
            this._drawRect = null;
        }
	},
	isLayer: function () {
		return true;
	},
	clip: function (g) {
		if (this._clip) {
			var r = this._drawRect = this._drawRect || new Rectangle();
			this.getClientRect(r);
			g.clipRect(r);
		}
	}
});
var GraphicElement = defineClass("LayerElement", UIElement, {
    init: function () {
        this._super(true);
        if (this._css) {
            this._css.pointerEvents = "none";
        }
    },
    $_getGraphics: function (clear, r) {
        var svg = this._svg;
        if (!svg) {
            svg = this._svg = new SvgSprite(this, this.container());
        }
        return svg.getGraphics(clear, r);
    }
});
var $$_fileloc = $$_locproto.substr(0, 4);
var Keys = _enum('Keys', {
    BACK: 8,
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    ESCAPE: 27,
    SPACE: 32,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,
    "0": 48,
    F2: 113,
    F3: 114,
    A: 65,
    C: 67,
    D: 68,
    I: 73,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    QUOT: 222
});
var Cursor = _enum('Cursor', {
    DEFAUT: "default",
    AUTO: "auto",
    POINTER: "pointer",
    WAIT: "wait",
    MOVE: "move",
    COL_RESIZE: "col-resize",
    ROW_RESIZE: "row-resize",
    CROSSHAIR: "crosshair",
    HORZ_RESIZE: "ew-resize",
    VERT_RESIZE: "ns-resize",
    NESW_RESIZE: "nesw-resize",
    NWSE_RESIZE: "nwse-resize",
    NO_DROP: "no-drop",
    NOT_ALLOWED: "not-allowed",
    GRAB: "grab",
    GRABBING: 'grabbing'
});
var _touchToOffset = function (container, touch) {
    if (!touch) { alert("no touch"); return; }
    if (!container) { alert('no container'); return; }
    if (!container._canvas) { alert('no canvas'); return; }
    /*
     이렇게 하면 값이 틀어지는 browser가 있다. androdi tab...
     var r = this._container._canvas.getBoundingClientRect();
     touch.x = touch.clientX - r.left;
     touch.y = touch.clientY - r.top;
     */
    var r = container._canvas.getBoundingClientRect();
    touch.x = touch.pageX - r.left;// - window.scrollX;// - (r.left + window.scrollX);
    touch.y = touch.pageY - r.top;// - window.scrollY;// - (r.top + window.scrollY);
    return touch;
}
var TouchManager = defineClass("TouchManager", null, {
    init: function (container) {
        this._super();
        this._container = container;
    },
    touchStart: function (event) {
        return false;
    },
    touchMove: function (event) {
        return false;
    },
    touchEnd: function (event) {
    },
    touchCancel: function (event) {
    },
    _toOffset: function (touch) {
        return _touchToOffset(this._container, touch);
    }
});
var DRAG_THRESHOLD = 3;
var VisualTool = defineClass("VisualTool", null, {
    init: function (owner, name) {
        this._super();
        this._owner = owner;
        this._name = name;
        this._dragTracker = null;
        this._clickX = 0;
        this._clickY = 0;
        this._currX = 0;
        this._currY = 0;
        this._mousePressed = false;
        this._mousePressing = false;
    },
    dragTracker: null,
    owner: function () {
        return this._owner;
    },
    setDragTracker: function (value) {
        if (value !== this._dragTracker) {
            if (this._dragTracker) {
                this._dragTracker.deactivate();
            }
            this._dragTracker = value;
            if (this._dragTracker) {
                this._dragTracker.activate();
            }
        }
    },
    isDragging: function () {
        return this._dragTracker && this._dragTracker.isDragging();
    },
    clickX: function () {
        return this._clickX;
    },
    clickY: function () {
        return this._clickY;
    },
    currX: function () {
        return this._currX;
    },
    currY: function () {
        return this._currY;
    },
    isEditing: function () {
        return false;
    },
    touchManager: function () {
        return null;
    },
    setMousePressing: function () {
        this._mousePressing = true;
    },
    mousePressed: function () {
        return this._mousePressed;
    },
    mousePressing: function () {
        return this._mousePressing;
    },
    activate: function () {
        this._doActivate();
    },
    deactivate: function () {
        this._doDeactivate();
    },
    keyDown: function (key, ctrl, shift, alt) {
        var ret = this._doKeyDown(key, ctrl, shift, alt);
        return ret;
    },
    keyUp: function (key, ctrl, shift, alt) {
        return this._doKeyUp(key, ctrl, shift, alt);
    },
    click: function (event) {
        this._doClick(event.mouseX, event.mouseY);
    },
    dblclick: function (event) {
        this._doDblClick(event.mouseX, event.mouseY)
    },
    mouseDown: function (event) {
        this._mousePressed = true;
        this._mousePressing = false;
        var x = this._currX = this._clickX = event.mouseX;
        var y = this._currY = this._clickY = event.mouseY;
        if (this.isDragging()) {
            this._stopDragTracker(x, y, false);
            this.setDragTracker(null);
        }
        this._doMouseDown(event.mouseX, event.mouseY, event.ctrlKey, event.shiftKey, event.button, _isMac && event.metaKey);
    },
    mouseMove: function (event) {
        var x = this._currX = event.mouseX;
        var y = this._currY = event.mouseY;
        var tracker = this.dragTracker();
        var request;
        if (tracker) {
            if (tracker.isDragging()) {
                if (!("$hasNotButtons" in VisualTool)) {
                    VisualTool.$hasNotButtons = _ieOld || _ieTen || _isSafari;
                }
                if ((VisualTool.$hasNotButtons && event.button == 0) || event.buttons > 0) {
                    if (!tracker.drag(x, y)) {
                        request = tracker.getNextRequest(x, y);
                        if (request) {
                            this._stopDragTracker(x, y, true);
                            this.setDragTracker(this._getDragTracker(request));
                            this._startDragTracker(x, y);
                        }
                    }
                } else {
                    this._stopDragTracker(x, y, true);
                }
            } else if (Math.abs(x - this._clickX) >= DRAG_THRESHOLD || Math.abs(y - this._clickY) >= DRAG_THRESHOLD) {
                this._startDragTracker(x, y);
            } else {
                this._doMouseMove(x, y);
            }
        } else {
            this._doMouseMove(x, y, event.ctrlKey, event.shiftKey, _isMac && event.metaKey);
        }
    },
    mouseUp: function (event) {
        var x = this._currX = event.mouseX,
            y = this._currY = event.mouseY;
        try {
            if (this.isDragging()) {
                var dropped = this._stopDragTracker(x, y, false);
            } else {
                this._doMouseUp(x, y);
            }
        } finally {
            this._mousePressed = this._mousePressing = false;
        }
    },
    mouseEnter: function (event) {
        this._doMouseEnter(event.mouseX, event.mouseY);
    },
    mouseLeave: function (event) {
        this._doMouseLeave(event.mouseX, event.mouseY);
    },
    mouseOver: function (event) {
        this._doMouseOver(event.mouseX, event.mouseY);
    },
    mouseOutside: function () {
        this._doMouseOutside();
    },
    mouseWheel: function (event) {
        return this._doMouseWheel(event.mouseX, event.mouseY, event.wheelDelta, event.wheelDelta);
    },
    touchStart: function (event) {
        return this.touchManager() ? this.touchManager().touchStart(event) : this._doTouchStart(event);
    },
    touchMove: function (event) {
        return this.touchManager() ? this.touchManager().touchMove(event) : this._doTouchMove(event);
    },
    touchEnd: function (event) {
        this.touchManager() ? this.touchManager().touchEnd(event) : this._doTouchEnd(event);
    },
    touchCancel: function (event) {
        this.touchManager() ? this.touchManager().touchCancel(event) : this._doTouchCancel(event);
    },
    findElementAt: function (x, y, hitTesting) {
        return this._owner.findElementAt(x, y, hitTesting);
    },
    setFocus: function () {
        return this._doSetFocus();
    },
    _doActivate: function () {
    },
    _doDeactivate: function () {
    },
    _doKeyDown: function (key, ctrl, shift) {
        return false;
    },
    _doKeyUp: function (key, ctrl, shift) {
        return false;
    },
    _doClick: function (x, y) {
    },
    _doDblClick: function (x, y) {
    },
    _doMouseDown: function (x, y) {
    },
    _doMouseMove: function (x, y) {
    },
    _doMouseUp: function (x, y) {
    },
    _doMouseEnter: function (x, y) {
    },
    _doMouseLeave: function (x, y) {
    },
    _doMouseOver: function (x, y) {
    },
    _doMouseOutside: function () {
    },
    _doMouseWheel: function (x, y, deltaX, deltaY) {
        return false;
    },
    _doTouchStart: function (event) {
        return false;
    },
    _doTouchMove: function (event) {
        return false;
    },
    _doTouchEnd: function (event) {
    },
    _doTouchCancel: function (event) {
    },
    _startDragTracker: function (x, y) {
        if (this._dragTracker) {
            if (this._dragTracker.start(x, y)) {
                this._doDragTrackerStarted(this._dragTracker);
            } else {
                this._dragTracker = null;
            }
        }
    },
    _stopDragTracker: function (x, y, canceled) {
        var tracker, rslt = false;
        if (this.isDragging()) {
            tracker = this._dragTracker;
            if (canceled) {
                tracker.cancel();
            } else {
                tracker.drop(x, y);
                rslt = true;
            }
            this.setDragTracker(null);
            this._doDragTrackerFinished(tracker, canceled);
            if (tracker.needRedraw()) {
                this._owner && this._owner.invalidate && this._owner.invalidate();
            }
        }
        return rslt;
    },
    _doDragTrackerStarted: function (dragTracker) {
        _console && _trace("dragTracker started: " + dragTracker.name());
    },
    _doDragTrackerFinished: function (dragTracker, canceled) {
        _console && _trace("dragTracker stopped: " + dragTracker.name() + ", " + (canceled ? "canceled" : "completed"));
    },
    _doSetFocus: function () {
    }
});
var EditRequest = defineClass("EditRequest", null, {
    init : function() {
        this._super();
    },
    cursor: function () { return Cursor.AUTO; },
    source: function () { return null; },
    isSelectable: function () { return false; },
    isDblClickable: function () { return false; }
});
var DragTracker = defineClass("DragTracker", null, {
    init : function(container, name, x, y) {
        this._super();
        this._container = container;
        this._name = name;
        this._active = false;
        this._completed = false;
        this._dragging = false;
        this._startX = x;
        this._startY = y;
        this._currentX = 0;
        this._currentY = 0;
    },
    cancelable: false,
    needRedraw: false,
    container: function () {
        return this._container;
    },
    name: function () {
        return this._name;
    },
    isActive: function () {
        return this._active;
    },
    isDragging: function () {
        return this._dragging;
    },
    isStartWhenCreated: function () {
        return false;
    },
    isCompleted: function () {
        return this._completed;
    },
    activate : function() {
        if (!this._active) {
            this._doActivate();
            this._active = true;
        }
    },
    deactivate : function() {
        if (this._active) {
            this.cancel();
            this._doDeactivate();
            this._active = false;
        }
    },
    start: function (x, y) {
        this.cancel();
        if (this._active && this._doStart(x, y)) {
            this._currentX = this._startX = x;
            this._currentY = this._startY = y;
            this._dragging = true;
            this._completed = false;
            this._showFeedback(x, y);
            return true;
        }
        return false;
    },
    drag: function (x, y) {
        if (this._dragging) {
            this._currentX = x;
            this._currentY = y;
            if (this._doDrag(x, y)) {
                this._moveFeedback(x, y);
                return true;
            }
        }
        return false;
    },
    cancel: function () {
        try {
            if (this._dragging) {
                try {
                    this._dragging = false;
                    this._doCanceled();
                } finally {
                    this._doEnded();
                }
            }
        } finally {
            this._hideFeedback();
        }
    },
    drop: function (x, y) {
        try {
            if (this._dragging) {
                try {
                    this._currentX = x;
                    this._currentY = y;
                    this._dragging = false;
                    if (this._canAccept(x, y)) {
                        this._doCompleted(x, y);
                        this._completed = true;
                    } else {
                        this._doCanceled(x, y);
                    }
                } finally {
                    this._doEnded();
                }
            }
        } finally {
            this._hideFeedback();
        }
    },
    getNextRequest: function (x, y) {
        return null;
    },
    startX: function () {
        return this._startX;
    },
    startY: function () {
        return this._startY;
    },
    currentX: function () {
        return this._currentX;
    },
    currentY: function () {
        return this._currentY;
    },
    offsetX: function () {
        return this._currentX - this._startX;
    },
    offsetY: function () {
        return this._currentY - this._startY;
    },
    _showFeedback: function (x, y) {
    },
    _moveFeedback: function (x, y) {
    },
    _hideFeedback: function () {
    },
    _doActivate : function () {
        _console && _trace(this._name + " activated");
    },
    _doDeactivate : function () {
        _console && _trace(this._name + " deactivated");
    },
    _doStart: function (x, y) {
        return true;
    },
    _doDrag: function (x, y) {
        return true;
    },
    _doCanceled: function () {
    },
    _canAccept: function (x, y) {
        return true;
    },
    _doCompleted: function () {
    },
    _doEnded: function () {
    },
    _findElementAt: function (x, y, hitTesting) {
        return this._container.findElementAt(x, y, hitTesting);
    }
});
var ToolTipOptions = defineClass("ToolTipOptions", null, {
	init : function (options) {
		this._super();
		options && this.assign(options);
	},
    minWidth: 0,
    maxWidth: 0,
    lineBreak: true,
	message: null,
	visible: true,
	styles: null,
	delay: 300,
	duration: 5000,
    animation: false,
	assignSimple: function (source) {
		if (typeof source == "string") {
			this._message = source;
			if (this._message) {
				this._visible = true;
			}
		} else if (typeof source == "boolean") {
			this._visible = Boolean(source);
		}
	}
});
var ToolTipView = defineClass("ToolTipView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._span = null;
		this._element = this._createElement();
		this._showing = false;
	},
	show: function (options, x, y) {
		this._showing = true;
		try {
			this.$_show(options, x, y);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (options, x, y) {
		var elt, styles, span, css, f, br, pr, cr, r,
			body = document.body,
			pElt = this._container._popupOwner || document.documentElement,
            styles = options.styles(),
			s = options.message();
		if (!s) {
			return;
		}
		elt = this._element;
		if (!elt) {
			return;
		}
        if (options.lineBreak()) {
            s = s.replace($_linebrreg, '<br>');
        }
		span = this._span;
		elt.innerHTML = s;
        css = elt.style;
		css.position = "absolute";
		css.overflow = "hidden";
		css.zIndex = 3001;
        css.background = (styles && styles.background() || SolidBrush.WHITE).css();
		css.color = (styles && styles.color() || SolidPen.BLACK).css();
		css.border = (styles && styles.border() || SolidPen.DIMGRAY).css();
		css.borderRadius = (styles ? styles.borderRadius() : 0) + 'px';
		css.boxShadow = "1px 1px 2px #555";
        css.font = (f = styles && styles.font()) ? f.font : DEF_FONT;
		css.padding = styles ? styles.paddings() : 0;
        css.maxWidth = options.maxWidth() > 0 ? options.maxWidth() + 'px' : '';
        css.minWidth = options.minWidth() > 0 ? options.minWidth() + 'px' : '';
        css.transition = this._showed && options.animation() ? "0.5s ease-in-out" : '';
        pElt.appendChild(elt);
		br = _getBrowserSize();
		if (body.scrollWidth > body.clientWidth) {
			br.height -= 18;
		}
		if (body.scrollHeight > body.clientHeight) {
			br.width -= 18;
		}
        pr = Dom.getBounds(pElt);
        cr = Dom.getBounds(this._container._container);
		r = Dom.getBounds(elt);
		x += cr.left - pr.left;
		if (x + pr.left + r.width > br.width) {
			x -= r.width;
		}
		y += cr.top - pr.top + 21;
        if (y + pr.top + r.height > br.height) {
			y -= r.height + 21;
        }
        css.left = Math.max(pr.left, x) + "px";
        css.top = Math.max(pr.top, y) + "px";
		/*
		var cr = elt.getBoundingClientRect();
		var w = cr.width + 10;
		var h = cr.height + 10;
		var r = new Rectangle();
		r.width = this._container.width();
		r.height = this._container.height();
		css.left = x + "px";//((r.width - w) / 2) + "px";
		css.top = y + "px";// ((r.height - h) / 2) + "px";
		*/
        this._showed = true;
	},
	hide: function () {
		var elt = this._element;
		if (elt && elt.parentNode) {
			elt.parentNode.removeChild(elt);
            this._showed = false;
		}
	},
	_createElement: function () {
		var element = _doc.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		Dom.disableSelection(element);
		return element;
	}
});
var ToolTipManager = defineClass("ToolTipManager", EventAware, {
	init: function (owner) {
		this._super();
		this._owner = owner
		this._container = owner.container();
        this._showCallback = ToolTipManager.prototype.$_show.bind(this);
	},
	visible: function () {
		return this._active;
	},
	target: null,
    $_show: function (options, target, callback) {
        if (this._target === target && options.duration() > 0) {
            if (options && options.visible()) {
                if (!this._tipView) {
                    this._tipView = new ToolTipView(this._container);
                }
                this._tipView.show(options, this._owner.mouseX(), this._owner.mouseY());
                this._active = true;
                this._closeCallback = callback;
                this._closeTimer && clearInterval(this._closeTimer);
                this._closeTimer = setTimeout(function () {
                    this.close();
                }.bind(this), options.duration());
            }
        }
    },
	show: function (options, target, callback) {
		if (this._showTimer !== undefined) {
			clearTimeout(this._showTimer);
			this._showTimer = undefined;
		}
		if (!this._active) {
			this.close();
			options = options instanceof ToolTipOptions ? options : options ? new ToolTipOptions(options) : null;
            if (options.delay() > 0) {
                this._showTimer = setTimeout(this._showCallback, options.delay(), options, target, callback);
            } else {
                this._showTimer = undefined;
                this.$_show(options, target, callback);
            }
		} else if (options.animation()) {
            this.$_show(options, target, callback);
        }
	},
	close: function () {
		if (this._closeTimer !== undefined) {
			clearTimeout(this._closeTimer);
			this._timer = undefined;
		}
		if (this._active) {
			this._tipView && this._tipView.hide();
			this._active = false;
            this._closeCallback && this._closeCallback();
		}
	}
});
var SVGNS = "http://www.w3.org/2000/svg";
var XLNS = 'http://www.w3.org/1999/xlink'
/*
var SvgContainer = defineClass("SvgContainer", UIContainer, {
    init: function (container) {
        this._super(container);
        var svg = this._svg = document.createElementNS(svgNS, "svg");
        this._container.appendChild(svg);
        svg.width = this._container.clientWidth;
        svg.height = this._container.clientHeight;
        svg.style.position = "absolute";
        svg.style.background = "#fff"; // 이렇게 하지 않으면 상위 div의 값을 따라간다.
        svg.style.borderStyle = "none";
        svg.style.borderWidth = "0px";
        svg.innerText = "Your browser does not support HTML5 Svg.";
        this._graphics = new SvgGraphics(svg);
        this._dirtyElements = [];
        this._updateRequested = false;
        this.invalidateLayout();
        this._registerEventHandlers(svg);
    },
    measureText: function (font, text) {
    },
    resetSize: function () {
        if (this._width != this._container.clientWidth || this._height != this._container.clientHeight) {
            this._width = this._svg.width = this._container.clientWidth;
            this._height = this._svg.height = this._container.clientHeight;
            this.invalidateLayout();
            trace("resized: " + this._width + ", " + this._height);
        }
    },
    $$_render: function (timestamp, scrollRect, scrollX, scrollY) {
        if (this._updateElements(new Rectangle(0, 0, this._width, this._height))) {
            this.$_drawElements()
        }
    },
    _createRootElement: function () {
        return new RootElement("root", this, this._svg);
    },
    $_invalidateElement: function (element) {
        this._dirtyElements.push(element);
        this.invalidate();
    },
    _updateElements: function (bounds) {
        return true;
    },
    $_drawElements: function () {
        var t = getTimer();
        var cnt = 0;
        for (var i = this._dirtyElements.length; i--;) {
            var elt = this._dirtyElements[i];
            if (elt.visible() && elt.container()) {
                elt.draw(this._graphics);
                cnt++;
            } else {
                elt.validate(true);
            }
        }
        this._dirtyElements.length = 0;
        _console && _trace(">>>>>>>>>>>>>>>>>>>> drawed elements: " + cnt + " in " + (getTimer() - t) + " ms.");
    }
});
var SvgElement = defineClass("SvgElement", EventAware, {
    init: function (name) {
        this._super();
        this._name = name;
        this._parent = null;
        this._children = 0;
    },
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    rotation: 0,
    visible: true,
    alpha: 1,
    name: function () {
        return this._name;
    },
    container: function () {
        return this._parent ? this._parent.container() : null;
    },
    parent: function () {
        return this._parent;
    },
    count: function () {
        return this._children && this._children._length;
    },
    getChild: function (index) {
        if (index < 0 || index >= this.count()) {
            throw new Error("Invalid child index: " + index);
        }
        return this._children[index];
    }
});
*/
var SVG_ALIGN = {
    "left": "start",
    "center": "middle",
    "right": "end"
};
var SVG_VALIGN = {
    "top": "hanging",
    "middle": "middle",
    "bottom": "baseline"
};
var SVG_DY = {
    "top": "1em",
    "middle": ".5em",
    "center": ".5em",
    "bottom": "0"
}
var SVG_DEF_FONT = {
    font: 'Verdana',
    size: 12
}
var SvgGraphics = defineClass("SvgGraphis", null, {
    init: function (svgElement, defs) {
        this._super();
        this._svg = svgElement;
        this._defs = defs;
        this._elt = svgElement;
        this._transforms = [];
        this._trans = null;
    },
    renderOpen: function (element) {
        this._elt = element;
        return this;
    },
    renderClose: function (element) {
        if (element !== this._elt) {
            throw new Error("Invalid render close");
        }
        this._elt = null;
        return this;
    },
    save: function () {
        this._trans = '';
        this._transforms.push(this._trans);
        return this;
    },
    restore: function () {
        var len = this._transforms.length;
        this._transforms.splice(len - 1, 1);
        this._trans = len > 0 ? this._transforms[len - 1] : null;
        return this;
    },
    translate: function (x, y) {
        this._trans += 'translate(' + x + ',' + y + ')';
        return this;
    },
    rotate: function (angle) {
        this._trans += 'rotate(' + (angle * 180 / Math.PI) + ')';
        return this;
    },
    rotateAt: function (angle, x, y) {
        this._trans += 'rotate(' + (angle * 180 / Math.PI) + ',' + x + ',' + y + ')';
        return this;
    },
    scale: function (x, y) {
        this._trans += 'scale(' + x + ',' + y + ')';
        return this;
    },
    clear: function () {
        var child;
        while (child = this._elt.lastChild) {
            this._elt.removeChild(child);
        }
        this._elt === this._svg && this._svg.appendChild(this._defs);
        return this;
    },
    clipRect: function (r) {
        this.clipBounds(r.x, r.y, r.width, r.height);
        return this;
    },
    clipBounds: function (x, y, w, h) {
        var id = 'ld' + SvgGraphics.$_nextId++;
        var clip = _document.createElementNS(SVGNS, 'clipPath');
        clip.setAttribute("id", id);
        var rect = _document.createElementNS(SVGNS, "rect");
        rect.x.baseVal.value = x;
        rect.y.baseVal.value = y;
        rect.width.baseVal.value = w;
        rect.height.baseVal.value = h;
        clip.appendChild(rect);
        this._defs.appendChild(clip);
        return this;
    },
    drawLine: function (stroke, x1, y1, x2, y2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            line.x1.baseVal.value = x1;
            line.x2.baseVal.value = x2;
            line.y1.baseVal.value = y1;
            line.y2.baseVal.value = y2;
            stroke.svg(line);
        }
        return this;
    },
    drawHLine: function (stroke, y, x1, x2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            line.x1.baseVal.value = x1;
            line.x2.baseVal.value = x2;
            line.y1.baseVal.value = y;
            line.y2.baseVal.value = y;
            stroke.svg(line);
        }
        return this;
    },
    drawVLine: function (stroke, x, y1, y2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            line.x1.baseVal.value = x;
            line.x2.baseVal.value = x;
            line.y1.baseVal.value = y1;
            line.y2.baseVal.value = y2;
            stroke.svg(line);
        }
        return this;
    },
    drawLineI: function (stroke, x1, y1, x2, y2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            var d = stroke ? (stroke.width() % 2) / 2 : 0;
            if (x1 == x2) {
                line.x1.baseVal.value = x1 + d;
                line.x2.baseVal.value = x2 + d;
                line.y1.baseVal.value = y1;
                line.y2.baseVal.value = y2;
            } else if (y1 == y2) {
                line.x1.baseVal.value = x1;
                line.x2.baseVal.value = x2;
                line.y1.baseVal.value = y1 + d;
                line.y2.baseVal.value = y2 + d;
            }
            stroke.svg(line);
        }
        return this;
    },
    drawHLineI: function (stroke, y, x1, x2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            y += (stroke.width() % 2) / 2;
            line.x1.baseVal.value = x1;
            line.x2.baseVal.value = x2;
            line.y1.baseVal.value = y;
            line.y2.baseVal.value = y;
            stroke.svg(line);
        }
        return this;
    },
    drawVLineI: function (stroke, x, y1, y2) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "line");
            this._elt.appendChild(line);
            x += (stroke.width() % 2) / 2;
            line.x1.baseVal.value = x;
            line.x2.baseVal.value = x;
            line.y1.baseVal.value = y1;
            line.y2.baseVal.value = y2;
            stroke.svg(line);
        }
        return this;
    },
    drawLines: function (stroke, pts) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "polyline");
            this._elt.appendChild(line);
            var points = [];
            var i;
            if (_isArray(pts) && pts.length >= 2) {
                points.push(pts[0].x + "," + pts[0].y);
                for (i = 1; i < pts.length; i++) {
                    points.push(pts[i].x + "," + pts[i].y);
                }
            } else if (arguments.length >= 5) {
                points.push(arguments[1] + "," + arguments[2]);
                for (i = 3; i < arguments.length - 1; i += 2) {
                    points.push(arguments[i] + "," + arguments[i + 1]);
                }
            }
            line.setAttributeNS(null, 'points', points.join(" "));
            line.style.fill = "none";
            stroke.svg(line);
        }
        return this;
    },
    drawLinesI: function (stroke, pts) {
        if (stroke) {
            var line = _document.createElementNS(SVGNS, "polyline");
            this._elt.appendChild(line);
            var points = [];
            var d = (stroke.width() % 2) / 2;
            var i;
            if (_isArray(pts) && pts.length >= 2) {
                points.push(pts[0].x + "," + pts[0].y);
                for (i = 1; i < pts.length; i++) {
                    points.push(pts[i].x + "," + pts[i].y);
                }
            } else if (arguments.length >= 5) {
                var pts2 = [];
                var len;
                for (i = 1, len = arguments.length; i < len; i++) {
                    pts2[i] = arguments[i] + d;
                }
                points.push(pts2[1] + "," + pts2[2]);
                for (i = 3; i < len - 1; i += 2) {
                    points.push(pts2[i] + "," + pts2[i + 1]);
                }
            }
            line.setAttributeNS(null, 'points', points.join(" "));
            line.style.fill = "none";
            stroke.svg(line);
        }
        return this;
    },
    drawQuadratic: function (stroke, x1, y1, x2, y2, x3, y3) {
        if (stroke) {
            var e = _document.createElementNS(SVGNS, "path");
            e.setAttributeNS(null, 'd', ['M', x1, y1, 'Q', x2, y2, x3, y3].join(' '));
            this._elt.appendChild(e);
            e.style.fill = "none";
            stroke && stroke.svg(e);
        }
        return this;
    },
    drawCurve: function (stroke, pts) {
        if (stroke) {
            var cmds = this.$_getCurvedLinePath(pts, 0, pts.length - 1);
            if (cmds) {
                var e = _document.createElementNS(SVGNS, "path");
                e.setAttributeNS(null, 'd', cmds.join(' '));
                this._elt.appendChild(e);
                e.style.fill = "none";
                stroke && stroke.svg(e);
            }
        }
        return this;
    },
    drawCurvedRange: function (fill, stroke, pts1, pts2) {
        if (pts1 && pts1.length > 1 && pts2 && pts2.length > 1 && (fill || stroke)) {
            var cmds1 = this.$_getCurvedLinePath(pts1, 0, pts1.length - 1, true);
            if (cmds1) {
                var p = pts2[pts2.length - 1];
                cmds1.push("L", p.x, p.y);
                var cmds2 = this.$_getCurvedLinePath(pts2, pts2.length - 1, 0, false);
                if (cmds2) {
                    cmds1 = cmds1.concat(cmds2);
                }
                p = pts1[0];
                cmds1.push("L", p.x, p.y);
                var e = _document.createElementNS(SVGNS, "path");
                e.setAttributeNS(null, 'd', cmds1.join(' '));
                this._elt.appendChild(e);
                stroke && stroke.svg(e);
                fill ? fill.svg(e) : e.style.fill = "none";
            }
        }
        return this;
    },
    $_getCurvedLinePath: function (pts, start, end, moving) {
        if (pts && end != start && pts.length > Math.max(end)) {
            var points = [];
            var reverse = start > end;
            var delta = reverse ? -1 : 1;
            var p = start;
            if (moving || moving === undefined) {
                points.push("M", pts[p].x, pts[p].y);
            }
            if (Math.abs(end - start) == 2) {
                points.push("L", pts[p + delta].x, pts[p + delta].y);
                return points;
            }
            var tension = 0.25;
            var tanLeft = { x: 0, y: 0 };
            var tanRight = { x: 0, y: 0 };
            var v1 = { x: 0, y: 0 };
            var v2 = { x: pts[p + delta].x - pts[p].x, y: pts[p + delta].y - pts[p].y };
            var tan = { x: 0, y: 0 };
            var p1 = { x: 0, y: 0 };
            var p2 = { x: 0, y: 0 };
            var mp = { x: 0, y: 0 };
            var len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            v2.x /= len;
            v2.y /= len;
            var tanLenFactor = pts[p + delta].x - pts[p].x;
            var prevX = pts[p].x;
            var prevY = pts[p].y;
            for (p += delta; p != end; p += delta) {
                v1.x = -v2.x;
                v1.y = -v2.y;
                v2.x = pts[p + delta].x - pts[p].x;
                v2.y = pts[p + delta].y - pts[p].y;
                len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                v2.x /= len;
                v2.y /= len;
                if (v2.x < v1.x) {
                    tan.x = v1.x - v2.x;
                    tan.y = v1.y - v2.y;
                } else {
                    tan.x = v2.x - v1.x;
                    tan.y = v2.y - v1.y;
                }
                var tanlen = Math.sqrt(tan.x * tan.x + tan.y * tan.y);
                tan.x /= tanlen;
                tan.y /= tanlen;
                if (v1.y * v2.y >= 0)
                    tan = { x: 1, y: 0 };
                tanLeft.x = -tan.x * tanLenFactor * tension;
                tanLeft.y = -tan.y * tanLenFactor * tension;
                if (p == (delta + start)) {
                    points.push("Q", pts[p].x + tanLeft.x, pts[p].y + tanLeft.y, pts[p].x, pts[p].y);
                } else {
                    p1.x = prevX + tanRight.x;
                    p1.y = prevY + tanRight.y;
                    p2.x = pts[p].x + tanLeft.x;
                    p2.y = pts[p].y + tanLeft.y;
                    mp.x = (p1.x + p2.x) / 2;
                    mp.y = (p1.y + p2.y) / 2;
                    points.push("Q", p1.x, p1.y, mp.x, mp.y);
                    points.push("Q", p2.x, p2.y, pts[p].x, pts[p].y);
                }
                tanLenFactor = pts[p + delta].x - pts[p].x;
                tanRight.x = tan.x * tanLenFactor * tension;
                tanRight.y = tan.y * tanLenFactor * tension;
                prevX = pts[p].x;
                prevY = pts[p].y;
            }
            points.push("Q", prevX + tanRight.x, prevY + tanRight.y, pts[p].x, pts[p].y);
            return points;
        }
        return null;
    },
    drawRect: function (fill, stroke, r) {
        if (!fill && !stroke) return;
        var rect = _document.createElementNS(SVGNS, "rect");
        this._elt.appendChild(rect);
        rect.x.baseVal.value = r.x;
        rect.y.baseVal.value = r.y;
        rect.width.baseVal.value = r.width;
        rect.height.baseVal.value = r.height;
        fill ? fill.svg(rect) : rect.style.fillOpacity = 0;
        stroke && stroke.svg(rect);
        return this;
    },
    drawRectI: function (fill, stroke, r) {
        if (!fill && !stroke) return;
        var d = stroke ? (stroke.width() % 2) / 2 : 0;
        var rect = _document.createElementNS(SVGNS, "rect");
        rect.x.baseVal.value = r.x + d;
        rect.y.baseVal.value = r.y + d;
        rect.width.baseVal.value = r.width;
        rect.height.baseVal.value = r.height;
        this._elt.appendChild(rect);
        fill ? fill.svg(rect) : rect.style.fillOpacity = 0;
        stroke && stroke.svg(rect);
        return this;
    },
    drawBounds: function (fill, stroke, x, y, w, h) {
        if (!fill && !stroke) return;
        var rect = _document.createElementNS(SVGNS, "rect");
        rect.x.baseVal.value = x;
        rect.y.baseVal.value = h < 0 ? y + h : y;
        rect.width.baseVal.value = w;
        rect.height.baseVal.value = _abs(h);
        this._elt.appendChild(rect);
        fill ? fill.svg(rect) : rect.style.fillOpacity = 0;
        stroke && stroke.svg(rect);
        return this;
    },
    drawBoundsI: function (fill, stroke, x, y, w, h) {
        if (!fill && !stroke) return;
        var d = stroke ? (stroke.width() % 2) / 2 : 0;
        var rect = _document.createElementNS(SVGNS, "rect");
        rect.x.baseVal.value = x + d;
        rect.y.baseVal.value = h < 0 ? y + h + d : y + d;
        rect.width.baseVal.value = w;
        rect.height.baseVal.value = _abs(h);
        this._elt.appendChild(rect);
        fill ? fill.svg(rect) : rect.style.fillOpacity = 0;
        stroke && stroke.svg(rect);
        return this;
    },
    drawCircle: function (fill, stroke, cx, cy, rd) {
        var e = _document.createElementNS(SVGNS, "circle");
        e.cx.baseVal.value = cx;
        e.cy.baseVal.value = cy;
        e.r.baseVal.value = rd;
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawCircleBounds: function (fill, stroke, x, y, w, h) {
        var cx = x + w / 2;
        var cy = y + h / 2;
        var rd = Math.min(w, h) / 2;
        var e = _document.createElementNS(SVGNS, "circle");
        e.cx.baseVal.value = cx;
        e.cy.baseVal.value = cy;
        e.r.baseVal.value = rd;
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawCircleRect: function (fill, stroke, r) {
        this.drawCircleBounds(fill, stroke, r.x, r.y, r.width, r.height);
        return this;
    },
    drawEllipse: function (fill, stroke, x, y, w, h) {
        var e = _document.createElementNS(SVGNS, "ellipse");
        var rx = w / 2;
        var ry = h / 2;
        e.cx.baseVal.value = x + rx;
        e.cy.baseVal.value = y + ry;
        e.rx.baseVal.value = rx;
        e.ry.baseVal.value = ry;
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    /*
     function annularSector(path,options){
     var opts = optionsWithDefaults(options);
     var p = [ // points
     [opts.cx + opts.r2*Math.cos(opts.startRadians),
     opts.cy + opts.r2*Math.sin(opts.startRadians)],
     [opts.cx + opts.r2*Math.cos(opts.closeRadians),
     opts.cy + opts.r2*Math.sin(opts.closeRadians)],
     [opts.cx + opts.r1*Math.cos(opts.closeRadians),
     opts.cy + opts.r1*Math.sin(opts.closeRadians)],
     [opts.cx + opts.r1*Math.cos(opts.startRadians),
     opts.cy + opts.r1*Math.sin(opts.startRadians)],
     ];
     var angleDiff = opts.closeRadians - opts.startRadians;
     var largeArc = (angleDiff % (Math.PI*2)) > Math.PI ? 1 : 0;
     var cmds = [];
     cmds.push("M"+p[0].join());                                // Move to P0
     cmds.push("A"+[opts.r2,opts.r2,0,largeArc,1,p[1]].join()); // Arc to  P1
     cmds.push("L"+p[2].join());                                // Line to P2
     cmds.push("A"+[opts.r1,opts.r1,0,largeArc,0,p[3]].join()); // Arc to  P3
     cmds.push("z");                                // Close path (Line to P0)
     path.setAttribute('d',cmds.join(' '));
     function optionsWithDefaults(o){
     var o2 = {
     cx           : o.centerX || 0,
     cy           : o.centerY || 0,
     startRadians : (o.startDegrees || 0) * Math.PI/180,
     closeRadians : (o.endDegrees   || 0) * Math.PI/180,
     };
     var t = o.thickness!==undefined ? o.thickness : 100;
     if (o.innerRadius!==undefined)      o2.r1 = o.innerRadius;
     else if (o.outerRadius!==undefined) o2.r1 = o.outerRadius - t;
     else                                o2.r1 = 200           - t;
     if (o.outerRadius!==undefined)      o2.r2 = o.outerRadius;
     else                                o2.r2 = o2.r1         + t;
     if (o2.r1<0) o2.r1 = 0;
     if (o2.r2<0) o2.r2 = 0;
     return o2;
     }
     }
     */
    $_arcSector2: function (path, cx, cy, rd2, rd1, startAngle, endAngle) {
        var p = [
            [cx + rd2 * Math.cos(startAngle), cy + rd2 * Math.sin(startAngle)],
            [cx + rd2 * Math.cos(endAngle), cy + rd2 * Math.sin(endAngle)],
            [cx + rd1 * Math.cos(endAngle), cy + rd1 * Math.sin(endAngle)],
            [cx + rd1 * Math.cos(startAngle), cy + rd1 * Math.sin(startAngle)],
        ];
        var angleDiff = endAngle - startAngle;
        var largeArc = (angleDiff % (Math.PI * 2)) > Math.PI ? 1 : 0;
        var cmds = [];
        cmds.push("M", p[0][0], p[0][1]);                           // Move to P0
        cmds.push("A", rd2, rd2, 0, largeArc, 1, p[1][0], p[1][1]); // Arc to  P1
        cmds.push("L", p[2][0], p[2][1]);                           // Line to P2
        cmds.push("A", rd1, rd1, 0, largeArc, 0, p[3][0], p[3][1]); // Arc to  P3
        cmds.push("z");                                             // Close path (Line to P0)
        path.setAttributeNS(null, 'd', cmds.join(' '));
    },
    $_arcSector: function (path, cx, cy, rd, startAngle, endAngle) {
        var p = [
            [cx + rd * Math.cos(startAngle), cy + rd * Math.sin(startAngle)],
            [cx + rd * Math.cos(endAngle), cy + rd * Math.sin(endAngle)]
        ];
        var angleDiff = endAngle - startAngle;
        var largeArc = (angleDiff % (Math.PI * 2)) > Math.PI ? 1 : 0;
        var cmds = [];
        cmds.push("M", cx, cy);                           // Move to P0
        cmds.push("L", p[0][0], p[0][1]);                           // Line to P2
        cmds.push("A", rd, rd, 0, largeArc, 1, p[1][0], p[1][1]); // Arc to  P1
        cmds.push("z");                                             // Close path (Line to P0)
        path.setAttributeNS(null, 'd', cmds.join(' '));
    },
    drawDounut: function (fill, stroke, cx, cy, radius, width) {
        var e = _document.createElementNS(SVGNS, "path");
        var r2 = radius;
        var r1 = radius - width;
        var cmd = [];
        cmd.push("M", cx, cy);
        cmd.push("m", -r2, 0);
        cmd.push("a", r2, r2, 0, 1, 0, r2 * 2, 0);
        cmd.push("a", r2, r2, 0, 1, 0, -r2 * 2, 0);
        cmd.push("z");
        cmd.push("M", cx, cy);
        cmd.push("m", -r1, 0);
        cmd.push("a", r1, r1, 0, 0, 1, r1 * 2, 0);
        cmd.push("a", r1, r1, 0, 0, 1, -r1 * 2, 0);
        cmd.push("z");
        e.setAttributeNS(null, 'd', cmd.join(' '));
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawArcSector2: function (fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
        var e = _document.createElementNS(SVGNS, "path");
        startAngle += Math.PI * 3 / 2 + orgAngle;
        this.$_arcSector2(e, x, y, radiusX, innerRadiusX, startAngle, startAngle + angle);
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawArcSector: function (fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
        var e = _document.createElementNS(SVGNS, "path");
        startAngle += Math.PI * 3 / 2 + orgAngle;
        this.$_arcSector(e, x, y, radiusX, startAngle, startAngle + angle);
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawPolygon: function (fill, stroke, points) {
        var len = points.length;
        var pts = new Array(len);
        for (var i = 0; i < len; i++) {
            var pt = points[i].x + ',' + points[i].y;
            pts[i] = pt;
        }
        var p = _document.createElementNS(SVGNS, "polygon");
        p.setAttributeNS(null, 'points', pts.join(' '));
        this._trans && p.setAttributeNS(null, 'transform', this._trans);
        this._elt.appendChild(p);
        fill ? fill.svg(p) : p.style.fillOpacity = 0;
        stroke && stroke.svg(p);
        return this;
    },
    drawPolygonArray: function (fill, stroke, points) {
        var len = _int(points.length / 2);
        var pts = new Array(len);
        for (var i = 0; i < len; i++) {
            var pt = points[i * 2] + ',' + points[i * 2 + 1];
            pts[i] = pt;
        }
        var p = _document.createElementNS(SVGNS, "polygon");
        p.setAttributeNS(null, 'points', pts.join(' '));
        this._trans && p.setAttributeNS(null, 'transform', this._trans);
        this._elt.appendChild(p);
        fill ? fill.svg(p) : p.style.fillOpacity = 0;
        stroke && stroke.svg(p);
        return this;
    },
    drawHoledPolygonArray: function (fill, stroke, points, hole) {
        var e = _document.createElementNS(SVGNS, "path");
        var i = 0,
            cnt = points.length,
            cmd = [];
        cmd.push("M", points[i++], points[i++]);
        while (i < cnt) {
            cmd.push("L", points[i++], points[i++]);
        }
        cmd.push("z");
        i = hole.length - 1;
        cmd.push("M", hole[i - 1], hole[i]);
        i -= 2;
        while (i > 0) {
            cmd.push("L", hole[i - 1], hole[i]);
            i -= 2;
        }
        cmd.push("z");
        e.setAttributeNS(null, 'd', cmd.join(' '));
        this._elt.appendChild(e);
        fill ? fill.svg(e) : e.style.fillOpacity = 0;
        stroke && stroke.svg(e);
        return this;
    },
    drawText: function(font, fill, text, x, y, align, layout, angle) {
        var t = _document.createElementNS(SVGNS, "text");
        font = font || SVG_DEF_FONT;
        t.setAttributeNS(null, "y", y);
        t.setAttributeNS(null, "dy", SVG_DY[layout || "top"]); // top : 1em, middle: .5em, bottom : "".
        t.setAttributeNS(null, "x", x);
        t.setAttributeNS(null, "text-anchor", SVG_ALIGN[align]);
        t.setAttributeNS(null, "font-family", font.font);
        t.setAttributeNS(null, "font-size", font.size);
        font.deco && t.setAttributeNS(null, "text-decoration", font.deco);
        t.textContent = text;
        fill && fill.svg(t);
        this._elt.appendChild(t);
        if (!isNaN(angle)) {
            t.setAttributeNS(null, "transform", 'rotate(' + (angle * 180 / Math.PI) + ',' + x + ',' + y + ')');
        }
        return this;
    },
    drawTextSh: function(font, fill, shadow, text, x, y, align, layout) {
        var st, t;
        font = font || SVG_DEF_FONT;
        if (shadow) {
            st = _document.createElementNS(SVGNS, "text");
            st.setAttributeNS(null, "y", y + shadow.vert);
            st.setAttributeNS(null, "dy", SVG_DY[layout || "top"]);
            st.setAttributeNS(null, "x", x + shadow.horz);
            st.setAttributeNS(null, "text-anchor", SVG_ALIGN[align]);
            t.setAttributeNS(null, "font-family", font.font);
            st.setAttributeNS(null, "font-size", font.size);
            font.deco && st.setAttributeNS(null, "text-decoration", font.deco);
            st.textContent = text;
            shadow.color.svg(st);
            this._elt.appendChild(st);
        }
        t = _document.createElementNS(SVGNS, "text");
        t.setAttributeNS(null, "y", y);
        t.setAttributeNS(null, "dy", SVG_DY[layout || "top"]);
        t.setAttributeNS(null, "x", x);
        t.setAttributeNS(null, "text-anchor", SVG_ALIGN[align]);
        t.setAttributeNS(null, "font-size", font.size);
        font.deco && t.setAttributeNS(null, "text-decoration", font.deco);
        t.textContent = text;
        fill && fill.svg(t);
        this._elt.appendChild(t);
        return this;
    },
    drawTextRect: function(font, fill, text, r, align, layout) {
        this.drawText(font, fill, text, r.x + r.width / 2, r.y + r.height / 2, align, layout);
        return this;
    },
    drawTextBounds: function(font, fill, text, x, y, w, h, align, layout) {
        this.drawText(font, fill, text, x + w / 2, y + h / 2, align, layout);
        return this;
    },
    drawTextRectA: function(font, fill, text, r, angle) {
        this.drawTextBoundsA(font, fill, text, r.x, r.y, r.width, r.height, angle);
        return this;
    },
    drawTextBoundsA: function(font, fill, text, x, y, w, h, angle) {
        x += w / 2;
        y += h / 2;
        this.drawText(font, fill, text, x, y, "center", "middle", angle);
        return this;
    },
    drawImage: function (image, x, y, w, h) {
        var img = _document.createElementNS(SVGNS, "image");
        img.setAttributeNS(XLNS, 'href', image.src);
        img.setAttributeNS(null, 'preserveAspectRatio', 'none');
        img.setAttributeNS(null, 'x', x);
        img.setAttributeNS(null, 'y', y);
        img.setAttributeNS(null, 'width', w);
        img.setAttributeNS(null, 'height', h);
        /*
        img.x.baseVal.value = x;
        img.y.baseVal.value = y;
        img.width.baseVal.value = w;
        img.height.baseVal.value = h;
        */
        this._elt.appendChild(img);
        return this;
    },
    drawImageAlpha: function (image, alpha, x, y, w, h) {
        var img = _document.createElementNS(SVGNS, "image");
        img.setAttributeNS(XLNS, 'href', image.src);
        img.setAttributeNS(null, 'preserveAspectRatio', 'none');
        img.setAttributeNS(null, 'x', x);
        img.setAttributeNS(null, 'y', y);
        img.setAttributeNS(null, 'width', w);
        img.setAttributeNS(null, 'height', h);
        img.setAttributeNS(null, 'opacity', alpha);
        /*
         img.x.baseVal.value = x;
         img.y.baseVal.value = y;
         img.width.baseVal.value = w;
         img.height.baseVal.value = h;
         */
        this._elt.appendChild(img);
        return this;
    },
    drawImageI: function (image, x, y, w, h) {
        var img = _document.createElementNS(SVGNS, "image");
        x = Math.floor(x);
        y = Math.floor(y);
        img.setAttributeNS(XLNS, 'href', image.src);
        img.setAttributeNS(null, 'preserveAspectRatio', 'none');
        img.setAttributeNS(null, 'x', x);
        img.setAttributeNS(null, 'y', y);
        img.setAttributeNS(null, 'width', w);
        img.setAttributeNS(null, 'height', h);
        /*
         img.x.baseVal.value = x;
         img.y.baseVal.value = y;
         img.width.baseVal.value = w;
         img.height.baseVal.value = h;
         */
        this._elt.appendChild(img);
        return this;
    },
    drawImageAlphaI: function (image, alpha, x, y, w, h) {
        var img = _document.createElementNS(SVGNS, "image");
        x = Math.floor(x);
        y = Math.floor(y);
        img.setAttributeNS(XLNS, 'href', image.src);
        img.setAttributeNS(null, 'preserveAspectRatio', 'none');
        img.setAttributeNS(null, 'x', x);
        img.setAttributeNS(null, 'y', y);
        img.setAttributeNS(null, 'width', w);
        img.setAttributeNS(null, 'height', h);
        img.setAttributeNS(null, 'opacity', alpha);
        this._elt.appendChild(img);
        return this;
    },
    aL: function (image, x, y, w, h) {
        this.drawImage(image, x, y, w, h);
        return this;
    }/*,
    $_getLinearGradient: function (fill) {
        var doc = _document;
        var svg = this._svg;
        var defs = this._defs;
        var id = 'lg' + fill.$_hash;
        var g = doc.getElementById(id);
        if (!g) {
            g = doc.createElementNS(SVGNS, 'linearGradient');
            g.setAttribute("id", id);
            g.setAttributeNS(null, "x1", "0%");
            g.setAttributeNS(null, "y1", "0%");
            g.setAttributeNS(null, "x2", "100%");
            g.setAttributeNS(null, "y2", "0%");
            var stop1 = doc.createElementNS(SVGNS, "stop");
            stop1.setAttributeNS(null, "offset", "0%");
            stop1.setAttributeNS(null, "style", "stop-color:" + fill._colors[0].value());
            g.appendChild(stop1);
            var stop2 = doc.createElementNS(SVGNS, "stop");
            stop2.setAttributeNS(null, "offset", "100%");
            stop2.setAttributeNS(null, "style", "stop-color:" + fill._colors[1].value());
            g.appendChild(stop2);
            defs.appendChild(g);
        }
        return "url(#" + id + ")";
    }
    */
}, {
    $_nextId: 10000,
});
var SvgSprite = defineClass("SvgSprite", null, {
    init: function (parent, pool) {
        this._super();
        var svg = this._svg = document.createElementNS(SVGNS, "svg");
        var defs = document.createElementNS(SVGNS, 'defs');
        svg.appendChild(defs);
        svg.$_svgPool = pool;
        parent && parent._dom.appendChild(svg);
        var css = svg.style;
        css.position = "absolute";
        css.background = '';// "#fff"; // 이렇게 하지 않으면 상위 div의 값을 따라간다.
        css.pointerEvents = "none";
        svg.contentText = svg.innerText = "Your browser does not support HTML5 Svg.";
        this._width = this._height = 0;
        this._graphics = new SvgGraphics(svg, defs);
    },
    setParent: function (element) {
        element._dom.appendChild(this._svg);
    },
    setBounds: function (x, y, width, height) {
        var svg = this._svg;
        svg.width = this._width = width;
        svg.height = this._height = height;
        svg.style.left = x + 'px';
        svg.style.top = y + 'px';
        svg.setAttributeNS(null, "width", width);
        svg.setAttributeNS(null, "height", height);
    },
    getGraphics: function (clear, r) {
        clear && this._graphics.clear();
        r && this.setBounds(r.x, r.y, r.width, r.height);
        return this._graphics;
    },
    render: function (callback) {
        var svg = this._svg;
        var g = this._graphics;
        g.renderOpen(svg);
        g.clear();
        callback(svg, g, this._width, this._height);
        g.renderClose(svg);
    },
    renderAdd: function (callback) {
        var svg = this._svg;
        var g = this._graphics;
        g.renderOpen(svg);
        callback(svg, g, this._width, this._height);
        g.renderClose(svg);
    }
});
var SingleTouchTracker = defineClass("SingleTouchTracker", null, {
    init: function () {
        this._super();
    },
    start: function (x, y) {
    },
    move: function (x, y) {
    },
    stop: function (x, y) {
    }
});
var $_TAP_THRESHOLD = 4;            // pixels
var $_DOUBLE_TAP_THRESHOLD = 300;   // milliseconds
var $_LONG_TAP_THRESHOLD = 700;     // milliseconds
var $_SWIPE_THRESHOLD = 20;         // pixels
var SingleTouchManager = defineClass("SingleTouchManager", TouchManager, {
    init: function (container) {
        this._super(container);
        this._touchId = undefined;
        this._started = null;
        this._seconded = null;
        this._startX = NaN;
        this._startY = NaN;
        this._tapped = 0;
        this._dragging = false;
        this._prevX = NaN;
        this._prevY = NaN;
        this._longTapTimer = undefined;
        this._tracker = null;
        this._events = [];
    },
    touchHandler: null,
    tapHandler: null,
    doubleTapHandler: null,
    longTapHandler: null,
    dragStartHandler: null,
    dragHandler: null,
    dragEndHandler: null,
    swipeHandler: null,
    touchStart: function (evt/*TouchEvent*/) {
        clearTimeout(this._longTapTimer);
        var touches = evt.changedTouches;
        if (touches.length > 0) {
            var t = this._toOffset(touches[0]);
            if (this._tracker) {
                this._tracker.stop(t.x, t.y);
                this._tracker = null;
            }
            this._touchId = t.identifier;
            this._dragging = false;
            if (this._touchHandler && (this._tracker = this._touchHandler(t.x, t.y))) {
                this._tracker.start(t.x, t.y);
                return true;
            }
            if (this._tapped == 0) {
                this._started = getTimer();
                this._prevX = this._startX = t.x;
                this._prevY = this._startY = t.y;
            } else {
                this._seconded = getTimer();
                this._prevX = t.x;
                this._prevY = t.y;
            }
            this._events = [];
            this._events.push({ x: t.x, y: t.y, t: evt.timeStamp });
            this._longTapTimer = setTimeout(function () {
                if (this._longTapHandler && this._longTapHandler(this._startX, this._startY)) {
                    this._touchId = undefined;
                    this._tapped = 0;
                }
            }.bind(this), $_LONG_TAP_THRESHOLD);
        } else {
            alert("no touch ?");
        }
        return false;
    },
    touchMove: function (evt) {
        var t = this.$_findTouch(evt);
        if (t) {
            if (this._tracker) {
                this._tracker.move(t.x, t.y);
                return true;
            }
            if (this._dragging) {
                this._dragHandler && this._dragHandler(this._prevX, this._prevY, t.x, t.y);
            } else if (Math.abs(this._prevX - t.x) > $_TAP_THRESHOLD || Math.abs(this._prevY - t.y) > $_TAP_THRESHOLD) {
                clearTimeout(this._longTapTimer);
                this._tapped = 0;
                this._dragging = true;
                this._dragStartHandler && this._dragStartHandler(this._startX, this._startY, t.x, t.y);
            }
            this._prevX = t.x;
            this._prevY = t.y;
            this._events.push({ x: t.x, y: t.y, t: evt.timeStamp });
            if (this._events.length > 30) this._events.splice(0, 15);
            return true;
        }
        return false;
    },
    touchEnd: function (evt) {
        clearTimeout(this._longTapTimer);
        if (this._touchId === undefined) {
            return;
        }
        var t = this.$_findTouch(evt);
        if (t) {
            if (this._tracker) {
                this._tracker.stop(t.x, t.y);
            } else if (this._dragging) {
                this._touchId = undefined;
                this._tapped = 0;
                this._swipeHandler && this.$_checkSwipe();
                this._dragEndHandler && this._dragEndHandler(t.x, t.y);
            } else if (this._tapped == 0) {
                this._tapped = 1;
                this._tapHandler && this._tapHandler(this._startX, this._startY);
            } else if (this._tapped == 1) {
                this._touchId = undefined;
                var t = getTimer();
                if (t - this._started < $_DOUBLE_TAP_THRESHOLD) {
                    this._tapped = 0;
                    this._doubleTapHandler && this._doubleTapHandler(this._startX, this._startY);
                } else {
                    this._tapped = 1;
                    this._started = this._seconded;
                    this._startX = this._prevX;
                    this._starty = this._prevY;
                    this._tapHandler && this._tapHandler(this._prevX, this._prevY);
                }
            } else {
                alert("touch end");
            }
        }
        this._tracker = null;
    },
    touchCancel: function (evt) {
        clearTimeout(this._longTapTimer);
        var t = this.$_findTouch(evt);
        if (t) {
            if (this._tracker) {
                this._tracker.stop(t.x, t.y);
            }
        }
    },
    $_findTouch: function (evt) {
        var touches = evt.changedTouches;
        for (var i = 0; i < touches.length; i++) {
            var t = touches[i];
            if (t && t.identifier == this._touchId) {
                return this._toOffset(t);
            }
        }
        return null;
    },
    $_checkSwipe: function () {
        /*
        var d =  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        var a = Math.round(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
        if (a < 0) a = 360 + a;
        alert(a + ", " + this._velocity);
        */
        var events = this._events;
        var cnt = events.length;
        if (cnt < 2) return;
        var e2 = events[cnt - 1];
        var e1 = events[cnt - 2];
        for (var i = cnt - 3; i >= 0; i--) {
            if (e2.t - e1.t > 100) {
                break;
            }
            e1 = events[i];
        }
        var x1 = e1.x;
        var y1 = e1.y;
        var x2 = e2.x;
        var y2 = e2.y;
        var d =  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        var dt = Math.max(16, e2.t - e1.t);
        var v = d / dt;
        var minv = 0.1;
        var friction = 0.998;
        if (v > minv) {
            var duration = Math.log(minv / v) / Math.log(friction);
            var distance = v * (1 - Math.pow(friction, duration + 1)) / (1 - friction);
            var dir = "right";
            var a = Math.round(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
            if (a < 0) a = 360 + a;
            if (a > 45 && a <= 135) dir = "bottom";
            else if (a > 135 && a <= 225) dir = "left";
            else if (a > 225 && a <= 315) dir = "top";
            this._swipeHandler(duration, distance, dir);
        }
    }
});
var _forbidden_hosts = [
    12354   // 12.33.22.22
];
var _licsond;
var CryptoJS=function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
    r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k<a;k++)c[j+k>>>2]|=(e[k>>>2]>>>24-8*(k%4)&255)<<24-8*((j+k)%4);else if(65535<e.length)for(k=0;k<a;k+=4)c[j+k>>>2]=e[k>>>2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
    32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
        2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
    q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
        a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
    e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
    _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
        f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
            m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
            E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
    l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
    finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
    c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
    e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
    this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
    1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
    decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
    b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
    16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
    d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
var $$_licd;
var _lic = CryptoJS.enc.Base64.parse(DataLudiLic);
_lic = CryptoJS.enc.Utf8.stringify(_lic);
_lic = CryptoJS.AES.decrypt(_lic, "kji_babo").toString(CryptoJS.enc.Utf8);
var $$_lic = JSON.parse(_lic);
var $$_licdom = $$_lic.domain = $$_lic.domain.split(';');
$$_loc = $$_loc["hostname"];
var GridLocale = function (lang) {
    this.lang = lang;
    this.dataFieldIndexOutOfBounds = "Data field index is out of bounds.";  //DataFilterRuntime.evaluateIndexerI,DataRowValidationRuntime.evaluateIndexerI
    this.valueIndexOutOfBounds = "Value index is out of bounds.";  //DataFilterRuntime.evaluateIndexerI,DataRowValidationRuntime.evaluateIndexerI
    this.emptyGridMessage = "You can set a message displaying here with DisplayOptions.emptyGridMessage property.";
    this.emptyDataMessage = "No data is loaded.";
    this.invalidDerivedFieldType = 'DerivedField는 object 자료형일 수 없습니다.';
    this.deleteRowsConfirm = "Are you sure you want to delete the selected row(s)?"; // EditOptions.getDeleteRowsMessage
    this.sortingToast = "Sorting...";                   // OperateOptions
    this.filteringToast = "Filtering...";               // OperateOptions
    this.groupingToast = "Grouping...";                 // OperateOptions
    this.completeEditing = "Please complete the editing first.";                    // GridBase.deleteSelection
    this.invalidInputFormat = "Input format is not invalid.";                       // EditController.commitEditor
    this.minLengthRequired = "The input should be at least ${length} characters.";  // EditController.commitEditor
    this.invalidCode128Char = "Invalid code128 charactor.";                         // Code128._convert
    this.invalidcode39Char = "Invalid code39 charactor.";                           // Code39._parse
    this.columnFilterExists = "Column filter already exists: "; // ColumnFilterCollection.$_checkName
    this.exporting = "Exporting...";
    /*
    this.nullFieldNameMesssage = "Field name must be exist."; //DataField.setFieldName, DataSet.$_addField
    this.clientEditingErrorMessage = "Client is editing (call grid.commit() or grid.cancel() first)";//ClientEditingError.message
    this.alreadyExistFieldNameMessage = "fieldName is already exists: ";//DataSet.$_addField
    this.invalidFieldIndexMessage = "Invalid field index: ";//DataSet._checkFieldIndex
    this.indexOutofBoundsMessage = "index is out of bounds:";//DataSet.$_internalInsertField
    this.nullDataFieldMessage = "Data field is not exists:"; //DataFieldRuntime.$_getField, DataRowValidationRuntime.evaluateIndexerS
    this.invalidFieldNameMessage = "Invalid field name or index: "; //FieldTrigger.init
    this.rowOutofBoundsMessage = "row is out of bounds: ";//GridDataSet.insertRow, GridDataSet._checkRowIndex
    this.indexInInvalidMessage = "index is invalid: ";//GroupRow.getItem, TreeDataSet.insertRow
    this.index1OutOfRangeMessage = "index1 is out of range: "; //GroupItem._exchangeItems
    this.index2OutOfRangeMessage = "index2 is out of range: "; //GroupItem._exchangeItems
    this.index1OutOfRangeMessage = "index1 is out of bounds: "; //DefaultRowProvider.exchange
    this.index2OutOfRangeMessage = "index2 is out of bounds: "; //DefaultRowProvider.exchange
    this.itemProviderNotEditingMessage = "itemProvider is not editing"; //EditableRowProvider._checkEditing
    this.itemProviderAlreadyEditingMessage = "itemProvider is already editing"; //EditableRowProvider._checkNotEditing
    this.itemIsNullMessage = "item is null"; //EditableRowProvider._beginUpdate
    this.dataProviderNullMessage = "data provider is null"; //EditableRowProvider._commitEdit
    this.fieldOutOfBoundsMessage = "field index is out of bounds: "; //EditableRowProvider.serValue, getData, setData, TreeEditItem.setValue
    this.LookupTableLevelsMessage = "LookupTable levels must be equal or greater than 1";
    this.keysLengthMessage = "Keys length must be ";
    this.keysLengthGreaterThanMessage = "Keys length must be equals or greate than ";
    this.invalidVisibeIndexMessage = "Invalid visible index: ";
    this.notVisibleGroupMemberColumn = "Column is not a visible group member";
    this.columnIsNullMessage = "Column is null";
    this.columnAlreadyContainedMessage = "Column is already contained";
    this.newIndexisInvalidMessage = "newIndex is invalid: ";
    this.viewIsNullMessage = "View is null";
    this.invalidRowGroupIndicatorMessage = "rowgroup indicator index is invalid: ";
    this.invalidMergedGroupFooterIndex = "Invalid MergedGroupFooter index: ";
    this.columnIsdupulicatedMessage = "Column is dupulicated: "
    this.invalidColumnLayoutCollectionMessage = "Invalid ColumnLayoutCollection index: ";
    this.notDataRootColumnMessage = "is not root column.";
    this.invalidLookupSourceMessage = "Invalid lookup source id: ";
    this.beforeDeletingMessage = "Commit or cancel editing before deteting.";
    this.itemIsEditingMessage = "Item is editing";
    this.rowProviderNotNullMessage = "RowProvider can not be null";
    this.targetIsNullMessage = "target is null";
    this.valueIndexOutOfBoundsMessage = "value index out of bounds: ";
    this.unkownItemTypeMessage = "unkown item type";
    this.unkownTreeItemTypeMessage = "unkown tree item type";
    this.notSupportedOnBrowserMessage = "not supported on this browser";
    this.childIsNullMessage = "child is null";
    this.invalidInsertIndexMessage = "Insert index is invalid: ";
    this.rowDataNotLoadedMessage = "Row data is not loaded";
    this.invalidRowCountMessage = "Invalid row count";
    */
};
GridLocale.getLocale = function (lang) {
    return GridLocale[lang] || GridLocale.en;
};
GridLocale.setLanguage = function (lang) {
    GridLocale._default = GridLocale.getLocale(lang || $_language);
};
GridLocale.setLocale = function (lang, locale) {
    if (lang && _isObject(locale)) {
        GridLocale[lang] = _extend(new GridLocale(lang), locale);
        switch (lang) {
            case 'ja':
                GridLocale.jp = GridLocale.ja;
                break;
            case 'jp':
                GridLocale.ja = GridLocale.jp;
                break;
            case 'zh':
                GridLocale.cn = GridLocale.zh;
                break;
            case 'cn':
                GridLocale.zh = GridLocale.cn;
                break;
        }
    }
};
GridLocale.en = _extend(new GridLocale("en"), {
});
GridLocale.ko = GridLocale.kr = _extend(new GridLocale("ko"), {
    dataFieldIndexOutOfBounds: "데이터필드 인덱스가 범위를 벗어났습니다.",
    valueIndexOutOfBounds: "값 인덱스가 범위를 벗어났습니다.",
    emptyGridMessage: "이 곳에 표시할 메시지를 DisplayOptions.emptyGridMessage 속성으로 설정합니다.",
    emptyDataMessage: "조회된 데이터가 없습니다.",
    invalidDerivedFieldType: 'DerivedField는 object 자료형일 수 없습니다.',
    deleteRowsConfirm: '선택된 행(들)을 삭제하시겠습니까?',
    sortingToast: "정렬 중...",
    filteringToast: "필터링 중...",
    groupingToast: "그룹핑 중...",
    completeEditing: "먼저 편집을 완료 하십시오.",
    invalidInputFormat: "잘못된 입력 형식입니다.",
    minLengthRequired: "최소 ${length} 문자가 입력돼야 합니다.",
    invalidCode128Char: "인식할 수 없는 code128 문자입니다.",
    invalidcode39Char: "인식할 수 없는 code39 문자입니다.",
    columnFilterExists: "이미 존재하는 컬럼 필터입니다: "
});
GridLocale._default = GridLocale.getLocale($_language);
var ScrollButtonLocation = _enum('ScrollButtonLocation', {
    NORMAL: 'normal',
    NEAR: 'near',
    FAR: 'far',
    HIDDEN: 'hidden'
});
var ScrollBarIndent = _enum('ScrollBarIndent', {
    NONE: 'none',
    HEADER: 'header',
    FIXED: 'fixed'
});
var ValueType = _enum('ValueType', {
	TEXT: "text",
	NUMBER: "number",
	BOOLEAN: "boolean",
	DATETIME: "datetime",
	OBJECT: "object"
});
var DataRowState = _enum('DataRowState', {
	NONE: "none",
	CREATED: "created",
	UPDATED: "updated",
	DELETED: "deleted",
	CREATE_AND_DELETED: "createAndDeleted",
	isNone: function (value) {
		return !value || value == DataRowState.NONE;
	},
	isDeleted: function (value) {
		return value == DataRowState.DELETED || value == DataRowState.CREATE_AND_DELETED;
	}
});
var DataPendingState = _enum('DataPendingState', {
	NONE: "none",
	INSERT_ROW: "insertRow",
	INSERT_ROWS: "insertRows",
	UPDATE_ROW: "updateRow",
	UPDATE_ROWS: "updateRows",
	DELETE_ROW: "deleteRow",
	DELETE_ROWS: "deleteRows"
});
var DataFillMode = _enum('DataFillMode', {
	SET: "set",
	APPEND: "append",
	INSERT: "insert",
	UPDATE: "update"
});
var DataRestoreMode = _enum('DataRestoreMode', {
	NONE: "none",
	AUTO: "auto",
	EXPLICIT: "explicit"
});
var ColumnCalcRange = _enum('ColumnCalcRange', {
    ROWS: "rows",
    FIRST: "first",
	LAST: "last",
    LOWER: "lower",
    UPPER: "upper",
    LOWER_BOUNDS: "lowerBounds",
	UPPER_BOUNDS: "upperBounds"
});
var ColumnCalcBounds = _enum('ColumnCalcBounds', {
    GRID: "grid",
    GROUP: "group"
});
var TextInputCase = _enum('TextInputCase', {
	NORMAL: "normal",
	UPPER: "upper",
	LOWER: "lower",
	DEFAULT: "default"
});
var GridRowState = _enum('GridRowState', {
	NORMAL: "normal",
	FOCUSED: "focused",
	UPDATING: "updating",
	INSERTING: "inserting",
	APPENDING: "appending",
	isEditing: function (state) {
		return state == GridRowState.UPDATING || state == GridRowState.INSERTING || state == GridRowState.APPENDING;
	},
	isInserting: function (state) {
		return state == GridRowState.INSERTING || state == GridRowState.APPENDING;
	},
    isUpdating: function (state) {
        return state == GridRowState.UPDATING;
    }
});
var PagingSource = _enum('PagingSource', {
	DATA_ROWS: "dataRows",
	GRID_ROWS: "gridRows"
});
var ColumnGroupLayout = _enum('ColumnGroupLayout', {
	HORIZONTAL: "horizontal",
	VERTICAL: "vertical"
});
var ButtonState = _enum('ButtonState', {
	UP: 0,
	HOVER: 1,
	DOWN: 2
});
var HandleVisibility = _enum('HandleVisibility', {
	VISIBLE: "visible",
	HOVERED: "hovered",
	ALWAYS: "always",
	HIDDEN: "hidden"
});
var SortMode = _enum('SortMode', {
    AUTO: "auto",
    EXPLICIT: "explicit"
});
var SortStyle = _enum('SortStyle', {
	NONE: "none",
	EXCLUSIVE: "exclusive",
	INCLUSIVE: "inclusive",
	REVERSE: "reverse"
});
var SortDirection = _enum('SortDirection', {
	ASCENDING: "ascending",
	DESCENDING: "descending"
});
var SortCase = _enum('SortCase', {
    SENSITIVE: "sensitive",
    INSENSITIVE: "insensitive"
});
var FilterMode = _enum('FilterMode', {
    AUTO: "auto",
    EXPLICIT: "explicit"
});
var RowGroupDisplayMode = _enum('RowGroupDisplayMode', {
    BANDED: "banded",
    BOXED: "boxed",
    MERGED: "merged"
});
var CellButton = _enum('CellButton', {
	NONE: "none",
	ACTION: "action",
	POPUP: "popup"
});
var ButtonVisibility = _enum('ButtonVisibility', {
    ALWAYS: "always",
    DEFAULT: "default",
    VISIBLE: "visible",
    CURRENT: "current",
    HIDDEN: "hidden"
});
var ButtonPosition = _enum('ButtonPosition', {
    DEFAULT: "default",
    LEFT: "left",
    RIGHT: "right"
});
var LookupCase = _enum('LookupCase', {
	SENSITIVE: "sensitvie",
	INSENSITIVE: "insensitive",
	LOWER: "lower",
	UPPER: "upper"
});
var RowIndicatorValue = _enum('RowIndicatorValue', {
	NONE: "none",
	ROW_INDEX: "rowIndex",
	DATA_INDEX: "dataIndex"
});
var DataStateDisplay = _enum('DataStateDisplay', {
	HIDDEN: "hidden",
	NEAR: "near",
	FAR: "far"
});
var GridFitStyle = _enum('GridFitStyle', {
	NONE: "none",
	EVEN: "even",
	EVEN_FILL: "evenFill",
	FILL: "fill"
});
var RowGroupAdornments = _enum('RowGroupAdornments', {
	BOTH: "both",
	HEADER: "header",
	FOOTER: "footer",
	NONE: "none",
	isHeader: function (v) {
		return v == "both" || v == "header";
	},
	isFooter: function (v) {
		return v == "both" || v == "footer";
	}
});
var RowGroupCellDisplay = _enum('RowGroupCellDisplay', {
	NORMAL: "normal",
	MERGE: "merge",
	HIDE: "hide"
});
var RowGroupFooterVisibility = _enum('RowGroupFooterVisibility', {
	ALWAYS: "always",
	MULTI_ROWS_ONLY: "multiRowsOnly"
});
var SelectionMode = _enum('SelectionMode', {
	NONE: "none",
	SINGLE: "single",
	EXTENDED: "extended"
});
var SelectionStyle = _enum('SelectionStyle', {
	BLOCK: "block",
	ROWS: "rows",
	COLUMNS: "columns",
	SINGLE_ROW: "singleRow",
	SINGLE_COLUMN: "singleColumn",
	SINGLE: "single",
	NONE: "none",
	isSingle: function (value) {
		return value && (value == SelectionStyle.SINGLE_ROW || value == SelectionStyle.SINGLE_COLUMN || value == SelectionStyle.SINGLE);
	},
	isRow: function (value) {
		return value && (value == SelectionStyle.ROWS || value == SelectionStyle.SINGLE_ROW);			
	},
	isColumn: function (value) {
		return value && (value == SelectionStyle.COLUMNS || value == SelectionStyle.SINGLE_COLUMN);			
	}
});
var SelectionDisplay = _enum('SelectionDisplay', {
	MASK: "mask",
	CELL: "cell"
});
var HeaderItemLocation = _enum('HeaderItemLocation', {
	DEFAULT: "default",
    NONE: "none",
    LEFT_SIDE: "leftSide",
    RIGHT_SIDE: "rightSide",
    TOP_SIDE: "topSide",
    BOTTOM_SIDE: "bottomSide",
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
    CENTER: "center",
	isHorz: function (v) {
		return _included(v, HeaderItemLocation.LEFT_SIDE, HeaderItemLocation.LEFT, HeaderItemLocation.RIGHT_SIDE, HeaderItemLocation.RIGHT);
	},
	isHorzSide: function (v) {
		return _included(v, HeaderItemLocation.LEFT_SIDE, HeaderItemLocation.RIGHT_SIDE);
	}
});
var SubTextLocation = _enum('SubTextLocation', {
    DEFAULT: "default",
    NONE: "none",
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
	isHorz: function (v) {
		return _included(v, SubTextLocation.LEFT, SubTextLocation.RIGHT);
	}
    /*,
	LEFT_FILL: "leftFill",
	RIGHT_FILL: "rightFill",
	UPPER_FILL: "upperFill",
	LOWER_FILL: "lowerFill"
	*/
});
var SearchOptions = function (source) {
	this.allFields = true;
	this.caseSensitive = false;
	this.partialMatch = false;
	source && _extend(this, source);
};
var SearchCellOptions = function (source) {
	this.caseSensitive = false;
	this.partialMatch = false;
	source && _extend(this, source);
};
var ImageDisplay = _enum('ImageDisplay', {
    DEFAULT: "default",
    CENTER: "center",
    BOTH: "both",
    WIDTH: "width",
    HEIGHT: "height",
    AUTO: "auto",
    REPEAT: "repeat",
    REPEATX: "repeatx",
    REPEATY: "repeaty",
});
var CheckLabelPosition = _enum('CheckLabelPosition', {
	HIDDEN: "hidden",
	RIGHT: "right",
	LEFT: "left",
	BOTTOM: "bottom",
	TOP: "top"
});
var IndicatorCurrentShape = _enum('IndicatorCurrentShape', {
	DEFAULT: "default",
	TRIANGLE: "triangle",
	CIRCLE: "circle"
});
var SortOrderVisibility = _enum('SortOrderVisibility', {
	INHERIT: "inherit",
	VISIBLE: "visible",
	HIDDEN: "hidden"
});
var CustomGroupItemType = _enum('CustomGroupItemType', {
	HEADER: "header",
	FOOTER: "footer"
});
var CustomGridItemType = _enum('CustomGridItemType', {
	HEADER: "header",
	FOOTER: "footer"
});
var  RowHoverMaskExtent = _enum('RowHoverMaskExtent', {
	INDICATOR_AND_DATA: "indicatorAndData",
	INDICATOR_AND_FILL: "indicatorAndFill",
	CHECK_AND_DATA: "checkAndData",
	CHECK_AND_FILL: "checkAndFill",
	DATA: "data",
	FILL: "fill",
	CELL: "cell"
});
var ListItemDisplay = _enum('ListItemDisplay', {
    DEFAULT: 'default',
    VALUE_LABEL: 'valueLabel',
    LABEL_VALUE: 'labelValue',
    subLabeled: function (v) {
        return v === ListItemDisplay.VALUE_LABEL || v === ListItemDisplay.LABEL_VALUE;
    }
});
var ImeMode = _enum('ImeMode', {
    ACTIVE: 'active',
    AUTO: 'auto',
    DISABLED: 'disabled',
    INACTIVE: 'inactive'
});
var DateTimeReader = function (format) {
	var _format = null;
	var _type = 0;
	var _parser = new DateTimeParser();
	var _parse = function (fmt) {
		if (fmt) {
			var s = fmt.toLowerCase();
			_type = Math.max(0, DateTimeReader.FORMATS.indexOf(s));
			if (_type == 0) {
				_parser.setFormat(fmt);
			}
		}
	};
	this.format = function () {
		return _format;
	};
	this.setFormat = function (value) {
		if (value != _format) {
			_format = value;
			_parse(value);
		}
	};
	this.amText = function () {
		return _parser.amText();
	};
	this.setAmText = function (value) {
		_parser.setAmText(value);
	};
	this.pmText = function () {
		return _parser.pmText();
	};
	this.setPmText = function (value) {
		_parser.setPmText(value);
	};
	this.baseYear = function () {
		return _parser.baseYear();
	};
	this.setBaseYear = function (value) {
		_parser.setBaseYear(value);
	};
    this.zoneDelta = function () {
        return _parser.zoneDelta()
    };
    this.setZoneDelta = function (value) {
        _parser.setZoneDelta(value);
    };
	this.toDate = function (value) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
		var d = value;
        if (!(d instanceof Date)) {
			var s = String(value);
			if (s) {
				switch (_type) {
					case 0:
						d = _parser.parse(s/*, strict*/);
						break;
					case 1:
						d = ISODateTimeParser.parse(s);
						break;
					case 2:
					default:
						d = new Date(s);
						break;
				}
			}
            if (d && isNaN(d.getTime())) {
                d = null;
            }
		}
        return d;
	};
	this.setFormat(format);
};
DateTimeReader.FORMATS = ["custom", "iso", "platform"];
DateTimeReader.Default = new DateTimeReader("yyyy/MM/dd HH:mm:ss");
DateTimeReader.Default.setAmText("AM");
DateTimeReader.Default.setPmText("PM");
DateTimeReader.Default.setBaseYear(2000);
var IconElement = defineClass("IconElement", UIElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._image = null;
    },
    setImage: function (value) {
        if (value != this._image) {
            this._image = value;
            this.invalidate();
        }
    },
    iconWidth: function () {
        return this._image ? this._image.width : 0;
    },
    iconHeight: function () {
        return this._image ? this._image.height : 0;
    },
    _doDraw: function (g) {
        var img = this._image;
        if (img) {
            var w = Math.min(this.width(), img.width);
            var h = Math.min(this.height(), img.height);
            var x = (this.width() - w) / 2;
            var y = (this.height() - h) / 2;
            g.drawImage(img, x, y, w, h);
        }
    },
    _doDrawHtml: function () {
        var svg = this._svg;
        if (!svg) {
            svg = this._svg = new SvgSprite(this, this.container());
        }
        this._doDraw(svg.getGraphics(true));
    }
});
var GridSummarizer = defineClass("GridSummarizer", null, {
    init: function () {
        this._super();
    },
    getCount: function () {
    },
    getSum: function (field) {
    },
    getMax: function (field) {
    },
    getMin: function (field) {
    },
    getAvg: function (field) {
    },
    getVar: function (field) {
    },
    getVarp: function (field) {
    },
    getStdev: function (field) {
    },
    getStdevp: function (field) {
    },
    summarize: function (scope, callback) {
    },
    summarizeGroup: function (scope, group, callback) {
    }
});
var DefaultSummarizer = defineClass("DefaultSummarizer", GridSummarizer, {
    init: function(provider) {
        this._super();
        this._provider = provider;
    },
    getCount: function(field) {
        return this._provider.getNumber(field);
    },
    getSum: function(field) {
        return this._provider.getSum(field);
    },
    getMax: function(field) {
        return this._provider.getMax(field);
    },
    getMin: function(field) {
        return this._provider.getMin(field);
    },
    getAvg: function(field) {
        return this._provider.getAvg(field);
    },
    getVar: function(field) {
        return this._provider.getVar(field);
    },
    getVarp: function(field) {
        return this._provider.getVarp(field);
    },
    getStdev: function(field) {
        return this._provider.getStdev(field);
    },
    getStdevp: function(field) {
        return this._provider.getStdevp(field);
    },
    summarize: function (scope, callback) {
        var v = this._provider.getSummarized(scope);
        if (isNaN(v)) {
            v = callback();
            this._provider.setSummarized(scope, v);
        }
        return v;
    },
    summarizeGroup: function (scope, group, callback) {
        var v = group.getSummarized(scope);
        if (isNaN(v)) {
            v = callback();
            group.setSummarized(scope, v);
        }
        return v;
    }
});
/** @internal */
var BarCode = defineClass("BarCode", null, {
	init: function () {
		this._super();
		this._value = null;
		this._error = null;
	},
	value: function () {
		return this._value;
	},
	setValue: function (v) {
		if (v != this._value) {
			this._value = v;
			try {
				this._error = null;
				this._parse(v);
			} catch (err) {
				this._error = err;
			}
		}
	},
	error: function () {
		return this._error;
	},
	render: function (g, r) {
		if (!this._error) {
			this._doRender(g, r);
		} else {
			trace("Barocde error: " + this._error);
		}
	},
	_parse: function (value) {
	},
	_doRender: function(g, r) {
	}
});
/** @internal */
var LinearBarcode = defineClass("LinearBarcode", BarCode, {
	init: function () {
		this._super();
	},
	barFill: null,
	integralBar: true,
	minBarWidth: 1,
	maxBarWidth: 0,
	barWidth: 0,
	_doRender: function (g, r) {
		if (!this._barFill) {
			return;
		}
		var len = this._getBarLength();
		if (len < 1) {
			return;
		}
		var w = this._barWidth;
		if (w <= 0) {
			if (this._integralBar) {
				w = Math.floor(r.width / len);
			} else {
				w = r.width / len;
			}
			w = Math.max(this._minBarWidth, w);
			if (this._maxBarWidth > 0) {
				w = Math.min(this._maxBarWidth, w);
			}
		}
		len = w * len;
		r.x += (r.width - len) / 2;
		if (this._integralBar) {
			r.x = Math.floor(r.x);
		}
		this._drawBars(g, this._barFill, r.x, r.y, w, r.height);
	},
	_getBarLength: function () {
		return 0;
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
	}
});
var $$_C128_BAR_WEIGHTS = [
	0x212222, 0x222122, 0x222221, 0x121223, 0x121322, 0x131222, 0x122213, 0x122312, 0x132212, 0x221213, 
	0x221312, 0x231212, 0x112232, 0x122132, 0x122231, 0x113222, 0x123122, 0x123221, 0x223211, 0x221132, 
	0x221231, 0x213212, 0x223112, 0x312131, 0x311222, 0x321122, 0x321221, 0x312212, 0x322112, 0x322211, 
	0x212123, 0x212321, 0x232121, 0x111323, 0x131123, 0x131321, 0x112313, 0x132113, 0x132311, 0x211313, 
	0x231113, 0x231311, 0x112133, 0x112331, 0x132131, 0x113123, 0x113321, 0x133121, 0x313121, 0x211331, 
	0x231131, 0x213113, 0x213311, 0x213131, 0x311123, 0x311321, 0x331121, 0x312113, 0x312311, 0x332111, 
	0x314111, 0x221411, 0x431111, 0x111224, 0x111422, 0x121124, 0x121421, 0x141122, 0x141221, 0x112214, 
	0x112412, 0x122114, 0x122411, 0x142112, 0x142211, 0x241211, 0x221114, 0x413111, 0x241112, 0x134111, 
	0x111242, 0x121142, 0x121241, 0x114212, 0x124112, 0x124211, 0x411212, 0x421112, 0x421211, 0x212141, 
	0x214121, 0x412121, 0x111143, 0x111341, 0x131141, 0x114113, 0x114311, 0x411113, 0x411311, 0x113141, 
	0x114131, 0x311141, 0x411131, 0x211412, 0x211214, 0x211232, 0x2331112
];
var $$_C128_STOP_CODE = 106;
var $$_C128_TYPE_A = 0;
var $$_C128_TYPE_B = 1;
var $$_C128_TYPE_C = 2;
var $$_C128_START_CODES = [103, 104, 105];
var $$_C128_MASKS = [
	0xF000000, 0x0F00000, 0x00F0000, 0x000F000, 0x0000F00, 0x00000F0, 0x000000F
];
var /* @internal */ Code128 = defineClass("Code128", LinearBarcode, {
	init: function() {
		this._super();
		this._weights = [];
	},
	quietZoneWidth: 10,
	_parse: function(value) {
		this._weights = [];
		var len = value ? value.length : 0;
		if (len < 1) {
			return;
		}
		var type = this._detectType(value);
		if (type == $$_C128_TYPE_C && len % 2 == 1) {
			value = "0" + value;
			len++;
		}
		var c = $$_C128_START_CODES[type];
		var w = $$_C128_BAR_WEIGHTS[c];
		var check = c;
        var i, s;
		this._weights.push(w);
		if (type == $$_C128_TYPE_C) {
			for (i = 0; i < len; i += 2) {
				s = value.substr(i, 2);
				c = parseInt(s);
				c = this._convert(type, c);
				w = $$_C128_BAR_WEIGHTS[c];
				this._weights.push(w);
				check += c * (i + 1);
			}
		} else {
			for (i = 0; i < len; i++) {
				c = value.charCodeAt(i);
				c = this._convert(type, c);
				w = $$_C128_BAR_WEIGHTS[c];
				this._weights.push(w);
				check += c * (i + 1);
			}
		}
		check = check % 103;
		this._weights.push($$_C128_BAR_WEIGHTS[check]);
		this._weights.push($$_C128_BAR_WEIGHTS[$$_C128_STOP_CODE]);
	},
	_getBarLength: function() {
		return this._quietZoneWidth + (this._weights.length - 1) * 11 + 13 + this._quietZoneWidth;
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
		x += 10 * barWidth;
		var cnt = this._weights.length - 1;
        var i, j, code, b;
		for (i = 0; i < cnt; i++) {
			code = this._weights[i];
			for (j = 0; j < 6; j ++) {
				b = (code & $$_C128_MASKS[j + 1]) >> ((5 - j) * 4);
				b *= barWidth;
				if (j % 2 == 0) {
					this._integralBar ?
					g.drawBoundsI(fill, null, x, y, b, barHeight) :
					g.drawBounds(fill, null, x, y, b, barHeight);
				}
				x += b;
			}
		}
		code = this._weights[cnt];
		for (j = 0; j < 7; j ++) {
			b = (code & $$_C128_MASKS[j]) >> ((6 - j) * 4);
			b *= barWidth;
			if (j % 2 == 0) {
				this._integralBar ?
				g.drawBoundsI(fill, null, x, y, b, barHeight) :
				g.drawBounds(fill, null, x, y, b, barHeight);
			}
			x += b;
		}
	},
	_convert: function (type, char) {
		switch (type) {
		case $$_C128_TYPE_A:
			if (char >= 0 && char < 32) 
				return char + 64;
			if (char >= 32 && char < 96) 
				return char - 32;
		case $$_C128_TYPE_B:
			if (char >= 32 && char < 128) 
				return char - 32;
		case $$_C128_TYPE_C:
			if (char >= 0 && char <= 99)
				return char;
		}
		throw new Error(GridLocale._default.invalidCode128Char + ": " + char);
	},
	_detectType: function (value) {
		var pattern = /^[0-9]+$/;
		if (pattern.test(value)) {
			return $$_C128_TYPE_C;
		}
		pattern = /[a-z]/;
		if (pattern.test(value)) {
			return $$_C128_TYPE_B;
		}
		return $$_C128_TYPE_A;
	}
});
var $$_C39_CODES = {
	"0": "nnnwwnwnn",
	"1": "wnnwnnnnw",
	"2": "nnwwnnnnw",
	"3": "wnwwnnnnn",
	"4": "nnnwwnnnw",
	"5": "wnnwwnnnn",
	"6": "nnwwwnnnn",
	"7": "nnnwnnwnw",
	"8": "wnnwnnwnn",
	"9": "nnwwnnwnn",
	"A": "wnnnnwnnw",
	"B": "nnwnnwnnw",
	"C": "wnwnnwnnn",
	"D": "nnnnwwnnw",
	"E": "wnnnwwnnn",
	"F": "nnwnwwnnn",
	"G": "nnnnnwwnw",
	"H": "wnnnnwwnn",
	"I": "nnwnnwwnn",
	"J": "nnnnwwwnn",
	"K": "wnnnnnnww",
	"L": "nnwnnnnww",
	"M": "wnwnnnnwn",
	"N": "nnnnwnnww",
	"O": "wnnnwnnwn",
	"P": "nnwnwnnwn",
	"Q": "nnnnnnwww",
	"R": "wnnnnnwwn",
	"S": "nnwnnnwwn",
	"T": "nnnnwnwwn",
	"U": "wwnnnnnnw",
	"V": "nwwnnnnnw",
	"W": "wwwnnnnnn",
	"X": "nwnnwnnnw",
	"Y": "wwnnwnnnn",
	"Z": "nwwnwnnnn",
	"-": "nwnnnnwnw",
	".": "wwnnnnwnn",
	" ": "nwwnnnwnn",
	"$": "nwnwnwnnn",
	"/": "nwnwnnnwn",
	"+": "nwnnnwnwn",
	"%": "nnnwnwnwn",
	"*": "nwnnwnwnn"
};
/** @internal */
var Code39 = defineClass("Code39", LinearBarcode, {
	init: function() {
		this._super();
		this._codes = [];
		this._wideWidth = 3;
	},
	_parse: function(value) {
		this._codes = [];
		if (!value) {
			return;
		}
		var i, c, code;
		var cnt = value.length;
		this._codes.push($$_C39_CODES["*"]);
		for (i = 0; i < cnt; i++) {
			c = value.charAt(i);
			code = $$_C39_CODES[c];
			if (!code) {
                throw new Error(GridLocale._default.invalidCode39Char + ": " + c);
			}
			this._codes.push(code);
		}
		this._codes.push($$_C39_CODES["*"]);
	},
	_getBarLength: function() {
		var len = this._codes.length;
		return len * (3 * this._wideWidth + 6) + (len - 1);
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
		var i, code, j, b;
		var cnt = this._codes.length;
		for (i = 0; i < cnt; i++) {
			code = this._codes[i];
			for (j = 0; j < 9; j ++) {
				b = code.charAt(j) == "n" ? 1 : this._wideWidth;
				b *= barWidth;
				if (j % 2 == 0) {
					this._integralBar ?
					g.drawBoundsI(fill, null, x, y, b, barHeight) :
					g.drawBounds(fill, null, x, y, b, barHeight);
				}
				x += b;
			}
			if (i < cnt - 1) {
				x += barWidth;
			}
		}
	}
});
function ExpressionStatementError(message, pos) {
	this.message = message;
	this.tokenPos = pos;
};
ExpressionStatementError.prototype = new Error();
ExpressionStatementError.prototype.constructor = ExpressionStatementError;
var $$_SEP_HEAD = "${";
var $$_SEP_TAIL = "}";
var /* internal */ ExpressionStatement = function (source, silentError) {
	var _source = null;
	var _silentError = silentError;
	var _tokens = [];
	var _createLiteral = function (literal) {
		return {
			literal: literal,
			evaluate: function (token, runtime) {
				return token.literal;
			}
		};
	};
	var _createIdent = function (ident) {
		return {
			ident: ident,
			idKey: -1,
			evaluate: function (token, runtime) {
				if (token.idKey < 0) {
					token.idKey = runtime.isIdentifier(token.ident);
				}
				return runtime.evaluateIdentifier(token.idKey);
			}
		};
	};
	var _parse = function (str) {
		_tokens.splice(0, _tokens.length);
		if (!str) {
			return;
		}
		var p, q, s, token,
			len = str.length,
			i = 0;
		while (i < len) {
			p = str.indexOf($$_SEP_HEAD, i);
			if (p >= 0) {
				q = str.indexOf($$_SEP_TAIL, p + 2);
				if (q >= 0) {
					if (p > i) {
						s = str.substring(i, p);
						token = _createLiteral(s);
						_tokens.push(token);
					}
					s = str.substring(p + 2, q).trim();
					if (s) {
						token = _createIdent(s);	
						_tokens.push(token);
					}
					i = q + 1;
				} else {
					p = -1;
				}
			} 
			if (p < 0) {
				s = str.substr(i, len);
				token = _createLiteral(s);
				_tokens.push(token);
				break;
			}
		}
	};
	this.source = function () {
		return _source;
	};
	this.setSource = function (value) {
		if (value != _source) {
			_source = value;
			_parse(value);
		}
	};
	this.evaluate = function (runtime) {
		try {
			var i, cnt, v,
				s = "";
			for (i = 0, cnt = _tokens.length; i < cnt; i++) {
				v = _tokens[i].evaluate(_tokens[i], runtime);
				s += v || "";
			}
			return s;
		} catch (err) {
			if (!_silentError) {
				throw err;
			}
		}
		return null;
	};
	_parse(source);
};
var _licson = JSON.parse(_lic);
var _licdom = _licson.domain = _licson.domain.split(';');
var _runloc = _runloc["hostname"];
/*
 * GridDataTag -> CellStyleMap -> GridCellStyleMap
 * GridDataTag -> DataTagManager -> GridDataTagManager
 * TreeDataTag -> CellStyleMap -> TreeCellStyleMap
 * TreeDataTag -> DataTagManager -> TreeDataTagManager
 *
 * DataTagCollection in GridDataSet
 * TreeDataTagCollection in TreeDataSet
 */
var DataTag = defineClass("DataTag", null, {
    init: function() {
        this._super();
    },
    connect: function (provider) {
    },
    disconnect: function () {
    },
    clearRows: function () {
    },
    setRows: function () {
    },
    removeRow: function (row) {
    },
    removeRows: function (rows) {
    },
    setValue: function (row, field) {
    },
    updateRow: function (row) {
    },
    saveValue: function (scope, row, field) {
    },
    restoreValue: function (scope, row, field) {
    },
    saveRow: function (scope, row, deleting) {
    },
    restoreRow: function (scope, row, created) {
    },
    saveRows: function (scope, rows, deleting) {
    },
    restoreRows: function (scope, rows, created) {
    }
});
var DataTagCollection = defineClass("DataTagCollection", null, {
	init: function(owner) {
		this._super();
		this._owner = owner;
		this._tags = null;
		this._tag = null;
	},
	add: function (tag) {
		if (tag) {
			if (!this._tag) {
				this._tag = tag;
			} else if (tag !== this._tag) {
				this._tags = [];
				this._tags.push(this._tag, tag);
				this._tag = null;
			} else if (this._tags.indexOf(tag) < 0) {
				this._tags.push(tag);
			}
			tag.connect(this._owner);
		}
	},
	remove: function (tag) {
		if (tag) {
            if (tag == this._tag) {
                this._tag = null;
                tag.disconnect();
            } else if (this._tags) {
                var idx = this._tags.indexOf(tag);
                if (idx >= 0) {
                    this._tags.splice(idx, 1);
                    if (this._tags.length == 1) {
                        this._tag = this._tags[0];
                        this._tags.length = 0;
                        this._tags = null;
                    }
                    tag.disconnect();
                }
            }
        }
	},
	clearRows: function () {
		if (this._tag) {
			this._tag.clearRows();
		} else if (this._tags) {
            var i, tags = this._tags;
			for (i = tags.length; i--;) {
				tags[i].clearRows();
			}
		}
	},
	setRows: function () {
		if (this._tag) {
			this._tag.setRows();
		} else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].setRows();
            }
		}
	},
    removeRow: function (row) {
        if (this._tag) {
            this._tag.removeRow(row);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].removeRow(row);
            }
        }
    },
    removeRows: function (rows) {
        if (this._tag) {
            this._tag.removeRows(rows);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].removeRows(rows);
            }
        }
    },
    setValue: function (row, field) {
        if (this._tag) {
            this._tag.setValue(row, field);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].setValue(row, field);
            }
        }
    },
    updateRow: function (row) {
        if (this._tag) {
            this._tag.updateRow(row);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].updateRow(row);
            }
        }
    },
    $_saveValue: function (scope, row, field) {
        if (this._tag) {
            this._tag.saveValue(scope, row, field);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].saveValue(scope, row, field);
            }
        }
    },
    $_restoreValue: function (scope, row, field) {
        if (this._tag) {
            this._tag.restoreValue(scope, row, field);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].restoreValue(scope, row, field);
            }
        }
    },
    $_saveRow: function (scope, row, deleting) {
        if (this._tag) {
            this._tag.saveRow(scope, row, deleting);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].saveRow(scope, row, deleting);
            }
        }
    },
    $_restoreRow: function (scope, row, created) {
        if (this._tag) {
            this._tag.restoreRow(scope, row, created);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].restoreRow(scope, row, created);
            }
        }
    },
    $_saveRows: function (scope, rows, deleting) {
        if (this._tag) {
            this._tag.saveRows(scope, rows, deleting);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].saveRows(scope, rows, deleting);
            }
        }
    },
    $_restoreRows: function (scope, rows, created) {
        if (this._tag) {
            this._tag.restoreRows(scope, rows, created);
        } else if (this._tags) {
            var i, tags = this._tags;
            for (i = tags.length; i--;) {
                tags[i].restoreRows(scope, rows, created);
            }
        }
    }
});
var GridDataTag = defineClass("GridDataTag", DataTag, {
    init: function() {
        this._super();
    },
    setRowCount: function (newCount) {
    },
    insertRow: function (row) {
    },
    insertRows: function (row, count) {
    },
    updateRows: function (rows) {
    },
    moveRow: function (row, newRow) {
    },
    moveRows: function (row, count, newRow) {
    }
});
var GridDataTagCollection = defineClass("GridDataTagCollection", DataTagCollection, {
    init: function(owner) {
        this._super();
        this._owner = owner;
        this._tags = null;
        this._tag = null;
    },
    setRowCount: function (newCount) {
        if (this._tag) {
            this._tag.setRowCount(newCount);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].setRowCount(newCount);
            }
        }
    },
    insertRow: function (row) {
        if (this._tag) {
            this._tag.insertRow(row);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].insertRow(row);
            }
        }
    },
    insertRows: function (row, count) {
        if (this._tag) {
            this._tag.insertRows(row, count);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].insertRows(row, count);
            }
        }
    },
    updateRows: function (rows) {
        if (this._tag) {
            this._tag.updateRows(rows);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].updateRows(rows);
            }
        }
    },
    moveRow: function (row, newRow) {
        if (this._tag) {
            this._tag.moveRow(row, newRow);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].moveRow(row, newRow);
            }
        }
    },
    moveRows: function (row, count, newRow) {
        if (this._tag) {
            this._tag.moveRows(row, count, newRow);
        } else if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].moveRows(row, count, newRow);
            }
        }
    }
});
var DataField = defineClass("DataField", EventAware, {
	init: function (fieldName, dataType, length) {
		this._super();
		this._owner = null;
		this._attrName = null;
		this._index = -1;
		this._boolParser = null;
		this._dateParser = null;
		this._ownerBoolParser = null;
		this._ownerDateParser = null;
        this._updatable = true;
		this.setFieldName(fieldName);
		if (dataType !== undefined) {
			if (dataType == 'dummy') {
				this._dataType = value;
			} else {
				this._dataType = dataType == "numeric" ? ValueType.NUMBER : dataType == "date" ? ValueType.DATETIME : dataType;
				_checkEnumValue(ValueType, this._dataType);
			}
		}
		if (length != undefined) {
            var len = parseInt(length);
            this._length = isNaN(len) ? 0 : Math.max(0, len);
		}
		this._sysDate = false;
		this._ranged = false;
		this._runMax = undefined;
		this._runMin = undefined;
		this._typeLock = false;
	},
	fieldName: null,
	dataType: ValueType.TEXT,
	length: 0,
	distinctNull: false,
	minimum: undefined,
	maximum: undefined,
	required: false,
    updatable: true,
	defaultValue: undefined,
    nanValue: undefined,
    emptyValue: undefined,
	header: null,
	booleanFormat: null,
	datetimeFormat: null,
	objectParser: null,     // function (field, text): Object
	amText: null,
	pmText: null,
	baseYear: NaN,
    zoneDelta: 0,
	loadCallback: null,		// function (field, value): *
	keyPath: undefined,
    keyCallback: null,      // function (field, value): *
	compareCallback: null,  // function (v1, v2): Integer
	displayText: function () {
		return this._header || this._fieldName;
	},
	hash: function () {
		return this._fieldName;
	},
	index: function () {
		return this._index;
	},
	$_setIndex: function (value) {
		this._index = value;
	},
    fieldName: function () {
        return this._fieldName || "";
    },
	setFieldName: function (value) {
		value = value && value.trim();
		if (!value) {
			throw new Error("Field name must be exists.");
		}
		if (value != this._fieldName) {
			this._attrName = "@" + value;
			this._fieldName = value;
			this._changed("fieldName");
		}
	},
	setDataType: function (value) {
		if (value == "numeric") {
			value = ValueType.NUMBER;
		} else if (value == "date") {
			value = ValueType.DATETIME;
		} else if (value == 'dummy') {
		} else {
			_checkEnumValue(ValueType, value)
		}
		if (value != this._dataType) {
			this._dataType = value;
			this._resetTypes();
			this._changed("dataTpe");
		}
	},
	setDistinctNull: function (value) {
		if (value != this._distinctNull) {
			this._distinctNull = value;
			(this._dataType == ValueType.TEXT) && this._resetTypes();
			this._changed("distinctNull");
		}
	},
	setLength: function (value) {
		value = _forceInt(value);
		if (value != this._length) {
			this._length = value;
			(this._dataType == ValueType.TEXT) && this._resetTypes();
			this._changed("length");
		}
	},
	setMinimum: function (value) {
		if (value != this._minimum) {
			this._minimum = value;
			this._resetTypes();
			this._changed("minimum");
		}
	},
	setMaximum: function (value) {
		if (value != this._maximum) {
			this._maximum = value;
			this._resetTypes();
			this._changed("maximum");
		}
	},
	setRequired: function (value) {
		if (value != this._required) {
			this._required = value;
			this._changed("required");
		}
	},
    setNaNValue: function (value) {
        value = Number(value);
        value = isNaN(value) ? undefined : value;
    },
	setHeader: function (value) {
		if (value != this._header) {
			this._header = value;
			this._changed("header");
		}
	},
	setDefaultValue: function (value) {
		if (value != this._defaultValue) {
			this._defaultValue = value;
            this._changed("defaultValue");
		}
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				this._boolParser = new BooleanConverter(value);
			} else {
				this._boolParser = null;	
			}
			this._changed("booleanFormat");
		}
	},
	setDatetimeFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
            if (value == "system") {
                this._sysDate = true;
            } else if (value) {
                this._sysDate = false;
				this._dateParser = new DateTimeReader(value);
				this._dateParser.setAmText(this._amText);
				this._dateParser.setPmText(this._pmText);
				this._dateParser.setBaseYear(this._baseYear);
                this._dateParser.setZoneDelta(this._zoneDelta);
			} else {
                this._sysDate = false;
				this._dateParser = null;
			}
			this._changed("datetimeFormat");
		}
	},
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
			if (this._dateParser) {
				this._dateParser.setAmText(value);
			}
			this._changed("amText");
		}
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
			if (this._dateParser) {
				this._dateParser.setPmText(value);
			}
			this._changed("pmText");
		}
	},
	setBaseYear: function (value) {
		if (value != this._baseYear) {
			this._baseYear = value;
			if (this._dateParser) {
				this._dateParser.setBaseYear(value);
			}
			this._changed("baseYear");
		}
	},
    setZoneDelta: function (value) {
        if (value != this._zoneDelta) {
            this._zoneDelta = value;
            if (this._dateParser) {
                this._dateParser.setZoneDelta(value);
            }
            this._changed("zoneDelta");
        }
    },
	setLoadCallback: function (value) {
		value = _asFunction(value);
		if (value != this._loadCallback) {
			this._loadCallback = value;
			this._changed("loadCallback");
		}
	},
	setKeyPath: function (value) {
		if (value != this._keyPath) {
			this._keyPath = value;
			this._changed("keyPath");
		}
	},
    setKeyCallback: function (value) {
        value = _asFunction(value);
        if (value != this._keyCallback) {
            this._keyCallback = value;
            this._changed("keyCallback");
        }
    },
	setCompareCallback: function (value) {
		value = _asFunction(value);
		if (value != this._compareCallback) {
			this._compareCallback = value;
			this._changed("compareCallback");
		}
	},
	readOnly: function () {
		return false;
	},
	isEmpty: function (value) {
		var v = value === undefined || value === null || value == "";
		if (!v && this._dataType == ValueType.NUMBER) {
			v = isNaN(value);
		}
		return v;
	},
    getZonedDate: function (d) {
        if (d) {
            var p = this._dateParser || this._ownerDateParser;
            var z = p.zoneDelta();
            if (z) {
                d = new Date(d.getTime() + z * 60000);
            }
        }
        return d;
    },
	propertyChanged: function (prop, newValue) {
		this._changed(prop);
	},
	clone: function (props) {
		var obj = this._super(props);
		obj._attrName = this._attrName;
		obj._boolParser = this._boolParser;
		obj._dateParser = this._dateParser;
		return obj;
	},
	/*
	clone: function () {
		var fld = new DataField();
	fieldName: null,
	dataType: ValueType.TEXT,
	length: 0,
	header: null,
	minimum: undefined,
	maximum: undefined,
	required: false,
	defaultValue: UNDEFINED,
	boolFormat: null,
	dateFormat: null,
	amText: null,
	pmText: null,
	baseYear: NaN,
		fld._orgFieldName = this._orgFieldName;
		fld._fieldName = this._fieldName;
		fld._dataType = this._dataType;
		fld._length = this._length;
		fld._header = this._header;
		fld._required = this._required;
		fld._defaultValue = this._defaultValue;
		fld._boolFormat = this._boolFormat;
		fld._dateFormat = this._dateFormat;
		fld._amText = this._amText;
		fld._pmText = this._pmText;
		fld._baseYear = this._baseYear;
		return fld;
	},
	*/
	_prepare: function (owner) {
		this._owner = owner;
	},
	_changed: function (prop) {
        this._owner && this._owner.onFieldChanged(this, prop);
	},
    _getDate: function (parser, value) {
		if (value === undefined || value === null || value === "") {
			return undefined;
		} else if (this._sysDate) {
            return new Date(value);
        } else if (typeof value == "string") {
            return value ? (this._dateParser ? this._dateParser.toDate(value) : parser.toDate(value)) : undefined;
        } else {
            return new Date(value);
        }
    },
	_resetTypes: function (ds) {
		if (this._typeLock) {
			return;
		}
		if (ds) {
			this._ownerBoolParser = ds._boolParser;
			this._ownerDateParser = ds._dateParser;
		}
		var reader,
			type = this._dataType;
		this._ranged = false;
        if (!this._ranged) {
            switch (this._dataType) {
                case ValueType.NUMBER:
                    this._runMin = Number(this._minimum);
                    this._runMax = Number(this._maximum);
                    if (!isNaN(this._runMin) && !isNaN(this._runMax)) {
                        this._ranged = this._runMin <= this._runMax;
                    } else {
                        this._ranged = !isNaN(this._runMin) || !isNaN(this._runMax);
                    }
                    break;
                case ValueType.DATETIME:
                    this._runMin = this._getDate(this._ownerDateParser, this._minimum);
                    this._runMax = this._getDate(this._ownerDateParser, this._maximum);
                    if (this._runMin && this._runMax) {
                        this._ranged = this._runMin.getTime() <= this._runMax.getTime();
                    } else {
                        this._ranged = this._runMin || this._runMax;
                    }
                    break;
            }
        }
        switch (type) {
            case ValueType.NUMBER:
                this.equalValues = this._equalNumberValues;
                this.sameValues = this._sameNumberValues;
				reader = this._readNumberValue;
                break;
			case ValueType.DATETIME:
                this.equalValues = this._equalDateValues;
                this.sameValues = this._sameDateValues;
				reader = this._readDatetimeValue;
                break;
			case ValueType.BOOLEAN:
                this.equalValues = this._equalBoolValues;
                this.sameValues = this._sameBoolValues;
				reader = this._readBooleanValue;
                break;
			case ValueType.OBJECT:
				this.equalValues = this._equalObjValues;
				this.sameValues = this._sameObjValues;
				reader = this._readObjectValue;
				break;
			case "dummy":
				this.equalValues = this._equalDummyValues;
				this.sameValues = this._sameDummyValues;
				reader = this._readDummyValue;
				break;
			case ValueType.TEXT:
			default:
				if (this._distinctNull) {
					reader = this._length > 0 ? this._readNullCharValue : this._readNullTextValue;
				} else {
					reader = this._length > 0 ? this._readCharValue : this._readTextValue;
				}
				this.equalValues = this._equalTextValues;
				this.sameValues = this._sameTextValues;
				break;
        }
		this.readValue = reader;
		if (this._loadCallback) {
			this.loadValue = (function (self, cb, fn) {
				return function (v) {
					return fn.call(self, cb(self, v));
				};
			})(this, this._loadCallback, reader);
		} else {
			this.loadValue = reader;
		}
	},
	_refreshFormats: function (owner) {
		this._owner = owner;
		if (this._dateParser) {
			if (!this._dateParser.baseYear) {
				this._dateParser.setBaseYear(owner.baseYear());
			}
			if (!this._dateParser.amText) {
				this._dateParser.setAmText(owner.amText());
			}
			if (!this._dateParser.pmText) {
				this._dateParser.setPmText(owner.pmText());
			}
		}
		this._ownerBoolParser = owner._boolParser;
		this._ownerDateParser = owner._dateParser;
	},
    _equalDummyValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return v1 == v2;
    },
    _sameDummyValues: function (v1, v2) {
        if (v1 === undefined || v1 === null) {
            return v2 === undefined || v2 === null;
        }
        if (v2 === undefined || v2 === null) {
            return false;
        }
        return v1 == v2;
    },
	_equalTextValues: function (v1, v2) {
		if (v1 === undefined) {
			return v2 === undefined;
		}
		if (v2 === undefined) {
			return false;
		}
		return v1 == v2;
	},
	_sameTextValues: function (v1, v2) {
		if (v1 === undefined || v1 === null || v1 == "") {
			return v2 === undefined || v2 === null || v2 == "";
		}
		if (v2 === undefined || v2 === null || v2 == "") {
			return false;
		}
		return v1 == v2;
	},
    _equalNumberValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        if (isNaN(v1)) {
            return isNaN(v2);
        }
        if (isNaN(v2)) {
            return false;
        }
        return v1 == v2;
    },
    _sameNumberValues: function (v1, v2) {
        if (isNaN(v1)) {
            return isNaN(v2);
        }
        if (isNaN(v2)) {
            return false;
        }
        return v1 == v2;
    },
    _equalDateValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        if (!(v1 instanceof Date)) {
            return !(v2 instanceof Date);
        }
        if (!(v2 instanceof Date)) {
            return false;
        }
        return v1.getTime() == v2.getTime();
    },
    _sameDateValues: function (v1, v2) {
        if (!(v1 instanceof Date)) {
            return !(v2 instanceof Date);
        }
        if (!(v2 instanceof Date)) {
            return false;
        }
        return v1.getTime() == v2.getTime();
    },
    _equalBoolValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return v1 == v2;
    },
    _sameBoolValues: function (v1, v2) {
        /*
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        */
        return Boolean(v1) == Boolean(v2);
    },
	_equalObjValues: function (v1, v2) {
		if (v1 === undefined) {
			return v2 === undefined;
		}
		if (v2 === undefined) {
			return false;
		}
		return v1 === v2;
	},
	_sameObjValues: function (v1, v2) {
		if (v1 === undefined || v1 === null) {
			return v2 === undefined || v2 === null;
		}
		if (v2 === undefined || v2 === null) {
			return false;
		}
		return v1 === v2;
	},
	_readDummyValue: function (v) {
		return v;
	},
	_readTextValue: function (v) {
		if (v === undefined || v === null) {
			return undefined;
		}
		return String(v);
	},
	_readCharValue: function (v) {
		if (v === undefined || v === null) {
			return undefined
		}
		var s = String(v);
		if (s) {
			s = s.substr(0, this._length);
		}
		return s;
	},
	_readNullTextValue: function (v) {
		if (v === undefined || v === null) {
			return v;
		}
		return String(v);
	},
	_readNullCharValue: function (v) {
		if (v === undefined || v === null) {
			return v
		}
		var s = String(v);
		if (s) {
			s = s.substr(0, this._length);
		}
		return s;
	},
	_readNumberValue: function (v) {
        var n;
        if (typeof v == 'number') {
            n = v;
        } else {
            if (v === undefined || v === null || v === "") {
                return undefined;
            }
            n = parseFloat(v);
        }
        if (isNaN(n)) {
            if (this._nanValue !== undefined) {
                n = this._nanValue;
            } else if (this._owner && this._owner._nanValue !== undefined) {
                n = this._owner._nanValue;
            }
        }
        if (!isNaN(n)) {
            if (this._ranged) {
                if (!isNaN(this._runMin)) {
                    n = Math.max(this._runMin, n);
                }
                if (!isNaN(this._runMax)) {
                    n = Math.min(this._runMax, n);
                }
            }
            return n;
        } else {
            return undefined;
        }
	},
	_readDatetimeValue: function (v) {
		var d = this._getDate(this._ownerDateParser, v);
		if (d && this._ranged) {
            if (this._runMin) {
                if (d.getTime() < this._runMin.getTime()) {
                    d = new Date(this._runMin);
                }
            }
            if (this._runMax) {
                if (d.getTime() > this._runMax.getTime()) {
                    d = new Date(this._runMax);
                }
            }
		}
		return d || undefined;
	},
	_readBooleanValue: function (v) {
		if (v === undefined || v === null || v === "") {
			return undefined;
		}
        switch (typeof v) {
            case "boolean":
                return v;
            case "string":
                return v ? (this._boolParser ? this._boolParser.toBool(v) : this._ownerBoolParser.toBool(v)) : undefined;
            default:
                return Boolean(v);
        }
	},
	_readObjectValue: function (v) {
		if (this._objectParser) {
            v = this._objectParser(this, v);
        } else if (typeof v === 'string') {
            try {
                v = JSON.parse(v);
            } catch (err) {
                throw new DataSetError("Invalid object string: " + err + "\r\n" + v);
            }
		} else if (!_isObject(v)) {
            try {
                v = JSON.parse(v);
            } catch (err) {}
		}
		return v;
	},
	$_compareObjs: function (v1, v2) {
		var k = this._keyCallback;
		if (k) {
            v1 = k(this, v1);
            v2 = k(this, v2);
		} else {
            k = this._keyPath;
            v1 = DataPath.extractJson(v1, k, true);
            v2 = DataPath.extractJson(v2, k, true);
        }
        return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
	}
});
var DerivedField = defineClass("DerivedField", DataField, {
	init: function (fieldName, dataType, length, expression, callback) {
		if (dataType == ValueType.OBJECT) {
			throw new Error(GridLocale._default.invalidDerivedFieldType);
		}
		this._super(fieldName, dataType || "number", length);
		expression && this.setExpression(expression);
		callback && this.setCallback(callback);
        this._srcFlds = null;
        this._updatable = false;
	},
	expression: null,
	callback: null,	// function (ds, row, values):*
    sourceFields: null,
	setExpression: function (value) {
		value = value && value.trim();
		if (value !== this._expression) {
			this._expression = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value) : null;
		}
	},
	setCallback: function (value) {
		value = _isFunction(value) ? value : null;
		if (value !== this._callback) {
			this._callback = value;
		}
	},
    setSourceFields: function (value) {
        if (value != this._sourceFields) {
            this._sourceFields = value;
            this._srcFlds = null;
            this._owner && this.$_resetSourceFields(this._owner);
        }
    },
    clone: function (props) {
        var obj = this._super(props);
        obj._expression = props._expression;
        obj._exprNode = props._exprNode;
        obj._callback = props._callback;
        return obj;
    },
	setDataType: function (value) {
		if (value == ValueType.OBJECT) {
			throw new Error(GridLocale._default.invalidDerivedFieldType);
		}
		this._super(value);
	},
    _resetTypes: function (ds) {
        this._super(ds);
        this.$_resetSourceFields(ds);
    },
	readOnly: function () {
		return true;
	},
    $_resetSourceFields: function (ds) {
        var fields, i, f;
        if (!this._srcFlds && (fields = this._sourceFields)) {
            if (_isArray(fields)) {
                for (i = fields.length; i--;) {
                    f = fields[i];
                    f = ds.getFieldIndexEx(f);
                    if (f >= 0) {
                        this._srcFlds = this._srcFlds || [];
                        this._srcFlds[f] = true;
                    }
                }
            } else {
                f = ds.getFieldIndexEx(f);
                if (f >= 0) {
                    this._srcFlds = [];
                    this._srcFlds[f] = true;
                }
            }
        }
    },
    $_getValue: function (ds, field, runtime, row, values, source, temp) {
        if (!this._srcFlds || source < 0 || this._srcFlds[source]) {
            if (this._callback) {
                return this.readValue(this._callback(ds, field, row, values, source, temp));
            } else if (this._exprNode) {
                runtime.setRow(row, values);
                return this.readValue(this._exprNode.evaluate(runtime));
            } else {
                return undefined;
            }
        }
		return $$$_NOT_CALCED;
    }
});
var $$$_NOT_CALCED = {};
/** @internal */
var DerivedFieldRuntime = defineClass("DerivedFieldRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
	},
	prepare: function (ds) {
		this._ds = ds;
		this._fieldCount = ds ? ds.baseFieldCount() : 0;
		return this;
	},
	setRow: function (row, values) {
		this._row = row;
		this._values = values;
	},
	isIdentifier: function (token) {
		var fld = this._ds.getFieldIndex(token, true);
		if (fld >= 0) {
			return fld + DerivedFieldRuntime.ID_FIELD;
		}
		token = token.toLowerCase();
		if (DerivedFieldRuntime.IDENTS.hasOwnProperty(token)) {
			return DerivedFieldRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		if (idKey >= DerivedFieldRuntime.ID_FIELD) {
			return this._values[idKey - DerivedFieldRuntime.ID_FIELD];
		}
		switch (idKey) {
			case DerivedFieldRuntime.ID_ROW:
				return this._row;
            case DerivedFieldRuntime.ID_TAG:
                return this._ds.getRowTag(this._row);
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			_invalidFieldIndex(index);
		}
		switch (idKey) {
			case DerivedFieldRuntime.ID_VALUES:
				return this._values[index];
		}
		return this._super(idKey, index);
	},
	evaluateIndexerS: function (idKey, index) {
		switch (idKey) {
			case DerivedFieldRuntime.ID_VALUES:
				var field = this.$_getField(index);
				return this._values[field];
		}
		return this._super(idKey, index);
	},
	$_getField: function (index) {
		var	fld = this._ds.getFieldIndex(index);
		if (fld < 0 || fld >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field is not exits:" + index);
		}
		return fld;
	}
}, {
	ID_ROW: 0,
    ID_TAG: 1,
	ID_VALUES: 2,
	ID_FIELD: 10
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
        tag: f.ID_TAG,
		values: f.ID_VALUES
	};
});
var DataSetError = _createError('DataLudi.DataSetError');
/** @internal */
var DataOutputOptions = defineClass("DataOutputOptions", null, {
    init: function (config) {
        this._super();
        config && this.assign(config);
    },
    visibleFields: null,
    hiddenFields: null,
	valueCallback: null,
	valueCallbacks: null,
    datetimeFormat: undefined,
    booleanFormat: undefined,
    nullDateText: "",
    separator: ",",
    lfText: undefined,
	crText: undefined,
    quoted: false,
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            if (value) {
                this._datetimeWriter = new DateTimeWriter(value);
            } else {
                this._datetimeWriter = null;
            }
        }
        return this;
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
        return this;
    },
    $_prepareFields: function (ds) {
        var i, cnt, f, flds, vFlds, hFlds;
        flds = this._visibleFields;
        if (_isArray(flds) && (cnt = flds.length) > 0) {
            vFlds = this._visFlds = [];
            for (i = 0; i < cnt; i++) {
                f = ds.getFieldIndex(flds[i]);
                f >= 0 && vFlds.push(ds.getField(f));
            }
        } else {
            vFlds = this._visFlds = null;
        }
        flds = this._hiddenFields;
        if (_isArray(flds) && (cnt = flds.length) > 0) {
            hFlds = this._hidFlds = [];
            for (i = 0; i < cnt; i++) {
                f = ds.getFieldIndex(flds[i]);
                f >= 0 && hFlds.push(ds.getField(f));
            }
        } else {
            hFlds = null;
        }
        if (!vFlds && !hFlds) return null;
        cnt = ds.fieldCount();
        flds = [];
        for (i = 0; i < cnt; i++) {
            f = ds.getField(i);
            if (hFlds && hFlds.indexOf(f) >= 0) {
                f = null;
            }
            if (f && (!vFlds || vFlds.indexOf(f) >= 0)) {
                flds.push(f);
            }
        }
        return flds;
    }
});
var DataSetPendingError = function () {
    this.name = 'DataLudi.DataSetPendingError';
	this.message = DataSetPendingError.message;
};
DataSetPendingError.prototype = new Error();
DataSetPendingError.prototype.constructor = DataSetPendingError;
DataSetPendingError.message = "DataSet is pending";
var ClientEditingError = function () {
    this.name = 'DataLudi.ClientEditingError';
    this.message = ClientEditingError.message;
};
ClientEditingError.prototype = new Error();
ClientEditingError.prototype.constructor = ClientEditingError;
ClientEditingError.message = "Client is editing (call grid.commit() or grid.cancel() first)";
/** @internal */
var FieldSummary = function (field) {
    this.field = field;
    this.count = 0;
    this.sum = NaN;
    this.max = NaN;
    this.min = NaN;
    this.avg = NaN;
    this.vars = NaN;
};
FieldSummary.prototype.clear = function () {
    this.count = 0;
    this.sum = this.max = this.min = this.avg = this.vars = NaN;
};
/** @abstract */
var DataSet = defineClass("DataSet", EventAware, {
	init: function (fields, derivedFields) {
        if (!_isValidAddr(_licdom, _runloc)) return;
		this._super();
		this._fieldMap = {};
        this._fieldMapI = {};
		this._boolParser = BooleanConverter.Default;
		this._dateParser = DateTimeReader.Default;
		this._eventLock = 0;
        this._countLock = 0;
        this._resetLock = 0;
		this._clients = [];
        this._derivedRuntime = new DerivedFieldRuntime();
        this._eventable = false;
		this._fields = [];
		this._baseFieldCount = 0;
        this._derivedFieldCount = 0;
        this._fieldNames = [];
        fields && this.setFields(fields, derivedFields);
        this._dataCommands = new DataCommandStack(this);
        this._onStack = 0;
    },
    onEditCommandStackChanged: function (stack, canUndo, canRedo) {
        this._fireCommandStackChanged(canUndo, canRedo);
    },
    onDisposed: DLCallback,
    onReset: DLCallback,
    onRefresh: DLCallback,
    onRowCountChanged: DLCallback,
    onDataChanged: DLCallback,
    onStatesCleared: DLCallback,
    onTagsCleared: DLCallback,
    onCommandStackChanged: DLCallback,
    dataInited: false,
    undoable: false,
    eventsOnStack: false,
	softDelete: false,
	deleteCreated: false,
	checkStates: true,
    checkClients: true,
	restoreMode: EnumProp(DataRestoreMode, DataRestoreMode.NONE),
    strictRestore: false,
	booleanFormat: null,
	datetimeFormat: null,
	baseYear: 2000,
	amText: null,
	pmText: null,
    zoneDelta: 0,
    nanValue: undefined,
    throwPendingError: true,
	alertClientError: true,
	throwClientError: false,
    resetIdWhenClear: true,
    userData: null, // dataludi는 손대지 않는다. 그리드 개발자들이 임의로 사용할 수 있도록 한다.
    isOnStack: function () {
        return this._onStack;
    },
	isInsertable: function () {
		return true;
	},
	isAppendable: function () {
		return true;
	},
	isUpdatable: function () {
		return true;
	},
	isDeletable: function () {
		return true;
	},
	isMovable: function () {
		return true;
	},
    fields: function () {
        return this._fields.slice();
    },
    setFields: function (fields, derivedFields) {
        function _copy(fld, field) {
            if (fld.hasOwnProperty("distinctNull")) {
                field.setDistinctNull(fld.distinctNull);
            }
            if (fld.hasOwnProperty("minimum")) {
                field.setMinimum(fld.minimum);
            }
            if (fld.hasOwnProperty("maximum")) {
                field.setMaximum(fld.maximum);
            }
            if (fld.hasOwnProperty("required")) {
                field._required = fld.required;
            }
            if (fld.hasOwnProperty("updatable")) {
                field._updatable = fld.updatable;
            }
            if (fld.hasOwnProperty("defaultValue")) {
                field._defaultValue = fld.defaultValue;
            }
            if (fld.hasOwnProperty("nanValue")) {
                field.setNanValue(fld.nanValue);
            }
            if (fld.hasOwnProperty("emptyValue")) {
                field._emptyValue = fld.emptyValue;
            }
            if (fld.hasOwnProperty("header")) {
                field._header = fld.header;
            }
            if (fld.hasOwnProperty("booleanFormat")) {
                field.setBooleanFormat(fld.booleanFormat);
            }
            if (fld.hasOwnProperty("datetimeFormat")) {
                field.setDatetimeFormat(fld.datetimeFormat);
            }
            if (fld.hasOwnProperty("amText")) {
                field.setAmText(fld.amText);
            }
            if (fld.hasOwnProperty("pmText")) {
                field.setPmText(fld.pmText);
            }
            if (fld.hasOwnProperty("baseYear")) {
                field.setBaseYear(fld.baseYear);
            }
            if (fld.hasOwnProperty("zoneDelta")) {
                field.setZoneDelta(fld.zoneDelta);
            }
            if (fld.hasOwnProperty("keyPath")) {
                field._keyPath = fld.keyPath;
            }
            if (fld.hasOwnProperty("keyCallback")) {
                field.setKeyCallback(fld.keyCallback);
            }
            if (fld.hasOwnProperty("compareCallback")) {
                field._compareCallback = fld.compareCallback;
            }
            if (field instanceof DerivedField) {
                if ("sourceFields" in fld) {
                    field.setSourceFields(fld.sourceFields);
                }
            }
        }
        if (!this._checkClientState()) return;
        this.beginUpdate();
        try {
            this.$_internalClearFields();
            var i, cnt, field, fld, expr, cb;
            if (_isArray(fields)) {
                for (i = 0, cnt = fields.length; i < cnt; i++) {
                    field = null;
                    fld = fields[i];
                    if (typeof fld === "string") {
                        field = this.$_addField(fld, ValueType.TEXT, 0);
                    } else if (fld instanceof DataField) {
                        field = fld.clone(fld._fieldName);
                        this.$_internalInsertField(this._fields.length, field);
                    } else {
                        field = this.$_addField(fld.fieldName, fld.dataType, fld.length);
                        _copy(fld, field);
                    }
                    if (field) {
                        field._resetTypes(this);
                    }
                }
            }
            if (_isArray(derivedFields)) {
                for (i = 0, cnt = derivedFields.length; i < cnt; i++) {
                    field = null;
                    fld = derivedFields[i];
                    if (fld instanceof DerivedField) {
                        field = fld.clone(fld._fieldName);
                        this.$_internalInsertField(this._fields.length, field);
                    } else {
                        expr = fld.expression;
                        cb = fld.callback;
                        if (expr || cb) {
                            field = this.$_addDerivedField(fld.fieldName, fld.dataType, fld.length, expr, cb);
                            _copy(fld, field);
                        }
                    }
                    if (field) {
                        field._resetTypes(this);
                    }
                }
            }
        } finally {
            this.endUpdate();
            this._doFieldsReset();
        }
        return this;
    },
    setUndoable: function (value) {
        if (value != this._undoable) {
            this._undoable = value;
            this._eventable = !value || this._eventsOnStack;
            this._dataCommands.flush();
        }
    },
    setEventsOnStack: function (value) {
        if (value != this._eventsOnStack) {
            this._eventsOnStack = value;
            this._eventable = value || !this._undoable;
        }
    },
	setCheckStates: function (value) {
		if (value != this._checkStates) {
			this._checkStates = value;
			this._doCheckStatesChanged();
		}
        return this;
	},
	setRestoreMode: function (value) {
		if (value != this._restoreMode) {
			var old = this._restoreMode;
			this._restoreMode = value;
			this._doRestoreModeChanged(old, value);
		}
        return this;
	},
	fieldCount: function () {
		return this._fields.length;
	},
	baseFieldCount: function () {
		return this._baseFieldCount;
	},
    derivedFieldCount: function () {
        return this._derivedFieldCount;
    },
    rowCount: function () {
        _throwAbstractError();
    },
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			this._boolParser = value ? new BooleanConverter(value) : BooleanConverter.Default;
			for (var i = this._fields.length; i--;) {
				this._fields[i]._ownerBoolParser = this._boolParser;
			}
		}
        return this;
	},
	$_createDateReader: function () {
		if (this._datetimeFormat) {
			this._dateParser = new DateTimeReader(this._datetimeFormat);
			this._dateParser.setAmText(this._amText);
			this._dateParser.setPmText(this._pmText);
			this._dateParser.setBaseYear(this._baseYear);
            this._dateParser.setZoneDelta(this._zoneDelta);
		} else {
			this._dateParser = DateTimeReader.Default;
		}
		for (var i = this._fields.length; i--;) {
			this._fields[i]._ownerDateParser = this._dateParser;
		}
	},
    setBaseYear: function (value) {
        if (value != this._baseYear) {
            this._baseYear = value;
            this.$_createDateReader();
        }
        return this;
    },
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
			this.$_createDateReader();
		}
        return this;
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
			this.$_createDateReader();
		}
        return this;
	},
	setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            this.$_createDateReader();
        }
        return this;
	},
    setZoneDelta: function (value) {
        if (value != this._zoneDelta) {
            this._zoneDelta = value;
            this.$_createDateReader();
        }
    },
    setNanValue: function (value) {
        var v = Number(value);
        this._nanValue = isNaN(v) ? undefined : v;
    },
    deletedCount: function () {
        return 0;
    },
    undoing: function () {
        return this._dataCommands.undoing();
    },
    redoing: function () {
        return this._dataCommands.redoing();
    },
    dispose: function () {
    },
	getField: function (index) {
		if (index >= 0 && index < this._fields.length) {
			return this._fields[index];
		}
		return null;
	},
	getFieldHeader: function (index) {
		if (index >= 0 && index < this._fields.length) {
			return this._fields[index].header();
		}
		return null;
	},
    getFieldLabel: function (index) {
        if (index >= 0 && index < this._fields.length) {
            var f = this._fields[index];
            return f.header() || f.fieldName();
        }
        return null;
    },
	isLocal: function () {
		return true;
	},
	isImmediateUpdate: function () {
		return false;
	},
    getEmptyObject: function () {
        var i, cnt,
            obj = {},
            flds = this._fields;
        for (i = 0, cnt = flds.length; i < cnt; i++) {
            obj[flds[i]._fieldName] = undefined;
        }
        return obj;
    },
    $_checkFieldName: function (fieldName) {
        if (!fieldName) {
            throw new Error("fieldName must be exists.");
        }
        if (this.getFieldIndex(fieldName) >= 0) {
            throw new Error("fieldName is already exists: " + fieldName);
        }
    },
	$_addField: function (fieldName, dataType, length) {
        this.$_checkFieldName(fieldName = fieldName && fieldName.trim());
		var field = new DataField(fieldName, dataType, length);
		this.$_internalInsertField(this._fields.length, field);
		return field;
	},
    $_addDerivedField: function (fieldName, dataType, length, expression, callback) {
        this.$_checkFieldName(fieldName = fieldName && fieldName.trim());
        var field = new DerivedField(fieldName, dataType, length, expression, callback);
        this.$_internalInsertField(this._fields.length, field);
        return field;
    },
    /* TODO: 계산 필드가 끝에 추가되도록 해야 한다.
	addField: function (fieldName, dataType, length) {
		if (!this._checkClientState()) return;
		var field = this.$_addField(fieldName, dataType, length);
		field._resetTypes();
		this._doFieldsReset();
		return field;
	},
    addDerivedField: function (fieldName, dataType, length, expression, callback) {
        if (!this._checkClientState()) return;
        var field = this.$_addField(fieldName, dataType, length, expression, callback);
        field._resetTypes();
        this._doFieldsReset();
        return field;
    },
    */
	clearFields: function () {
        if (!this._checkClientState()) return;
		if (this._fields.length > 0) {
			this.$_internalClearFields();
			this._doFieldsReset();
		}
	},
	getFieldNames: function () {
		var i, cnt,
            names = [];
		for (i = 0, cnt = this._fields.length; i < cnt; i++) {
			names.push(this._fields[i]._fieldName);
		}
		return names;
	},
	getFieldHeaders: function () {
		var i, cnt, f,
            headers = [];
		for (i = 0, cnt = this._fields.length; i < cnt; i++) {
			f = this._fields[i];
			headers.push(f._header || f._fieldName);
		}
		return headers;
	},
	getFieldName: function (field) {
		this._checkFieldIndex(field);
		return this._fields[field]._fieldName;
	},
    getFieldByName: function (fieldName, ignoreCase) {
        var i = this.getFieldIndex(fieldName, ignoreCase);
        return i >= 0 ? this._fields[i] : null;
    },
	getFieldIndex: function (fieldName, ignoreCase) {
		if (fieldName) {
			var map;
			if (ignoreCase) {
				fieldName = fieldName.toUpperCase();
				map = this._fieldMapI;
			} else {
				map = this._fieldMap;
			}
			if (fieldName in map) {
				return map[fieldName];
			}
		}
		return -1;
	},
	getFieldIndexEx: function (field, ignoreCase) {
        var f;
		if (typeof field == "string") {
			f = this.getFieldIndex(field, ignoreCase);
			if (f < 0) {
                f = parseInt(field);
            }
		} else {
			f = parseInt(field);
		}
        return isNaN(f) ? -1 : f;
	},
	getValidFields: function (fldNames, ignoreCase) {
		if (!fldNames) return null;
		var i, s,
			map = ignoreCase ? this._fieldMapI : this._fieldMap,
			flds = [],
			cnt = fldNames.length;
		for (i = 0; i < cnt; i++) {
			s = fldNames[i];
			if (s) {
				if (ignoreCase) {
					s = s.toUpperCase();
				}
				if (s in map) {
					flds.push(this._fields[map[s]]);
				}
			}
		}
		return flds;
	},
    getFieldByName: function (fieldName, ignoreCase) {
		if (fieldName) {
			var map = ignoreCase ? this._fieldMapI : this._fieldMap;
			if (ignoreCase) {
				fieldName = fieldName.toUpperCase();
			}
			if (fieldName in map) {
				return this._fields[map[fieldName]];
			}
		}
        return null;
    },
    /** @internal */
	getValueType: function (field) {
		return this._fields[field]._dataType;
	},
    /** @internal */
	getDefaultValue: function (field) {
		return this._fields[field]._defaultValue;
	},
    getDefaultValues: function () {
        var i,
			flds = this._fields,
        	defs = new Array(flds.length);
        for (i = flds.length; i--;) {
            defs[i] = flds[i]._defaultValue;
        }
        return defs;
    },
    isUpdated: function (row, field) {
        return false;
    },
    getValue: function (row, field) {
    },
    getRowTag: function (row) {
    },
    getRowsByTag: function (tag) {
    },
    getRowsByTags: function (tags) {
    },
    setRowTag: function (row, tag) {
    },
    setRowTags: function (rows, tag) {
    },
    unsetRowTags: function (rows, tags) {
    },
	clearRowTags: function () {
	},
	getRowState: function (row) {
	},
	setRowState: function (row, state, force) {
	},
	clearRowStates: function (states, deleteRows, rowEvents) {
	},
	getStateRows: function (state) {
	},
	getAllStateRows: function () {
	},
	setRowStates: function (rows, state, force, rowEvents) {
	},
	getRowStateCount: function (states) {
	},
	restoreUpdatedStates: function (rows) {
	},
	restoreUpdatedRows: function (rows) {
	},
	beginUpdate: function () {
        if (!this._checkClientState()) {
            return false;
        }
        this._eventLock++;
        return true;
	},
	endUpdate: function (refresh) {
		if (!this._checkClientState()) {
            return;
        }
		if (this._eventLock > 0) {
			this._eventLock--;
            refresh = arguments.length > 0 ? refresh : true;
			if (this._eventLock == 0 && refresh) {
				this._doEndUpdate(refresh);
			}
		}
	},
    _doEndUpdate: function (refresh) {
        if (refresh) {
            if (this._resetLock > 0) {
                this._fireReset();
                this._resetLock = 0;
            } else {
                this._fireRefresh();
            }
            if (this._countLock > 0) {
                this._fireRowCountChanged();
                this._countLock = 0;
            }
        } else {
            this._resetLock = this._countLock = 0;
        }
    },
	hasData: function (row) {
		return false;
	},
	canUpdateRow: function (row) {
		return true;
	},
	canAppendRow: function () {
		return true;
	},
	canInsertRow: function (row) {
		return true;
	},
	canDeleteRow: function (row) {
		return true;
	},
	canUpdateValue: function (row, field) {
        var fld, st;
		if (field >= 0 && field < this._baseFieldCount) {
            fld = this._fields[field];
            if (!fld._updatable && row >= 0) {
                try {
                    st = this.getRowState(row);
                    return !st || st == DataRowState.CREATED || st == DataRowState.CREATE_AND_DELETED;
                } catch (err) {
                    return false;
                }
            }
            return true;
        }
        return false;
	},
    /*
	getDataComparer: function (field) {
		if (field >= 0) {
			var comparer = this._comparers[field];
			if (comparer) {
				return comparer;
			}
		}
		this._defComparer.dataType = field >= 0 ? this.getValueType(field) : ValueType.TEXT;
		return this._defComparer;
	},
	setDataComaprer: function (field, comparer) {
		if (comparer) {
			this._comparers[field] = comparer;
		} else {
			this._comparers[field] = undefined;
		}
	},
	*/
	canSummarize: function (field) {
		if (field >= 0 && field < this.fieldCount()) {
			var t = this.getValueType(field);
			if (t === ValueType.BOOLEAN || t === ValueType.NUMBER || t === ValueType.DATETIME) {
				return true;
			}
		}
		return false;
	},
	getDistinctValues: function (field, maxCount) {
        maxCount = arguments.length > 1 ? maxCount : -1;
        field = this.getFieldIndexEx(field);
        this._checkFieldIndex(field);
        return this._doGetDistinctValues(field, maxCount);
	},
    _doGetDistinctValues: function (field, maxCount) {
        return null;
    },
	registerClient: function (client) {
		if (client && this._clients.indexOf(client) < 0) {
			this._clients.push(client);
		}
	},
	unregisterClient: function (client) {
		if (client) {
			var index = this._clients.indexOf(client);
			index >= 0 && this._clients.splice(index, 1);
		}
	},
	cancelClients: function () {
		for (var i = this._clients.length; i--;) {
			this._clients[i].cancelDataEditing(this);
		}
	},
	commitClients: function () {
		for (var i = this._clients.length; i--;) {
			this._clients[i].commitDataEditing(this);
		}
	},
	refreshClients: function () {
		for (var i = this._clients.length; i--;) {
			this._clients[i].dataRefreshRequested(this);
		}
	},
    updateDerivedValues: function (row, values, source) {
        return this.$_deriveValues(row, values, source, true);
    },
    addFieldTrigger: function (field, callback) {
    	this._triggers.addField(field, callback);
    },
    execute: function (command) {
        return this._lockedAction ? this._lockedAction.add(command) : this._dataCommands.execute(command);
    },
    canUndo: function () {
        return this._dataCommands.canUndo();
    },
    canRedo: function () {
        return this._dataCommands.canRedo();
    },
    undo: function () {
        this._dataCommands.undo();
        return this;
    },
    redo: function () {
        this._dataCommands.redo();
        return this;
    },
    canUndoAll: function (bookmark) {
        return this._dataCommands.canUndoAll(bookmark);
    },
    canRedoAll: function (bookmark) {
        return this._dataCommands.canRedoAll(bookmark);
    },
    undoAll: function (bookmark, silent) {
        this._dataCommands.undoAll(bookmark, silent);
        return this;
    },
    redoAll: function (bookmark, silent) {
        this._dataCommands.redoAll(bookmark, silent);
        return this;
    },
    clearUndo: function () {
        this._dataCommands.flush();
        return this;
    },
    setBookmark: function (bookmark) {
        this._dataCommands.setBookmark(bookmark);
    },
    unsetBookmark: function (bookmark) {
        this._dataCommands.unsetBookmark(bookmark);
    },
    clearBookmarks: function () {
        this._dataCommands.clearBookmarks();
    },
    beginActions: function () {
        if (this._lockedAction) {
            throw new Error("A locked action already exists");
        }
        return this._lockedAction = this.createActionGroup();
    },
    endActions: function (canceled) {
        var group = this._lockedAction;
        if (group) {
            this._lockedAction = null;
            if (!canceled) {
                this.execute(group);
            }
        }
    },
    requestPending: function () {
        return this._pending = this._createPending();
    },
    createActionGroup: function () {
    },
    equalRowValues: function (vals1, vals2, strict) {
        var i, flds = this._fields;
        for (i = flds.length; i--;) {
            if (strict && !flds[i].equalValues(vals1[i], vals2[i])) {
                return false;
            } else if (!strict && !flds[i].sameValues(vals1[i], vals2[i])) {
                return false;
            }
        }
        return true;
    },
    equalRowObjects: function (obj1, obj2, strict) {
        var i, n,
            flds = this._fields;
        for (i = flds.length; i--;) {
            n = flds[i]._fieldName;
            if (strict && !flds[i].equalValues(obj1[n], obj2[n])) {
                return false;
            } else if (!strict && !flds[i].sameValues(obj1[n], obj2[n])) {
                return false;
            }
        }
        return true;
    },
    recalcRows: function (rows) {
        if (this._derivedFieldCount) {
            var ret;
            if (rows == null || rows === undefined) {
                ret = this._doRecalcAll();
            } else if (_isArray(rows)) {
                ret = this._doRecalcRows(rows);
            } else {
                ret = this._doRecalcRow(rows);
            }
            ret && this._fireCalculated(rows);
        }
    },
    getComparer: function (field) {
        switch (this.getField(field).dataType()) {
            case ValueType.NUMBER:
                return this.compareNumbers;
            case ValueType.DATETIME:
                return this.compareDates;
            case ValueType.BOOLEAN:
                return this.compareBools;
            case ValueType.OBJECT:
                return this.compareObjs;
            default:
                return this.compareValues;
        }
    },
    _doFieldsReset: function () {
        var i, cnt = this._fields.length;
        this._fieldNames = new Array(cnt);
        for (i = 0; i < cnt; i++) {
            this._fieldNames[i] = this._fields[i]._fieldName;
        }
        this._fireReset();
    },
	_checkClientState: function () {
        if (this._pending) {
            if (this._throwPendingError) {
                throw new DataSetPendingError();
            }
            return false;
        }
		if (this._checkClients && this.$_isClientsBusy()) {
			if (this._throwClientError) {
				throw new ClientEditingError();
			}
			if (this._alertClientError) {
				_alert(ClientEditingError.message);
				_throwDebug(ClientEditingError.message);
			}
			return false;
		}
		return true;
	},
    _createPending: function () {
    },
	_doCheckStatesChanged: function () {
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
	},
	$_isClientsBusy: function () {
		for (var i = this._clients.length; i--;) {
			if (this._clients[i].isDataEditing()) {
				return true;
			}
		}
		return false;
	},
	_checkFieldIndex: function (field, s) {
		if (isNaN(field) || field != parseInt(field) || field < 0 || field >= this._fields.length) {
            if (s) {
                throw new DataSetError("Invalid field name: " + s);
            }
			throw new DataSetError("Invalid field index: " + field);
		}
	},
	$_internalClearFields: function () {
        if (this._fields) {
            for (var i = this._fields.length; i--;) {
                this._fields[i].$_setIndex(-1);
            }
            this._fields.splice(0, this._fields.length);
        } else {
            this._fields = [];
        }
		this._derivedFieldCount = this._baseFieldCount = 0;
        this._derivedRuntime.prepare(this);
        this._fieldMap = {};
        this._fieldMapI = {};
	},
	$_internalInsertField: function (index, field) {
        if (!(field instanceof DataField)) return -1;
		var i,
            len = this._fields.length;
		if (index < 0 || index > len) {
			throw new DataSetError("index is out of bounds:" + index);
		}
        field._prepare(this);
        this._fields.splice(index, 0, field);
        field.$_setIndex(index);
        var fname = field.fieldName();
        this._fieldMap[fname] = index;
        this._fieldMapI[fname.toUpperCase()] = index;
        for (i = index + 1; i <= len; i++) {
            field = this._fields[i];
            field.$_setIndex(i);
            fname = field.fieldName();
            this._fieldMap[fname] = i;
            this._fieldMapI[fname.toUpperCase()] = i;
        }
        this._derivedRuntime.prepare(this);
        field instanceof DerivedField ? (this._derivedFieldCount++) : (this._baseFieldCount++);
        return index;
	},
	refreshFieldFormats: function () {
		for (var i = this._fields.length; i--;) {
			this._fields[i]._refreshFormats(this);
		}
	},
	refreshFieldFormat: function (field) {
		field && field._refreshFormats(this);
	},
    $_deriveValues: function (row, vals, source, temp) {
        var i, cnt, f, v, runtime = this._derivedRuntime;
        for (i = 0, cnt = this._derivedFieldCount; i < cnt; i++) {
            f = this._baseFieldCount + i
            v = this._fields[f].$_getValue(this, f, runtime, row, vals, source, temp);
            if (v !== $$$_NOT_CALCED) {
                vals[f] = v;
            }
        }
    },
    $_createOutputRows: function (rows, options, startIdx) {
		startIdx = arguments.length > 2 ? startIdx : 0;
        var flds, r, row, callback, callbacks, nullDate, i, field, prop, cb, writer, d,
            list = _asArray(startIdx),
            rowCount = rows.length;
        if (!(options instanceof DataOutputOptions)) {
            options = new DataOutputOptions(options);
        }
        flds = options.$_prepareFields(this);
        fldCount = this.fieldCount();
		callback = options.valueCallback();
		callbacks = options.valueCallbacks();
        nullDate = options.nullDateText();
        for (i = 0; i < fldCount; i++) {
            field = this.getField(i)
            prop = field.fieldName();
            if (!flds || flds.indexOf(field) >= 0) {
                cb = (callbacks && callbacks[prop]) || callback;
                if (cb) {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = cb(list ? list[r] : r + startIdx, prop, row[prop]);
                    }
                } else if (field._dataType == ValueType.DATETIME) {
                    if (writer = options._datetimeWriter) {
                        for (r = 0; r < rowCount; r++) {
                            row = rows[r];
                            d = row[prop];
                            row[prop] = d ? writer.getText(row[prop]) : nullDate;
                        }
                    } else {
                        for (r = 0; r < rowCount; r++) {
                            row = rows[r];
                            if (!row[prop] && nullDate) {
                                row[prop] = nullDate;
                            }
                        }
                    }
                } else if (field._dataType == ValueType.BOOLEAN && (writer = options._booleanFormatter)) {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = writer.formatValue(row[prop]);
                    }
                }
            } else {
                for (r = 0; r < rowCount; r++) {
                    delete rows[r][prop];
                }
            }
        }
    },
    $_createOutputLines: function (values, options, startRow, endRow) {
		if (!(options instanceof DataOutputOptions)) {
			options = new DataOutputOptions(options);
		}
        var r, vals, line, f, v, field, writer, cb, prop,
            flds = options.$_prepareFields(this),
            fldCount = flds ? flds.length : this.fieldCount(),
		    callback = options.valueCallback(),
		    callbacks = options.valueCallbacks(),
            sep = options.separator() || ",",
            quoted = options.quoted(),
            nullDate = options.nullDateText(),
            lf = options.lfText(),
		    cr = options.crText(),
            s = "";
        for (r = startRow; r < endRow; r++) {
            vals = values[r];
            line = "";
            if (vals) {
                for (f = 0; f < fldCount; f++) {
                    v = vals[f];
                    field = this._fields[f];
					prop = field.fieldName();
                    if (!flds || flds.indexOf(field) >= 0) {
                        cb = (callbacks && callbacks[prop]) || callback;
                        if (cb) {
                            v = cb(r, prop, v);
                        } else if (field._dataType == ValueType.DATETIME) {
                            if (writer = options._datetimeWriter) {
                                v = v ? writer.getText(v) : nullDate;
                            } else if (!v && nullDate) {
                                v = nullDate;
                            }
                        } else if (field._dataType == ValueType.BOOLEAN && (writer = options._booleanFormatter)) {
                            v = writer.formatValue(v);
                        } else if (field._dataType == ValueType.TEXT && v) {
                            if (cr) {
                                v = v.replace(/\r/g, cr);
                            }
                            if (lf) {
                                v = v.replace(/\n/g, lf);
                            }
                        }
                        if (v === undefined || v === null) {
                            v = '';
                        }
                        line += quoted ? ('"' + v + '"') : v;
                        if (f < fldCount - 1) {
                            line += sep;
                        }
                    }
                }
            }
            s += line;
            if (r < endRow - 1) {
                s += "\r\n";
            }
        }
        return s;
    },
	$_sortRows: function (rows, field, compFunc, left, right) {
		var i, j, row, m, r, v, t;
		do {
			i = left;
			j = right;
			row = _int((left + right) / 2);
			m = rows[row];
			do {
				while (i <= j) {
					r = rows[i];
					v = compFunc(field, m, r);
					if (v <= 0)
						break;
					i++;
				}
				while (i <= j) {
					r = rows[j];
					v = compFunc(field, m, r);
					if (v >= 0)
						break;
					j--;
				}
				if (i <= j) {
					if (i != j) {
						t = rows[i];
						rows[i] = rows[j];
						rows[j] = t;
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				this.$_sortRows(rows, field, compFunc, left, j);
			}
			left = i;
		} while (left < right);
	},
    $_getComparer: function (valueType, ignoreCase) {
        switch (valueType) {
            case ValueType.DATETIME:
            case ValueType.NUMBER:
                return this.$_cmpNum || (this.$_cmpNum = this.compareNumbers.bind(this));
            case ValueType.BOOLEAN:
                return this.$_cmpBool ||  (this.$_cmpBool = this.compareBools.bind(this));
            case ValueType.OBJECT:
                return this.$_cmpObj || (this.$_cmpObj = this.compareObjs.bind(this));
            default:
                if (ignoreCase) {
                    return this.$_cmpText || (this.$_cmpText = this.compareTexts.bind(this));
                } else {
                    return this.$_cmpVal || (this.$_cmpVal = this.compareValues.bind(this));
                }
        }
    },
    $_getEmptyValue: function (ev) {
        if (_isObject(ev)) {
            var i, f, obj = {};
            for (i = this._fields.length; i--;) {
                f = this._fields[i];
                obj[f._fieldName] = ev[f._fieldName];
            }
            return obj;
        }
        return ev === null ? undefined : ev;
    },
    onFieldChanged: function (field, prop) {
    },
    $_cmd: function (cmd) {
        return this._undoable && cmd;
    },
    _fireDisposed: function (cmd) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.DISPOSED);
            this.onDisposed && (!this._onStack || this._eventable) && this.onDisposed(this);
        }
    },
    _fireReset: function (cmd) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.RESET);
            this.onReset && (!this._onStack || this._eventable) && this.onReset(this);
        } else {
            this._resetLock++;
        }
    },
    _fireRefresh: function (cmd) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.REFRESH);
            this.onRefresh && (!this._onStack || this._eventable) && this.onRefresh(this);
        }
    },
    _fireRowCountChanged: function (cmd) {
        if (this._eventLock <= 0) {
            var count = this.rowCount();
            this.$$_cmd = cmd;
            this.fireEvent(GridDataSet.ROW_COUNT_CHANGED, count);
            this.onRowCountChanged && this.onRowCountChanged(this, count);
        } else {
            this._countLock++;
        }
    },
    _fireStatesCleared: function (cmd) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.STATES_CLEARED);
            this.onStatesCleared && (!this._onStack || this._eventable) && this.onStatesCleared(this);
        }
    },
    _fireTagsCleared: function (cmd) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.TAGS_CLEARED);
            this.onTagsCleared && (!this._onStack || this._eventable) && this.onTagsCleared(this);
        }
    },
    _fireCalculated: function (cmd, rows) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.CALCULATED, rows);
        }
    },
    _fireCommandStackChanged: function (canUndo, canRedo) {
        if (this._eventLock <= 0) {
            this.fireEvent(DataSet.COMMAND_STACK_CHANGED, canUndo, canRedo);
            this.onCommandStackChanged && this.onCommandStackChanged(this, canUndo, canRedo);
        }
    }
}, {
	DISPOSED: "onDataSetDisposed",
	RESET: "onDataSetReset",
	REFRESH: "onDataSetRefresh",
	DATA_CHANGED: "onDataSetDataChanged",
	STATES_CLEARED: "onDataSetStatesCleared",
    TAGS_CLEARED: "onDataSetTagsCleared",
    CALCULATED: "onDataSetCalculated",
    COMMAND_STACK_CHANGED: "onDataSetCommandStackChanged",
    ALL_ROWS: { all: "rows" }
});
/** @internal */
var DataFilterRuntime = defineClass("DataFilterRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
	},
	prepare: function (provider) {
		this._provider = provider;
		this._fieldCount = provider ? provider.fieldCount() : 0;
        return this;
	},
	setRow: function (no, row, values) {
        this._no = no;
		this._row = row;
		this._values = values;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return DataRowExpressionRuntime.IDENTS[token];
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
            case DataRowExpressionRuntime.ID_NO:
                return this._no;
            case DataRowExpressionRuntime.ID_ROW:
                return this._row;
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
			case DataRowExpressionRuntime.ID_VALUES:
				return this._values[index];
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index) {
		switch (idKey) {
			case DataRowExpressionRuntime.ID_VALUES:
				var field = this.$_getField(index);
				return this._values[field];
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	$_getField: function (index) {
		var	fld = this._provider.getFieldIndex(index, true);
		if (fld < 0 || fld >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field is not exits:" + index);
		}
		return fld;	
	}
}, {
    ID_NO: 0,
	ID_ROW: 1,
	ID_VALUES: 2
}, function (f) {
	f.IDENTS = {
        no: f.ID_NO,
		row: f.ID_ROW,
		values: f.ID_VALUES
	};
});
var DataFilter = defineClass("DataFilter", null, {
	init: function (criteria) {
		this._super();
		this._runtime = null;
		this._exprNode = null;
		this.setCriteria(criteria);
	},
	criteria: null,
	setCriteria: function (value) {
		value = value && value.trim();
		if (value != this._criteria) {
			this._criteria = value;
			if (value) {
				this._exprNode = ExpressionParser.Default.parse(value);
			} else {
				this._exprNode = null;
			}
		}
	},
    prepare: function (runtime) {
        this._runtime = runtime;
    },
	select: function (no, row, values) {
		if (this._exprNode) {
			this._runtime.setRow(no, row, values);
			return this._exprNode.evaluate(this._runtime);
		} else {
			return true;
		}
	}
});
/*
var DataTrigger = defineClass("DataTrigger", null, {
	init: function (dataSet, callback) {
		this._super();
		this._dataSet = dataSet;
		this._callback = callback;
	},
	prepare: function (row) {
	},
	fire: function () {
	}
});
*/
/*
var DataTriggerCollection = defineClass("DataTriggerCollection", null, {
	init: function () {
		this._super();
		this._items = [];
	},
	count: function () {
		return this._items.length;
	},
	add: function (trigger) {
		if (trigger && this._items.indexOf(trigger) < 0) {
			this._items.push(trigger);
		}
		return this;
	},
	prepare: function (row) {
		for (var i = this._items.length; i--;) {
			this._items[i].prepare(row);
		}
	},
	fire: function () {
		for (var i = this._items.length; i--;) {
			this._items[i].fire();
		}
	}
});
*/
/*
var DataTriggerManager = defineClass("DataTriggerManager", null, {
	init: function (dataSet) {
		this._super();
		this._dataSet = dataSet;
		this._fields = {};
	},
	addField: function (field, callback) {
		if (field !== undefined && field !== null && callback) {
			var trigger = new FieldTrigger(this._dataSet, field, callback);
			var list = this._fields[field];
			if (list instanceof DataTriggerCollection) {
				list.add(trigger);
			} else if (list) {
				var t = list;
				list = new DataTriggerCollection();
				list.add(t).add(trigger);
				this._fields[field] = list;
			} else {
				this._fields[field] = trigger;
			}
		}
	},
	prepareUpdate: function (row) {
		var list = this._fields;
		for (var t in list) {
			list[t].prepare(row);
		}
	},
	fireUpdate: function () {
		var list = this._fields;
		for (var t in list) {
			list[t].fire();
		}
	}
});
*/
/*
var FieldTrigger = defineClass("FieldTrigger", DataTrigger, {
	init: function (dataSet, field, callback) {
		this._super(dataSet, callback);
		this._field = isNaN(field) ? dataSet.getFieldIndex(field, true) : _int(field);
		if (this._field < 0 || this._field >= dataSet.fieldCount()) {
			throw "Invalid field name or index: " + field;
		}
		this._field = this._dataSet.getField(this._field);
		this._row = undefined;
		this._oldValue = undefined;
	},
	prepare: function (row) {
		this._row = row;
		this._oldValue = this._dataSet.getValue(row, this._field._index);
	},
	fire: function () {
		if (this._callback) {
			var value = this._dataSet.getValue(this._row, this._field._index);
			if (!this._field.equalValues(this._oldValue, value)) {
				this._callback(this._row, this._oldValue, value);
			}
		}
	}
});
*/
var DataCommandStack = defineClass("DataCommandStack", EditCommandStack, {
    init: function (ds) {
        this._super(ds);
    },
    undoAll: function (bookmark, silent) {
        var ds = this._owner,
            eventable = ds._eventable;
        ds._eventable = eventable && !slient;
        try {
            while (this.canUndo() && (!bookmark || this._currCmd().$$_mark !== bookmark)) {
                this.undo();
            }
        } finally {
            ds._eventable = eventable;
        }
    },
    redoAll: function (bookmark, silent) {
        var ds = this._owner,
            eventable = ds._eventable;
        ds._eventable = eventable && !slient;
        try {
            while (this.canRedo()) {
                this.redo();
                if (bookmark && this._currCmd().$$_mark === bookmark) break;
            }
        } finally {
            ds._eventable = eventable;
        }
    },
    canUndoAll: function (bookmark) {
        if (bookmark) {
            if (bookmark ===  this.$$_mark) {
                return this.canUndo();
            }
            if (this._current > 0) {
                var i, cmds = this._commands;
                for (i = this._current; i > 0; i--) {
                    if (cmds[i].$$_mark === bookmark) {
                        return true;
                    }
                }
            }
            return false;
        }
        return this.canUndo();
    },
    canRedoAll: function (bookmark) {
        if (bookmark) {
            var i,
                cmds = this._commands,
                cnt = cmds.length;
            if (this._current < cnt - 1) {
                for (i = this._current + 1; i < cnt; i++) {
                    if (cmds[i].$$_mark === bookmark) {
                        return true;
                    }
                }
            }
            return false;
        }
        return this.canRedo();
    },
    setBookmark: function (bookmark) {
        if (bookmark) {
            if (this._current >= 0) {
                this._commands[this._current].$$_mark = bookmark;
            } else {
                this.$$_mark = bookmark;
            }
            return true;
        }
    },
    unsetBookmark: function (bookmark) {
        if (bookmark) {
            if (bookmark === this.$$_mark) {
                delete this.$$_mark;
            } else {
                var i, cmds = this._commands;
                for (i = cmds.length; i--;) {
                    if (cmds[i].$$_mark === bookmark) {
                        delete cmds[i].$$_mark;
                        return true;
                    }
                }
            }
        }
    },
    clearBookmarks: function () {
        var i, cmds = this._commands;
        delete this.$$_mark;
        for (i = cmds.length; i--;) {
            delete cmds[i].$$_mark;
        }
    }
});
/** @abstract */
var DataSetEditCommand = defineClass("DataSetEditCommand", EditCommand, {
    init: function (ds) {
        this._super();
        this.ds = ds;
        this.undoable = ds.undoable();
    },
    undo: function (post) {
        var ds = this.ds;
        if (!ds._checkClientState()) {
            return this.throwEmpty();
        }
        this.saveCheckStates = ds._checkStates;
        this.saveSoftDelete = ds._softDelete;
        this.saveOrgValues = ds._orgValues;
        ds._checkStates = this.checkStates;
        ds._softDelete = this.softDelete;
        ds._orgValues = this.orgValues;
        try {
            this.keep = this._doKeep(ds, this.save);
            return this._doUndo(ds, this.save, post);
        } finally {
            ds._checkStates = this.saveCheckStates;
            ds._softDelete = this.saveSoftDelete;
            ds._orgValues = this.saveOrgValues;
        }
    },
    redo: function (redoing, post) {
        var ds = this.ds;
        if (this.undoable) {
            if (!redoing) {
                this.checkStates = ds._checkStates;
                this.softDelete = ds._softDelete;
                this.orgValues = ds._orgValues;
            }
            this.saveCheckStates = ds._checkStates;
            this.saveSoftDelete = ds._softDelete;
            this.saveOrgValues = ds._orgValues;
            ds._checkStates = this.checkStates;
            ds._softDelete = this.softDelete;
            ds._orgValues = this.orgValues;
        }
        try {
            if (!ds._checkClientState()) {
                return this.throwEmpty();
            }
            if (redoing) {
                return this._doRedo(ds, this.keep, post);
            } else if (this.undoable) {
                return this._doRun(ds, this.save = {}, post);
            } else {
                return this._doRun(ds, null, post);
            }
        } finally {
            if (this.undoable) {
                ds._checkStates = this.saveCheckStates;
                ds._softDelete = this.saveSoftDelete;
                ds._orgValues = this.saveOrgValues;
            }
        }
    },
    postUndo: function (post) {
        this._doPostUndo(this.ds, post);
    },
    postRedo: function (post) {
        this._doPostRedo(this.ds, post);
    },
    postRun: function (post) {
        this._doPostRun(this.ds, post);
    },
    rollback: function () {
        this._doRollback(this.ds);
    },
    Empty: function () {
        return DataSetEditCommand.Empty;
    },
    _doUndo: function (ds, save, post) {
    },
    _doKeep: function (ds, save) {
    },
    _doRun: function (ds, save, post) {
    },
    _doRedo: function (ds, keep, post) {
    },
    _doPostUndo: function (ds, post) {
    },
    _doPostRedo: function (ds, post) {
    },
    _doPostRun: function (ds, post) {
    },
    _doRollback: function (ds) {
    },
    $_updating: function () {
        return false;
    }
}, {
    Empty: {}
});
var DataActionGroup = defineClass("DataActionGroup", EditCommandGroup, {
    init: function (ds, immediately) {
        this._super(immediately);
        this.ds = ds;
        this.undoable = ds.undoable();
    }
});
/** @abstract */
var DataSetPending = defineClass("DataSetPending", null, {
    init: function (action) {
        this._super();
        this._action = action;
    },
    action: function () {
        return this._action;
    },
    close: function () {
    },
    cancel: function () {
    }
});
/** @internal */
var DataHelper = {
	csvToArray: function (provider, source, start, count, quoted, trim, delimiter, currency, treeFld) {
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		delimiter = arguments.length > 5 ? delimiter : ",";
		var i, s, len, lines, r, line, vals, v, flds, fieldCount, hflds, hasFlds,
			rows = null;
		if (source) {
			lines = source.split("\r\n");// source.split(/(\r\n|\n|\r)/);
			if (lines.length == 1) {
				lines = source.split("\n");
			}
			if (lines.length == 1) {
				lines = source.split("\r");
			}
			for (i = lines.length - 1; i >= 0; i--) {
				s = lines[i];
				s = s ? s.trim() : null;
				if (s && s.length > 0) {
					break;
				}
				lines.pop();
			}
			len = lines.length;
			if (len > 0) {
				start = Math.max(0, start);
				if (count < 0) {
					count = len;
				}
				count = Math.min(len - start, count);
				if (count > 0) {
					flds = provider.fields();
					fieldCount = flds.length;
                    nflds = new Array(fieldCount);
					hasFlds = fieldCount > 0;
                    if (currency) {
                        for (i = 0; i < fieldCount; i++) {
                            nflds[i] = flds[i].dataType() == ValueType.NUMBER;
                        }
                    }
					rows = new Array(count);
					if (quoted) {
						for (r = 0; r < count; r++) {
							line = lines[r + start];
							vals = $_parseCSV(line, delimiter);
							if (hasFlds && vals.length > fieldCount) {
								vals.splice(vals.length, fieldCount - vals.length);
							}
							if (treeFld >= 0) {
								for (i = 0; i < treeFld; i++) {
									v = vals[i];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim) {
                                            v = v.trim();
                                        }
                                    }
									vals[i] = flds[i].readValue(v);
								}
								for (i = treeFld; i < fieldCount; i++) {
									v = vals[i + 1];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim) {
                                            v = v.trim();
                                        }
                                        vals[i + 1] = flds[i].readValue(v);
                                    }
								}
							} else {
								for (i = 0; i < fieldCount; i++) {
									v = vals[i];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim && v) {
                                            v = v.trim();
                                        }
                                        vals[i] = flds[i].readValue(v);
                                    }
								}
							}
							rows[r] = vals;
						}
					} else {
						for (r = 0; r < count; r++) {
							line = lines[r + start];
							vals = line.split(delimiter);
							if (hasFlds && vals.length > fieldCount) {
								vals.splice(vals.length, fieldCount - vals.length);
							}
							if (treeFld >= 0) {
								for (i = 0; i < treeFld; i++) {
									v = vals[i];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim && v) {
                                            v = v.trim();
                                        }
                                        vals[i] = flds[i].readValue(v);
                                    }
								}
								for (i = treeFld; i < fieldCount; i++) {
									v = vals[i + 1];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim && v) {
                                            v = v.trim();
                                        }
                                        vals[i + 1] = flds[i].readValue(v);
                                    }
								}
							} else {
								for (i = 0; i < fieldCount; i++) {
									v = vals[i];
                                    if (v) {
                                        if (nflds[i]) {
                                            v = v.replace($_currencyreg, '');
                                        } else if (trim && v) {
                                            v = v.trim();
                                        }
                                        vals[i] = flds[i].readValue(v);
                                    }
								}
							}
							rows[r] = vals;
						}
					}
				}
			}
		}
		return rows;
	},
	xmlToRow: function (xml, fields, fieldNames) {
		var i, len, c, node,
			nodes = xml.childNodes,
        	fldCnt = fields.length,
			vals = new Array(fldCnt);
		for (i = 0, len = nodes.length; i < len; i++) {
			node = nodes[i];
			if ((c = fieldNames.indexOf(node.tagName)) >= 0) {
                var v = _getNodeValue(node);
				vals[c] = v;
			}
		}
		for (i= 0; i < fldCnt; i++) {
			if (vals[i] === undefined) {
                v = _getXmlAttr(xml, fieldNames[i]);
				vals[i] = v;
			}
		}
		return vals;
	},
	xmlToArray: function (provider, xmlList, start, count, currency) {
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		var flds, fldNames, i, xml, vals,
			rows = null,
			xmlToRow = DataHelper.xmlToRow,
			cnt = xmlList ? xmlList.length : 0;
		if (cnt) {
			start = Math.max(0, start);
			if (count < 0) {
				count = cnt;
			}
			count = Math.min(cnt - start, count);
			if (count) {
				flds = provider.fields();
				fldNames = provider.getFieldNames();
				rows = new Array(count);
				for (i = 0; i < count; i++) {
					xml = xmlList[i + start];
					vals = xmlToRow(xml, flds, fldNames, currency);
					rows[i] = vals;
				}
			}
		}
		return rows;
	}
};
var GridDataActionGroup = defineClass("GridDataActionGroup", DataActionGroup, {
    init: function (ds, immediately) {
        this._super(ds, immediately);
    },
    clearRows: function () {
        return this.add(new DataClearRowsCommand(this.ds));
    },
    setRows: function (rows, start, count, rowState, filter) {
        return this.add(new DataSetRowsCommand(this.ds, rows, start, count, rowState, filter));
    },
    setXmlRows: function (rows, start, count, state, filter) {
        var rows = DataHelper.xmlToArray(this, rows, start, count);
        return this.add(new DataSetRowsCommand(this.ds, rows, start, count, rowState, filter));
    },
    setRowCount: function (newCount, fillDefaults, defaultValues, rowState) {
        return this.add(new DataSetRowCountCommand(this.ds, newCount, fillDefaults, defaultValues, rowState));
    },
    setValue: function (row, field, value) {
        return this.add(new DataSetValueCommand(this.ds, row, field, value, true, true, false));
    },
    setValueEx: function (row, field, value, checkDiff, strictDiff, noEvent) {
        return this.add(new DataSetValueCommand(this.ds, row, field, value, checkDiff, noEvent));
    },
    updateRow: function (row, values, checkDiff, strictDiff, checkEmpty) {
        return this.add(new DataUpdateRowCommand(this.ds, row, values, checkDiff, strictDiff, checkEmpty));
    },
    updateRows: function (row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter) {
        return this.add(new DataUpdateRowsCommand(this.ds, row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter));
    },
    updateXmlRows: function (row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter) {
        var rows = DataHelper.xmlToArray(this, rows, start, count);
        return this.add(new DataUpdateRowsCommand(this.ds, row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter));
    },
    updateValues: function (where, newValues, checkDiff, strictDiff, noState) {
        return this.add(new DataUpdateValuesCommand(this.ds, where, newValues, checkDiff, strictDiff, noState));
    },
    deleteRow: function (row) {
        return this.add(new DataDeleteRowCommand(this.ds, row));
    },
    deleteRows: function (rows, rowEvents) {
        return this.add(new DataDeleteRowsCommand(this.ds, rows, rowEvents));
    },
    insertRow: function (row, values, field) {
        return this.add(new DataInsertRowCommand(this.ds, row, values, field));
    },
    appendRow: function (values, field) {
        return this.add(new DataInsertRowCommand(this.ds, this.ds.rowCount(), values, field));
    },
    insertRows: function (row, rows, start, count, rowEvents, filter) {
        return this.add(new DataInsertRowsCommand(this.ds, row, rows, start, count, rowEvents, filter));
    },
    insertXmlRows: function (row, rows, start, count, rowEvents, filter) {
        var rows = DataHelper.xmlToArray(this, rows, start, count);
        return this.add(new DataInsertRowsCommand(this.ds, row, rows, start, count, rowEvents, filter));
    },
    appendRows: function (rows, start, count, rowEvents, filter) {
        return this.add(new DataInsertRowsCommand(this.ds, this.ds.rowCount(), rows, start, count, rowEvents, filter));
    },
    appendXmlRows: function (rows, start, count, rowEvents, filter) {
        var rows = DataHelper.xmlToArray(this, rows, start, count);
        return this.add(new DataInsertRowsCommand(this.ds, this.ds.rowCount(), rows, start, count, rowEvents, filter));
    },
    moveRow: function (row, newRow) {
        return this.add(new DataMoveRowCommand(this.ds, row, newRow));
    },
    moveRows: function (row, count, newRow) {
        return this.add(new DataMoveRowsCommand(this.ds, row, count, newRow));
    },
    setRowState: function (row, state, force) {
        return this.add(new DataSetRowStateCommand(this.ds, row, state, force));
    },
    setRowStates: function (rows, state, force, rowEvents) {
        return this.add(new DataSetRowStatesCommand(this.ds, rows, state, force, rowEvents));
    },
    clearRowStates: function (states, deleteRows, rowEvents) {
        return this.add(new DataClearRowStatesCommand(this.ds, states, deleteRows, rowEvents));
    },
    restoreUpdatedStates: function (rows) {
        return this.add(new DataRestoreUpdatedStatesCommand(this.ds, rows));
    },
    restoreUpdatedRows: function (rows) {
        return this.add(new DataRestoreUpdatedRowsCommand(this.ds, rows));
    },
    setRowTag: function (row, tag) {
        return this.add(new DataSetRowTagCommand(this.ds, row, tag));
    },
    setRowTags: function (rows, tag) {
        return this.add(new DataSetRowTagsCommand(this.ds, rows, tag));
    },
    unsetRowTags: function (rows, tags) {
        rows = (rows && rows.length > 0) ? rows : null;
        tags = (tags && tags.length > 0) ? tags : null;
        if (!rows && !tags) {
            return this.add(new DataClearRowTagsCommand(this.ds));
        } else {
            return this.add(new DataUnsetRowTagsCommand(this.ds, rows, tags));
        }
    },
    clearRowTags: function () {
        return this.add(new DataClearRowTagsCommand(this.ds));
    }
});
var DataClearRowsCommand = defineClass("DataClearRowsCommand", DataSetEditCommand, {
    init: function (ds) {
        this._super(ds);
    },
    _doUndo: function (ds, save) {
        ds.$_restoreAll(this, save, true);
    },
    _doPostUndo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        var keep = {
        };
        return ds.$_saveAll(this, keep, false);
    },
    _doRun: function (ds, save) {
        if (ds.rowCount() > 0 && ds.isDeletable()) {
            if (save) {
                ds.$_saveAll(this, save, true);
                this._setReady();
            }
            ds.$_clearRows();
            !save && this._doPostRun(ds);
            return true;
        }
        this.throwEmpty();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, false);
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var DataSetRowsCommand = defineClass("DataSetRowsCommand", DataSetEditCommand, {
    init: function (ds, rows, start, count, rowState, filter) {
        this._super(ds);
        this.rows = rows;
        this.start = start;
        this.count = count;
        this.rowState = rowState;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var cnt = ds.rowCount();
        ds.$_clearRows();
        ds.$_restoreAll(this, save, true);
        post.cnt = cnt;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRefresh(this);
        post.cnt > 0 && ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        return ds.$_saveAll(this, {
        }, false);
    },
    _doRun: function (ds, save) {
        var len, end, r, i, row,
            rows = this.rows,
            start = this.start,
            count = this.count,
            rowState = this.rowState,
            filter = this.filter;
        if (!ds.isAppendable()) {
            return this.throwEmpty(0);
        }
        if (ds.rowCount() > 0 && !ds.isDeletable()) {
            return this.throwEmpty(0);
        }
        ds.refreshFieldFormats();
        if (save) {
            ds.$_saveAll(this, save, true);
            this._setReady();
        }
        ds.beginUpdate();
        try {
            ds.$_clearRows();
            ds._rowCount = 0;
            if (rows && (len = rows.length) > 0 && start < len) {
                start = Math.max(0, start);
                if (count < 0) {
                    count = len;
                } else {
                    count = Math.min(count, len - start);
                }
                rowState = ds._checkStates ? (rowState || DataRowState.NONE) : undefined;
                if (filter instanceof DataFilter) {
                    ds._values.length = ds._rowIds.length = ds._rowStates.length = ds._rowTags.length = count;
                    filter.prepare(ds.filterRuntime().prepare(ds));
                    end = len;
                    r = 0;
                    for (i = start; i < end && r < count; i++) {
                        row = rows[i];
                        if (!_isArray(row)) {
                            row = ds.objectToRow(row);
                        }
                        if (filter.select(i, r, row)) {
                            ds._rowStates[r] = rowState;
                            ds._internalSetRow(r++, row);
                        }
                    }
                    ds._values.length = ds._rowIds.length = ds._rowStates.length = ds._rowTags.length = r;
                } else {
                    end = Math.min(len, start + count);
                    if (end > start) {
                        ds._values.length = ds._rowIds.length = ds._rowStates.length = ds._rowTags.length = end - start;
                        r = 0;
                        for (i = start; i < end; i++) {
                            row = rows[i];
                            if (!_isArray(row)) {
                                row = ds.objectToRow(row);
                            }
                            ds._rowStates[r] = rowState;
                            ds._internalSetRow(r++, row);
                        }
                    }
                }
            }
        } finally {
            ds.endUpdate(false);
        }
        ds.setDataInited(true);
        ds._tags.setRows();
        !save && this._doPostRun(ds);
        return ds.rowCount();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, true);
        ds._tags.setRows();
        return ds.rowCount();
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var DataSetRowCountCommand = defineClass("DataSetRowCountCommand", DataSetEditCommand, {
    init: function (ds, newCount, fillDefaults, defaultValues, rowState) {
        this._super(ds);
        this.newCount = newCount;
        this.fillDefaults = fillDefaults;
        this.defaultValues = defaultValues;
        this.rowState = rowState;
    },
    _doUndo: function (ds, save) {
        var i, r,
            delta = this.newRows,
            len = ds._values.length,
            cnt = len - delta;
        if (delta > 0) {
            ds._values.length = ds._rowIds.length = ds._rowStates.length = ds._rowTags.length = cnt;
            ds._orgValues && (ds._orgValues.length = cnt);
            ds._tags.setRowCount(cnt);
        } else {
            for (i = 0; i < -delta; i++) {
                r = len + i;
                ds._values[r] = save.values[i];
                ds._rowIds[r] = save.rowIds[i];
                ds._rowStates[r] = save.rowStates[i];
                ds._rowTags[r] = save.rowTags[i];
                ds._orgValues && (ds._orgValues[r] = save.orgValues[i]);
            }
            ds._tags.setRowCount(cnt);
            ds._tags.$_restoreRows(this, save.rows, true);
        }
    },
    _doPostUndo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        var i, r,
            delta = this.newRows,
            len = ds._values.length,
            cnt = len - delta,
            keep = {
                values: [],
                rowIds: [],
                rowStates: [],
                rowTags: [],
                orgValues: []
            };
        if (delta > 0) {
            keep.rows = save.rows && save.rows.concat();
            for (i = 0; i < delta; i++) {
                r = cnt + i;
                keep.values[i] = ds._values[r] && ds._values[r].concat();
                keep.rowIds[i] = ds._rowIds[r];
                keep.rowStates[i] = ds._rowStates[r];
                keep.rowTags[i] = ds._rowTags[r];
                ds._orgValues && (keep.orgValues[i] = ds._orgValues[r] && ds._orgValues[r].concat());
            }
        } else {
        }
        return keep;
    },
    _doRun: function (ds, save) {
        var save,
            values, oldCount, count, delta, rows,
            i, j, fld, vals, flds, defaults, v, defCount, ids, states, rtags,
            newCount = this.newCount,
            fillDefaults = this.fillDefaults,
            defaultValues = this.defaultValues,
            rowState = this.rowState;
        values = ds._values;
        oldCount = values.length;
        count = Math.max(0, newCount);
        if (count == oldCount) {
            return this.throwEmpty();
        }
        if (count > oldCount && !ds.isAppendable()) {
            return this.throwEmpty();
        }
        if (count < oldCount && !ds.isDeletable()) {
            return this.throwEmpty();
        }
        ds.refreshFieldFormats();
        ids = ds._rowIds,
        states = ds._rowStates,
        rtags = ds._rowTags;
        if (save) {
            delta  = this.newRows = count - oldCount;
            if (delta < 0) {
                if (ds._orgValues) {
                    save.orgValues = ds._orgValues.splice(count, -delta);
                }
                save.values = ds._values.splice(count, -delta);
                save.rowIds = ds._rowIds.splice(count, -delta);
                save.rowStates = ds._rowStates.splice(count, -delta);
                save.rowTags = ds._rowTags.splice(count, -delta);
                rows = new Array(-delta);
                for (i = count; i < oldCount; i++) {
                    rows[i - count] = i;
                }
                save.rows = rows;
                ds._tags.$_saveRows(this, rows);
            } else {
            }
            save.nextRowId = ds._nextRowId;
            save.deletedCount = ds._deletedCount;
            this._setReady();
        }
        values.length = ids.length = states.length = rtags.length = count;
        if (ds._orgValues && ds._orgValues.length > count) {
            ds._orgValues.length = count;
        }
        if (count > oldCount && (fillDefaults || defaultValues)) {
            flds = ds._fields.length;
            defaults = defaultValues;
            if (!_isArray(defaults) && defaults && _isObject(defaults)) {
                defaults = ds.objectToRow(defaults);
            }
            if (defaults && defaults.length < 1) {
                defaults = null;
            }
            if (fillDefaults || defaults) {
                defCount = defaults ? Math.min(defaults.length, flds) : 0;
                for (i = oldCount; i < count; i++) {
                    vals = [];
                    if (fillDefaults) {
                        for (j = 0; j < flds; j++) {
                            fld = ds._fields[j];
                            vals[j] = fld._defaultValue;
                        }
                    }
                    if (defCount > 0) {
                        for (j = 0; j < defCount; j++) {
                            v = defaults[j];
                            if (v !== undefined) {
                                vals[j] = ds._fields[j].readValue(v);
                            }
                        }
                    }
                    ds._derivedFieldCount && ds.$_deriveValues(row, vals, -1);
                    values[i] = vals;
                }
            }
        } else if (count < oldCount && ds._deletedCount > 0) {
            for (i = oldCount - 1; i >= count; i--) {
                if (states[i] == DataRowState.DELETED || states[i] == DataRowState.CREATE_AND_DELETED) {
                    ds._deletedCount--;
                }
                states[i] = DataRowState.NONE;
            }
        }
        rowState = ds._checkStates && rowState ? rowState : DataRowState.NONE;
        for (i = oldCount; i < count; i++) {
            states[i] = rowState;
            ids[i] = ds._nextRowId++;
        }
        ds.setDataInited(true);
        ds._tags.setRowCount(count);
        !save && this._doPostRun(ds);
        return count;
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        var i, r,
            delta = this.newRows,
            len = ds._values.length,
            cnt = len + delta;
        if (delta > 0) {
            for (i = 0; i < delta; i++) {
                r = len + i;
                ds._values[r] = keep.values[i];
                ds._rowIds[r] = keep.rowIds[i];
                ds._rowStates[r] = keep.rowStates[i];
                ds._rowTags[r] = keep.rowTags[i];
                ds._orgValues && (ds._orgValues[r] = keep.orgValues[i]);
            }
            ds._tags.setRowCount(cnt);
            ds._tags.$_restoreRows(this, keep.rows, false);
        } else {
            ds._values.length = ds._rowIds.length = ds._rowStates.length = ds._rowTags.length = cnt;
            ds._orgValues && (ds._orgValues.length = cnt);
            ds._tags.setRowCount(cnt);
        }
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var DataSetValueCommand = defineClass("DataSetValueCommand", DataSetEditCommand, {
    init: function (ds, row, field, value, checkDiff, strictDiff, noEvent) {
        this._super(ds);
        this.row = row;
        this.field = field;
        this.value = value;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.noEvent = noEvent;
    },
    $_updating: function () {
        return true;
    },
    _doUndo: function (ds, save) {
        var row = this.row,
            field = this.field,
            keep = this.keep;
        ds._values[row] = save.values;
        ds._rowStates[row] = save.state;
        ds._orgValues && (ds._orgValues[row] = save.orgValues);
        ds._tags.$_restoreValue(this, row, field);
    },
    _doPostUndo: function (ds) {
        ds._fireValueChanged(this, this.row, this.field);
    },
    _doKeep: function (ds, save) {
        var row = this.row,
            keep = {};
        keep.values = ds._values[row].concat();
        keep.state = ds._rowStates[row];
        ds._orgValues && (keep.orgValues = ds._orgValues[row]);
        return keep;
    },
    _doRun: function (ds, save, post) {
        var row = this.row,
            field = this.field,
            value = this.value;
        return this.$_run(ds, row, field, value, this.checkDiff, this.strictDiff, this.noEvent, save, post) || this.throwEmpty(false);
    },
    $_run: function (ds, row, field, value, checkDiff, strictDiff, noEvent, save, post) {
        var s, fld, state, vals, newVal, ret, oldVals, needState;
        if (!ds.isUpdatable()) {
            return this.throwEmpty(false);
        }
        ds._checkRowIndex(row);
        if (typeof field == "string") {
            s = field;
            field = ds.getFieldIndex(s);
            if (field < 0) {
                field = Number(s);
            }
        }
        ds._checkFieldIndex(field);
        fld = ds._fields[field];
        state = this.oldState = ds._rowStates[row];
        if (DataRowState.isDeleted(state)) {
            return this.throwEmpty(false);
        }
        if (!fld._updatable && (state == DataRowState.NONE || state == DataRowState.UPDATED)) {
            return this.throwEmpty(false);
        }
        vals = ds._values[row];
        newVal = fld.readValue(value);
        if (vals && checkDiff) {
            if (strictDiff) {
                if (fld.equalValues(newVal, vals[field])) {
                    return this.throwEmpty(false);
                }
            } else if (fld.sameValues(newVal, vals[field])) {
                return this.throwEmpty(false);
            }
        }
        ds.refreshFieldFormat(fld);
        ret = !!ds._pending || ds.fireValueChanging(this, row, field, newVal);
        if (ret instanceof DataSetPending && ret.action() === this) {
            return ds._pending = ret;
        } else if (ret) {
            ds._tags.$_saveValue(this, row, field);
            if (save) {
                save.values = vals && vals.concat();
                save.state = state;
                ds._orgValues && (save.orgValues = ds._orgValues[row]);
                this._setReady();
            }
            needState = ds._checkStates && (state == DataRowState.NONE || !state);
            if (!vals) {
                ds._values[row] = vals = [];
            }
            if (needState && ds._orgValues) {
                oldVals = vals.concat();
            }
            vals[field] = newVal;
            ds._derivedFieldCount && ds.$_deriveValues(row, vals, field);
            if (needState) {
                if (oldVals) {
                    ds._orgValues[row] = oldVals;
                }
                ds._changeRowState(this, row, DataRowState.UPDATED, false);
                save && (post.needState = needState);
            } else if (ds._needAutoRestore && state == DataRowState.UPDATED) {
                ds.$_restoreState(row);
            }
            ds._tags.setValue(row, field);
            if (save) {
                post.row = row;
                post.field = field;
            } else if (!this.noEvent) {
                needState && ds._fireStateChanged(this, row, this.oldState);
                ds._fireValueChanged(this, row, field);
            }
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        if (!this.noEvent) {
            var cmd = ds.$_cmd(this);
            post.needState && ds._fireStateChanged(cmd, post.row, this.oldState);
            ds._fireValueChanged(cmd, post.row, post.field);
        }
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            field = this.field;
        ds._tags.$_saveValue(this, row, field);
        ds._values[row] = keep.values;
        ds._rowStates[row] = keep.state;
        ds._orgValues && (ds._orgValues[row] = keep.orgValues);
        ds._tags.setValue(row, field);
        return true;
    },
    _doPostRedo: function (ds) {
        ds._fireValueChanged(this, this.row, this.field);
    }
});
var DataUpdateRowCommand = defineClass("DataUpdateRowCommand", DataSetEditCommand, {
    init: function (ds, row, values, checkDiff, strictDiff, checkEmpty) {
        this._super(ds);
        this.row = row;
        this.values = values;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.checkEmpty = checkEmpty;
    },
    $_updating: function () {
        return true;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        ds._values[row] = save.values;
        ds._rowStates[row] = save.state;
        ds._orgValues && (ds._orgValues[row] = save.orgVals);
        ds._tags.$_restoreRow(this, row);
    },
    _doPostUndo: function (ds) {
        ds._fireRowUpdated(this, this.row);
    },
    _doKeep: function (ds, save) {
        var row =  this.row,
            keep = {};
        keep.values = ds._values[row].concat();
        keep.state = ds._rowStates[row];
        ds._orgValues && (keep.orgValues = ds._orgValues[row]);
        return keep;
    },
    _doRun: function (ds, save) {
        var ret, changed, orgVals, state,
            row = this.row,
            values = this.values,
            checkDiff = this.checkDiff,
            strictDiff = this.strictDiff,
            checkEmpty = this.checkEmpty;
        if (!ds.isUpdatable() || !values) {
            return this.throwEmpty(false);
        }
        ds._checkRowIndex(row);
        ds.refreshFieldFormats();
        state = ds._rowStates[row];
        if (DataRowState.isDeleted(state)) {
            return this.throwEmpty(false);
        }
        ret = !!ds._pending || ds._fireRowUpdating(this, row, values);
        if (ret instanceof DataSetPending && ret.action() === this) {
            return ds._pending = ret;
        } else if (ret) {
            if (save) {
                orgVals = ds._orgValues && ds._orgValues[row];
                this._setReady();
            }
            changed = ds._internalUpdateRow(this, row, values, checkDiff, strictDiff, checkEmpty, true, !_isArray(values));
            if (changed) {
                if (save) {
                    save.values = ds.$$_oldVals;
                    save.state = state;
                    save.orgVals = orgVals;
                    ds._tags.$_saveRow(this, row);
                }
                ds._tags.updateRow(this.row);
                !save && this._doPostRun(ds);
                return true;
            }
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRowUpdated(cmd, this.row);
    },
    _doRedo: function (ds, keep) {
        var row = this.row;
        ds._tags.$_saveRow(this, row);
        ds._values[row] = keep.values;
        ds._rowStates[row] = keep.state;
        ds._orgValues && (ds._orgValues[row] = keep.orgValues);
        ds._tags.updateRow(row);
        return true;
    },
    _doPostRedo: function (ds) {
        ds._fireRowUpdated(this, this.row);
    }
});
var DataUpdateRowsCommand = defineClass("DataUpdateRowsCommand", DataSetEditCommand, {
	init: function (ds, row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter) {
		this._super(ds);
        this.row = row;
        this.rows = rows;
        this.start = start;
        this.count = count;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.checkEmpty = checkEmpty;
        this.rowEvents = rowEvents;
        this.filter = filter;
	},
    $_updating: function () {
        return true;
    },
    _doUndo: function (ds, save, post) {
        var r,
            orgs = ds._orgValues,
            ids = [];
        for (r in save.rows) {
            ds._values[r] = save.rows[r];
            ds._rowStates[r] = save.states[r];
            orgs && (orgs[r] = save.orgVals[r]);
            ids.push(r);
        }
        ds._tags.$_restoreRows(this, ids);
        post.ids = ids;
	},
    _doPostUndo: function (ds, post) {
        ds._fireRowsUpdated(this, post.ids);
    },
    _doKeep: function (ds, save) {
        var r,
            orgs = ds._orgValues,
            keep = {
                rows: {},
                states: {},
                tags: {},
                orgVals: orgs && {}
            };
        for (r in save.rows) {
            keep.rows[r] = ds._values[r].concat();
            keep.states[r] = ds._rowStates[r];
            orgs && (keep.orgVals[r] = orgs[r]);
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var	saveRows, saveStates, saveTags, saveOrgs,
            len, i, r, end, v, changed, ids, list, state, rowCount, orgVals,
            row = this.row,
            rows = this.rows,
            start = this.start,
            count = this.count,
            checkDiff = this.checkDiff,
            strictDiff = this.strictDiff,
            checkEmpty = this.checkEmpty,
            rowEvents = this.rowEvents && !save, // undoable일 때 rowEvents를 사용할 수 없다.
            filter = this.filter;
        if (!ds.isUpdatable()) {
            return this.throwEmpty(false);
        }
        if (isNaN(row)) {
            return this.throwEmpty(false);
        }
        if (!rows || (len = rows.length) < 1) {
            return this.throwEmpty(false);
        }
        count = (count < 0) ? len : Math.min(len, count);
        if (count == 0) {
            return this.throwEmpty(false);
        }
        if (!ds._fireRowsUpdating(this, row, rows, start, count)) {
            return this.throwEmpty(false);
        }
        if ((len = rows.length) < 1) {
            return this.throwEmpty(false);
        }
        count = Math.min(count, len);
        ds.refreshFieldFormats();
        rowCount = ds.rowCount();
        start = Math.max(0, start);
        end = Math.min(len, start + count);
        if (end <= start) {
            return this.throwEmpty(false);
        }
        if (save) {
            saveRows = save.rows = {};
            saveStates = save.states = {};
            saveOrgs = save.orgVals = {};
            this._setReady();
        }
        if (rowEvents) {
            r = row;
            for (i = start; i < end && r < rowCount; i++, r++) {
                state = ds._rowStates[r];
                if (!DataRowState.isDeleted(state) && ds._fireRowUpdating(this, r)) {
                    v = rows[i];
                    orgVals = ds._orgValues && ds._orgValues[r];
                    changed = ds._internalUpdateRow(this, r, v, checkDiff, strictDiff, checkEmpty, true, !_isArray(v));
                    if (changed) {
                        if (saveRows) {
                            saveRows[r] = ds.$$_oldVals;
                            saveStates[r] = state;
                            saveOrgs[r] = orgVals;
                        }
                        ds._tags.$_saveRow(this, row);
                        ds._tags.updateRow(r);
                        ds._fireRowUpdated(this, r);
                    }
                }
            }
        } else {
            ids = [];
            list = [];
            r = row;
            for (i = start; i < end && r < rowCount; i++, r++) {
                state = ds._rowStates[r];
                if (!DataRowState.isDeleted(state)) {
                    v = rows[i];
                    orgVals = ds._orgValues && ds._orgValues[r];
                    changed = ds._internalUpdateRow(this, r, v, checkDiff, strictDiff, checkEmpty, false, !_isArray(v));
                    if (changed) {
                        if (saveRows) {
                            saveRows[r] = ds.$$_oldVals;
                            saveStates[r] = state;
                            saveOrgs[r] = orgVals;
                        }
                        ids.push(r);
                        if (state == DataRowState.NONE) {
                            list.push(r);
                        }
                    }
                }
            }
            (save && ids.length > 0) && ds._tags.$_saveRows(this, ids);
            if (ids.length > 0) {
                ds._tags.updateRows(ids);
            }
            post.list = list;
            post.ids = ids;
            !save && this._doPostRun(ds, post);
        }
        return ids;
	},
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.list.length > 0) {
            ds._fireStatesChanged(cmd, post.list, 0);
        }
        if (post.ids.length > 0) {
            ds._fireRowsUpdated(cmd, post.ids);
        }
    },
    _doRedo: function (ds, keep, post) {
        var r,
            orgVals = ds._orgValues,
            vals = ds._values,
            states = ds._rowStates,
            ids = [];
        for (r in keep.rows) {
            vals[r] = keep.rows[r];
            states[r] = keep.states[r];
            orgVals && (orgVals[r] = keep.orgVals[r]);
            ids.push(r);
        }
        ds._tags.$_saveRows(this, ids);
        post.ids = ids;
    },
    _doPostRedo: function (ds, post) {
        ds._fireRowsUpdated(this, post.ids);
    }
});
var DataUpdateValuesCommand = defineClass("DataUpdateValuesCommand", DataSetEditCommand, {
    init: function (ds, where, newValues, checkDiff, strictDiff, noState) {
        this._super(ds);
        this.where = where;
        this.newValues = newValues;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.noState = noState;
    },
    _doUndo: function (ds, save, post) {
        var r,
            orgs = ds._orgValues,
            ids = [];
        for (r in save.rows) {
            ds._values[r] = save.rows[r];
            ds._rowStates[r] = save.states[r];
            orgs && (orgs[r] = save.orgVals[r]);
            ids.push(r);
        }
        ds._tags.$_restoreRows(this, ids);
        post.ids = ids;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRowsUpdated(this, post.ids);
    },
    _doKeep: function (ds, save) {
        var r,
            orgs = ds._orgValues,
            keep = {
                rows: {},
                states: {},
                tags: {},
                orgVals: orgs && {}
            };
        for (r in save.rows) {
            keep.rows[r] = ds._values[r].concat();
            keep.states[r] = ds._rowStates[r];
            orgs && (keep.orgVals[r] = orgs[r]);
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows, saveStates, saveTags, saveOrgs,
            changed, rowCount, callback, fldCount, flds, vals, fld, f, len,
            rows, list, expr, runtime, r, orgVals, oldState,
            where = this.where,
            newValues = this.newValues,
            checkDiff = this.checkDiff,
            strictDiff = this.strictDiff,
            noState = this.noState;
        if (!ds.isUpdatable()) {
            return this.throwEmpty();
        }
        if (!newValues) {
            return this.throwEmpty();
        }
        rowCount = ds._values.length;
        if (rowCount < 1) {
            return this.throwEmpty();
        }
        if (!ds._fireValuesUpdating(this, where, newValues)) {
            return this.throwEmpty(false);
        }
        callback = _asFunction(where);
        fldCount = ds.fieldCount();
        flds = [];
        vals = [];
        for (fld in newValues) {
            f = ds.getFieldIndexEx(fld);
            if (f >= 0 || f < fldCount) {
                flds.push(ds.getField(f));
                vals.push(newValues[fld]);
            }
        }
        len = flds.length;
        if (!len) {
            return this.throwEmpty();
        }
        if (save) {
            saveRows = save.rows = {};
            saveStates = save.states = {};
            saveOrgs = save.orgVals = {};
            this._setReady();
        }
        rows = [];
        list = [];
        expr = null;
        runtime = null;
        if (where && !callback) {
            expr = ExpressionParser.Default.parse(where);
            runtime = new DataRowRuntime(ds);
        }
        for (r = 0; r < rowCount; r++) {
            oldState = ds._rowStates[r];
            orgVals = save && ds._orgValues && ds._orgValues[r];
            changed = false;
            if (!DataRowState.isDeleted(oldState)) {
                if (callback) {
                    if (callback(ds, r, ds._values[r])) {
                        if (ds._internalUpdateValues(this, r, flds, vals, checkDiff, strictDiff, false, false, noState)) {
                            rows.push(r);
                            if (!noState && oldState == DataRowState.NONE) {
                                list.push(r);
                            }
                            changed = true;
                        }
                    }
                } else if (expr) {
                    runtime.setRow(r, ds._values[r]);
                    if (expr.evaluate(runtime)) {
                        if (ds._internalUpdateValues(this, r, flds, vals, checkDiff, strictDiff, false, false, noState)) {
                            rows.push(r);
                            if (!noState && oldState == DataRowState.NONE) {
                                list.push(r);
                            }
                            changed = true;
                        }
                    }
                } else if (ds._internalUpdateValues(this, r, flds, vals, checkDiff, strictDiff, false, false, noState)) {
                    rows.push(r);
                    if (!noState && oldState == DataRowState.NONE) {
                        list.push(r);
                    }
                    changed = true;
                }
                if (changed && save) {
                    saveRows[r] = ds.$$_oldVals;
                    saveStates[r] = oldState;
                    saveOrgs[r] = orgVals;
                }
            }
        }
        rows.length > 0 && ds._tags.$_saveRows(this, rows);
        if (rows.length > 0) {
            ds._tags.updateRows(rows);
        }
        post.list = list;
        post.rows = rows;
        !save && this._doPostRun(ds, post);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.list.length > 0) {
            ds._fireStatesChanged(cmd, post.list, 0);
        }
        if (post.rows.length > 0) {
            ds._fireRowsUpdated(cmd, post.rows);
        }
    },
    _doRedo: function (ds, keep, post) {
        var r,
            orgVals = ds._orgValues,
            ids = [];
        for (r in keep.rows) {
            ds._values[r] = keep.rows[r];
            ds._rowStates[r] = keep.states[r];
            orgVals && (orgVals[r] = keep.orgVals[r]);
            ids.push(r);
        }
        ds._tags.$_saveRows(this, ids);
        post.ids = ids;
    },
    _doPostRedo: function (ds, post) {
        ds._fireRowsUpdated(this, post.ids);
    }
});
var DataDeleteRowCommand = defineClass("DataDeleteRowCommand", DataSetEditCommand, {
    init: function (ds, row) {
        this._super(ds);
        this.row = row;
    },
    _doUndo: function (ds, save, post) {
        var id, row = this.row;
        if (save.values) {
            id = save.id;
            ds._values.splice(row, 0, save.values);
            ds._rowIds.splice(row, 0, save.id);
            ds._deletedCount = save.deletedCount;
            save.orgValues && ds._orgValues && ds._orgValues.splice(row, 0, save.orgValues);
            ds._rowStates.splice(row, 0, save.state);
            ds._rowTags.splice(row, 0, save.tag);
            ds._tags.insertRow(row);
            ds._tags.$_restoreRow(this, row, true);
            post.id = id;
        } else if (ds._rowStates[row] != save.state) {
            this._oldState = ds.getRowState(row);
            ds._tags.$_restoreRow(this, row);
            ds._changeRowState(this, this.row, post.state, false, true, true);
        }
    },
    _doPostUndo: function (ds, post) {
        if (post.id !== undefined) {
            ds._fireRowInserted(this, this.row);
            ds._fireRowCountChanged();
        } else {
            ds._fireStateChanged(this, this.row, this._oldState);
        }
    },
    _doKeep: function (ds, save) {
        var keep = {};
        keep.values = save.values;
        keep.state = save.state;
        keep.id = save.id;
        keep.deletedCount = ds._deletedCount;
        return keep;
    },
    _doRun: function (ds, save, post) {
        var dirty, state, id,
            row = this.row;
        if (!ds.isDeletable()) {
            return this.throwEmpty();
        }
        ds._checkRowIndex(row);
        if (!ds._fireRowDeleting(this, row)) {
            return this.throwEmpty(false);
        }
        dirty = false;
        state = this._oldState = ds._rowStates[row];
        id = ds._rowIds[row];
        if (save) {
            save.id = id;
            save.state = state;
            ds._tags.$_saveRow(this, row, true);
            this._setReady();
        }
        if (ds._softDelete && ds._checkStates) {
            switch (state) {
                case DataRowState.CREATED:
                    if (ds._deleteCreated) {
                        dirty = post.deleted = ds.$$_deleteRow(row, save);
                    } else {
                        dirty = ds._changeRowState(this, row, DataRowState.CREATE_AND_DELETED, false, true, true);
                    }
                    break;
                case DataRowState.CREATE_AND_DELETED:
                    if (ds._deleteCreated) {
                        dirty = post.deleted = ds.$$_deleteRow(row, save);
                    }
                    break;
                case DataRowState.DELETED:
                    break;
                default:
                    dirty = ds._changeRowState(this, row, DataRowState.DELETED, false, true, true);
                    break;
            }
        } else {
            dirty = post.deleted = ds.$$_deleteRow(row, save);
        }
        if (dirty) {
            post.deleted && (post.id = id);
            !save && this._doPostRun(ds, post);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.id !== undefined) {
            ds._fireRowDeleted(cmd, this.row, post.id);
            ds._fireRowCountChanged(cmd);
        } else {
            ds._fireStateChanged(cmd, this.row, this._oldState);
        }
    },
    _doRedo: function (ds, keep, post) {
        var row = this.row;
        ds._tags.$_saveRow(this, row, true);
        if (keep.values) {
            ds._internalDeleteRow(row);
            ds._deletedCount = keep.deletedCount;
            ds._tags.removeRow(row);
            post.id = keep.id;
        } else {
            this._oldState = ds.getRowState(row);
            ds._changeRowState(this, row, keep.state, false, true, true);
        }
        return true;
    },
    _doPostRedo: function (ds, post) {
        if (post.id !== undefined) {
            ds._fireRowDeleted(this, this.row, post.id);
            ds._fireRowCountChanged(this);
        } else {
            ds._fireStateChanged(this, this.row, this._oldState);
        }
    }
});
var DataDeleteRowsCommand = defineClass("DataDeleteRowsCommand", DataSetEditCommand, {
    init: function (ds, rows, rowEvents) {
        this._super(ds);
        this.rows = rows;
        this.rowEvents = rowEvents;
    },
    _doUndo: function (ds, save, post) {
        var rows, i, src, row, list, list2,
            oldDeleted = ds._deletedCount;
        if ((rows = save.rows) && rows.length > 0) {
            list = [];
            for (i = rows.length; i--;) {
                src = rows[i];
                row = src.row;
                list.push(row);
                ds._values.splice(row, 0, src.values);
                ds._rowIds.splice(row, 0, src.id);
                save.orgValues && ds._orgValues.splice(row, 0, src.orgValues);
                ds._rowStates.splice(row, 0, src.state);
                ds._rowTags.splice(row, 0, src.tag);
                ds._tags.insertRow(row);
            }
        }
        if (rows = save.states) {
            list2 = [];
            for (row in rows) {
                list2.push(row);
                ds._rowStates[row] = rows[row];
            }
        }
        ds._deletedCount = save.deletedCount;
        this._deletedInc = ds._deletedCount - oldDeleted;
        if (list && list.length > 0) {
            ds._tags.$_restoreRows(this, list, true);
        }
        if (list2 && list2.length > 0) {
            ds._tags.$_restoreRows(this, list2, true)
        }
        post.list = list;
        post.list2 = list2;
    },
    _doPostUndo: function (ds, post) {
        var list = post.list,
            list2 = post.list2;
        if (list && list.length > 0) {
            ds._fireRowsInserted(this, list);
            ds._fireRowCountChanged(this);
        }
        if (list2 && list2.length > 0) {
            ds._fireStatesChanged(this, list2, this._deletedInc);
        }
    },
    _doKeep: function (ds, save) {
        var rows, i, row,
            keep = {};
        keep.rows = [];
        keep.ids = [];
        if ((rows = save.rows) && rows.length > 0) {
            for (i = rows.length; i--;) {
                keep.rows.push(rows[i].row);
                keep.ids.push(rows[i].id);
            }
        }
        keep.states = {};
        if (rows = save.states) {
            for (row in rows) {
                keep.states[row] = ds._rowStates[row];
            }
        }
        keep.deletedCount = ds._deletedCount;
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveStates, saveRows, error,
            cnt, i, row, state, changed, stateRows, deleteCreated,
            oldDeleted = ds._deletedCount,
            rows = this.rows.concat(),
            rowEvents = this.rowEvents && !save; // undoable일 때 rowEvents를 사용할 수 없다.
        if (!ds.isDeletable()) {
            return this.throwEmpty(0);
        }
        if (!rows || rows.length < 1) {
            return this.throwEmpty(0);
        }
        rows.sort(function (v1, v2) {
            return v1 - v2;
        });
        for (i = rows.length; i > 0; i--) {
            if (rows[i] == rows[i - 1]) {
                rows.splice(i, 1);
            }
        }
        if (!ds._fireRowsDeleting(this, rows)) {
            return this.throwEmpty(0);
        }
        if ((cnt = rows.length) < 1) {
            return this.throwEmpty(0);
        }
        deleteCreated = ds.deleteCreated();
        if (save) {
            save.deletedCount = ds._deletedCount;
            saveStates = save.states = {};
            saveRows = save.rows = [];
            this._setReady();
        }
        if (ds._softDelete && ds._checkStates) {
            stateRows = rowEvents ? null : [];
            for (i = cnt; i--;) {
                row = rows[i];
                if (ds._checkRowIndex(row, true)) {
                    changed = false;
                    state = ds._rowStates[row];
                    switch (state) {
                        case DataRowState.CREATED:
                            if (!deleteCreated) {
                                changed = ds._changeRowState(this, row, DataRowState.CREATE_AND_DELETED, rowEvents, false, true);
                                rows.splice(i, 1);
                            }
                            break;
                        case DataRowState.DELETED:
                        case DataRowState.CREATE_AND_DELETED:
                            rows.splice(i, 1);
                            break;
                        default:
                            changed = ds._changeRowState(this, row, DataRowState.DELETED, rowEvents, false, true);
                            rows.splice(i, 1);
                            break;
                    }
                    if (changed) {
                        stateRows.push(row);
                        save && (saveStates[row] = state);
                    }
                } else {
                    rows.splice(i, 1);
                }
            }
            if (save && stateRows.length > 0) {
                ds._tags.$_saveRows(this, stateRows, true);
            }
            if (!rowEvents) {
                if (stateRows && stateRows.length > 0) {
                    post.stateRows = stateRows;
                }
            }
        }
        if ((cnt = rows.length) > 0) {
            save && ds._tags.$_saveRows(this, rows, true);
            if (rowEvents) {
                for (i = cnt; i--;) {
                    row = rows[i];
                    if (ds._checkRowIndex(row, true)) {
                        save && saveRows.push(ds.$_saveRow(row, {}));
                        ds.$_deleteRow(this, row);
                    } else {
                        rows.splice(i, 1);
                    }
                }
            } else {
                for (i = cnt; i--;) {
                    row = rows[i];
                    if (ds._checkRowIndex(row, true)) {
                        save && saveRows.push(ds.$_saveRow(row, {}));
                        state = ds._rowStates[row];
                        ds._internalDeleteRow(row);
                        if (DataRowState.isDeleted(state)) {
                            ds._deletedCount--;
                        }
                    } else {
                        rows.splice(i, 1);
                    }
                }
                cnt = rows.length;
                if (cnt > 0) {
                    ds._tags.removeRows(rows);
                    post.rows = rows;
                }
            }
        }
        this._deletedInc = ds._deletedCount - oldDeleted;
        if (post.rows || post.stateRows) {
            !save && this._doPostRun(ds, post);
            return cnt;
        }
        return this.throwEmpty(0);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.stateRows) {
            ds._fireStatesChanged(cmd, post.stateRows, this._deletedInc);
        }
        if (post.rows) {
            ds._fireRowsDeleted(cmd, post.rows);
            ds._fireRowCountChanged(cmd);
        }
    },
    _doRedo: function (ds, keep, post) {
        var rows, row, i,
            oldDeleted = ds._deletedCount;
        ds._tags.$_saveRows(this, keep.rows, true);
        rows = [];
        for (row in keep.states) {
            ds._rowStates[row] = keep.states[row];
            rows.push(row);
        }
        if (rows.length > 0) {
            post.stateRows = rows;
        }
        for (i = keep.rows.length; i--;) {
            row = keep.rows[i];
            ds._internalDeleteRow(row);
        }
        ds._deletedCount = keep.deletedCount;
        this._deletedInc = ds._deletedCount - oldDeleted;
        if (keep.rows.length > 0) {
            ds._tags.removeRows(keep.rows);
            post.rows = keep.rows;
        }
    },
    _doPostRedo: function (ds, post) {
        if (post.stateRows) {
            ds._fireStatesChanged(this, post.stateRows, this._deletedInc);
        }
        if (post.rows) {
            ds._fireRowsDeleted(this, post.rows);
            ds._fireRowCountChanged(this);
        }
    }
});
var DataInsertRowCommand = defineClass("DataInsertRowCommand", DataSetEditCommand, {
    init: function (ds, row, values, field) {
        this._super(ds);
        this.row = row;
        this.values = values;
        this.field = field === undefined ? -1 : field;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        ds._values.splice(row, 1);
        ds._rowIds.splice(row, 1);
        ds._rowStates.splice(row, 1);
        ds._rowTags.splice(row, 1);
        ds._orgValues && ds._orgValues.splice(row, 1);
        ds._tags.removeRow(row);
    },
    _doPostUndo: function (ds) {
        ds._fireRowDeleted(this, this.row);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        var row = this.row,
            keep = {};
        keep.values = ds._values[row].concat();
        keep.id = ds._rowIds[row];
        keep.state = ds._rowStates[row];
        keep.tag = ds._rowTags[row];
        ds._orgValues && (keep.orgVals = ds._orgValues[row] && ds._orgValues[row].concat());
        return keep;
    },
    _doRun: function (ds, save) {
        var row = this.row,
            values = this.values;
        if (isNaN(row) || row < 0 || row > ds._values.length) {
            throw new RangeError("row is out of bounds:" + row);
        }
        if (!ds.isInsertable()) {
            return this.throwEmpty(false);
        }
        if (row == ds._values.length && !ds.isAppendable()) {
            return this.throwEmpty(false);
        }
        ds.refreshFieldFormats();
        if (values && ds._fireRowInserting(this, row, values)) {
            if (save) {
                this._setReady();
            }
            if (!isArray(values)) {
                values = ds.objectToRow(values);
            }
            ds._internalInsertRow(row, values, this.field);
            ds.setDataInited(true);
            ds._tags.insertRow(row);
            !save && this._doPostRun(ds);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRowInserted(cmd, this.row);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        var row = this.row;
        ds._values.splice(row, 0, keep.values);
        ds._rowIds.splice(row, 0, keep.id);
        ds._rowStates.splice(row, 0, keep.state);
        ds._rowTags.splice(row, 0, keep.tag);
        ds._orgValues && ds._orgValues.splice(row, 0, keep.orgVals);
        ds._tags.insertRow(row);
        return true;
    },
    _doPostRedo: function (ds) {
        ds._fireRowInserted(this, this.row);
        ds._fireRowCountChanged(this);
    }
});
var DataInsertRowsCommand = defineClass("DataInsertRowsCommand", DataSetEditCommand, {
    init: function (ds, row, rows, start, count, rowEvents, filter) {
        this._super(ds);
        this.row = row;
        this.rows = rows;
        this.start = start;
        this.count = count;
        this.rowEvents = rowEvents;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var i, r
            rows = save.rows,
            orgVals = ds._orgValues;
        rows = save.rows;
        for (i = rows.length; i--;) {
            r = rows[i];
            ds._values.splice(r, 1);
            ds._rowIds.splice(r, 1);
            ds._rowStates.splice(r, 1);
            ds._rowTags.splice(r, 1);
            orgVals && orgVals.splice(r, 1);
            ds._tags.removeRow(r);
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRowsDeleted(this, post.rows);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        var saveRows, i, r, row,
            orgVals = ds._orgValues,
            keep = {},
            rows = keep.rows = [];
        saveRows = save.rows;
        for (i = 0; i < saveRows.length; i++) {
            r = saveRows[i];
            row = { row: r };
            row.values = ds._values[r].concat();
            row.id = ds._rowIds[r];
            row.state = ds._rowStates[r];
            row.tag = ds._rowTags[r];
            orgVals && (row.orgVals = orgVals[r] && orgVals[r].concat());
            rows.push(row);
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows,
            len, i, r, v, end,
            ds = this.ds,
            row = this.row,
            rows = this.rows,
            start = this.start,
            count = this.count,
            rowEvents = this.rowEvents && !save, // undoable일 때 rowEvents를 사용할 수 없다.
            filter = this.filter;
        if (isNaN(row) || row < 0 || row > ds.rowCount()) {
            throw new RangeError("row is out of bounds:" + row);
        }
        if (!ds.isInsertable()) {
            return this.throwEmpty(0);
        }
        if (!rows || (len = rows.length) < 1) {
            return this.throwEmpty(0);
        }
        count = (count < 0) ? len : Math.min(len, count);
        if (count == 0) {
            return this.throwEmpty(0);
        }
        if (!ds._fireRowsInserting(this, row, rows, start, count)) {
            return this.throwEmpty(0);
        }
        if ((len = rows.length) < 1) {
            return this.throwEmpty(0);
        }
        count = Math.min(count, len);
        ds.refreshFieldFormats();
        start = Math.max(0, start);
        end = Math.min(len, start + count);
        if (filter instanceof DataFilter) {
            filter.prepare(ds.filterRuntime().prepare(ds));
        } else {
            filter = null;
        }
        if (save) {
            saveRows = save.rows = [];
            this._setReady();
        }
        if (rowEvents) {
            r = row;
            for (i = start; i < end; i++) {
                v = rows[i];
                if (!_isArray(v)) {
                    v = ds.objectToRow(v);
                }
                if (ds._fireRowInserting(this, r, v)) {
                    if (!filter || filter.select(i, r, v)) {
                        ds._internalInsertRow(r, v);
                        ds._tags.insertRow(r);
                        ds._fireRowInserted(this, r);
                        ds._fireRowCountChanged(this);
                        saveRows && saveRows.push(r);
                        r++;
                    }
                }
            }
        } else {
            r = row;
            for (i = start; i < end; i++) {
                v = rows[i];
                if (!isArray(v)) {
                    v = ds.objectToRow(v);
                }
                if (!filter || filter.select(i, r, v)) {
                    saveRows && saveRows.push(r);
                    ds._internalInsertRow(r++, v);
                }
            }
            ds.setDataInited(true);
            ds._tags.insertRows(row, count = end - start);
            post.count = count;
            !save && this._doPostRun(ds, post);
        }
        return r - row;
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireRowsInserted(cmd, this.row, post.count);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep, post) {
        var i, r,
            row = this.row,
            keepRows = keep.rows;
        for (i = 0; i < keepRows.length; i++) {
            r = keepRows[i];
            ds._values.splice(r.row, 0, r.values);
            ds._rowIds.splice(r.row, 0, r.id);
            ds._rowStates.splice(r.row, 0, r.state);
            ds._rowTags.splice(r.row, 0, r.tag);
            ds._orgValues && ds._orgValues.splice(r.row, 0, r.orgVals && r.orgVals);
        }
        ds._tags.insertRows(row, keepRows.length);
        post.count = keepRows.length;
    },
    _doPostRedo: function (ds, post) {
        ds._fireRowsInserted(this, this.row, post.count);
        ds._fireRowCountChanged(this);
    }
});
var DataMoveRowCommand = defineClass("DataMoveRowCommand", DataSetEditCommand, {
    init: function (ds, row, newRow) {
        this._super(ds);
        this.row = row;
        this.newRow = newRow;
    },
    _doUndo: function (ds, save) {
        var row = this.row,
            newRow = this.newRow;
        ds._internalMoveRow(newRow, row);
        ds._tags.moveRow(newRow, row);
    },
    _doPostUndo: function (ds) {
        ds._fireRowMoved(this, this.newRow, this.row);
    },
    _doKeep: function (ds, save) {
        return {};
    },
    _doRun: function (ds, save) {
        var row = this.row,
            newRow = this.newRow;
        if (!ds.isMovable()) {
            return this.throwEmpty();
        }
        if (row == newRow) {
            return this.throwEmpty();
        }
        ds._checkRowIndex(row);
        ds._checkRowIndex(newRow);
        if (ds._fireRowMoving(this, row, newRow)) {
            this._setReady();
            ds._internalMoveRow(row, newRow);
            ds._tags.moveRow(row, newRow);
            !save && this._doPostRun(ds);
            return true;
        }
        return this.throwEmpty();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRowMoved(cmd, this.row, this.newRow);
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            newRow = this.newRow;
        ds._internalMoveRow(row, newRow);
        ds._tags.moveRow(row, newRow);
    },
    _doPostRedo: function (ds) {
        ds._fireRowMoved(this, this.row, this.newRow);
    }
});
var DataMoveRowsCommand = defineClass("DataMoveRowsCommand", DataSetEditCommand, {
    init: function (ds, row, count, newRow) {
        this._super(ds);
        this.row = row;
        this.count = count;
        this.newRow = newRow;
    },
    _doUndo: function (ds, save) {
        var row = this.row,
            count = this.count,
            newRow = this.newRow;
        ds._internalMoveRows(newRow, count, row);
        ds._tags.moveRows(newRow, count, row);
    },
    _doPostUndo: function (ds) {
        ds._fireRowsMoved(this, this.newRow, this.count, this.row);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save, post) {
        var cnt,
            row = this.row,
            count = this.count,
            newRow = this.newRow;
        if (!ds.isMovable()) {
            return this.throwEmpty(0);
        }
        ds._checkRowIndex(row);
        ds._checkRowIndex(newRow);
        if (row == newRow) {
            return this.throwEmpty(0);
        }
        cnt = ds.rowCount();
        this.count = cnt = Math.min(count, cnt - row, cnt - newRow);
        if (cnt < 1) {
            return this.throwEmpty(0);
        }
        if (ds._fireRowsMoving(this, row, cnt, newRow)) {
            this._setReady();
            ds._internalMoveRows(row, cnt, newRow);
            ds._tags.moveRows(row, cnt, newRow);
            post.count = cnt;
            !save && this._doPostRun(ds, post);
            return cnt;
        }
        return this.throwEmpty(0);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireRowsMoved(cmd, this.row, post.count, this.newRow);
    },
    _doRedo: function (ds, keep) {
        var row = this.row;
            cnt = this.count,
            newRow = this.newRow;
        ds._internalMoveRows(row, cnt, newRow);
        ds._tags.moveRows(row, cnt, newRow);
    },
    _doPostRedo: function (ds) {
        ds._fireRowsMoved(this, this.row, this.count, this.newRow);
    }
});
var DataSetRowStateCommand = defineClass("DataSetRowStateCommand", DataSetEditCommand, {
    init: function (ds, row, state, force) {
        this._super(ds);
        this.row = row;
        this.state = state;
        this.force = force;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        this._oldState = ds._rowStates[row];
        ds._rowStates[row] = save.state;
        ds._rowTags[row] = save.tag;
        ds._orgValues && (ds._orgValues[row] = save.orgValues);
    },
    _doPostUndo: function (ds) {
        ds._fireStateChanged(this, this.row, this._oldState);
    },
    _doKeep: function (ds, save) {
        return {};
    },
    _doRun: function (ds, save) {
        var changed,
            row = this.row,
            state = this.state,
            force = this.force;
        ds._checkRowIndex(row);
        this._oldState = ds.getRowState(row);
        if (save) {
            save.state = this._oldState;
            save.tag = ds._rowTags[row];
            save.orgValues = ds._orgValues ? ds._orgValues[row] : undefined;
            this._setReady();
        }
        if (ds._orgValues) {
            changed = ds._changeRowStateEx(this, row, state, false, force);
        } else {
            changed = ds._changeRowState(this, row, state, false, force, true);
        }
        if (changed) {
            !save && this._doPostRun(ds);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireStateChanged(cmd, this.row, this._oldState);
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            state = this.state,
            force = this.force;
        this._oldState = ds.getRowState(row);
        if (ds._orgValues) {
            ds._changeRowStateEx(this, row, state, false, force);
        } else {
            ds._changeRowState(this, row, state, false, force, true);
        }
    },
    _doPostRedo: function (ds) {
        ds._fireStateChanged(this, this.row, this._oldState);
    }
});
var DataSetRowStatesCommand = defineClass("DataSetRowStatesCommand", DataSetEditCommand, {
    init: function (ds, rows, state, force, rowEvents) {
        this._super(ds);
        this.rows = rows;
        this.state = state;
        this.force = force;
        this.rowEvents = rowEvents;
    },
    _doUndo: function (ds, save, post) {
        var r, list,
            oldDeleted = ds._deletedCount,
            orgVals = ds._orgValues;
        list = [];
        for (r in save.states) {
            if (ds._rowStates[r] != save.states[r]) {
                ds._rowStates[r] = save.states[r];
                ds._rowTags[r] = save.tags[r];
                orgVals && (orgVals[r] = save.orgVals[r]);
                list.push(r);
            }
        }
        ds._deletedCount = save.deletedCount;
        this._deletedInc = ds._deletedCount - oldDeleted;
        post.list = list;
    },
    _doPostRedo: function (ds, post) {
        if (post.list.length > 0) {
            ds._fireStatesChanged(this, post.list, this._deletedInc);
        }
    },
    _doKeep: function (ds, save) {
        var r,
            orgVals = ds._orgValues,
            keep = {};
        keep.deletedCount = ds._deletedCount;
        keep.states = {};
        keep.tags = {};
        keep.orgVals = {};
        for (r in save.states) {
            keep.states[r] = ds._rowStates[r];
            keep.tags[r] = ds._rowTags[r];
            orgVals && (keep.orgVals[r] = orgVals[r]);
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveStates, saveTags, saveOrgVals,
            r, i, cnt, row, list, states, oldState,
            rows = this.rows,
            state = this.state,
            force = this.force,
            rowEvents = this.rowEvents && !save, // undoable일 때 rowEvents를 사용할 수 없다.
            oldDeleted = ds._deletedCount,
            orgVals = ds._orgValues;
        if (!rows || (cnt = rows.length) < 1) {
            return this.throwEmpty();
        }
        if (save) {
            save.deletedCount = ds._deletedCount;
            saveStates = save.states = {};
            saveTags = save.tags = {};
            saveOrgVals = save.orgVals = {};
            this._setReady();
        }
        if (rowEvents) {
            for (i = 0; i < cnt; i++) {
                row = rows[i];
                if (ds._checkRowIndex(row, true)) {
                    oldState = ds.getRowState(row);
                    if (ds._changeRowStateEx(this, row, state, true, force, false)) {
                        if (save) {
                            saveStates[row] = oldState;
                            saveTags[row] = ds._rowTags[row];
                            saveOrgVals = ds._orgValues ? ds._orgValues[row] : undefined;
                        }
                    }
                }
            }
        } else {
            list = [];
            states = ds._rowStates;
            for (i = 0; i < cnt; i++) {
                row = rows[i];
                if (ds._checkRowIndex(row, true)) {
                    oldState = states[row];
                    if (state != oldState) {
                        states[row] = state;
                        list.push(row);
                        if (DataRowState.isDeleted(state)) {
                            ds._deletedCount++;
                        } else if (DataRowState.isDeleted(oldState) && !DataRowState.isDeleted(state)) {
                            ds._deletedCount--;
                        }
                        if (ds._orgValues) {
                            ds.$_prepareOrgValues(row, oldState, state);
                        }
                        if (save) {
                            saveStates[row] = oldState;
                            saveTags[row] = ds._rowTags[row];
                            saveOrgVals[row] = orgVals ? orgVals[row] : undefined;
                        }
                    }
                }
            }
            post.list = list;
            this._deletedInc = ds._deletedCount - oldDeleted;
            !save && this._doPostRun(ds, post);
        }
    },
    _doPostRun: function (ds, post) {
        if (post.list.length > 0) {
            var cmd = ds.$_cmd(this);
            ds._fireStatesChanged(cmd, post.list, this._deletedInc);
        }
    },
    _doRedo: function (ds, keep, post) {
        var r,
            oldDeleted = ds._deletedCount,
            orgVals = ds._orgValues,
            list = [];
        for (r in keep.states) {
            ds._rowStates[r] = keep.states[r];
            ds._rowTags[r] = keep.tags[r];
            orgVals && (orgVals[r] = keep.orgVals[r]);
            list.push(r);
        }
        ds._deletedCount = keep.deletedCount;
        this._deletedInc = ds._deletedCount - oldDeleted;
        post.list = list;
    },
    _doPostRedo: function (ds, post) {
        ds._fireStatesChanged(this, post.list, this._deletedInc);
    }
});
var DataClearRowStatesCommand = defineClass("DataClearRowStatesCommand", DataSetEditCommand, {
    init: function (ds, states, deleteRows, rowEvents) {
        this._super(ds);
        this.states = states;
        this.deleteRows = deleteRows;
        this.rowEvents = rowEvents;
    },
    _doUndo: function (ds, save) {
        var rows, states, i, src, row,
            orgVals = ds._orgValues;
        if ((rows = save.delRows) && rows.length > 0) {
            for (i = rows.length; i--;) {
                src = rows[i];
                row = src.row;
                ds._values.splice(row, 0, src.values);
                ds._rowIds.splice(row, 0, src.id);
                save.orgValues && ds._orgValues.splice(row, 0, src.orgValues);
                ds._rowStates.splice(row, 0, src.state);
                ds._rowTags.splice(row, 0, src.tag);
                ds._tags.insertRow(row);
            }
        }
        if (states = save.states) {
            for (row in states) {
                ds._rowStates[row] = states[row];
                ds._rowTags[row] = save.tags[row];
                orgVals && (orgVals[row] = save.orgVals[row]);
            }
        }
        ds._deletedCount = save.deletedCount;
    },
    _doPostUndo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        var rows, i, states, row,
            keep = {};
        keep.deletedCount = ds._deletedCount;
        keep.rows = [];
        keep.states = {};
        keep.tags = {};
        if ((rows = save.delRows) && rows.length > 0) {
            for (i = 0; i < rows.length; i++) {
                keep.rows.push(rows[i].row);
            }
        }
        if (states = save.states) {
            for (row in states) {
                keep.states[row] = ds._rowStates[row];
                keep.tags[row] = ds._rowTags[row];
            }
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveStates, saveDelRows, saveTags, saveOrgVals,
            i, st, rowStates, rows, changed,
            states = this.states,
            deleteRows = this.deleteRows,
            rowEvents = this.rowEvents && !save; // undoable일 때 rowEvents를 사용할 수 없다.
        if (save) {
            save.deletedCount = ds._deletedCount;
            saveStates = save.states = {};
            saveTags = save.tags = {};
            saveDelRows = save.delRows = [];
            saveOrgVals = save.orgVals = [];
            this._setReady();
        }
        rowStates = ds._rowStates;
        rows = [];
        changed = 0;
        for (i = rowStates.length; i--;) {
            st = rowStates[i];
            if (!states || states.indexOf(st) >= 0) {
                switch (st) {
                    case DataRowState.CREATE_AND_DELETED:
                    case DataRowState.DELETED:
                        if (deleteRows) {
                            saveDelRows && saveDelRows.push(ds.$_saveRow(i, {}));
                            if (rowEvents) {
                                ds.$_deleteRow(this, i);
                            } else {
                                ds._internalDeleteRow(i);
                                ds._deletedCount--;
                            }
                            rows.push(i);
                        } else if (ds._changeRowState(this, i, DataRowState.NONE, rowEvents, false, false, this)) {
                            if (save) {
                                saveStates[i] = st;
                                saveTags[i] = ds._rowTags[i];
                            }
                            ds._deletedCount--;
                            changed++;
                        }
                        break;
                    default:
                        if (ds._changeRowState(this, i, DataRowState.NONE, rowEvents, false, false, this)) {
                            if (save) {
                                saveStates[i] = st;
                                saveTags[i] = ds._rowTags[i];
                            }
                            changed++;
                        }
                        break;
                }
            }
        }
        if (!states || states.indexOf('DataRowState.UPDATED') >= 0) {
            if (saveOrgVals) {
                saveOrgVals = ds._orgValues ? ds._orgValues.concat() : undefined;
            }
            ds.$_resetOrgValues();
        }
        if (!rowEvents) {
            post.rows = rows;
            post.changed = changed;
            !save && this._doPostRun(ds, post);
        }
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.rows.length > 0) {
            ds._fireRowsDeleted(cmd, post.rows);
            ds._fireRowCountChanged(cmd);
        }
        if (post.changed > 0) {
            ds._fireStatesCleared(cmd);
        }
    },
    _doRedo: function (ds, keep, post) {
        var i,
            states = this.states,
            changed = 0,
            rows = keep.rows;
        if (rows.length > 0) {
            for (i = 0; i < rows.length; i++) {
                ds._internalDeleteRow(rows[i]);
            }
        }
        for (i in keep.states) {
            ds._changeRowState(this, i, DataRowState.NONE, false, false, false);
            ds._rowTags[i] = keep.tags[i];
            changed++;
        }
        if (!states || states.indexOf('DataRowState.UPDATED') >= 0) {
            ds.$_resetOrgValues();
        }
        ds._deletedCount = keep.deletedCount;
        post.rows = rows;
        post.changed = changed;
    },
    _doPostRedo: function (ds, post) {
        if (post.rows.length > 0) {
            ds._fireRowsDeleted(this, post.rows);
            ds._fireRowCountChanged(this);
        }
        if (post.changed > 0) {
            ds._fireStatesCleared(this);
        }
    }
});
var DataRestoreUpdatedStatesCommand = defineClass("DataRestoreUpdatedStatesCommand", DataSetEditCommand, {
    init: function (ds, rows) {
        this._super(ds);
        this.rows = rows;
    },
    _doUndo: function (ds, save, post) {
        var i, cnt, r,
            rows = save.rows,
            orgs = save.orgs,
            list = [];
        for (i = 0, cnt = save.rows.length; i < cnt; i++) {
            r = rows[i];
            ds._rowStates[r] = DataRowState.UPDATED;
            ds._orgValues[r] = orgs[i];
            list.push(r);
        }
        post.list = list;
    },
    _doPostUndo: function (ds, post) {
        if (post.list.length > 0) {
            ds._fireStatesChanged(this, post.list);
        }
    },
    _doKeep: function (ds, save) {
        var i, cnt, r, keep = {};
        keep.rows = save.rows.concat();
        keep.orgs = new Array(cnt = keep.rows.length);
        for (i = 0; i < cnt; i++) {
            keep.orgs[i] = ds._orgValues[keep.rows[i]];
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows, saveOrgs,
            i, cnt, r, states, state, orgVals, list,
            ds = this.ds,
            rows = this.rows;
        if (!ds._orgValues) {
            return this.throwEmpty();
        }
        if (save) {
            saveRows = save.rows = [];
            saveOrgs = save.orgs = [];
            this._setReady();
        }
        states = ds._rowStates;
        list = [];
        if (rows === undefined || rows === null) {
            for (i = 0, cnt = ds._values.length; i < cnt; i++) {
                orgVals = ds._orgValues[i];
                if (states[i] == DataRowState.UPDATED && ds.$_restoreState(i)) {
                    if (save) {
                        saveRows.push(i);
                        saveOrgs.push(orgVals);
                    }
                    list.push(i);
                }
            }
        } else if (_isArray(rows)) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                r = rows[i];
                if (r >= 0 && r < ds._values.length && (state = states[r]) == DataRowState.UPDATED) {
                    orgVals = ds._orgValues[r];
                    if (ds.$_restoreState(r)) {
                        if (save) {
                            saveRows.push(r);
                            saveOrgs.push(orgVals);
                        }
                        list.push(r);
                    }
                }
            }
        } else if (!isNaN(r = parseInt(rows))) {
            if (r >= 0 && r < ds._values.length && (state = states[r]) == DataRowState.UPDATED) {
                orgVals = ds._orgValues[r];
                if (ds.$_restoreState(r)) {
                    if (save) {
                        saveRows.push(r);
                        saveOrgs.push(orgVals);
                    }
                    list.push(r);
                }
            }
        }
        if (list.length > 0) {
            post.list = list;
            !save && this._doPostRun(ds, post);
        } else {
            return this.throwEmpty();
        }
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireStatesChanged(cmd, post.list, 0);
    },
    _doRedo: function (ds, keep, post) {
        var i, cnt, r,
            rows = keep.rows,
            orgs = keep.orgs,
            list = [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            r = rows[i];
            ds._rowStates[r] = DataRowState.NONE;
            ds._orgValues[r] = orgs[i];
            list.push(r);
        }
        post.list = list;
    },
    _doPostRedo: function (ds, post) {
        ds._fireStatesChanged(this, post.list, 0);
    }
});
var DataRestoreUpdatedRowsCommand = defineClass("DataRestoreUpdatedRowsCommand", DataSetEditCommand, {
    init: function (ds, rows) {
        this._super(ds);
        this.rows = rows;
    },
    _doUndo: function (ds, save, post) {
        var i, cnt, r,
            list = [],
            rows = save.rows,
            orgs = save.orgs,
            vals = save.vals;
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            r = rows[i];
            ds._values[r] = vals[i];
            ds._rowStates[r] = DataRowState.UPDATED;
            ds._orgValues[r] = orgs[i];
            list.push(r);
        }
        post.list = list;
    },
    _doPostUndo: function (ds, post) {
        ds._fireStatesChanged(this, post.list, 0);
    },
    _doKeep: function (ds, save) {
        var i, r, rows, vals,
            keep = {};
        rows = save.rows;
        vals = save.vals;
        keep.rows = rows.slice();
        keep.vals = new Array(rows.length);
        for (i = rows.length; i--;) {
            r = rows[i];
            keep.vals[i] = ds._values[r].slice();
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows, saveOrgs, saveVals,
            i, cnt, r, states, list, orgVals,
            rows = this.rows;
        if (!ds._orgValues) {
            return this.throwEmpty();
        }
        states = ds._rowStates;
        list = [];
        if (save) {
            save.deletedCount = ds._deletedCount;
            saveRows = save.rows = [];
            saveOrgs = save.orgs = [];
            saveVals = save.vals = [];
            this._setReady();
        }
        if (rows === undefined || rows === null) {
            for (i = 0, cnt = ds._values.length; i < cnt; i++) {
                if (states[i] == DataRowState.UPDATED && ds.$_restoreUpdated(i, save)) {
                    if (save) {
                        saveRows.push(i);
                        saveOrgs.push(ds.$$_orgVals);
                        saveVals.push(ds.$$_oldVals);
                    }
                    list.push(i);
                }
            }
        } else if (_isArray(rows)) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                r = rows[i];
                if (r >= 0 && r < ds._values.length && states[r] == DataRowState.UPDATED) {
                    if (ds.$_restoreUpdated(r, save)) {
                        if (save) {
                            saveRows.push(r);
                            saveOrgs.push(ds.$$_orgVals);
                            saveVals.push(ds.$$_oldVals);
                        }
                        list.push(r);
                    }
                }
            }
        } else if (!isNaN(r = parseInt(rows))) {
            if (r >= 0 && r < ds._values.length && states[r] == DataRowState.UPDATED) {
                if (ds.$_restoreUpdated(r, save)) {
                    if (save) {
                        saveRows.push(r);
                        saveOrgs.push(ds.$$_orgVals);
                        saveVals.push(ds.$$_oldVals);
                    }
                    list.push(r);
                }
            }
        }
        if (list.length > 0) {
            post.list = list;
            !save && this._doPostRun(ds, post);
        } else {
            return this.throwEmpty();
        }
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireStatesChanged(cmd, post.list, 0);
    },
    _doRedo: function (ds, keep, post) {
        var i, cnt, r,
            list = [],
            rows = keep.rows,
            vals = keep.vals;
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            r = rows[i];
            ds._values[r] = vals[i];
            delete ds._orgValues[r];
            ds._rowStates[r] = DataRowState.NONE;
            list.push(r);
        }
        post.list = list;
    },
    _doPostRedo: function (ds, post) {
        ds._fireStatesChanged(this, post.list, 0);
    }
});
var DataSetRowTagCommand = defineClass("DataSetRowTagCommand", DataSetEditCommand, {
    init: function (ds, row, tag) {
        this._super(ds);
        this.row = row;
        this.tag = tag;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        ds._rowTags[row] = save.tag;
    },
    _doPostUndo: function (ds) {
        ds._fireTagChanged(this, this.row);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var oldTag,
            row = this.row,
            tag = this.tag;
        ds._checkRowIndex(row);
        if (tag !== (oldTag = ds._rowTags[row])) {
            if (save) {
                save.tag = oldTag;
                this._setReady();
            }
            ds._rowTags[row] = tag;
            !save && this._doPostRun(ds);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireTagChanged(cmd, this.row);
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            tag = this.tag;
        ds._rowTags[row] = tag;
        return true;
    },
    _doPostRedo: function (ds) {
        ds._fireTagChanged(this, this.row);
    }
});
var DataSetRowTagsCommand = defineClass("DataSetRowTagsCommand", DataSetEditCommand, {
    init: function (ds, rows, tag) {
        this._super(ds);
        this.rows = rows;
        this.tag = tag;
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            ds._rowTags[rows[i]] = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            rows: save.rows
        };
    },
    _doRun: function (ds, save, post) {
        var save, oldTag,
            rowTags = ds._rowTags,
            list = [],
            rows = this.rows,
            tag = this.tag;
        if (save) {
            save.tags = [];
            this._setReady();
        }
        if ((rows === null || rows === UNDEFINED) && (cnt = ds.rowCount()) > 0) {
            for (i = 0; i < cnt; i++) {
                if (tag !== rowTags[i]) {
                    save && save.tags.push(rowTags[i]);
                    rowTags[i] = tag;
                    list.push(i);
                }
            }
        } else if (rows && (cnt = rows.length) > 0) {
            for (i = 0; i < cnt; i++) {
                r = rows[i];
                if (ds._checkRowIndex(r, true) && tag !== rowTags[r]) {
                    save && save.tags.push(rowTags[r]);
                    rowTags[r] = tag;
                    list.push(r);
                }
            }
        }
        if (list.length > 0) {
            save && (save.rows = list.slice());
            post.list = list;
            !save && this._doPostRun(ds, post);
            return list.length;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireTagsChanged(cmd, post.list);
    },
    _doRedo: function (ds, keep, post) {
        var i,
            rows = keep.rows;
        for (i = rows.length; i--;) {
            ds._rowTags[rows[i]] = this.tag;
        }
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    }
});
var DataUnsetRowTagsCommand = defineClass("DataUnsetRowTagsCommand", DataSetEditCommand, {
    init: function (ds, rows, tags) {
        this._super(ds);
        this.rows = rows;
        this.tags = tags;
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            ds._rowTags[rows[i]] = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            rows: save.rows
        };
    },
    _doRun: function (ds, save, post) {
        var oldTag,
            rowTags = ds._rowTags,
            list = [],
            rows = this.rows,
            tags = this.tags;
        if (save) {
            save.tags = [];
            this._setReady();
        }
        if (rows && tags) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                r = rows[i];
                if (ds._checkRowIndex(r, true)) {
                    t = rowTags[r];
                    if (tags.indexOf(t) >= 0) {
                        save && save.tags.push(t);
                        rowTags[r] = undefined;
                        list.push(r);
                    }
                }
            }
        } else if (rows) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                r = rows[i];
                if (ds._checkRowIndex(r, true)) {
                    t = rowTags[r];
                    if (t !== undefined) {
                        save && save.tags.push(t);
                        rowTags[r] = undefined;
                        list.push(r);
                    }
                }
            }
        } else if (tags) {
            for (i = 0, cnt = rowTags.length; i < cnt; i++) {
                t = rowTags[i];
                if (tags.indexOf(t) >= 0) {
                    save && save.tags.push(t);
                    rowTags[i] = undefined;
                    list.push(i);
                }
            }
        }
        if (list.length > 0) {
            save && (save.rows = list.slice());
            post.list = list;
            !save && this._doPostRun(ds, post);
            return list.length;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireTagsChanged(cmd, post.list);
    },
    _doRedo: function (ds, keep, post) {
        var i,
            rows = keep.rows;
        for (i = rows.length; i--;) {
            ds._rowTags[rows[i]] = undefined;
        }
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    }
});
var DataClearRowTagsCommand = defineClass("DataClearRowTagsCommand", DataSetEditCommand, {
    init: function (ds) {
        this._super(ds);
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            ds._rowTags[rows[i]] = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var i, cnt,
            rowTags = ds._rowTags;
        if (save) {
            save.rows = [];
            save.tags = [];
            for (i = 0, cnt = rowTags.length; i < cnt; i++) {
                if (rowTags[i] !== undefined) {
                    save.rows.push(i);
                    save.tags.push(rowTags[i]);
                }
            }
            if (save.rows.length < 1) {
                return this.throwEmpty(false);
            }
            this._setReady();
        }
        ds._rowTags = new Array(ds.rowCount());
        !save && this._doPostRun(ds);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(cmd, this);
        ds._fireTagsCleared(cmd);
    },
    _doRedo: function (ds, keep) {
        ds._rowTags = new Array(ds.rowCount());
    },
    _doPostRedo: function (ds) {
        ds._fireTagsCleared(this);
    }
});
var GridDataSet = defineClass("GridDataSet", DataSet, {
	init: function (fields, derivedFields) {
		this._super(fields, derivedFields);
        this._needAutoRestore = false;
		this._tags = new GridDataTagCollection(this);
		this._filterRuntime = new DataFilterRuntime();
        this._rowCount = 0;
        this._nextRowId = 0;
		this._values = [];
		this._rowIds = [];
		this._rowStates = [];
        this._rowTags = [];
		this._orgValues = null;
		this._deletedCount = 0;
        (this._setValueCmd = new DataSetValueCommand(this)).undoable = false;
        (this._insertRowCmd = new DataInsertRowCommand(this)).undoable = false;
	},
	onRowInserting: DLCallback,
	onRowInserted: DLCallback,
	onRowsInserted: DLCallback,
	onRowDeleting: DLCallback,
	onRowDeleted: DLCallback,
	onRowsDeleting: DLCallback,
	onRowsDeleted: DLCallback,
    onRowUpdating: DLCallback,
    onRowUpdated: DLCallback,
    onRowsUpdated: DLCallback,
	onRowMoving: DLCallback,
	onRowMoved: DLCallback,
	onRowsMoving: DLCallback,
	onRowsMoved: DLCallback,
	onValueChanging: DLCallback,
	onValueChanged: DLCallback,
	onStateChanged: DLCallback,
	onStatesChanged: DLCallback,
    onTagChanged: DLCallback,
    onTagsChanged: DLCallback,
	filterRuntime: function () {
		return this._filterRuntime;
	},
	getRowId: function (row) {
		return this._rowIds[row];
	},
    getRowById: function (rowId) {
        for (var i = this.rowCount(); i--;) {
            if (this._rowIds[i] == rowId) {
                return i;
            }
        }
        return -1;
    },
	addTag: function (tag) {
		this._tags.add(tag);
	},
	removeTag: function (tag) {
		this._tags.remove(tag);
	},
	setRowCount: function (newCount, fillDefaults, defaultValues, rowState) {
        fillDefaults = arguments.length > 1 ? fillDefaults : false;
        defaultValues = arguments.length > 2 ? defaultValues : null;
        rowState = arguments.length > 3 ? rowState : "none";
        var cmd = new DataSetRowCountCommand(this, newCount, fillDefaults, defaultValues, rowState);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    $_saveAll: function (scope, save, deleting) {
        save = save || {};
        save.nextRowId = this._nextRowId;
        save.values = this._values;
        save.rowIds = this._rowIds;;
        save.rowStates = this._rowStates;
        save.rowTags = this._rowTags;
        save.orgValues = this._orgValues;
        save.deletedCount = this._deletedCount;
        this._tags.$_saveRows(scope, DataSet.ALL_ROWS, deleting);
        return save;
    },
    $_restoreAll: function (scope, save, created) {
        this._nextRowId = save.nextRowId;
        this._values = save.values;
        this._rowIds = save.rowIds;
        this._rowStates = save.rowStates;
        this._rowTags = save.rowTags;
        this._orgValues = save.orgValues;
        this._deletedCount = save.deletedCount;
        this._tags.$_restoreRows(scope, DataSet.ALL_ROWS, created);
    },
	$_clearRows: function () {
        this._resetIdWhenClear && (this._nextRowId = 0);
		this._values = [];
		this._rowIds = [];
		this._rowStates = [];
		this._rowTags = [];
        this._orgValues = this._orgValues ? [] : null;
		this._deletedCount = 0;
		this._tags.clearRows();
	},
	clearRows: function () {
        var cmd = new DataClearRowsCommand(this);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	setRows: function (rows, start, count, rowState, filter) {
        start = arguments.length > 1 ? start : 0;
        count = arguments.length > 2 ? count : -1;
        var cmd = new DataSetRowsCommand(this, rows, start, count, rowState, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	setXmlRows: function (rows, start, count, state, filter) {
		if (!this._checkClientState()) return;
		start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
		if (count == 0) return;
		rows = DataHelper.xmlToArray(this, rows, start, count);
		this.setRows(rows, 0, -1, state, filter);
	},
	appendRows: function (rows, start, count, rowEvents, filter) {
        if (!this._checkClientState()) return;
        if (rows && rows.length > 0 && !this.isAppendable()) {
            return 0;
        }
        start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
		rowEvents = arguments.length > 3 ? rowEvents : false;
		return this.insertRows(this.rowCount(), rows, start, count, rowEvents, filter);
	},
	insertRows: function (row, rows, start, count, rowEvents, filter) {
        start = arguments.length > 2 ? start : 0;
        count = arguments.length > 3 ? count : -1;
        rowEvents = arguments.length > 4 ? rowEvents : false;
        var cmd = new DataInsertRowsCommand(this, row, rows, start, count, rowEvents, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	appendXmlRows: function (rows, start, count, rowEvents) {
        start = arguments.length > 1 ? start : 0;
        count = arguments.length > 2 ? count : -1;
		this.insertXmlRows(this.rowCount(), rows, start, count, rowEvents);
	},
	insertXmlRows: function (row, rows, start, count, rowEvents) {
		if (!this._checkClientState()) return;
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		rows = DataHelper.xmlToArray(this, rows, start, count);
        this.insertRows(row, rows, start, count, rowEvents);
	},
	updateRows: function (row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter) {
        start = arguments.length > 2 ? start : 0;
        count = arguments.length > 3 ? count : -1;
        var cmd = new DataUpdateRowsCommand(this, row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	updateXmlRows: function (row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter) {
		if (!this._checkClientState() || !this.isUpdatable()) return;
        start = arguments.length > 2 ? start : 0;
        count = arguments.length > 3 ? count : -1;
		rows = DataHelper.xmlToArray(this, rows, start, count);
        this.updateRows(row, rows, start, count, checkDiff, strictDiff, checkEmpty, rowEvents, filter);
	},
	updateValues: function (where, newValues, checkDiff, strictDiff, noState) {
        var cmd = new DataUpdateValuesCommand(this, where, newValues, checkDiff, strictDiff, noState);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	updateRow: function (row, values, checkDiff, strictDiff, checkEmpty) {
        var cmd = new DataUpdateRowCommand(this, row, values, checkDiff, strictDiff, checkEmpty);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    setValue: function (row, field, value) {
        if (this.undoable()) {
            return this.execute(new DataSetValueCommand(this, row, field, value, true, true, false));
        } else {
            if (this._checkClientState()) {
                return this._setValueCmd.$_run(this, row, field, value, true, true, false);
            }
        }
    },
    setValueEx: function (row, field, value, checkDiff, strictDiff, noEvent) {
        if (this.undoable()) {
            return this.execute(new DataSetValueCommand(this, row, field, value, checkDiff, strictDiff, noEvent));
        } else {
            if (this._checkClientState()) {
                return this._setValueCmd.$_run(this, row, field, value, checkDiff, strictDiff, noEvent);
            }
        }
    },
	addRow: function (values) {
		var r = this.rowCount();
		return this.insertRow(this._values.length, values) ? r : -1;
	},
	insertRow: function (row, values, field) {
        var cmd = new DataInsertRowCommand(this, row, values, field);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	appendRow: function (values, field) {
        return this.insertRow(this.rowCount(), values, field);
	},
    $$_deleteRow: function (row, save) {
        var state = this._rowStates[row],
            id = this._rowIds[row];
        this._internalDeleteRow(row, save);
        if (DataRowState.isDeleted(state)) {
            this._deletedCount--;
        }
        this._tags.removeRow(row);
        return true;
    },
	$_deleteRow: function (cmd, row) {
		if (this._fireRowDeleting(cmd, row)) {
            if (this.$$_deleteRow(row)) {
                this._fireRowDeleted(cmd, row, this._rowIds[row]);
                this._fireRowCountChanged(cmd);
                return true;
            }
		}
		return false;
	},
	deleteRow: function (row) {
        var cmd = new DataDeleteRowCommand(this, row);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	deleteRows: function (rows, rowEvents) {
        var cmd = new DataDeleteRowsCommand(this, rows, rowEvents);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	moveRow: function (row, newRow) {
        var cmd = new DataMoveRowCommand(this, row, newRow);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	moveRows: function (row, count, newRow) {
        var cmd = new DataMoveRowsCommand(this, row, count, newRow);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    /** @deprecated use getValues instead */
	getRow: function (row) {
        this._checkRowIndex(row);
        var vals = this._values[row];
        return vals ? vals.slice() : [];
	},
    getValues: function (row) {
        this._checkRowIndex(row);
        var vals = this._values[row];
        return vals ? vals.slice() : [];
    },
    $_getRowProps: function (row, props, ev, fldList) {
        var i, p, f, v, flds,
            vals = this._values[row],
            data = {};
        if (vals) {
            flds = this._fields;
            for (i = props.length; i--;) {
                p = props[i];
                f = fldList ? fldList[i] : this.getFieldIndex(p);
                if (f >= 0) {
                    v = vals[f];
                    data[p] = v === UNDEFINED
                        ? (ev !== UNDEFINED ? (ev.hasOwnProperty(p) ? ev[p] : ev) : flds[f]._emptyValue) : v;
                }
            }
        }
        return data;
    },
    _getRowProps: function (row, props) {
        var i, p, f,
            data = {},
            vals = this._values[row];
        if (vals) {
            for (i = props.length; i--;) {
                p = props[i];
                f = this.getFieldIndex(p);
                if (f >= 0) {
                    data[p] = vals[f];
                }
            }
        }
        return data;
    },
    getRowProps: function (row, props, emptyValue) {
        this._checkRowIndex(row);
        return this.$_getRowProps(row, props, this.$_getEmptyValue(emptyValue));
    },
    $_getRowObject: function (row, ev) {
        var i, cnt, v, flds, names, n,
            data = {},
            vals = this._values[row];
        if (vals) {
            flds = this._fields;
            names = this._fieldNames;
            for (i = 0, cnt = names.length; i < cnt; i++) {
                v = vals[i];
                n = names[i];
                data[n] = v === UNDEFINED
                    ? (ev !== UNDEFINED ? (ev.hasOwnProperty(n) ? ev[n] : ev) : flds[i]._emptyValue) : v;
            }
        }
        return data;
    },
	getRowObject: function (row, emptyValue) {
		this._checkRowIndex(row);
		return this.$_getRowObject(row, this.$_getEmptyValue(emptyValue));
	},
    _getRowObject: function (row) {
        var i, cnt, names,
            data = {},
            vals = this._values[row];
        if (vals) {
            names = this._fieldNames;
            for (i = 0, cnt = names.length; i < cnt; i++) {
                data[names[i]] = vals[i];
            }
        }
        return data;
    },
    copyToObject: function (row, obj) {
        var i,
            vals = this._values[row],
            flds = this._fields;
        if (vals) {
            for (i = flds.length; i--;) {
                obj[flds[i]._fieldName] = vals[i];
            }
        } else {
            for (i = flds.length; i--;) {
                obj[flds[i]._fieldName] = undefined;
            }
        }
        return obj;
    },
	getRows: function (startRow, count) {
        var i, cnt, r, r1, r2,
            vals = this._values,
            rowCount = vals.length,
            rows = [];
        if (_isArray(startRow)) {
            for (i = 0, cnt = startRow.length; i < cnt; i++) {
                r = startRow[i];
                if (r >= 0 && r < rowCount) {
                    rows.push(vals[r].concat() || []);
                }
            }
        } else {
            startRow = arguments.length > 0 ? startRow : 0;
            count = arguments.length > 1 ? count : rowCount;
            r1 = Math.max(0, startRow);
            r2 = Math.min(rowCount, startRow + count);
            if (r1 < rowCount && r2 > r1) {
                rows = new Array(r2 - r1);
                for (r = r1; r < r2; r++) {
                    rows[r - r1] = vals[r].concat() || [];
                }
            }
        }
        return rows;
	},
    getRowsProps: function (props, startRow, count, emptyValue) {
        var i, cnt, r1, r2, r,
            rowCount = this._values.length,
            flds = [],
            rows = [];
        for (i = 0; i < props.length; i++) {
            flds.push(this.getFieldIndex(props[i]));
        }
        emptyValue = this.$_getEmptyValue(emptyValue);
        if (_isArray(startRow)) {
            for (i = 0, cnt = startRow.length; i < cnt; i++) {
                r = startRow[i];
                if (r >= 0 && r < rowCount) {
                    rows.push(this.$_getRowProps(r, props, emptyValue, flds));
                }
            }
        } else {
            startRow = arguments.length > 1 ? startRow : 0;
            count = (arguments.length > 2 && count >= 0) ? count : rowCount;
            r1 = Math.max(0, startRow);
            r2 = Math.min(rowCount, startRow + count);
            if (r1 < rowCount && r2 > r1) {
                rows = new Array(r2 - r1);
                for (r = r1; r < r2; r++) {
                    rows[r - r1] = this.$_getRowProps(r, props, emptyValue, flds);
                }
            }
        }
        return rows;
    },
	getRowObjects: function (startRow, count, emptyValue) {
        var i, cnt, r1, r2, r,
            rowCount = this._values.length,
            rows = [];
        emptyValue = this.$_getEmptyValue(emptyValue);
        if (_isArray(startRow)) {
            rows = new Array(cnt = startRow.length);
            for (i = 0; i < cnt; i++) {
                r = startRow[i];
                if (r >= 0 && r < rowCount) {
                    rows[i] = this.$_getRowObject(r, emptyValue);
                }
            }
        } else {
            startRow = arguments.length > 0 ? startRow : 0;
            count = (arguments.length > 1 && count >= 0) ? count : rowCount;
            r1 = Math.max(0, startRow);
            r2 = Math.min(rowCount, startRow + count);
            if (r1 < rowCount && r2 > r1) {
                rows = new Array(r2 - r1);
                for (r = r1; r < r2; r++) {
                    rows[r - r1] = this.$_getRowObject(r, emptyValue);
                }
            }
        }
        return rows;
	},
    getModifiedRowObjects: function (states, valueCallback, stateProp, stateNames, emptyValue) {
        var i, cnt,	st, row, map, len,
            cb = valueCallback,
            rowStates = this._rowStates,
            rows = [];
        stateProp = stateProp = '' ? null : (stateProp || 'row_state');
        if (_isArray(stateNames)) {
            if ((len = stateNames.length) >= 3) {
                map = {
                    created: stateNames[0],
                    updated: stateNames[1],
                    deleted: stateNames[2],
                    createAndDeleted: len > 3 ? stateNames[3] : stateNames[2]
                };
            }
        } else if (_isObject(stateNames)) {
            map = stateNames;
            if (!map.hasOwnProperty(DataRowState.CREATE_AND_DELETED)) {
                map[DataRowState.CREATE_AND_DELETED] = map[DataRowState.CREATED];
            }
        }
        emptyValue = this.$_getEmptyValue(emptyValue);
        for (i = 0, cnt = rowStates.length; i < cnt; i++) {
            st = rowStates[i];
            if (st && st != "none" && (!states || st == states || states.indexOf(st) >= 0)) {
                row = this.$_getRowObject(i, emptyValue);
                cb && cb.call(this, this, i, row);
                if (stateProp && !row.hasOwnProperty(stateProp)) {
                    row[stateProp] = map ? map[st] : st;
                }
                rows.push(row);
            }
        }
        return rows;
    },
	hasData: function (row) {
		return row >= 0 && row < this._values.length && this._values[row] !== undefined;
	},
	hasAllData: function () {
		for (var r = this._values.length; r--;) {
			if (!this._values[r]) return false;
		}
		return true;
	},
	getValue: function (row, field) {
		this._checkRowIndex(row);
        var s, vals;
		if (typeof field == "string") {
			s = field;
			field = this.getFieldIndex(s);
			if (field < 0) {
				field = Number(s);
			}
		}
		this._checkFieldIndex(field, s);
		vals = this._values[row];
		return vals ? vals[field] : undefined;
	},
	getFieldValues: function (field, startRow, count) {
		startRow = arguments.length > 1 ? startRow : 0;
		count = arguments.length > 2 ? count : this.rowCount();
        var endRow, values, i, vals;
        if (count <= 0) {
            return null;
        }
        startRow = Math.max(0, startRow);
        if (startRow >= this.rowCount()) {
            return null;
        }
        if (typeof field === "string") {
            field = this.getFieldIndex(field, true);
        }
		this._checkFieldIndex(field);
        endRow = Math.min(this.rowCount(), startRow + count);
		values = new Array(endRow - startRow);
		for (i = startRow; i < endRow; i++) {
			vals = this._values[i];
			values[i - startRow] = vals && vals[field];
		}
		return values;
	},
	findRow: function (fields, values, strict) {
        var rows = this.findRows(fields, values, strict, 1);
        return rows.length > 0 ? rows[0] : -1;
	},
    findRows: function (fields, values, strict, maxCount) {
        if (!fields || fields.length < 1 || !values || values.length < fields.length) {
            return null;
        }
        var i, c, cnt, row, len, found,
            nfld = this.fieldCount(),
            flds = [],
            flds2 = [],
            vals = [],
            rows = [],
            data = this._values;
        maxCount = isNaN(maxCount) || maxCount <= 0 ? MAX_INT : maxCount;
        cnt = fields.length;
        for (i = 0; i < cnt; i++) {
            c = this.getFieldIndexEx(fields[i]);
            if (c >= 0 && c < nfld && flds.indexOf(c) < 0) {
                flds.push(c);
                flds2.push(this._fields[c]);
                vals.push(values[i]);
            }
        }
        len = flds.length;
        cnt = data.length;
        for (i = 0; i < cnt && rows.length < maxCount; i++) {
            row = data[i];
            found = true;
            for (c = 0; c < len; c++) {
                if (strict && !flds2[c].equalValues(vals[c], row[flds[c]])) {
                    found = false;
                    break;
                } else if (!strict && !flds2[c].sameValues(vals[c], row[flds[c]])) {
                    found = false;
                    break;
                }
            }
            found && rows.push(i);
        }
        return rows;
    },
    filterRows: function (filter, maxCount) {
        maxCount = (isNaN(maxCount) || maxCount < 0) ? MAX_INT : maxCount;
        var i, df, cnt,
            rows = [],
            vals = this._values,
            len = vals.length;
        if (_isFunction(filter)) {
            for (i = 0; i < len && (cnt = rows.length) < maxCount; i++) {
                try {
                    if (filter(this, i, cnt)) {
                        rows.push(i);
                    }
                } catch (err) {
                    if ((err instanceof AbortError)) break;
                    throw err;
                }
            }
        } else if (filter) {
            df = new DataFilter(filter);
            df.prepare(this.filterRuntime().prepare(this));
            r = 0;
            for (i = 0; i < len && (cnt = rows.length) < maxCount; i++) {
                if (df.select(cnt, i, vals[i])) {
                    rows.push(i);
                }
            }
        }
        return rows;
    },
    /** @internal */
	objectToRow: function (obj, row) {
        var i, cnt, fld;
		row = row || [];
		if (obj) {
			for (i = 0, cnt = this._baseFieldCount; i < cnt; i++) {
				fld = this.getFieldName(i);
				if (obj.hasOwnProperty(fld)) {
					row[i] = obj[fld];
				}
			}
		}
		return row;
	},
    /** @internal */
	rowToObject: function (row, obj) {
        var i, cnt, v;
		obj = obj || {};
		if (_isArray(row)) {
			for (i = 0, cnt = this._baseFieldCount; i < cnt; i++) {
				v = row[i];
				if (v !== undefined) {
					obj[this.getFieldName(i)] = v;
				}
			}
		}
		return obj;
	},
	equalValues: function (field, row1, row2) {
        var fld, v1, v2;
		if (row1 !== row2) {
			fld = this._fields[field];
			v1 = this.getValue(row1, field);
			v2 = this.getValue(row2, field);
			return fld.equalValues(v1, v2);
		} else {
			return true;
		}
	},
	equalTexts: function (field, row1, row2) {
        var v1, v2;
		if (row1 !== row2) {
			v1 = this.getValue(row1, field);
			v2 = this.getValue(row2, field);
			if (v1 === undefined || v1 === null) {
				return v2 === undefined || v2 === null;
			}
			if (v2 === undefined || v2 === null) {
				return false;
			}
			return v1.toLowerCase() == v2.toLowerCase();
		} else {
			return true;
		}
	},
	sameValues: function (field, row1, row2) {
        var fld, v1, v2;
		if (row1 !== row2) {
			fld = this._fields[field];
			v1 = this.getValue(row1, field);
			v2 = this.getValue(row2, field);
			return fld.sameValues(v1, v2);
		} else {
			return true;
		}
	},
	copyRows: function (sourceRow, count, targetRow, noStates) {
	},
    createActionGroup: function (immediately) {
        return new GridDataActionGroup(this, immediately);
    },
	rowCount: function () {
		return this._values.length;
	},
	getOptions: function () {
		return this._super();
	},
    deletedCount: function () {
        return this._deletedCount;
    },
	canUpdateRow: function (row) {
		return this.isUpdatable() && row >= 0 && row < this.rowCount();
	},
	canAppendRow: function () {
		return this.isAppendable();
	},
	canInsertRow: function (row) {
		return this.isInsertable() && row >= 0 && row <= this.rowCount();
	},
	canDeleteRow: function (row) {
		return this.isDeletable() && row >= 0 && row < this.rowCount();
	},
	$_internalInsertField: function (index, field) {
		index = this._super(index, field);
		if (index >= 0) {
			var r, vals,
			    rows = this._values.length;
			for (r = 0; r < rows; r++) {
				vals = this._values[r];
				vals && vals.length > index && vals.splice(index, 0, undefined);
			}
			if (this._orgValues) {
				rows = Math.min(rows, this._orgValues.length);
				for (r = 0; r < rows; r++) {
					vals = this._orgValues[r];
					vals && vals.length > 0 && vals.splice(index, 0, undefined);
				}
			}
		}
		return index;
	},
	$_internalClearFields: function () {
		GridDataSet.Base.$_internalClearFields.call(this);
		this.$_clearRows();
	},
    isUpdated: function (row, field) {
        this._checkRowIndex(row);
        this._checkFieldIndex(field);
        if (this._orgValues && this._orgValues[row]) {
            return !this._fields[field].equalValues(this._orgValues[row][field], this._values[row][field]);
        }
        return false;
    },
    getRowTag: function (row) {
        return this._rowTags[row];
    },
    getRowsByTag: function (tag) {
        var i, cnt,
            tags = this._rowTags,
            rows = [];
        if (tag) {
            for (i = 0, cnt = tags.length; i < cnt; i++) {
                if (tags[i] === tag) {
                    rows.push(i);
                }
            }
        }
        return rows;
    },
    getRowsByTags: function (tags) {
        var i, cnt,
            rowTags = this._rowTags,
            rows = [];
        if (tags && tags.length) {
            for (i = 0, cnt = rowTags.length; i < cnt; i++) {
                if (tags.indexOf(rowTags[i]) >= 0) {
                    rows.push(i);
                }
            }
        }
        return rows;
    },
    setRowTag: function (row, tag) {
        var cmd = new DataSetRowTagCommand(this, row, tag);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setRowTags: function (rows, tag) {
        var cmd = new DataSetRowTagsCommand(this, rows, tag);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    unsetRowTags: function (rows, tags) {
        var cmd;
        rows = (rows && rows.length > 0) ? rows : null;
        tags = (tags && tags.length > 0) ? tags : null;
        if (!rows && !tags) {
            cmd = new DataClearRowTagsCommand(this);
        } else {
            cmd = new DataUnsetRowTagsCommand(this, rows, tags);;
        }
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
	clearRowTags: function () {
        var cmd = new DataClearRowTagsCommand(this);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	getRowState: function (row) {
		this._checkRowIndex(row);
		return this._rowStates[row] || DataRowState.NONE;
	},
	setRowState: function (row, state, force) {
        var cmd = new DataSetRowStateCommand(this, row, state, force);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	setRowStates: function (rows, state, force, rowEvents) {
        var cmd = new DataSetRowStatesCommand(this, rows, state, force, rowEvents);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	clearRowStates: function (states, deleteRows, rowEvents) {
        var cmd = new DataClearRowStatesCommand(this, states, deleteRows, rowEvents);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	getStateRows: function (state) {
		var i, cnt,	st,
			rows = [];
		if (state) {
			for (i = 0, cnt = Math.min(this._values.length, this._rowStates.length); i < cnt; i++) {
				st = this._rowStates[i];
				if (st == state) {
					rows.push(i);
				}
			}
		}
		return rows;
	},
	getAllStateRows: function () {
		var i, cnt,	st,
		    rows = {},
		    created = rows.created = [],
		    updated = rows.updated = [],
		    deleted = rows.deleted = [],
		    cdeleted = rows.createAndDeleted = [];
		for (i = 0, cnt = Math.min(this._values.length, this._rowStates.length); i < cnt; i++) {
			st = this._rowStates[i];
			if (st === DataRowState.CREATED) {
				created.push(i);
			} else if (st === DataRowState.UPDATED) {
				updated.push(i);
			} else if (st === DataRowState.DELETED) {
				deleted.push(i);
			} else if (st === DataRowState.CREATE_AND_DELETED) {
				cdeleted.push(i);
			}
		}
		return rows;
	},
	getRowStateCount: function (states) {
		var i, state,
		    len = states ? states.length : 0,
		    cnt = Math.min(this._values.length, this._rowStates.length),
		    count = 0;
		if (len && cnt) {
			if (len > 1) {
				for (i = 0; i < cnt; i++) {
					state = this._rowStates[i];
					if (states.indexOf(state) >= 0) {
						count++;
					}
				}
			} else {
				state = states[0];
				for (i = 0; i < cnt; i++) {
					if (this._rowStates[i] === state) {
						count++;
					}
				}
			}
		}
		return count;
	},
	$_restoreState: function (row) {
        var strict, i, cnt, v1, v2, strict,
            orgs = this._orgValues[row],
            vals = this._values[row];
        if (vals && orgs) {
            strict = this.strictRestore();
            for (i = 0, cnt = this._fields.length; i < cnt; i++) {
                v1 = vals.length > i ? vals[i] : undefined;
                v2 = orgs.length > i ? orgs[i] : undefined;
                if (strict) {
                    if (!this._fields[i].equalValues(v1, v2)) {
                        return false;
                    }
                } else {
                    if (!this._fields[i].sameValues(v1, v2)) {
                        return false;
                    }
                }
            }
            this._rowStates[row] = DataRowState.NONE;
            delete this._orgValues[row];
            return true;
        }
        return false;
	},
	restoreUpdatedStates: function (rows) {
        var cmd = new DataRestoreUpdatedStatesCommand(this, rows);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	$_restoreUpdated: function (row, save) {
        var vals, i, cnt,
            orgs = this.$$_orgVals = this._orgValues[row];
        if (orgs) {
            vals = this._values[row];
            save && (this.$$_oldVals = vals && vals.concat());
            if (orgs) {
                this._values[row] = vals = vals || [];
                for (i = 0, cnt = this._fields.length; i < cnt; i++) {
                    vals[i] = orgs[i];
                }
            }
            this._derivedFieldCount && this.$_deriveValues(row, vals, -1);
            this._rowStates[row] = DataRowState.NONE;
            delete this._orgValues[row];
            return true;
        }
        return false;
	},
	restoreUpdatedRows: function (rows) {
        var cmd = new DataRestoreUpdatedRowsCommand(this, rows);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    /*
	savePoint: function (saveStates, saveTags) {
		if (!this._checkClientState()) return;
		saveStates = arguments.length > 0 ? arguments : true;
		var values = this._values;
		var flds = this._fields.length;
        var i, cnt, row, rows, states, tags;
		if (flds > 0 && values && (cnt = values.length) > 0) {
			rows = new Array(cnt);
			for (i = 0; i < cnt; i++) {
				row = values[i];
				if (row) {
					row = row.concat();
				}
				rows[i] = row;
			}
			states = saveStates ? this._rowStates.concat() : null;
			tags = saveTags ? this._rowTags.concat() : null;
			i = this._nextPoint++;
			this._points.push({
				id: i,
				data: rows,
				states: states,
				tags: tags
			});
			return i;
		}
		return -1;
	},
	rollback: function (savePoint) {
		if (!this._checkClientState()) return;
		for (var i = this._points.length - 1; i >= 0; i--) {
			var point = this._points[i];
			if (point.id == savePoint) {
				this.$_removeSavePoints(i + 1);
				this.setRows(point.data);
                var states = point.states;
				if (states) {
					this._rowStates = states.concat();
				}
				var tags = point.tags;
				if (tags) {
					this._rowTags = tags.concat();
				}
				break;
			}
		}
	},
	$_removeSavePoints: function (index) {
		var point;
		var points = this._points;
		for (var i = points.length - 1; i >= index; i--) {
			point = points[i];
			point.data = null;
			points.pop();
		}
	},
	clearSavePoints: function () {
		this.$_removeSavePoints(0);
	},
	getSavePoints: function () {
		var points = [];
		for (var i = 0, cnt = this._points.length; i < cnt; i++) {
			points.push(this._points[i].id);
		}
		return points;
	},
	*/
	_doGetDistinctValues: function (field, maxCount) {
        var isNum, rows, row, i, cnt, value, compFunc,
		    values = [];
		if (maxCount < 0) {
			maxCount = this._values.length;
		}
		if (maxCount > 0) {
			isNum = this.getField(field).dataType() == ValueType.NUMBER;
            rows = new Array(this._values.length);
            for (i = rows.length; i--;) {
                rows[i] = i;
            }
            compFunc = this.getComparer(field).bind(this);
            this.$_sortRows(rows, field, compFunc, 0, rows.length - 1);
			row = this._values[rows[0]];
			values.push(row ? row[field] : undefined);
			for (i = 1, cnt = rows.length; i < cnt; i++) {
				if (compFunc(field, rows[i - 1], rows[i]) < 0) {
					row = this._values[rows[i]];
					value = row ? row[field] : undefined;
                    values.push(value);
					if (values.length >= maxCount) {
						break;
					}
				}
			}
		}
		return values;
	},
	compareValues: function (field, row1, row2) {
        var v1, v2,
		    vals1 = this._values[row1],
		    vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			v1 = vals1 ? vals1[field] : null;
			v2 = vals2 ? vals2[field] : null;
			if (v1 === undefined || v1 === null) {
				return (v2 === undefined || v2 === null) ? 0 : -1;
			}
			if (v2 === undefined || v2 === null) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareTexts: function (field, row1, row2) {
        var v1, v2,
		    vals1 = this._values[row1],
		    vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (v1 === undefined || v1 === null) {
				return (v2 === undefined || v2 === null) ? 0 : -1;
			}
			if (v2 === undefined || v2 === null) {
				return 1;
			}
			v1 = String(v1).toLocaleLowerCase();
			v2 = String(v2).toLocaleLowerCase();
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareNumbers: function (field, row1, row2) {
        var v1, v2,
		    vals1 = this._values[row1],
		    vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			v1 = vals1 ? vals1[field] : NaN;
			v2 = vals2 ? vals2[field] : NaN;
			if (isNaN(v1)) {
				return (isNaN(v2)) ? 0 : -1;
			}
			if (isNaN(v2)) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareDates: function (field, row1, row2) {
        var v1, v2,
		    vals1 = this._values[row1],
		    vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			v1 = vals1 ? vals1[field] : null;
			v2 = vals2 ? vals2[field] : null;
			if (!(v1 instanceof Date)) {
				return !(v2 instanceof Date) ? 0 : -1;
			}
			if (!(v2 instanceof Date)) {
				return 1;
			}
			return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
		}
	},
	compareBools: function (field, row1, row2) {
        var v1, v2,
		    vals1 = this._values[row1],
		    vals2 = this._values[row2];
		if (vals1 === vals2) {
            return 0;
		} else {
			v1 = vals1 ? vals1[field] : undefined;
			v2 = vals2 ? vals2[field] : undefined;
            if (v1 === undefined || v2 === undefined) {
                return v1 === v2 ? 0 : v1 === undefined ? -1 : 1;
            }
            return (v1 && !v2) ? 1 : (!v1 && v2) ? -1 : 0;
		}
	},
    compareObjs: function (field, row1, row2) {
        var v1, v2, fld, cb,
            vals1 = this._values[row1],
            vals2 = this._values[row2];
        if (vals1 === vals2) {
            return 0;
        } else {
            v1 = vals1 ? vals1[field] : null;
            v2 = vals2 ? vals2[field] : null;
            if (!v1) {
                return (!v2) ? 0 : -1;
            }
            if (!v2) {
                return 1;
            }
            fld = this.getField(field);
            cb = fld._compareCallback || fld.$_compareObjs;
            return cb(v1, v2);
        }
    },
	aggregate: function (summary, calcVars) {
		if (summary == null) {
			return false;
		}
        summary.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
        var vals, v, i, vars, avg, t,
		    n = 0,
		    f = summary.field,
		    sum = 0,
		    min = NaN,
		    max = NaN;
		i = 0;
		while (i < count) {
			vals = this._values[i++];
			v = vals ? vals[f] : NaN;
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
			vals = this._values[i++];
			v = vals ? vals[f] : NaN;
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				else if (v > max) max = v;
				n++;
			}
		}
		summary.count = count;
		if (n > 0) {
			summary.sum = sum;
			summary.min = min;
			summary.max = max;
			summary.avg = sum / count;
			if (calcVars) {
				vars = 0;
				avg = summary.avg;
				for (i = 0; i < count; i++) {
					vals = this._values[i];
					v = vals ? vals[f] : NaN;
					if (!isNaN(v)) {
						vars += Math.pow(v - avg, 2);
					}
				}
				summary.varsp = vars / count;
				summary.vars = vars / (count - 1);
			} else {
				summary.varsp = NaN;
				summary.vars = NaN;
			}
			t = this._fields[f]._dataType;
			if (t === ValueType.DATETIME) {
				summary.min = new Date(summary.min);
                summary.max = new Date(summary.max);
			}
		}
		return true;
	},
	aggregateRange: function (summary, rows, calcVars) {
		if (summary == null || rows == null) {
			return false;
		}
		summary.clear();
		var count = rows.length;
		if (count < 1) {
            return false;
        }
        var i, r, vals, v, vars, avg, t,
		    n = 0,
		    f = summary.field,
		    values = this._values,
		    sum = 0,
		    min = NaN,
		    max = NaN;
		i = 0;
		while (i < count) {
			r = rows[i++];
			vals = values[r];
			v = vals ? vals[f] : NaN;
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
			r = rows[i++];
			vals = values[r];
			v = vals ? vals[f] : NaN;
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				if (v > max) max = v;
				n++;
			}
		}
		summary.count = count;
		if (n > 0) {
			summary.sum = sum;
			summary.min = min;
			summary.max = max;
			summary.avg = sum / count;
			if (calcVars) {
				vars = 0;
				avg = summary.avg;
				for (i = 0; i < count; i++) {
					r = rows[i];
					vals = values[r];
					v = vals ? vals[f] : NaN;
					if (!isNaN(v)) {
						vars += Math.pow(v - avg, 2);
					}
				}
				summary.varsp = vars / count;
				summary.vars = vars / (count - 1);
			} else {
				summary.varsp = NaN;
				summary.vars = NaN;
			}
            t = this._fields[f]._dataType;
            if (t === ValueType.DATETIME) {
                summary.min = new Date(summary.min);
                summary.max = new Date(summary.max);
            }
		}
		return true;
	},
	exportToJson: function (options, startRow, count, emptyValue) {
        startRow = arguments.length > 1 ? startRow : 0;
        count = arguments.length > 2 ? count : this.rowCount();
        var rows = this.getRowObjects(startRow, count, emptyValue);
        if (rows && rows.length > 0 && options) {
			if (!(options instanceof DataOutputOptions)) {
				options = new DataOutputOptions(options);
			}
            this.$_createOutputRows(rows, options, startRow);
        }
        return rows;
	},
	exportToCsv: function (options, startRow, count) {
        startRow = arguments.length > 1 ? startRow : 0;
        count = arguments.length > 2 ? count : this.rowCount();
		if (count > 0) {
			if (!(options instanceof DataOutputOptions)) {
				options = new DataOutputOptions(options);
			}
			var rows = Math.max(0, Math.min(this.rowCount(), startRow + count));
			if (rows > startRow) {
				return this.$_createOutputLines(this._values, options, startRow, rows);
			}
		}
		return null;
	},
	exportToXml: function (options, startRow, count) {
	},
	_doCheckStatesChanged: function () {
		this.$_resetOrgValues();
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
		this.$_resetOrgValues();
	},
    copyRows: function (sourceRow, count, targetRow, noStates) {
        this._checkRowIndex(sourceRow);
        var i, cnt, values, row, f, len, v, checkStates, rows,
            cnt = this._values.length;
        count = Math.max(0, Math.min(count, cnt - sourceRow));
        if (count < 1 || targetRow > cnt) {
            return;
        }
        rows = [];
        for (i = 0; i < cnt; i++) {
            values = this._values[i + sourceRow];
            row = [];
            for (f = 0, len = this._fields.length; f < len; f++) {
                v = values[f];
                if (this._fields[f].dataType() == ValueType.DATE) {
                    row[f] = typeof v == Date ? new Date(v) : v;
                } else {
                    row[f] = v;
                }
            }
            rows.push(row);
        }
        checkStates = this._checkStates;
        if (noStates) {
            this._checkStates = false;
        }
        try {
            this.insertRows(targetRow, rows);
        } finally {
            this._checkStates = checkStates;
        }
    },
	tags: function () {
		return this._tags;
	},
	isEventLocked: function () {
		return this._eventLock > 0;
	},
	_checkRowIndex: function (row, noThrow) {
		if (isNaN(row) || row != parseInt(row) || row < 0 || row >= this._values.length) {
			if (noThrow) return false;
            throw new RangeError("Row is out of bounds: " + row);
		}
        return true;
	},
	$_resetOrgValues: function () {
		var mode = this.restoreMode();
		this._orgValues = (this._checkStates && (mode == DataRestoreMode.AUTO || mode == DataRestoreMode.EXPLICIT)) ? [] : null;
		this._needAutoRestore = this._orgValues && mode == DataRestoreMode.AUTO;
	},
	_arrayToRow: function (values) {
        var c,
		    cols = Math.min(values ? values.length : 0, this._baseFieldCount),
            vals = new Array(cols);
		for (c = 0; c < cols; c++) {
			vals[c] = this._fields[c].loadValue(values[c]);
		}
		return vals;
	},
	_internalInsertRow: function (row, values, field) {
		var vals = this._arrayToRow(values),
		    append = row == this._values.length;
        this._derivedFieldCount && this.$_deriveValues(row, vals, field >= 0 ? field : -1);
        if (append) {
			this._values.push(vals);
			this._rowIds.push(this._nextRowId++);
            this._rowTags.push(undefined);
		} else {
			this._values.splice(row, 0, vals);
			this._rowIds.splice(row, 0, this._nextRowId++);
            this._rowTags.splice(row, 0, undefined);
		}
		if (append) {
			this._rowStates.push(this._checkStates ? DataRowState.CREATED : DataRowState.NONE);
		} else {
			this._rowStates.splice(row, 0, this._checkStates ? DataRowState.CREATED : DataRowState.NONE);
			if (this._orgValues) {
				this._orgValues.splice(row, 0, undefined);
			}
		}
	},
	_internalSetRow: function (row, values) {
		var vals = this._arrayToRow(values);
        this._derivedFieldCount && this.$_deriveValues(row, vals, -1);
		this._values[row] = vals;
		this._rowIds[row] = this._nextRowId++;
        this._rowTags[row] = undefined;
	},
	_xmlToRow: function (xml) {
	},
	_internalInsertXmlRow: function (cmd, row, xml, stateEvent) {
	},
	_internalSetXmlRow: function (cmd, row, xml) {
	},
	_internalUpdateRow: function (cmd, row, values, checkDiff, strictDiff, checkEmpty, stateEvent, isObj) {
        var oldVals, c, fld, v, diff, fname,
            fields = this._fields,
		    cnt = isObj ? fields.length : Math.min(fields.length, values.length),
		    vals = this._values[row],
		    oldState = this._rowStates[row],
            created = oldState == DataRowState.CREATED || oldState == DataRowState.CREATE_AND_DELETED,
		    needState = this._checkStates && (oldState == DataRowState.NONE || !oldState),
		    changed = false;
        this.$$_oldVals = vals && vals.concat();
		if (!vals) {
			this._values[row] = vals = [];
		}
		if (needState && this._orgValues) {
			oldVals = this.$$_oldVals;
		}
		for (c = 0; c < cnt; c++) {
            fld = fields[c];
            if (fld._updatable || created) {
                if (isObj) {
                    fname = fld.fieldName();
                    if (!values.hasOwnProperty(fname)) fname = null;
                    else v = values[fname];
                } else {
                    v = values[c];
                }
                if (!isObj || fname) {
                    if (!checkEmpty || v !== undefined) {
                        v = fld.readValue(v);
                        diff = !checkDiff;
                        if (!diff) {
                            if (strictDiff) {
                                diff = !fld.equalValues(v, vals[fld._index]);
                            } else {
                                diff = !fld.sameValues(v, vals[fld._index]);
                            }
                        }
                        if (diff) {
                            vals[c] = v;
                            changed = true;
                        }
                    }
                }
            }
		}
        if (changed) {
            this._derivedFieldCount && this.$_deriveValues(row, vals, -1);
            if (needState) {
                if (oldVals) {
                    this._orgValues[row] = oldVals;
                }
                this._changeRowState(cmd, row, DataRowState.UPDATED, stateEvent);
            } else if (this._needAutoRestore && oldState == DataRowState.UPDATED) {
                this.$_restoreState(row);
            }
        }
        return changed;
	},
	_internalUpdateValues: function (cmd, row, fields, values, checkDiff, strictDiff, checkEmpty, stateEvent, noState) {
		fields = fields || this._fields;
        var c, fld, v, diff, oldVals,
		    cnt = Math.min(fields.length, values.length),
		    vals = this._values[row],
		    oldState = this._rowStates[row],
            created = oldState == DataRowState.CREATED || oldState == DataRowState.CREATE_AND_DELETED,
		    needState = !noState && this._checkStates && (oldState == DataRowState.NONE || !oldState),
            changed = false;
		if (!vals) {
			this._values[row] = vals = [];
		}
        this.$$_oldVals = vals.concat();
		if (needState && this._orgValues) {
			oldVals = this.$$_oldVals;
		}
		for (c = 0; c < cnt; c++) {
			fld = fields[c];
			if (fld._updatable || created) {
				v = values[c];
				if (!checkEmpty || v !== undefined) {
                    if (_isFunction(v)) {
                        v = v(this, row, fld._index);
                    }
					v = fld.readValue(v);
                    diff = !checkDiff;
                    if (!diff) {
                        if (strictDiff) {
                            diff = !fld.equalValues(v, vals[fld._index]);
                        } else {
                            diff = !fld.sameValues(v, vals[fld._index]);
                        }
                    }
					if (diff) {
						vals[fld._index] = v;
						changed = true;
					}
				}
			}
		}
		if (changed) {
            this._derivedFieldCount && this.$_deriveValues(row, vals, -1);
			if (needState) {
				if (oldVals) {
					this._orgValues[row] = oldVals;
				}
				this._changeRowState(cmd, row, DataRowState.UPDATED, stateEvent);
			} else if (this._needAutoRestore && oldState == DataRowState.UPDATED) {
				this.$_restoreState(row);
			}
		}
		return changed;
	},
	_internalUpdateXmlRow: function (row, xml, checkDiff, strictDiff, checkEmpty, stateEvent) {
	},
    $_saveRow: function (row, save) {
        save.row = row;
        save.values = this._values[row];
        save.id = this._rowIds[row];
        save.state = this._rowStates[row];
        if (this._orgValues && this._orgValues.length > row) {
            save.orgValues = this._orgValues[row];
        }
        save.tag = this._rowTags[row];
        return save;
    },
	_internalDeleteRow: function (row, save) {
        save && this.$_saveRow(row, save);
		this._values.splice(row, 1);
		this._rowIds.splice(row, 1);
		if (this._orgValues && this._orgValues.length > row) {
			this._orgValues.splice(row, 1);
		}
		this._rowStates.splice(row, 1);
		this._rowTags.splice(row, 1);
	},
	_internalMoveRow: function (row, newRow) {
		var vals = this._values.splice(row, 1)[0],
		    id = this._rowIds.splice(row, 1)[0],
		    state = this._rowStates.splice(row, 1)[0],
            tag = this._rowTags.splice(row, 1)[0];
        this._values.splice(newRow, 0, vals);
        this._rowIds.splice(newRow, 0, id);
        this._rowStates.splice(newRow, 0, state);
        this._rowTags.splice(newRow, 0, tag);
        if (this._orgValues) {
            this._orgValues.length = Math.max(this._orgValues.length, row + 1, newRow + 1);
        	vals = this._orgValues.splice(row, 1)[0];
            this._orgValues.splice(newRow, 0, vals);
        }
	},
	_internalMoveRows: function (row, count, newRow) {
        var i, r,
            vals = this._values.splice(row, count),
		    ids = this._rowIds.splice(row, count),
		    states = this._rowStates.splice(row, count),
		    tags = this._rowTags.splice(row, count);
        for (i = 0; i < count; i++) {
            r = newRow + i;
            this._values.splice(r, 0, vals[i]);
            this._rowIds.splice(r, 0, ids[i]);
            this._rowStates.splice(r, 0, states[i]);
            this._rowTags.splice(r, 0, tags[i]);
        }
		if (this._orgValues) {
            this._orgValues.length = Math.max(this._orgValues.length, row + count, newRow + count);
            vals = this._orgValues.splice(row, count);
            for (i = 0; i < count; i++) {
                this._orgValues.splice(newRow + i, 0, vals[i]);
            }
		}
	},
	_changeRowState: function (cmd, row, newState, fireEvent, force, checkDeleted) {
		if (this._checkStates || force) {
			var state = this._rowStates[row];
			newState = newState || DataRowState.NONE;
			if (newState != state) {
				this._rowStates[row] = newState;
				if (checkDeleted) {
					if (!DataRowState.isDeleted(state) && DataRowState.isDeleted(newState)) {
						this._deletedCount++;
					} else if (DataRowState.isDeleted(state) && !DataRowState.isDeleted(newState)) {
						this._deletedCount--;
					}
				}
				if (fireEvent) {
					this._fireStateChanged(cmd, row, state);
				}
				return true;
			}
		}
		return false;
	},
	$_prepareOrgValues: function (row, oldState, newState) {
		if (newState == DataRowState.UPDATED) {
			this._orgValues[row] = this._values[row] ? this._values[row].concat() : [];
		} else if (oldState == DataRowState.UPDATED) {
			if (this._orgValues[row]) {
				this._orgValues[row] = undefined;
			}
		}
	},
	_changeRowStateEx: function (cmd, row, newState, fireEvent, force) {
		var oldState = this._rowStates[row];
		if (this._changeRowState(cmd, row, newState, false, force, true)) {
			if (this._orgValues) {
				this.$_prepareOrgValues(row, oldState, newState);
			}
			if (fireEvent) {
				this._fireStateChanged(cmd, row, oldState);
			}
			return true;
		}
		return false;
	},
    _doRecalcAll: function () {
        var i,
            vals = this._values,
            cnt = vals.length;
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                this.$_deriveValues(i, vals[i], -1);
            }
        }
        return cnt;
    },
    _doRecalcRows: function (rows) {
        var i, row,
            vals = this._values,
            calced = 0,
            cnt = rows.length;
        for (i = 0; i < cnt; i++) {
            row = rows[i];
            if (row >= 0 && row < vals.length && vals[row]) {
                this.$_deriveValues(row, vals[row], -1);
                calced++;
            }
        }
        return calced;
    },
    _doRecalcRow: function (row) {
        var vals = this._values;
        if (row >= 0 && row < vals.length && vals[row]) {
            this.$_deriveValues(row, vals[row], -1);
            return 1;
        }
        return 0;
    },
	_fireRowInserting: function (cmd, row, values) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(GridDataSet.ROW_INSERTING, row, values);
            if (ret && this.onRowInserting/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowInserting(this, row, values) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowInserted: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROW_INSERTED, row);
            this.onRowInserted && (!this._onStack || this._eventable) && this.onRowInserted(this, row);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
    _fireRowsInserting: function (cmd, row, rows, start, count) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            var ret = this.fireConfirmEvent(GridDataSet.ROWS_INSERTING, row, rows, start, count);
            if (ret && this.onRowsInserting/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowsInserting(this, row, rows, start, count) !== false;
            }
            return ret;
        }
        return true;
    },
	_fireRowsInserted: function (cmd, row, count) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROWS_INSERTED, row, count);
            this.onRowsInserted && (!this._onStack || this._eventable) && this.onRowsInserted(this, row, count);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowDeleting: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(GridDataSet.ROW_DELETING, row);
            if (ret && this.onRowDeleting/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowDeleting(this, row) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowDeleted: function (cmd, row, rowId) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROW_DELETED, row, rowId);
            this.onRowDeleted && (!this._onStack || this._eventable) && this.onRowDeleted(this, row, rowId);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowsDeleting: function (cmd, rows) {
		if (this._eventLock <= 0) {
			var ret = this.fireConfirmEvent(GridDataSet.ROWS_DELETING, rows);
            if (ret && this.onRowsDeleting/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowsDeleting(this, rows) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowsDeleted: function (cmd, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROWS_DELETED, rows);
            this.onRowsDeleted && (!this._onStack || this._eventable) && this.onRowsDeleted(this, rows);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowUpdating: function (cmd, row, values) {
		if (this._eventLock <= 0) {
			var ret = this.fireConfirmEvent(GridDataSet.ROW_UPDATING, row, values);
            if (ret && this.onRowUpdating/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowUpdating(this, row, values) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowUpdated: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROW_UPDATED, row);
            this.onRowUpdated && (!this._onStack || this._eventable) && this.onRowUpdated(this, row);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
    _fireRowsUpdating: function (cmd, row, rows, start, count) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            var ret = this.fireConfirmEvent(GridDataSet.ROWS_UPDATING, row, rows, start, count);
            if (ret && this.onRowsUpdating/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowsUpdating(this, row, rows, start, count) !== false;
            }
            return ret;
        }
        return true;
    },
    _fireValuesUpdating: function (cmd, where, newValues) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            var ret = this.fireConfirmEvent(GridDataSet.VALUES_UPDATING, where, newValues);
            if (ret && this.onValuesUpdating/* && (!this._onStack || this._eventable)*/) {
                ret = this.onValuesUpdating(this, where, newValues) !== false;
            }
            return ret;
        }
        return true;
    },
	_fireRowsUpdated: function (cmd, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROWS_UPDATED, rows);
            this.onRowsUpdated && (!this._onStack || this._eventable) && this.onRowsUpdated(this, rows);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowMoving: function (cmd, row, newRow) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(GridDataSet.ROW_MOVING, row, newRow);
            if (ret && this.onRowMoving/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowMoving(this, row, newRow) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowMoved: function (cmd, row, newRow) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROW_MOVED, row, newRow);
            this.onRowMoved && (!this._onStack || this._eventable) && this.onRowMoved(this, row, newRow);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowsMoving: function (cmd, row, count, newRow) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(GridDataSet.ROWS_MOVING, row, count, newRow);
            if (ret && this.onRowsMoving/* && (!this._onStack || this._eventable)*/) {
                ret = this.onRowsMoving(this, row, count, newRow) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowsMoved: function (cmd, row, count, newRow) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.ROWS_MOVED, row, count, newRow);
            this.onRowsMoved && (!this._onStack || this._eventable) && this.onRowsMoved(this, row, count, newRow);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	fireValueChanging: function (cmd, row, field, value) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(GridDataSet.VALUE_CHANGING, row, field, value);
            if (ret && this.onValueChanging/* && (!this._onStack || this._eventable)*/) {
                ret = this.onValueChanging(this, row, field, value) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireValueChanged: function (cmd, row, field) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.VALUE_CHANGED, row, field);
            if (!(this.onValueChanged && (!this._onStack || this._eventable) && this.onValueChanged(this, row, field))) {
                this.onRowUpdated && (!this._onStack || this._eventable) && this.onRowUpdated(this, row, field);
            }
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireStateChanged: function (cmd, row, oldState) {
		if (this._eventLock <= 0) {
            var updating = cmd && cmd.$_updating();
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.STATE_CHANGED, row, oldState, updating);
            this.onStateChanged && (!this._onStack || this._eventable) && this.onStateChanged(this, row, oldState, updating);
		}
	},
	_fireStatesChanged: function (cmd, rows, deletedInc) {
		if (this._eventLock <= 0) {
            var updating = cmd && cmd.$_updating();
            this.$$_cmd = cmd;
			this.fireEvent(GridDataSet.STATES_CHANGED, rows, deletedInc, updating);
            this.onStatesChanged && (!this._onStack || this._eventable) && this.onStatesChanged(this, rows, deletedInc, updating);
		}
	},
    _fireTagChanged: function (cmd, row) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(GridDataSet.TAG_CHANGED, row);
            this.onTagChanged && (!this._onStack || this._eventable) && this.onTagChanged(this, row);
        }
    },
    _fireTagsChanged: function (cmd, rows) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(GridDataSet.TAGS_CHANGED, rows);
            this.onTagsChanged && (!this._onStack || this._eventable) && this.onTagsChanged(this, rows);
        }
    }
}, null, function (f) {
	f.ROW_COUNT_CHANGED = "onGridDataSetRowCountChanged";
	f.ROW_INSERTING = "onGridDataSetRowInserting";
	f.ROW_INSERTED = "onGridDataSetRowInserted";
    f.ROWS_INSERTING = "onGridDataSetRowsInserting";
	f.ROWS_INSERTED = "onGridDataSetRowsInserted";
	f.ROW_DELETING = "onGridDataSetRowDeleting";
	f.ROW_DELETED = "onGridDataSetRowDeleted";
	f.ROWS_DELETING = "onGridDataSetRowsDeleting";
	f.ROWS_DELETED = "onGridDataSetRowsDeleted";
	f.ROW_UPDATING = "onGridDataSetRowUpdating";
	f.ROW_UPDATED = "onGridDataSetRowUpdated";
    f.ROWS_UPDATING = "onGridDataSetRowsUpdating";
    f.VALUES_UPDATING = "onGridDataSetValuesUpdating";
	f.ROWS_UPDATED = "onGridDataSetRowsUpdated";
	f.VALUE_CHANGING = "onGridDataSetValueChanging";
	f.VALUE_CHANGED = "onGridDataSetValueChanged";
	f.ROW_MOVING = "onGridDataSetRowMoving";
	f.ROW_MOVED = "onGridDataSetRowMoved";
	f.ROWS_MOVING = "onGridDataSetRowsMoving";
	f.ROWS_MOVED = "onGridDataSetRowsMoved";
	f.STATE_CHANGED = "onGridDataSetStateChanged";
	f.STATES_CHANGED = "onGridDataSetStatesChanged";
	f.TAG_CHANGED = "onGridDataSetTagChanged";
    f.TAGS_CHANGED = "onGridDataSetTagsChanged";
});
/** @internal */
var DataPath = defineClass("DataPath", null, {
    init : function() {
        this._super();
    }
}, {
    extractJson: function (source, path, force) {
        var segs, k, seg, i, j, s, arr, idx,
			data = source;
        path = path && path.trim(path);
        if (path) {
			if (path.indexOf('.') >= 0) {
				segs = path.split(".");
				for (k = 0; k < segs.length; k++) {
					seg = segs[k] && segs[k].trim();
					if (seg) {
						i = seg.indexOf("[");
						j = seg.lastIndexOf("]");
						if (i > 0 && j > i) {
							s = seg.substring(0, i);
							arr = (s != "$") ? data[s] : data;
							if (_isArray(arr)) {
								s = seg.substring(i + 1, j);
								idx = parseInt(s);
								if (idx >= 0 && idx < arr.length) {
									data = arr[idx];
								} else {
									data = null;
								}
							} else {
								data = null;
							}
						} else if (seg != "$") {
							data = data[seg];
						}
						if (!data) {
							break;
						}
					}
				}
			} else {
				data = data[path];
			}
        }
        return (force || _isArray(data)) ? data : null;
    },
    extractXml: function (root, path) {
        var data = null;
        path = path && path.trim();
        if (path) {
            var segs = path.split(".");
            for (var k = 0; k < segs.length; k++) {
                var seg = segs[k] && segs[k].trim();
                if (seg) {
                    var i = seg.indexOf("[");
                    var j = seg.lastIndexOf("]");
                    if (i > 0 && j > i) {
                        var s = seg.substring(0, i);
                        var idx;
                        if (data) {
                            data = _getXmlList(data[0], s);
                        } else {
                            data = _getXmlList(root, s);
                        }
                        if (data) {
                            s = seg.substring(i + 1, j);
                            idx = parseInt(s);
                            data = data[idx];
                        }
                    } else {
                        if (data) {
                            data = _getXmlList(data[0], seg);
                        } else {
                            data = _getXmlList(root, seg);
                        }
                    }
                    if (!data) {
                        break;
                    }
                }
            }
        }
        return data;
    }
});
/** @internal */
var DataFillOptions = function (source) {
	this.fillMode = DataFillMode.SET;
	this.fillPos = 0;
	this.count = -1;
	this.rootArray = true;
	this.rows = "";
    this.childRows = "rows";
	this.start = 0;
	this.delimiter = ",";
	this.quoted = false;
    this.trim = false;
	this.parentId = 0;
	this.treeField = -1;
	this.useTreeField = false;
	this.needSorting = false;
	this.callback = null;
	if (source) {
		if (source.hasOwnProperty("append")) {
			this.fillMode = DataFillMode.APPEND;
		}
		if (source.hasOwnProperty("fillMode")) {
			this.fillMode = source.fillMode;
		}
		if (source.hasOwnProperty("fillPos")) {
			this.fillPos = source.fillPos;
		}
		if (source.hasOwnProperty("count")) {
			this.count = source.count;
		}
		if (source.hasOwnProperty("rootArray")) {
			this.rootArray = source.rootArray;
		}
		if (source.hasOwnProperty("rows")) {
			this.rows = source.rows;
		}
        if (source.hasOwnProperty("childRows")) {
            this.rows = source.childRows;
        }
		if (source.hasOwnProperty("start")) {
			this.start = source.start;
		}
		if (source.hasOwnProperty("delimiter")) {
			this.delimiter = source.delimiter;
		}
		if (source.hasOwnProperty("quoted")) {
			this.quoted = source.quoted;
		}
		for (var p in source) {
			if (source[p] !== undefined) {
				this[p] = source[p];
			}
		}
		this.parentId = source.parentId;
		this.treeField = source.treeField;
		this.useTreeField = source.useTreeField;
		this.needSorting = source.needSorting;
		this.callback = _asFunction(source.callback);
	}
};
var DataLoader = defineClass("DataLoader", null, {
	init: function (provider) {
		Base.init.call(this);
		this._provider = provider;
        this._filter = null;
	},
	load: function (type, data, options) {
		if (!(options instanceof DataFillOptions)) {
			options = new DataFillOptions(options);
		}
		if (this.$_checkEmpty(data, options)) {
			return 0;
		}
		this.$_prepareLoad(options);
		type = type && type.toLowerCase();
		try {
			switch (type) {
				case "json":
					return this.$_loadJson(data, options, this._filter);
				case "xml":
					return this.$_loadXml(data, options, this._filter);
				case "csv":
					return this.$_loadCsv(data, options, this._filter);
			}
		} finally {
			var callback = _asFunction(options.callback);
			callback && callback(this._provider);
		}
		return 0;
	},
	$_loadJson: function (data, options, filter) {
		if (typeof data === "string") {
			data = JSON.parse(data);
		}
		var rows = null;
		if (options.rows) {
            rows = DataPath.extractJson(data, options.rows);
        } else {
			rows = _asArray(data);
		}
		if (rows) {
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.appendRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, start, count);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, start, count, null, filter);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options);
			return 0;
		}
	},
	$_loadXml: function (data, options, filter) {
		if (typeof data === "string") {
			data = _parseXml(data);
		}
		if (data && data.documentElement) {
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			var rowProp = options.rows || "row";
			var rows = DataPath.extractXml(data.documentElement, rowProp);
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.appendXmlRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertXmlRows(fillPos, rows, start, count);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateXmlRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setXmlRows(rows, start, count, null, filter);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options);
			return 0;
		}
	},
	$_loadCsv: function (data, options, filter) {
		var fillPos = options.fillPos;
		var start = options.start;
		var count = options.count;
		var quoted = options.quoted;
        var trim = options.trim;
		var currency = options.currency;
		var delimiter = options.delimiter;
		var rows = DataHelper.csvToArray(this._provider, data, start, count, quoted, trim, delimiter, currency);
		if (rows && (count = rows.length) > 0) {
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.appendRows(rows, 0, count, false, filter);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, 0, count, false, filter);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, 0, count, false, false, false, false, filter);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, 0, count, null, filter);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options);
			return 0;
		}
	},
	$_fillEmpty: function (options) {
		if (options.fillMode === DataFillMode.SET) {
			this._provider.setRows(null);
		}
	},
	$_checkEmpty: function (data, options) {
		if (!data) {
			this.$_fillEmpty(options);
			return true;
		}
		return false;
	},
	$_prepareLoad: function (options) {
		if (options.filter) {
			this._filter = new DataFilter(options.filter);
		}
	}
});
var ITEM_EXT_CHECKED 	= 0x00000001;
var ITEM_EXT_SAVECHECK 	= 0x00000002;
var ITEM_UNCHECKABLE    = 0x00000004;
var ITEM_EXT_READONLY	= 0x00000008;
var ITEM_EXT_HEIGHTED	= 0x00000010;
var ITEM_EXT_HEIGHT		= 0xFFFF0000;
var $$_grid_item_id = 0;
var GridRow = defineClass("GridRow", null, {
    init: function () {
        this._super(true);
        this._id = $$_grid_item_id++;
        this._index = -1;
        this._parent = null;
		this._viewExts = {};
    },
    id: function () {
		return this._id;
    },
    index: function () {
		return this._index;
    },
    parent: function () {
		return this._parent;
    },
	parentIndex: function () {
		return this._parent ? this._parent._index : -1;
	},
	root: function () {
		var p = this;
		while (p = p._parent) {}
		return p;
	},
	childIndex: function () {
		return this._parent ? this._parent.indexOf(this) : -1;
    },
	level: function () {
		return this._parent ? this._parent.level() + 1 : 0;
    },
    leaf: function () {
		return true;
    },
	isLeaf: function () {
		return true;
	},
	visible: function () {
		return this._parent && this._index >= 0;
    },
    dataState: function () {
		var row = this.dataIndex();
		if (row >= 0) {
			var ds = this.dataSource();
			return ds ? ds.getRowState(row) : DataRowState.NONE;
		} else {
			return DataRowState.NONE;
		}
    },
    rowState: function () {
		return GridRowState.NORMAL;
    },
    next: function () {
		return this._parent && this._parent.getNext(this);
    },
    prev: function () {
		return this._parent && this._parent.getPrev(this);
    },
    displayLevel: function () {
		return this.level();
	},
	provider: function () {
		return this._parent ? this._parent.provider() : null;
	},
	dataSource: function () {
		return this._parent ? this._parent.dataSource() : null;
	},
	dataIndex: function () {
		return -1;
	},
	dataId: function () {
		return -1;
	},
	dataTag: function () {
		return undefined;
	},
    isEditing: function () {
        return false;
    },
    copyToObject: function (obj) {
    },
	getAncestor: function (level) {
		if (level < this.level()) {
			var p = this._parent;
			while (p.level() > level) {
				p = p._parent;
			}
			return p;
		}
		return null;
	},
	getAncestors: function () {
		var items = null,
			p = this._parent;
		if (p) {
			items = [];
			do {
				items.push(p);
				p = p._parent;
			} while (p);
		}
		return items;
	},
	isDescendantOf: function (group) {
		if (group) {
			var p = this._parent;
			while (p && p != group) {
				p = p._parent;
			}
			return p === group;
		}
		return false;
	},
	getSiblings: function (dataOnly) {
		var childs, items, i, cnt, child,
			p = this._parent;
		if (p) {
			childs = p._children;
			items = [];
			for (i = 0, cnt = childs.length; i < cnt; i++) {
				child = childs[i];
				if (child !== this && (!dataOnly || child.dataIndex() >= 0)) {
					items.push(child);
				}
			}
			return items;
		}
		return null;
	},
	getUncles: function (dataOnly) {
		return this._parent && this._parent.getSiblings(dataOnly);
	},
	getValue: function (field) {
		var ds = this.dataSource();
        if (ds) {
            var r = this.dataIndex();
            if (r >= 0) {
                return ds.getValue(this.dataIndex(), field);
            }
        }
        return undefined;
	},
	setValue: function (field, value) {
		var ds = this.dataSource();
        if (ds) {
            var r = this.dataIndex();
            if (r >= 0) {
                ds.setValue(this.dataIndex(), field, value);
            }
        }
	},
	getRowData: function () {
		var row = this.dataIndex();
		if (row >= 0) {
			var ds = this.dataSource();
			if (ds) {
				return ds.getRow(row);
			}
		}
		return null;
	},
	getRowObject: function () {
	},
    getRowProps: function (propNames) {
    },
    setRowProps: function (props, checkDiff, strictDiff, checkEmpty) {
    },
	canEdit: function () {
		return false;
	},
	makeVisible: function () {
		if (this._parent) {
			this._parent.makeVisible();
			this._parent.setExpanded(true);
		}
	},
	checkExpanded: function () {
	},
    merged: function () {
    	return false;
    },
    $_dataKey: function () {
        return this.dataIndex();
    },
	setIndex: function (value) {
		this._index = value;
	},
	$_isChecked: function (view) {
		return (this._viewExts[view.$_hash] & ITEM_EXT_CHECKED) != 0;
	},
	$_setChecked: function (view, checked) {
		var v = view.$_hash;
		var ext = this._viewExts[v];
		if (!ext) {
			if (checked) {
				this._viewExts[v] = ITEM_EXT_CHECKED;
				return true;
			}
		} else {
			var old = (ext & ITEM_EXT_CHECKED) != 0
			if (checked != old) {
				this._viewExts[v] = checked ? (ext | ITEM_EXT_CHECKED) : (ext & ~ITEM_EXT_CHECKED);
				return true;
			}
		}
		return false;
	},
	$_saveChecked: function (scope, view, id, exclusive) {
		var key;
		if (this.$_isChecked(view)) {
			key = view.$_hash + '_' + id;
			scope.set(key, true);
			if (exclusive) {
				key += '_ex';
				scope.set(key, true);
			}
		}
		if (!this.$_isCheckable(view)) {
			key = view.$_hash + '_c_' + id;
			scope.set(key, true);
		}
	},
	$_restoreChecked: function (scope, view, id, callback) {
		var key = view.$_hash + '_' + id;
		if (scope.get(key)) {
			scope.unset(key);
			key += '_ex';
			if (scope.get(key)) {
				scope.unset(key);
				callback.call(view);
			}
			this.$_setChecked(view, true);
		}
		key = view.$_hash + '_c_' + id;
		if (scope.get(key)) {
			scope.unset(key);
			this.$_setCheckable(view, false);
		}
	},
	$_isCheckable: function (view) {
		return (this._viewExts[view.$_hash] & ITEM_UNCHECKABLE) == 0;
	},
	$_setCheckable: function (view, checkable) {
		var ext = this._viewExts[view.$_hash];
		if (!ext) {
			if (!checkable) {
				this._viewExts[view.$_hash] = ITEM_UNCHECKABLE;
				return true;
			}
		} else {
			var old = (ext & ITEM_UNCHECKABLE) == 0;
			if (checkable != old) {
				this._viewExts[view.$_hash] = checkable ? (ext & ~ITEM_UNCHECKABLE) : (ext | ITEM_UNCHECKABLE);
				return true;
			}
		}
		return false;
	},
    $_height: function (view) {
        var h = this._viewExts[view.$_hash];
        if (h & ITEM_EXT_HEIGHTED) {
            return (h & ITEM_EXT_HEIGHT) >>> 16;
        }
        return NaN;
    },
    $_setHeight: function (view, value) {
        value = parseInt(value);
        if (isNaN(value)) {
            this._viewExts[view.$_hash] &= ~ITEM_EXT_HEIGHTED;
        } else {
            this._viewExts[view.$_hash] = (Math.min(0xffff, value) << 16) | ((this._viewExts[view.$_hash] & 0xffff) | ITEM_EXT_HEIGHTED);
        }
    },
	$_saveExpanded: function (scope, view, id) {
		var key;
		if (this.expanded()) {
			key = view.$_hash + '_exp_' + id;
			scope.set(key, true);
		}
	},
	$_restoreExpanded: function (scope, view, id) {
		var key = view.$_hash + '_' + id;
		if (scope.get(key)) {
			scope.unset(key);
			this.setExpanded(true);
		}
	},
	isEditable: function () {
		return false;
	},
	isReadOnly: function () {
		return (this._extents & EXT_READONLY) != 0;
	},
	setReadOnly: function (value) {
		this._extents = value ? (this._extents | EXT_READONLY) : (this._extents & ~EXT_READONLY);
	},
	isResizable: function () {
		return false;
	}
}, {
	$_ALL: {}
});
var DataRow = defineClass("DataRow", GridRow, {
	init: function (dataIndex) {
		this._super();
		this._dataIndex = dataIndex;
		this._displayLevel = -1;
	},
    $_dataKey: function () {
        return this._dataIndex;
    },
	dataIndex: function () {
		return this._dataIndex;
	},
	dataId: function () {
		return this.dataSource().getRowId(this._dataIndex);
	},
	dataTag: function () {
		return this.dataSource().getRowTag(this._dataIndex);
	},
	isEditable: function () {
		return true;
	},
	isResizable: function () {
		return true;
	},
	displayLevel: function () {
		return this._displayLevel >= 0 ? this._displayLevel : this.level();
	},
	canEdit: function () {
		return true;
	},
	getValue: function (field) {
		return this.dataSource().getValue(this._dataIndex, field);
	},
	setValue: function (field, value) {
		this.dataSource().setValue(this._dataIndex, field, value);
	},
    getRowObject: function () {
        var ds = this.dataSource();
		return ds ? ds._getRowObject(this._dataIndex) : null;
    },
    getRowProps: function (props) {
        var ds = this.dataSource();
		return ds ? ds._getRowProps(this._dataIndex, props) : null;
    },
    setRowProps: function (props, checkDiff, strictDiff, checkEmpty) {
        var ds = this.dataSource();
		ds && ds.updateRow(this._dataIndex, props, checkDiff, strictDiff, checkEmpty);
    },
    copyToObject: function (obj) {
        var ds = this.dataSource();
        ds && ds.copyToObject(this._dataIndex, obj);
    }
});
var GroupRow = defineClass("GroupRow", GridRow, {
	init: function () {
		this._super();
		this._children = [];
		this._descendantCount = 0;
        this._descendantRowCount = 0;
		this._summaries = undefined;
        this._summarized = undefined;
		this._rows = null;
	},
	expanded: false,
	collapsed: true,
	count: function () {
		return this._children.length;
	},
	children: function () {
		return this._children.slice();
	},
	setExpanded: function (value) {
		if (value != this._expanded) {
			if (value) {
				this.provider().expand(this, false, false);
			} else {
				this.provider().collapse(this, false);
			}
		}
	},
	collapsed_: function () {
		return !this.expanded();
	},
	setCollapsed: function (value) {
		this.setExpanded(!value);
	},
	footer: function () {
		return null;
	},
	first: function () {
		return this._children.length > 0 ? this._children[0] : null;
	},
	last: function () {
		var len = this._children.length;
		return len > 0 ? this._children[len - 1] : null;
	},
	firstLeaf: function () {
		if (this._children.length > 0) {
			var item = this._children[0];
			return (item instanceof GroupRow) ? item.firstLeaf() : item;
		}
		return null;
	},
	lastLeaf: function () {
        var len = this._children.length;
		if (len > 0) {
			var item = this._children[len - 1];
			return (item instanceof GroupRow) ? item.lastLeaf() : item;
		}
		return null;
	},
	/** @dprecated use descendantDataCount instead. */
	descendantCount: function () {
		return this._descendantCount;
	},
	descendantDataCount: function () {
		return this._descendantCount;
	},
    descendantRowCount: function () {
        return this._descendantRowCount;
    },
    firstVisibleItem: function () {
        for (var i = 0, len = this._children.length; i < len; i++) {
            var item = this._children[i];
            if (item.visible()) {
                return item;
            }
        }
        return null;
    },
	expandable: function () {
		return true;
	},
	collapsable: function () {
		return true;
	},
	visitAll: function (callback) {
		if (callback) {
			var i, cnt, child,
				children = this._children;
			if (children && (cnt = children.length) > 0) {
				for (i = 0; i < cnt; i++) {
					child = children[i];
					if (callback(child, cnt, i) === false) {
                        return false;
                    }
                    if (child instanceof GroupRow) {
                        if (child.visitAll(callback) === false) {
							return false;
						}
                    }
				}
			}
		}
	},
	visit: function (callback, level) {
		level = level === undefined ? 0 : level;
		if (callback && level >= 0) {
			var i, cnt, child,
				children = this._children;
			if (children && (cnt = children.length) > 0) {
				for (i = 0; i < cnt; i++) {
					child = children[i];
					if (callback(child, cnt, i) === false) {
                        return false;
                    }
					if (level > 0 && child instanceof GroupRow) {
						if (child.visit(callback, level - 1) === false) {
							return false;
						}
					}
				}
			}
		}
	},
    visitRows: function (visibleOnly, dataOnly, callback) {
        if (callback) {
            var i, cnt, child,
				children = this._children;
            if (children && (cnt = children.length) > 0) {
                for (i = 0; i < cnt; i++) {
                    child = children[i];
                    if (!visibleOnly || child.visible()) {
                        if ((!dataOnly || child.dataIndex() >= 0) && (callback(child, cnt, i) === false)) {
                            return false;
                        }
                        if (child instanceof GroupRow) {
                            if (child.visitRows(visibleOnly, dataOnly, callback) === false) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
    },
	collectDataRows: function (rows, list) {
		list = list || [];
		this.visitRows(false, true, function (child) {
            list.push(child);
		});
		return list;
	},
    /** @deprecated */
	getItem: function (index) {
		if (index < 0 || index >= this._children.length)
			throw new RangeError("index is invalid: " + index);
		return this._children[index];
	},
    getChild: function (index) {
        if (index < 0 || index >= this._children.length)
            throw new RangeError("index is invalid: " + index);
        return this._children[index];
    },
	getNext: function (child) {
		for (var i = 0, cnt = this._children.length; i < cnt - 1; i++) {
			if (this._children[i] === child) {
				return this._children[i + 1];
			}
		}
        return null;
	},
	getPrev: function (child) {
		for (var i = this._children.length - 1; i > 0; i--) {
			if (this._children[i] === child) {
				return this._children[i - 1];
			}
		}
        return null;
	},
	itemOfRow: function (dataIndex) {
		for (var i = this._children.length; i--;) {
			if (this._children[i].dataIndex() == dataIndex) {
				return this._children[i];
			}
		}
		return null;
	},
	indexOf: function (item) {
		for (var i = 0, cnt = this._children.length; i < cnt; i++) {
			if (this._children[i] == item) {
				return i;
			}
		}
		return -1;
	},
	isDescendant: function (item) {
		if (item && item !== this) {
			var g = item._parent;
			while (g && g != this) {
				g = g._parent;
			}
			return g === this;
		}
		return false;
	},
	$_getDescendants: function (visibleOnly, dataOnly, leafOnly, filter) {
		function collectItems(p/*GroupRow*/, items/*[GridRow]*/) {
            var i, cnt, item, item2;
			for (i = 0, cnt = p.count(); i < cnt; i++) {
				item = p.getItem(i);
				if ((!leafOnly || item.leaf()) && (!dataOnly || item.dataIndex() >= 0)) {
					if (filter) {
						item2 = filter(item);
						item2 && items.push(item2);
					} else {
						items.push(item);
					}
				}
                if (item instanceof GroupRow && (!visibleOnly || item.expanded())) {
                    collectItems(item, items);
                }
			}
		}
		if ((!visibleOnly || this._expanded) && this._children && this._children.length > 0) {
			var items = [];
			collectItems(this, items);
			return items;
		}
		return null;
	},
	getDescendants: function (visibleOnly, dataOnly, filter) {
		return this.$_getDescendants(visibleOnly, dataOnly, false, filter);
	},
	getLeaves: function (visibleOnly, dataOnly, filter) {
		return this.$_getDescendants(visibleOnly, dataOnly, true, filter);
	},
	clear: function () {
		this._summaries = undefined;
        this._summarized = undefined;
		this._children.splice(0, this._children.length);
        this._descendantCount = this._descendantRowCount = 0;
	},
	insert: function (index, item, counts) {
		this._addChild(item, index, counts);
	},
	add: function (item, counts) {
		this._addChild(item, -1, counts);
	},
	addAll: function (items, counts) {
		this._addChildren(items, counts);
	},
	remove: function (item, counts) {
		this._removeChild(item, counts);
	},
	setItem: function (item, newItem) {
		if (item && newItem && item != newItem) {
			var idx = this._removeChild(item);
			this._insertChild(idx, newItem);
			if (newItem instanceof GridRow) {
				newItem._index = item.index();
			}
		}
	},
	getNumber: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.count;
		} else if (summary) {
			return summary.length;
		}
		return this._descendantCount;
	},
	getSum: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.sum;
		} else if (summary) {
			var v2, i,
				ds = this.dataSource(),
				cnt = summary.length,
				v = 0;
			for (i = 0; i < cnt; i++) {
				v2 = ds.getValue(summary[i], field);
				if (!isNaN(v2)) {
					v += v2;
				}
			}
			return v;
		}
		return NaN;
	},
	getMax: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.max;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v, v2, i;
			if (cnt > 1) {
				v = NaN;
				i = 0;
				do {
					v = ds.getValue(summary[i++], field);
				} while (isNaN(v) && i < cnt);
				while (i < cnt) {
					v2 = ds.getValue(summary[i++], field);
					if (!isNaN(v2) && v2 > v) {
						v = v2;
					}
				}
				return v;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v;
			}
		}
		return NaN;
	},
	getMin: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.min;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v, v2, i;
			if (cnt > 1) {
				v = NaN;
				i = 0;
				do {
					v = ds.getValue(summary[i++], field);
				} while (isNaN(v) && i < cnt);
				while (i < cnt) {
					v2 = ds.getValue(summary[i++], field);
					if (!isNaN(v2) && v2 < v) {
						v = v2;
					}
				}
				return v;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v;
			}
		}
		return NaN;
	},
	getAvg: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.avg;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v, i;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				return v / cnt;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v;
			}
		}
		return NaN;
	},
	getVar: function (field, n) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return n = 0 ? summary.varsp : summary.vars;
		} else if (summary && this.summaryMode() == SummaryMode.STATISTICAL) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v, i, avg;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				avg = v / cnt;
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += Math.pow(ds.getValue(summary[i], field) - avg, 2);
				}
				v = v / (cnt - n);
				return v;
			} else if (cnt == 1) {
				return 0;
			}
		}
		return NaN;
	},
	getStdev: function (field, n) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return n == 0 ? Math.sqrt(summary.varsp) : Math.sqrt(summary.vars);
		} else if (summary && this.summaryMode() == SummaryMode.STATISTICAL) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v, i, avg;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				avg = v / cnt;
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += Math.pow(ds.getValue(summary[i], field) - avg, 2);
				}
				v = Math.sqrt(v / (cnt - n));
				return v;
			} else if (cnt == 1) {
				return 0;
			}
		}
		return NaN;
	},
    getSummarized: function (scope) {
        return this._summarized && this._summarized[scope];
    },
    setSummarized: function (scope, value) {
		this._summarized = this._summarized || {};
        return this._summarized[scope] = value;
    },
	leaf: function () {
		return false;
	},
	summaryMode: function () {
		return this.provider().summaryMode();
	},
	_setExpanded: function (value) {
		this._expanded = value;
	},
	_insertChild: function (index, item, counts) {
		this._children.splice(index, 0, item);
		if (item instanceof GridRow) {
			item._parent = this;
		}
        if (counts) {
            this._descendantCount++;
            this._descendantRowCount++;
        }
	},
	_addChild: function (item, index, counts) {
		if (item && this.indexOf(item) < 0) {
			if (index < 0) {
				this._children.push(item);
			} else {
				this._children.splice(index, 0, item);
			}
			item._parent = this;
            if (counts) {
                this._descendantCount++;
                this._descendantRowCount++;
            }
		}
	},
	_addChildren: function (items, counts) {
		var cnt;
		if (items && (cnt = items.length) > 0) {
			var i, item, n = 0;
			for (i = 0; i < cnt; i++) {
				item = items[i];
				if (item && this.indexOf(item) < 0) {
					item._parent = this;
					this._children.push(item);
                    n++;
				}
			}
            if (counts) {
                this._descendantCount += n;
                this._descendantRowCount += n;
            }
		}
	},
	_removeChild: function (item, counts) {
		var idx = this.indexOf(item);
		if (idx >= 0) {
			this._children.splice(idx, 1);
			if (item instanceof GridRow) {
				item._parent = null;
			}
            if (counts) {
                this._descendantCount--;
                this._descendantRowCount--;
            }
		}
		return idx;
	},
	attachItem: function (item) {
		if (item) {
			item._parent = this;
		}
	},
	detachItem: function (item) {
		if (item && item_parent == this) {
			item._parent = null;
		}
	},
	_exchangeItems: function (index1, index2) {
		var t, items = this._children;
		if (index1 < 0 || index1 >= items.length)
			throw new RangeError("index1 is out of range: " + index1);
		if (index2 < 0 || index2 >= items.length)
			throw new RangeError("index2 is out of range: " + index2);
		if (index1 === index2)
			return;
		t = items[index1];
		items[index1] = items[index2];
		items[index2] = t;
	},
	_collectSummaryRows: function (group, rows) {
		var i, cnt, item, row;
        for (i = 0, cnt = group.count(); i < cnt; i++) {
            item = group.getItem(i);
			if (item instanceof GroupRow) {
				this._collectSummaryRows(item, rows);
			} else {
				row = item.dataIndex();
				if (row >= 0) {
					rows.push(row);
				}
			}
		}
	},
	_clearSummary: function () {
		var i, cnt, item;
		this._summaries = undefined;
		this._summarized = undefined;
		for (i = this._children.length; i--;) {
			item = this._children[i];
			if (item instanceof GroupRow) {
				item._clearSummary();
			}
		}
	},
	$_getSummary: function (field) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		if (!this._summaries) {
			this._summaries = {};
			this._rows = null;
		}
		var fs = this._summaries[field];
		if (!fs) {
			if (ds.canSummarize(field)) {
				fs = this.$_summarize(field, ds);
				if (fs) {
					this._summaries[field] = fs;
				}
			}
		}
		return fs;
	},
	$_summarize: function (field, ds) {
		var THRESHOLD = 3;
		var mode = this.summaryMode();
		if (mode != SummaryMode.NONE) {
			if (!this._rows) {
				this._rows = [];
				this._collectSummaryRows(this, this._rows);
			}
			if (this._rows.length > THRESHOLD && ds.canSummarize(field)) {
				var fs = new FieldSummary(field);
				ds.aggregateRange(fs, this._rows, mode == SummaryMode.STATISTICAL);
				return fs;
			} else {
				return this._rows;
			}
		}
		return null;
	}
});
var GroupFooter = defineClass("GroupFooter", GridRow, {
    init: function() {
        this._super();
    },
    expandable: false,
    displayLevel: function() {
        return this._expandable ? this.level() - 1 : this.level();
    }
});
/** @internal */
var RootRow = defineClass("RootRow", GroupRow, {
	init: function(provider) {
		this._super(-1);
		this._provider = provider;
	},
	provider: function () { return this._provider; },
	level: function() { return 0; },
    expanded: function () { return true; },
	isExpanded: function () { return true; },
    setExpanded: function () {},
    leaf: function () { return false; },
	isLeaf: function () { return false; },
    visible: function () { return true; },
	dataSource: function () { return this._provider.dataSource(); },
    expandable: function () { return false; },
	isExpandable: function () { return false; },
    collapsable: function () { return false; },
	isCollapsable: function () { return false; },
    makeVisible: function () {}
});
/** @abstract */
var CustomGroupItem = defineClass("CustomGroupItem", null, {
	init: function (owner, config) {
		this._super();
		this._owner = owner;
		this._styles = new GridStyles(this, "customGroupItem", null, false);
		config && this.assign(config);
		this._styles.setBorderRight(new SolidPen(0xffa0a0a0));
		this._styles.setBorderBottom(new SolidPen(0xffa0a0a0));
	},
	displayLevels: null,    // * or []
	displayCallback: null,  // function (groupRow):Boolean
	styles: null,
	minHeight: 10,
	maxHeight: 0,
	height: 0,
    setDisplayLevels: function (value) {
        var all = typeof value === "string" && value.trim() === "*";
        var levels = all ? null : _asArray(value);
        if (all != this._allLevels || levels != this._displayLevels) {
            if (all) {
                this._allLevels = true;
                this._displayLevels = null;
            } else {
                this._allLevels = false;
                this._displayLevels = levels;
            }
            this._changed();
        }
    },
    setDisplayCallback: function (value) {
        value = _asFunction(value);
        if (value != this._displayCallback) {
            this._displayCallback = value;
            this._changed();
        }
    },
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles.extend(value);
			this._changed();
		}
	},
	itemType: function () {
		return this._owner._itemType;
	},
	isHeader: function () {
		return this._owner._itemType == CustomGroupItemType.HEADER;
	},
    displayText: function () {
        return this.className();
    },
	canCreate: function (group) {
		var callback = this._displayCallback;
		if (callback) {
			return callback(group);
		}
        if (this._allLevels) {
            return true;
        }
        return !this._displayLevels || this._displayLevels.indexOf(group.level()) >= 0;
	},
	/** @abstract */
    createRow: function () {
        return null;
    },
	/** @abstract */
    createRowView: function (dom) {
        return null;
    },
	propertyChanged: function () {
		this._changed();
	},
	proxy: function () {
		var p = this._super();
		p.type = this.$_type();
		return p;
	},
	_changed: function () {
		this._owner && this._owner._itemChanged(this);
	}
});
var CustomGroupItemCollection = defineClass("CustomGroupItemCollection", null, {
	init: function (owner, itemType) {
		this._super();
		this._owner = owner;
		this._itemType = itemType || CustomGroupItemType.FOOTER;
		this._items = [];
		this._itemTypes = {};
	},
	count: function () {
		return this._items.length;
	},
	registerType: function (type, clazz/* CustomGroupItem class */) {
		if (type && _isFunction(clazz)) {
			this._itemTypes[type] = clazz;
			return clazz;
		}
		return null;
	},
	getItem: function (index) {
		return this._items[index];
	},
	getRows: function (group, list) {
        var items, cnt, i, item;
		if (group instanceof GroupRow) {
			items = this._items;
			cnt = items.length;
			if (cnt > 0) {
				list = list || [];
				for (i = 0; i < cnt; i++) {
					item = items[i];
					if (item.canCreate(group)) {
						list.push(item.createRow(item));
					}
				}
				return list;
			}
		}
		return null;
	},
	assign: function (source) {
		if (source === this) return;
		var i, item;
		this._items = [];
		this._itemMap = {};
		if (_isArray(source)) {
			for (i = 0; i < source.length; i++) {
				item = this._createItem(source[i]);
				item && this._items.push(item);
			}
		} else if (source) {
			item = this._createItem(source);
			item && this._items.push(item);
		}
	},
	_createItem: function (source) {
		var clazz = this._itemTypes[source.type];
        return clazz ?  new clazz(this, source) : null;
	},
	_itemChanged: function (item) {
		this._owner.customGroupItemChanged(item);
	}
});
/** @absract */
var CustomGroupItemRow = defineClass("CustomGroupItemRow", GridRow, {
	init: function(model/*CustomGroupItem*/) {
		this._super();
		this._model = model;
	},
	expandable: false,
	model: function () { return this._model; },
    displayText: function () { return this._model ? this._model.displayText() : this.className(); },
	displayLevel: function() {
		return this._expandable ? this.level() - 1 : this.level();
	}
});
/** @abstract */
var RowProvider = defineClass("RowProvider", EventAware, {
	init: function (indexing) {
		this._super();
		this._rowFilterRuntime = new RowFilterRuntime();
		this._rowFilter = new RowFilter(this);
		this._indexing = indexing;
		this._rootRow = this._createRootRow();
		this._eventLock = 0;
	},
	rowFilterChanged: function (filter) {
		if (!this._rowFilterSetting) {
			this.refreshItems();
		}
	},
	alwaysSorting: true,
	hideDeleted: false,
    rowFilter: null,
	setRowFilter: function (value) {
		if (value !== this._rowFilter) {
			this._rowFilterSetting = true;
			try {
				this._rowFilter.assign(value);
			} finally {
				this._rowFilterSetting = false;
				this._doApplyRowFilter();
			}
		}
	},
	dataSource: function () {
		_throwAbstractError();
	},
	rowCount: function () {
		_throwAbstractError();
	},
    fixedCount: function () {
        _throwAbstractError();
    },
    getView: function (viewId) {
        return this.findListener(function (view) {
            return view.viewId() === viewId;
        });
    },
	getItem: function (index) {
		_throwAbstractError();
	},
	getItems: function (index, count) {
		_throwAbstractError();
	},
	attachItem: function (item) {
		if (item) {
			item._parent = this._rootRow;
		}
	},
	refreshItems: function () {
		_throwAbstractError();
	},
	getItemsByIndices: function (indices) {
		var items = [];
		if (indices) {
			for (var i = 0, cnt = indices.length; i < cnt; i++) {
				var item = this.getItem(indices[i]);
				item && items.push(item);
			}
		}
		return items;
	},
	getIndexOfRow: function (dataRow) {
		var item = this.getItemOfRow(dataRow);
		return item ? item.index() : -1;
	},
	getIndicesOfRows: function (dataRows) {
		var items = [];
		var cnt = dataRows ? dataRows.length : 0;
		if (cnt) {
			for (var i = 0; i < cnt; i++) {
				var item = this.getItemOfRow(dataRows[i]);
				items.push(item ? item.index() : -1);
			}
		}
		return items;
	},
	getItemOfRow: function (dataRow) {
		_throwAbstractError();
	},
	getItemsOfRows: function (dataRows, all) {
		var i, item;
		var items = [];
		var cnt = dataRows ? dataRows.length : 0;
		for (i = 0; i < cnt; i++) {
			item = this.getItemOfRow(dataRows[i], all);
			if (item) {
				items.push(item);
			}
		}
		return items;
	},
	exchange: function (index1, index2) {
		_throwAbstractError();
	},
    visitAll: function (callback, visibleOnly) {
        for (var i = 0, cnt = this.rowCount(); i < cnt; i++) {
            if (callback(this.getItem(i)) === false) {
				return false;
			}
        }
    },
	_clearDisplayLevels: function () {
	},
	hasCellStyle: function () {
		return false;
	},
	setCellStyle: function (row, field, style) {
	},
	setCellStyles: function (provider, rows, fieldMap) {
	},
	clearCellStyles: function () {
	},
	removeCellStyle: function (style) {
	},
	getCellStyle: function (dataRow, field) {
		return null;
	},
	canUpdateField: function (item, field) {
		if (item) {
            var ds = this.dataSource();
            if (ds) {
                var row = item.dataIndex();
                var inserting = GridRowState.isInserting(item.rowState());
                return (row >= 0 || inserting) && (inserting || ds.canUpdateRow(row)) && ds.canUpdateValue(row, field);
            }
		}
		return false;
	},
    canUpdate: function (item) {
        if (item) {
            var ds = this.dataSource();
            if (ds) {
                var row = item.dataIndex();
                var inserting = GridRowState.isInserting(item.rowState());
                return (row >= 0 || inserting) && (inserting || ds.canUpdateRow(row));
            }
        }
        return false;
    },
	canAppend: function () {
		var ds = this.dataSource();
		return ds && ds.canAppendRow();
	},
	canInsert: function (row) {
		if (row) {
            var ds = this.dataSource();
            if (ds) {
                var r = row.dataIndex();
                return (r >= 0) && ds.canInsertRow(r);
            }
		}
		return false;
	},
	canDelete: function (row) {
		if (row) {
            var ds = this.dataSource();
            if (ds) {
                var r = row.dataIndex();
                return (r >= 0) && ds.canDeleteRow(r);
            }
		}
		return false;
	},
	getAllItems: function () {
		_throwAbstractError();
	},
	getDistinctValues: function (field, maxCount) {
		var fld, comp, f, rows, items, len, i, r1, r2,
			ds = this._dataSource;
		if (ds) {
			fld = ds.getField(f = ds.getFieldIndexEx(field));
			if (fld) {
                comp = ds.getComparer(f).bind(ds);
				rows = this._doGetDistinctValues(f, fld.dataType());
				len = rows.length;
				maxCount = maxCount > 0 ? Math.min(maxCount, rows.length) : len;
				i = 0;
				items = [r1 = rows[i++]];
				while (items.length < maxCount && i < len) {
					r2 = rows[i++];
                    if (comp(f, r1.$_dataKey(), r2.$_dataKey()) < 0) {
                        items.push(r2);
                    }
					r1 = r2;
				}
                for (i = items.length; i--;) {
                    items[i] = ds.getValue(items[i].dataIndex(), f);
                }
				return items;
			}
		}
		return [];
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		_throwAbstractError();
	},
    getNumber: function () {
        return 0;
    },
	getSum: function (field) {
		return NaN;
	},
	getMax: function (field) {
		return NaN;
	},
	getMin: function (field) {
		return NaN;
	},
	getAvg: function (field) {
		return NaN;
	},
	getVar: function (field) {
		return NaN;
	},
    getVarp: function (field) {
        return NaN;
    },
	getStdev: function (field) {
		return NaN;
	},
    getStdevp: function (field) {
        return NaN;
    },
	isIndexing: function () {
		return this._indexing;
	},
	isController: function () {
		return false;
	},
	_createRootRow: function () {
		return new RootRow(this);
	},
	_resetItemIndices: function (fromIndex) {
		if (this._indexing) {
			for (var i = fromIndex, cnt = this.rowCount(); i < cnt; i++) {
				this.getItem(i)._index = i;
			}
		}
	},
	_setExpanded: function (group, value) {
		group._setExpanded(value);
	},
	_resetItemIndex: function (index) {
		var item = this.getItem(index);
		if (item) {
			item._index = index;
		}
	},
	_incDescendants: function (group, count, rowCount) {
		var p = group.parent();
        group._descendantCount += count;
        group._descendantRowCount += count + rowCount;
		p && this._incDescendants(p, count, rowCount);
	},
	_copyExtents: function (source, target) {
		if (source instanceof GridRow && target instanceof GridRow && source != target) {
            for (var p in source._viewExts) {
                target._viewExts[p] = source._viewExts[p];
            }
		}
	},
	_doApplyRowFilter: function () {
	},
	_fireReset: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.RESET);
		}
	},
	_fireRefresh: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.REFRESH);
		}
	},
	_fireIndicesPolluted: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.INDICES_POLLUTED);
		}
	},
	_fireSummaryCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.SUMMARY_CLEARED);
		}
	},
	_fireUndoStateChanged: function (canUndo, canRedo) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.UNDO_STATE_CHANGED, canUndo, canRedo);
		}
	},
	_fireCountChanged: function (oldCount, newCount) {
		newCount = arguments.length > 1 ? newCount : this.rowCount();
		if (this._eventLock <= 0 && oldCount != newCount) {
			this.fireEvent(RowProvider.COUNT_CHANGED, oldCount, newCount);
		}
	},
	_fireDataCountChanged: function (oldCount, newCount) {
		if (this._eventLock <= 0 && oldCount != newCount) {
			this.fireEvent(RowProvider.DATA_COUNT_CHANGED, oldCount, newCount);
		}
	},
	_fireRowCountChanged: function (oldCount, newCount) {
		if (this._eventLock <= 0 && oldCount != newCount) {
			this.fireEvent(RowProvider.ROW_COUNT_CHANGED, oldCount, newCount);
		}
	},
	_fireDataCalculated: function (rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.DATA_CALCULATED, rows);
		}
	},
	_fireItemInserted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEM_INSERTED, item);
		}
	},
	_fireItemDeleted: function (item, rowId) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEM_DELETED, item, rowId);
		}
	},
	_fireItemUpdated: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEM_UPDATED, item);
		}
	},
	_fireCheckableChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.CHECKABLE_CHANGED, item);
		}
	},
	_fireItemChecked: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEM_CHECKED, item);
		}
	},
	_fireItemsChecked: function (items, checked) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEMS_CHECKED, items, checked);
		}
	},
	_fireItemAllChecked: function (checked) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ITEM_ALL_CHECKED, checked);
		}
	},
	_fireRowStateChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ROW_STATE_CHANGED, item);
		}
	},
	_fireRowStatesChanged: function (items) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ROW_STATES_CHANGED, items);
		}
	},
	_fireRowStatesCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.ROW_STATES_CLEARED);
		}
	},
    _fireRowTagChanged: function (item) {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.ROW_TAG_CHANGED, item);
        }
    },
    _fireRowTagsChanged: function (items) {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.ROW_TAGS_CHANGED, items);
        }
    },
    _fireRowTagsCleared: function () {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.ROW_TAGS_CLEARED);
        }
    },
	_fireSorting: function (fields, directions, cases) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(RowProvider.SORTING, fields, directions, cases);
		}
        return true;
	},
	_fireSorted: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.SORTED);
		}
	},
    _fireFiltering: function () {
        if (this._eventLock <= 0) {
            return this.fireConfirmEvent(RowProvider.FILTERING);
        }
        return true;
    },
	_fireFilterAdded: function (field, expression) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.FILTER_ADDED, field, expression);
		}
	},
	_fireFilterRemoved: function (field, filter) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.FILTER_REMOVED, field, filter);
		}
	},
	_fireFilterCleared: function (field) {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.FILTER_CLEARED, field);
		}
	},
	_fireFilterAllCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(RowProvider.FILTER_ALL_CLEARED);
		}
	},
	_fireFiltered: function () {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.FILTERED);
        }
    },
    _firePaged: function (paged) {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.PAGED, paged);
        }
    },
    _firePageCountChanged: function (oldCount, newCount) {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.PAGE_COUNT_CHANGED, oldCount, newCount);
        }
    },
    _firePageIndexChanging: function (oldPage, newPage) {
        if (this._eventLock <= 0) {
            return this.fireConfirmEvent(RowProvider.PAGE_INDEX_CHANGING, oldPage, newPage);
        }
        return true;
    },
    _firePageIndexChanged: function (oldPage, newPage) {
        if (this._eventLock <= 0) {
            this.fireEvent(RowProvider.PAGE_INDEX_CHANGED, oldPage, newPage);
        }
    }
});
RowProvider.RESET = "onRowProviderReset";
RowProvider.REFRESH = "onRowProviderRefresh";
RowProvider.INDICES_POLLUTED = "onRowProviderIndicesPolluted";
RowProvider.SUMMARY_CLEARED = "onRowProviderSummaryCleared";
RowProvider.UNDO_STATE_CHANGED = "onRowProviderUndoStateChanged";
RowProvider.COUNT_CHANGED = "onRowProviderCountChanged";
RowProvider.DATA_COUNT_CHANGED = "onRowProviderDataCountChanged";
RowProvider.ROW_COUNT_CHANGED = "onRowProviderRowCountChanged";
RowProvider.DATA_CALCULATED = "onRowProviderDataCalculated";
RowProvider.ITEM_INSERTED = "onRowProviderItemInserted";
RowProvider.ITEM_DELETED = "onRowProviderItemDeleted";
RowProvider.ITEM_UPDATED = "onRowProviderItemUpdated";
RowProvider.CHECKABLE_CHANGED = "onRowProviderCheckableChanged";
RowProvider.ITEM_CHECKED = "onRowProviderItemChecked";
RowProvider.ITEMS_CHECKED = "onRowProviderItemsChecked";
RowProvider.ITEM_ALL_CHECKED = "onRowProviderItemAllChecked";
RowProvider.ROW_STATE_CHANGED = "onRowProviderRowStateChanged";
RowProvider.ROW_STATES_CHANGED = "onRowProviderRowStatesChanged";
RowProvider.ROW_STATES_CLEARED = "onRowProviderRowStatesCleared";
RowProvider.ROW_TAG_CHANGED = "onRowProviderRowTagChanged";
RowProvider.ROW_TAGS_CHANGED = "onRowProviderRowTagsChanged";
RowProvider.ROW_TAGS_CLEARED = "onRowProviderRowTagsCleared";
RowProvider.SORTING = "onRowProviderSorting";
RowProvider.SORTED = "onRowProviderSorted";
RowProvider.FILTER_ADDED = "onRowProviderFilterAdded";
RowProvider.FILTER_REMOVED = "onRowProviderFilterRemoved";
RowProvider.FILTER_CLEARED = "onRowProviderFilterCleared";
RowProvider.FILTER_ALL_CLEARED = "onRowProviderFilterAllCleared";
RowProvider.FILTERING = "onRowProviderFiltering";
RowProvider.FILTERED = "onRowProviderFiltered";
RowProvider.PAGED = "onRowProviderPaged";
RowProvider.PAGE_COUNT_CHANGED = "onRowProviderPageCountChanged";
RowProvider.PAGE_INDEX_CHANGING = "onRowProviderPageIndexChanging";
RowProvider.PAGE_INDEX_CHANGED = "onRowProviderPageIndexChanged";
var $$_compareTextValue = function (v1, v2, caseSensitive, partialMatch) {
	if (v1 instanceof RegExp) {
		return v1.test(v2);
	}
	if (v1 === v2) {
		return true;
	}
	var s1 = v1 === undefined || v1 === null ? '' : String(v1);
	var s2 = v1 === undefined || v1 === null ? '' : String(v2);
	if (!s1) {
		if (!s2) return true;
		return false;
	}
	if (!s2) return false;
	if (!caseSensitive) {
		s1 = s1.toLowerCase();
		s2 = s2.toLowerCase();
	}
	return partialMatch ? s2.indexOf(s1) >= 0 : s1 == s2;
};
var FilteredRowProvider = defineClass("FilteredRowProvider", RowProvider, {
    init: function (indexing) {
        this._super(indexing);
        this._explicitFilter = false;
        this._filtered = false;
        this._filters = [];
        this._filterRuntime = new ColumnFilterRuntime();
        this._filterLock = 0;
        this._fixedFiltering = false;
        this._sortingDirty = true;
        this._explicitSort = false;
        this._sorted = false;
        this._sortFields = [];
        this._sortDirections = [];
        this._sortCases = [];
		this._editing = false;
    },
    hideDeleted: false,
    sortMode: EnumProp(SortMode, SortMode.AUTO),
    filterMode: EnumProp(FilterMode, FilterMode.AUTO),
	dataStateFiltering: true,
    dataTagFiltering: false,
	sortFirst: false,
    setHideDeleted: function (value) {
        if (value != this._hideDeleted) {
            this._hideDeleted = value;
            this._hideDeletedChanged();
        }
    },
    isFiltered: function () {
        return this._filtered;
    },
    isSorted: function () {
        return this._sorted;
    },
	getSortFieldCount: function () {
		return this._sortFields.length;
	},
	getSortFields: function () {
		return this._sortFields.slice();
	},
	getSortDirections: function () {
		return this._sortDirections.slice();
	},
	getSortCases: function () {
		return this._sortCases.concat();
	},
	setDataStateFiltering: function (value) {
		if (value != this._dataStateFiltering) {
			this._dataStateFiltering = value;
			this._doApplyFilters(true, true);
		}
	},
	setDataTagFiltering: function (value) {
		if (value != this._dataTagFiltering) {
			this._dataTagFiltering = value;
			this._doApplyFilters(true, true);
		}
	},
	setSortFirst: function (value) {
		if (value != this._sortFirst) {
			this._sortFirst = value;
			this._doApplyFilters(true, true);
		}
	},
	beginFilter: function () {
		this._filterLock++;
	},
	endFilter: function (apply) {
		apply = arguments.length > 0 ? apply : true;
		if (this._filterLock > 0) {
			this._filterLock--;
			if (this._filterLock == 0 && apply) {
				this.applyFilters();
			}
		}
	},
	hasFilter: function (field) {
		var filters = this._filters[field];
		return filters && filters.length > 0;
	},
	addFilter: function (field, filter) {
		if (field >= 0 && !this._editing) {
			this._fireFilterAdded(field, filter);
			var filters = this._filters[field];
			if (!filters) {
				filters = [];
				this._filters[field] = filters;
			}
			var f = typeof filter === 'string' ? new ColumnFilterRun(filter) : filter;
			filters.push(f);
			this.applyFilters();
			return f;
		}
	},
	removeFilter: function (field, filter) {
		if (this._filtered && this._filters[field]) {
			this._fireFilterRemoved(field, filter);
			var filters = this._filters[field];
			var i = filters.indexOf(filter);
			if (i >= 0) {
				filters.splice(i, 1);
				this.applyFilters();
			}
		}
	},
	clearFilters: function (field) {
		if (this._filtered && this._filters[field]) {
			this._fireFilterCleared(field);
			var filters = this._filters[field];
			if (filters && filters.length > 0) {
				filters.length = 0;
				delete this._filters[field];
				this.applyFilters();
			}
		}
	},
	clearAllFilters: function () {
		if (this._filtered) {
			this._fireFilterAllCleared();
			this._filters = [];
			this.applyFilters();
		}
	},
	hasFilters: function () {
		var i, cnt, filters;
		for (i = 0, cnt = this._filters.length; i < cnt; i++) {
			filters = this._filters[i];
			if (filters && filters.length > 0) {
				return true;
			}
		}
		return false;
	},
	applyFilters: function (fireEvent) {
		fireEvent = arguments.length > 0 ? fireEvent : true;
		if (this._filterLock > 0) {
			return;
		}
		if (!this._fireFiltering()) {
			return;
		}
		this._explicitFilter = true;
		this._doApplyFilters(fireEvent);
	},
	$_setEditing: function (value) {
		this._editing = value;
		/*
		 if (value != this._editing) {
		 this._editing = value;
		 if (!value) {
		 if (this._pendingRows.length > 0) {
		 var rows = this._pendingRows.slice();
		 this._pendingRows = [];
		 if (rows.length > 1) {
		 this.$_buildItems();
		 this._fireRefresh();
		 } else {
		 if (this.$_needFilter() || this.$_needSort() || this._paging) {
		 this.$_buildItems();
		 }
		 this._fireItemUpdated(rows[0]);
		 }
		 }
		 }
		 }
		 */
	},
    $_needSort: function () {
        return this._sorted && this._sortMode == SortMode.AUTO && this._sortingDirty;
    },
    $_needFilter: function () {
        return this._filtered && this._filterMode == FilterMode.AUTO;
    },
    $_checkSorted: function () {
        var i, nfld,
            flds = this._sortFields,
            ds = this._dataSource;
        if (flds && ds) {
            nfld = ds.fieldCount();
            for (i = flds.length - 1; i >= 0; i--) {
                if (flds[i] >= nfld) {
                    flds.splice(i, 1);
                    this._sortDirections.splice(i, 1);
                    this._sortCases.splice(i, 1);
                }
            }
            return flds.length > 0;
        }
    },
    $_checkFiltered: function () {
        var ds = this._dataSource;
        if (ds) {
            this._activeRowFilter = undefined;
            this._filters.length = ds.fieldCount();
            if (this._rowFilter.canFiltering() && (!this._paging || this._pageFiltering)) {
                this._activeRowFilter = this._rowFilter;
                return true;
            }
            return this.hasFilters() || (this._hideDeleted && ds.deletedCount() > 0);
        }
    },
    $_prepareFilters: function (ds) {
        var i, cnt, c, f, nFilter,
            rowFilter = this._activeRowFilter,
            filterList = this._filters,
            runtime = this._filterRuntime;
        if (rowFilter) {
            this._rowFilterRuntime.setDataSource(ds);
            rowFilter.prepare(this._rowFilterRuntime);
        }
        for (i = 0, cnt = filterList.length; i < cnt; i++) {
            filters = filterList[i];
            if (filters) {
                nFilter = 0;
                for (c = filters.length; c--;) {
					f = filters[c];
                    if (f instanceof ColumnFilterRun) {
                        f.prepare(runtime, ds);
                        nFilter++;
                    } else if (f instanceof ColumnAutoFilter && f._checkCount > 0) {
                        nFilter++;
                    }
                }
                for (c = filters.length; c--;) {
                    f = filters[c];
                    if (f instanceof ColumnAutoFilter) {
                        f.setAlone(nFilter == 0);
                    }
                }
            }
        }
    },
    $_select: function (row, rowFilter) {
        var i, len, j, cnt, filters, f, ok,
            runtime = this._filterRuntime,
            filterList = this._filters;
        if (!rowFilter || rowFilter.select(row)) {
            for (i = 0, len = filterList.length; i < len; i++) {
                filters = filterList[i];
                if (filters) {
                    ok = false;
                    for (j = 0, cnt = filters.length; j < cnt; j++) {
                        f = filters[j];
                        if (f instanceof ColumnAutoFilter) {
                            if (f.select(row.getValue(i))) {
                                ok = true;
                            }
                        } else if (f.select(runtime, row, i)) {
                            ok = true;
                        }
                        if (ok) break;
                    }
                    if (!ok) return false;
                }
            }
            return true;
        }
        return false;
    }
});
var DefaultRowProvider = defineClass("DefaultRowProvider", FilteredRowProvider, {
    init: function (indexing) {
        this._super(indexing);
        this._dataSource = null;
        this._rows = [];
        this._hiddens = [];
        this._filteredItems = [];
        this._pageItems = [];
        this._sortedItems = [];
        this._pubItems = this._items = this._rows;
        this._pendingRows = [];
        this._fixedCount = 0;
        this._fixedSorting = false;
        this._maxItemCount = 0;
        this._rowCount = 0;
        this._pubCount = 0;
        this._hiddenCount = 0;
        this._hiddenChanged = false;
        this._paging = false;
        this._pageSize = 10;
        this._pageCount = -1;
        this._pageOffset = 0;
        this._pageRows = null;
        this._currPage = -1;
        this._currPageCount = 0;
        this._reqPage = -1;
        this._pageStart = 0;
        this._summaryMap = null;
        this._summarizedMap = {}; // for user's summarize callback
    },
    pageSorting: true,
    pageFiltering: true,
    summaryMode: EnumProp(SummaryMode, SummaryMode.AGGREGATE),
    setPageSorting: function (value) {
        if (value != this._pageSorting) {
            this._pageSorting = value;
            if (this._sorted) {
                this.$_buildItems();
                this._fireRefresh();
            }
        }
    },
    setPageFiltering: function (value) {
        if (value != this._pageFiltering) {
            this._pageFiltering = value;
            if (this._filtered) {
                this.$_buildItems();
                this._fireRefresh();
            }
        }
    },
    setSummaryMode: function (value) {
        if (value != this._summaryMode) {
            this._summaryMode = value;
            this.$_resetSummary();
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    isPaging: function () {
        return this._paging;
    },
    pageStartIndex: function () {
        return this._pageStart;
    },
    hiddenCount: function () {
        return this._hiddenCount;
    },
    getDataRow: function (dataIndex) {
        return dataIndex >= 0 && dataIndex < this._rows.length ? this._rows[dataIndex] : null;
    },
    getFieldDomain: function (field) {
        var i, cnt,
            rows = this._rows,
            values = [],
            curr = UNDEFINED,
            prev = UNDEFINED;
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            curr = this._dataSource.getValue(i, field);
            if (curr != prev && values.indexOf(curr) < 0) {
                values.push(curr);
            }
            prev = curr;
        }
        return values;
    },
    isRowHidden: function (row) {
        return this._hiddens[row];
    },
    setHiddenRow: function (row, hidden) {
        if (row >= 0 && row < this._rows.length && this._hiddens[row] != hidden) {
            var oldCount = this.rowCount();
            this._hiddens[row] = hidden;
            this._hiddenCount += hidden ? 1 : -1;
            this._hiddenChanged = true;
            this.$_buildMaxItems();
            this._fireRefresh();
            this._fireCountChanged(oldCount);
            return true;
        }
    },
    getHiddenRows: function () {
        var i,
            hiddens = this._hiddens,
            cnt = hiddens.length,
            rows = [];
        for (i = 0; i < cnt; i++) {
            hiddens[i] && rows.push(i);
        }
        return rows;
    },
    setHiddenRows: function (rows, hidden) {
        var i, len, row,
            rowCount = this._rows.length,
            hiddens = this._hiddens,
            cnt = 0;
        if (_isArray(rows) && (len = rows.length) > 0) {
            for (i = 0; i < len; i++) {
                row = rows[i];
                if (row >= 0 && row < rowCount && hiddens[row] != hidden) {
                    hiddens[row] = hidden;
                    cnt++;
                }
            }
            if (cnt > 0) {
                rowCount = this.rowCount();
                this._hiddenCount += (hidden ? 1 : -1) * cnt;
                this._hiddenChanged = true;
                this.$_buildMaxItems();
                this._fireRefresh();
                this._fireCountChanged(rowCount);
            }
        }
        return cnt;
    },
    unhideAllRows: function () {
        if (this._hiddenCount > 0) {
            var count = this.rowCount();
            this._hiddens.length = 0;
            this._hiddenCount = 0;
            this._hiddenChanged = true;
            this.$_buildMaxItems();
            this._fireRefresh();
            this._fireCountChanged(count);
            return true;
        }
    },
    _doApplyFilters: function (fireEvent, noFilter) {
        var oldCount = this.rowCount();
        this.$_buildMaxItems();
        try {
            if (fireEvent) {
                this._fireRefresh();
            }
        } finally {
            if (!noFilter) {
                this._fireFiltered();
            }
        }
        this._fireCountChanged(oldCount);
    },
    _doApplyRowFilter: function () {
        this._doApplyFilters(true);
    },
    orderBy: function (fields, directions, cases, fireEvent) {
        fireEvent = arguments.length > 3 ? fireEvent : true;
        if (!this._fireSorting(fields, directions, cases)) {
            return;
        }
        this._sortFields = [];
        this._sortDirections = [];
        this._sortCases = [];
        var i,
            cnt = fields ? fields.length : 0,
            len = directions ? directions.length : 0,
            clen = cases ? cases.length : 0;
        for (i = 0; i < cnt; i++) {
            this._sortFields.push(fields[i]);
            if (len > i) {
                this._sortDirections.push(directions[i]);
            } else if (len > 0) {
                this._sortDirections.push(directions[len - 1]);
            } else {
                this._sortDirections.push(SortDirection.ASCENDING);
            }
            if (clen > i) {
                this._sortCases.push(cases[i]);
            } else if (clen > 0) {
                this._sortCases.push(cases[clen - 1]);
            } else {
                this._sortCases.push(SortCase.SENSITIVE);
            }
        }
        this._explicitSort = true;
        this.$_buildItems();
        try {
            if (fireEvent) {
                this._fireRefresh();
            }
        } finally {
            this._fireSorted();
        }
    },
    setPaging: function (paging, pageSize, pageCount, pageOffset) {
        pageSize = arguments.length > 1 ? pageSize : 10;
        pageCount = arguments.length > 2 ? pageCount : -1;
        pageOffset = arguments.length > 3 ? pageOffset : 0;
        pageSize = Math.max(_forceInt(pageSize), 1);
        pageCount = Math.max(_forceInt(pageCount), -1);
        pageOffset = Math.max(_forceInt(pageOffset), 0);
        var oldPaging = this._paging,
            oldSize = this._pageSize,
            oldCount = this._pageCount,
            oldPage = this._currPage;
        if (paging != oldPaging || pageSize != oldSize || pageCount != oldCount || pageOffset != this._pageOffset) {
            var oldRowCount = this.rowCount();
            if (paging != oldPaging) {
                this._currPage = -1;
                this._currPageCount = 0;
                this._reqPage = -1;
                this._pageStart = 0;
            }
            this._paging = paging;
            this._pageSize = pageSize;
            this._pageCount = pageCount;
            this._pageOffset = pageOffset;
            this.$_buildItems();
            this._fireRefresh();
            if (this._paging != oldPaging) {
                this._firePaged(this._paging);
            }
            this._fireCountChanged(oldRowCount);
        }
    },
    page: function () {
        return this._paging ? this._currPage : -1;
    },
    setPage: function (newPage) {
        if (this._paging) {
            var oldCount = this.rowCount();
            newPage = Math.max(0, Math.min(this.pageCount() - 1, isNaN(newPage) ? 0 : newPage));
            if (newPage != this._currPage && this._firePageIndexChanging(this._currPage, newPage)) {
                this._reqPage = newPage;
                try {
                    this.$_buildPage();
                } finally {
                    this._reqPage = -1;
                }
            }
            this._fireCountChanged(oldCount);
        }
    },
    pageSize: function () {
        return this._pageSize;
    },
    setPageSize: function (value) {
        value = Math.max(1, value);
        if (value != this._pageSize) {
            var oldCount = this.rowCount(),
                oldSize = this._pageSize;
            this._pageSize = value;
            if (this._paging) {
                this.$_buildPage();
            }
            this._fireCountChanged(oldCount);
        }
    },
    pageCount: function () {
        if (this._paging) {
            return this._currPageCount;
        } else {
            return this._pageCount;
        }
    },
    setPageCount: function (value) {
        value = Math.max(-1, value);
        if (value != this._pageCount) {
            var oldCount = this.rowCount();
            this._pageCount = value;
            if (this._paging) {
                this.$_buildPage();
            }
            this._fireCountChanged(oldCount);
        }
    },
    pageOffset: function () {
        return this._pageOffset;
    },
    setPageOffset: function (value) {
        var off = _int(value);
        if (isNaN(off)) off = 0;
        if (off != this._pageOffset) {
            var oldCount = this.rowCount();
            this._pageOffset = off;
            if (this._paging) {
                this.$_buildPage();
            }
            this._fireCountChanged(oldCount);
        }
    },
    setPageAndOffset: function (page, offset) {
        var pg = _int(page);
        if (isNaN(pg)) pg = 0;
        var off = _int(offset);
        if (isNaN(off)) off = 0;
        if (pg != this._currPage) {
            this._pageOffset = off;
            this.setPage(pg);
        } else if (off != this._pageOffset) {
            this.setPageOffset(off);
        }
    },
    pageRows: function () {
        var rows = this._pageRows;
        if (!rows && this._paging) {
            rows = this._pubItems.concat();
            for (var i = rows.length; i--;) {
                rows[i] = rows[i].dataIndex();
            }
        }
        return rows;
    },
    setPageRows: function (value) {
        this._pageRows = value ? value.concat() : null;
        if (this._paging) {
            var oldCount = this.rowCount();
            this.$_buildPage();
            this._fireRefresh();
            this._fireCountChanged(oldCount);
        }
    },
    setPageAndRows: function (page, rows) {
        var pg = _int(page);
        if (isNaN(pg)) pg = 0;
        if (pg != this._currPage) {
            this._pageRows = rows ? rows.concat() : null;
            this.setPage(pg);
        } else {
            this.setPageRows(rows);
        }
    },
    dataSource: function () {
        return this._dataSource;
    },
    setDataSource: function (value) {
        if (value !== this._dataSource) {
            var oldCount = this.rowCount();
            this.$_clearRows();
            if (this._dataSource) {
                this._dataSource.removeListener(this);
            }
            this._dataSource = value;
            if (this._dataSource) {
                this.$_buildRows();
                this._dataSource.addListener(this);
            }
            this.$_resetSummary();
            this._fireReset();
            this._fireCountChanged(oldCount);
        }
    },
    rowCount: function () {
        return this._pubCount;
    },
    descendantCount: function () {
        return this._pubCount;
    },
    descendantRowCount: function () {
        return this._pubCount;
    },
    getDescendantRows: function (visibleOnly, dataOnly) {
        return this._pubItems.slice();
    },
    visitRows: function (visibleOnly, dataOnly, callback) {
        if (callback) {
            var i,
                items = this._pubItems,
                cnt = items.length;
            for (i = 0; i < cnt; i++) {
                if (callback(items[i]) === false) {
                    return false;
                }
            }
        }
    },
    fixedCount: function () {
        return this._fixedCount;
    },
    maxItemCount: function () {
        return this._maxItemCount;
    },
    setMaxItemCount: function (value) {
        value = Math.max(0, parseInt(value));
        if (!isNaN(value) && value != this._maxItemCount) {
            var oldCount = this.rowCount();
            this._maxItemCount = value;
            this.refreshItems(true);
            this._fireCountChanged(oldCount);
        }
    },
    _doApplyRowFilter: function () {
        var oldCount = this.rowCount();
        this.refreshItems();
        this._fireCountChanged(oldCount);
    },
    visitAll: function (callback, visibleOnly) {
        for (var i = 0, cnt = this._pubCount; i < cnt; i++) {
            if (callback(this._pubItems[i]) === false) {
                return false;
            }
        }
    },
    getItem: function (index) {
        if (index < 0 || index >= this._pubCount) {
            return null;
        }
        return this._pubItems[index];
    },
    getItems: function (index, count) {
        return this._pubItems.slice(index, index + count);
    },
    getIndexOfRow: function (dataRow) {
        if (dataRow >= 0 && dataRow < this._rows.length) {
            return this._rows[dataRow]._index;
        }
        return -1;
    },
    getItemOfRow: function (dataRow, all) {
        if (dataRow >= 0 && dataRow < this._rows.length) {
            var item = this._rows[dataRow];
            return (all || item._index >= 0) ? item : null;
        }
        return null;
    },
    _hideDeletedChanged: function () {
        var count = this.rowCount();
        this.$_buildItems();
        this._fireRefresh();
        this._fireCountChanged(count);
    },
    refreshItems: function (noHiddens) {
        var ds = this._dataSource;
        var oldCount = this.rowCount();
        var save, restore;
        if (ds.$$_cmd) {
            save = ds.rowCount() < oldCount;
            restore = ds.rowCount() > oldCount;
        }
        save && this.onSaveRows(ds.$$_cmd);
        this.$_clearRows(noHiddens);
        this.$_buildRows(noHiddens);
        restore && this.onRestoreRows(ds.$$_cmd);
        this._fireRefresh();
    },
    setFixed: function (count, sorting, filtering) {
        count = Math.max(0, count);
        if (count != this._fixedCount || sorting != this._fixedSorting || filtering != this._fixedFiltering) {
            this._fixedCount = count;
            this._fixedSorting = sorting;
            this._fixedFiltering = filtering;
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    exchange: function (index1, index2) {
        if (index1 == index2) {
            return;
        }
        if (!this._sorted && !this._filtered) {
            if (index1 < 0 || index1 >= this._rows.length) {
                throw new Error("index1 is out of bounds: " + index1);
            }
            if (index2 < 0 || index2 >= this._rows.length) {
                throw new Error("index2 is out of bounds: " + index1);
            }
            var t = this._rows[index1];
            this._rows[index1] = this._rows[index2];
            this._rows[index2] = t;
        }
    },
    clearDisplayLevels: function () {
        var rows = this._rows;
        for (var i = 0, cnt = rows.length; i < cnt; i++) {
            rows[i]._displayLevel = -1;
        }
    },
    getAllItems: function () {
        return this._pubItems.slice();
    },
    /*
    hasCellStyle: function () {
        return !this._cellStyles.isEmpty();
    },
    setCellStyle: function (row, field, style) {
        this._cellStyles.setCellStyle(row, field, style);
    },
    setCellStyles: function (provider, rows, fieldMap, startRow, count) {
        this._cellStyles.setCellStyles(provider, rows, fieldMap, startRow, count);
    },
    removeCellStyle: function (style) {
        this._cellStyles.removeCellStyle(style);
    },
    clearCellStyles: function () {
        this._cellStyles.clearCellStyles();
    },
    getCellStyle: function (dataRow, field) {
        return this._cellStyles.getCellStyle(dataRow, field);
    },
    */
    getNumber: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.count : this.rowCount();
    },
    getSum: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.sum : NaN;
    },
    getMax: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.max : NaN;
    },
    getMin: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.min : NaN;
    },
    getAvg: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.avg : NaN;
    },
    getVar: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.vars : NaN;
    },
    getVarp: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.varsp : NaN;
    },
    getStdev: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? Math.sqrt(fs.vars) : NaN;
    },
    getStdevp: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? Math.sqrt(fs.varsp) : NaN;
    },
    getSummarized: function (scope) {
        return this._summarizedMap[scope.$_hash];
    },
    setSummarized: function (scope, value) {
        return this._summarizedMap[scope.$_hash] = value;
    },
    _doGetDistinctValues: function (field, dataType) {
        var rows = this._pubItems.slice();
        if (rows.length > 0) {
            this.$_sortRange(rows, field, true, false, this._dataSource.$_getComparer(dataType), 0, rows.length - 1, true);
        }
        return rows;
    },
    $_clearRows: function (noHiddens) {
        this._rows.length = 0;
        if (!noHiddens) {
            this._hiddens.length = 0;
            this._hiddenCount = 0;
        }
        this._filteredItems.length = 0;
        this._filtered = false;
        this._sorted = false;
        this._sortedItems = null;
        this._pubItems = this._rows;
        this._pubCount = 0;
    },
    $_clearIndices: function () {
        for (var i = this._rows.length; i--;) {
            this._rows[i]._index = -1;
        }
    },
    $_buildRows: function (checkIndex) {
        var ds = this._dataSource,
            licson = _licson,
            toolvar = licson[_lictool + "var"];
        if (!ds) {
            return;
        }
        var toolval = licson[_lictool + "val"];
        var filtered = (this.$_checkFiltered() || this._hiddenCount > 0) && !(this._paging && this._pageFiltering);
        var maxCount = this.maxItemCount();
        this._rowCount = ds.rowCount();
        if (!filtered && !this._paging && maxCount > 0) {
            this._rowCount = Math.min(this._rowCount, maxCount);
        }
        if (toolvar && toolval != _window[toolvar]) {
            this._rowCount = this._rowCount = 0;
        }
        this._rows = new Array(this._rowCount);
        for (var i = 0, cnt = this._rowCount; i < cnt; i++) {
            this._rows[i] = this.$_createRow(i);
        }
        if (licson) {
            this.$_buildItems(false, false, checkIndex);
        }
    },
    $_resetCounts: function () {
        if (this._filtered) {
            this._pubCount = this._rowCount = this._items.length;
        } else {
            this._pubCount = this._rowCount = this._rows.length;
        }
    },
    $_buildItems: function (noFilter, noSort, checkIndex) {
        var i, j, cnt, row, state, rowFilter, pageFiltering, pageSorting, fixedCount, exceptFiltering, nMax, filterCount, items,
            ds = this._dataSource,
            dataRows = this._rows,
            hiddens = this._hiddens,
            maxCount = this.maxItemCount() > 0 ? this.maxItemCount() : this._rows.length;
        this._pubItems = this._items = dataRows;
        this._pubCount = this._rowCount = dataRows.length;
        this._explicitSort = this._explicitFilter = false;
        this._filtered = this.$_checkFiltered() || this._hiddenCount > 0;
        this._sorted =  this.$_checkSorted();
        if (this._filtered || this._hiddenChanged) {
            this._filteredItems.length = 0;
            if (this._hideDeleted) {
                for (i = 0; i < this._rowCount; i++) {
                    row = dataRows[i];
                    if (hiddens[i]) {
                        row._index = -1;
                    } else {
                        state = ds.getRowState(row._dataIndex);
                        row._index = DataRowState.isDeleted(state) ? -1 : 0;
                    }
                }
            } else {
                for (i = 0; i < this._rowCount; i++) {
                    row = dataRows[i];
                    row._index = hiddens[i] ? -1 : 0;
                }
            }
            rowFilter = this._activeRowFilter;
            pageFiltering = this._paging && this._pageFiltering;
            fixedCount = this.fixedCount();
            exceptFiltering = (fixedCount > 0) && !this._fixedFiltering;
            nMax = this._rows.length;
            filterCount = this._filters.length;
            if (!noFilter) {
                this.$_prepareFilters(ds);
            }
            if (!this._paging) {
                nMax = Math.min(nMax, maxCount);
            }
            cnt = 0;
            for (i = 0; i < this._rowCount && cnt < nMax; i++) {
                row = dataRows[i];
                if (row._index >= 0) {
                    if (noFilter || pageFiltering || exceptFiltering && cnt < fixedCount) {
                        this._filteredItems.push(row);
                        cnt++;
                    } else if (this.$_select(row, rowFilter)) {
                        this._filteredItems.push(row);
                        cnt++;
                    } else {
                        row._index = -1;
                    }
                }
            }
            for (i = cnt; i < this._rowCount; i++) {
                dataRows[i]._index = -1;
            }
            this._hiddenChanged = false;
            this._pubItems = this._items = this._filteredItems;
            this._pubCount = this._rowCount = this._items.length;
        } else if (checkIndex && !this._paging) {
            for (i = 0; i < this._rowCount; i++) {
                dataRows[i]._index = 0;
            }
        }
        pageSorting = this._paging && this._pageSorting;
        if (!pageSorting && this._sorted) {
            if (noSort) {
                items = this._sortedItems;
                for (i = items.length; i--;) {
                    if (items[i]._index < 0) {
                        items.splice(i, 1);
                    }
                }
            } else {
                this.$_sortRows();
            }
            this._pubItems = this._sortedItems;
        }
        if (this._paging) {
            checkIndex && this.$_clearIndices();
            this.$_buildPageItems(false, noFilter, noSort);
            if (checkIndex) {
                for (i = 0; i < this._rowCount; i++) {
                    this._items[i]._index = 0;
                }
            }
        }
        this.$_clearSummary();
        this._resetItemIndices(0);
    },
    $_buildMaxItems: function (noFilter, noSort, checkIndex) {
        this.maxItemCount() > 0 ? this.$_buildRows(checkIndex) : this.$_buildItems(noFilter, noSort, checkIndex);
    },
    $_buildPageItems: function (refresh, noFilter, noSort) {
        var maxCount, cnt, pageItems, fixedCount, filterCount, row, j, filters, r,
            rows = (this._sorted && !this._pageSorting) ? this._sortedItems :
            (this._filtered && !this._pageFiltering) ? this._filteredItems : this._rows,
            rowCount = rows.length,
            pageSize = this.pageSize(),
            oldCount = this.pageCount(),
            oldPage = this.page(),
            pageCount = this._pageCount >= 0 ? this._pageCount :  _int((rowCount + pageSize - 1) / pageSize),
            newPage = Math.max(0, Math.min(pageCount - 1, this._reqPage < 0 ? oldPage : this._reqPage)),
            i = newPage * pageSize + this.pageOffset();
        if (i >= rowCount) {
            this._pageItems.length = 0;
            this._pubItems = this._items = this._pageItems;
            this._pubCount = this._rowCount = this._items.length;
        } else {
            maxCount = this.maxItemCount() > 0 ? this.maxItemCount() : rowCount;
            cnt = Math.min(pageSize, maxCount);
            pageItems = this._pageItems;
            pageItems.length = 0;
            if (_isArray(this._pageRows)) {
                rows = this._pageRows;
                for (i = 0; i < rows.length; i++) {
                    r = rows[i];
                    if (r >= 0 && r < rowCount) {
                        pageItems.push(this._rows[r]);
                    }
                }
            } else {
                for (; i < rowCount && cnt > 0; i++, cnt--) {
                    i >= 0 && pageItems.push(rows[i]);
                }
            }
            this._pubItems = this._items = pageItems;
            cnt = this._pubCount = pageItems.length;
            if (cnt > 0) {
                if (this._pageFiltering && !noFilter) {
                    fixedCount = !this._fixedFiltering ? this._fixedCount : 0;
                    cnt = pageItems.length;
                    for (i = cnt - 1; i >= fixedCount; i--) {
                        row = pageItems[i];
                        if (!this.$_select(row, this._activeRowFilter)) {
                            pageItems.splice(i, 1);
                        }
                    }
                    this._pubCount = this._rowCount = this._items.length;
                }
                if (this._pageSorting && !noSort) {
                    this.$_sortRows(pageItems);
                }
            }
        }
        this._currPageCount = pageCount;
        this._currPage = newPage;
        this._pageStart = this._currPage * this._pageSize;
        if (refresh) {
            this._resetItemIndices(0);
            this._fireRefresh();
        }
        if (this._currPageCount != oldCount) {
            this._firePageCountChanged(oldCount, this._currPageCount);
        }
        if (this._currPage != oldPage) {
            this._firePageIndexChanged(oldPage, this._currPage);
        }
    },
    $_buildPage: function () {
        this.$_clearIndices();
        this.$_buildPageItems(true);
    },
    $_sortRows: function (items) {
        this._sortedItems = items || this._items.concat();
        var rowCount = this._sortedItems.length;
        if (this._fixedCount > 0 && !this._fixedSorting) {
            this.$_sort(0, this._fixedCount, rowCount - 1);
        } else {
            this.$_sort(0, 0, rowCount - 1);
        }
        this._sortingDirty = false;
    },
    $_sort: function (level, startIndex, endIndex) {
        this.$_sortLevel(level, startIndex, endIndex);
    },
    $_compFunc: function (vt) {
        switch (t) {
            case ValueType.DATETIME:
            case ValueType.NUMBER:
                compFunc = ds.compareNumbers.bind(ds);
                break;
            case ValueType.BOOLEAN:
                compFunc = ds.compareBools.bind(ds);
                break;
            case ValueType.OBJECT:
                compFunc = ds.compareObjs.bind(ds);
                break;
            default:
                compFunc = ignoreCase ? ds.compareTexts.bind(ds) : ds.compareValues.bind(ds);
                break;
        }
    },
    $_sortLevel: function (level, startIndex, endIndex) {
        if (startIndex >= endIndex || level >= this._sortFields.length) {
            return;
        }
        var ascending, ignoreCase, t, compFunc, equalFunc, i, pi, items,
            ds = this._dataSource,
            fld = this._sortFields[level],
            field = ds.getField(fld);
        if (field) {
            items = this._sortedItems;
            ascending = this._sortDirections[level] != SortDirection.DESCENDING;
            ignoreCase = this._sortCases[level] == SortCase.INSENSITIVE;
            t = field.dataType();
            compFunc = ds.$_getComparer(t, ignoreCase);
            if (t == ValueType.TEXT && ignoreCase) {
                equalFunc = ds.equalTexts.bind(ds);
            } else {
                equalFunc = ds.equalValues.bind(ds);
            }
            this.$_sortRange(items, fld, ascending, ignoreCase, compFunc, startIndex, endIndex, level + 1 == this._sortFields.length);
            if (level + 1 < this._sortFields.length) {
                i = startIndex;
                pi = i;
                while (i < endIndex) {
                    i++;
                    if (!equalFunc(fld, items[i]._dataIndex, items[i - 1]._dataIndex)) {
                        this.$_sortLevel(level + 1, pi, i - 1);
                        pi = i;
                    }
                }
                if (pi < endIndex) {
                    this.$_sortLevel(level + 1, pi, endIndex);
                }
            }
        }
    },
    $_sortRange: function (items, field, ascending, ignoreCase, compFunc, left, right, checkRow) {
        var i, j, row, m, r, v;
        do {
            i = left;
            j = right;
            row = _floor((left + right) / 2);
            m = items[row]._dataIndex;
            do {
                if (ascending) {
                    while (i <= j) {
                        r = items[i]._dataIndex;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v <= 0)
                            break;
                        i++;
                    }
                    while (i <= j) {
                        r = items[j]._dataIndex;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v >= 0)
                            break;
                        j--;
                    }
                } else {
                    while (i <= j) {
                        r = items[i]._dataIndex;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v >= 0)
                            break;
                        i++;
                    }
                    while (i <= j) {
                        r = items[j]._dataIndex;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v <= 0)
                            break;
                        j--;
                    }
                }
                if (i <= j) {
                    if (i != j) {
                        var t = items[i];
                        items[i] = items[j];
                        items[j] = t;
                    }
                    i++;
                    j--;
                }
            } while (i <= j);
            if (left < j) {
                this.$_sortRange(items, field, ascending, ignoreCase, compFunc, left, j, checkRow);
            }
            left = i;
        } while (left < right);
    },
    $_createRow: function (row) {
        var item = new DataRow(row);
        this.attachItem(item);
        return item;
    },
    $_createAllRow: function () {
        for (var i = 0; i < this._rowCount; i++) {
            if (!this._rows[i]) {
                this._rows[i] = this.$_createRow(i);
            }
        }
    },
    $_resetSummary: function () {
        this._summaryMap = [];
        this._summarizedMap = {};
    },
    $_clearSummary: function () {
        if (this._summaryMap) {
            for (var i = this._summaryMap.length; i--;) {
                this._summaryMap[i] && this._summaryMap[i].clear();
            }
        }
        this._summarizedMap = {};
        this._fireSummaryCleared();
    },
    $_getSummary: function (field) {
        var fs = this._summaryMap[field];
        if (!fs) {
            var ds = this._dataSource;
            if (ds && ds.canSummarize(field)) {
                fs = new FieldSummary(field);
                this._summaryMap[field] = fs;
            }
        }
        if (fs && fs.count == 0 && this.rowCount() > 0) {
            this.$_summarize(fs);
        }
        return fs;
    },
    $_summarize: function (fs) {
        var ds = this._dataSource;
        if (ds) {
            if (this._filtered) {
                var cnt = this._items.length;
                var rows = new Array(cnt);
                for (var i = 0; i < cnt; i++) {
                    rows[i] = this._pubItems[i]._dataIndex;
                }
                ds.aggregateRange(fs, rows, this._summaryMode == SummaryMode.STATISTICAL);
            } else {
                ds.aggregate(fs, this._summaryMode == SummaryMode.STATISTICAL);
            }
        }
    },
    onDataSetDisposed: function (ds) {
        var oldCount = this.rowCount();
        this.setDataSource(null);
        this._fireCountChanged(oldCount, 0);
    },
    onDataSetReset: function (ds) {
        var oldCount = this.rowCount();
        var ds = this._dataSource;
        var save, restore;
        if (ds.$$_cmd) {
            save = ds.rowCount() < oldCount;
            restore = ds.rowCount() > oldCount;
        }
        save && this.onSaveRows(ds.$$_cmd);
        this._sortingDirty = true;
        this.$_clearRows();
        this.$_buildRows();
        this.$_resetSummary();
        restore && this.onRestoreRows(ds.$$_cmd);
        this._fireReset();
        this._fireCountChanged(oldCount);
    },
    onDataSetRefresh: function (ds) {
        var oldCount = this.rowCount();
        this._sortingDirty = true;
        this.refreshItems();
        this._fireCountChanged(oldCount);
    },
    onDataSetCalculated: function (rows) {
        this._fireDataCalculated(rows);
    },
    onDataSetCommandStackChanged: function (ds, canUndo, canRedo) {
        this._fireUndoStateChanged(canUndo, canRedo);
    },
    onGridDataSetRowCountChanged: function (ds, newCount) {
    },
    onGridDataSetRowInserting: function (ds, row, values) {
        return true;
    },
    onGridDataSetRowInserted: function (ds, row) {
        var item, items, i, cnt, inserted,
            oldCount = this.rowCount(),
            rows = this._rows,
            posRow = row < rows.length ? rows[row] : null;
        this._sortingDirty = true;
        item = this.$_createRow(row);
        rows.splice(row, 0, item);
        this._hiddens.splice(row, 0, false);
        for (i = row, cnt = rows.length; i < cnt; i++) {
            rows[i]._dataIndex = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems(false, false, true);
            inserted = item._index >= 0;
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
            inserted = item._index >= 0;
        } else {
            inserted = true;
            if (this._filtered) {
                items = this._filteredItems;
                row = Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                items.splice(row, 0, item);
            }
            if (this._sorted) {
                items = this._sortedItems;
                row = Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                items.splice(row, 0, item);
            }
            this.$_clearSummary();
            this.$_resetCounts();
            this._resetItemIndices(this._sorted ? 0 : row);
        }
        ds.$$_cmd && this.onRestoreRow(ds.$$_cmd, item, row);
        if (inserted) {
            this._fireItemInserted(item);
            this._fireCountChanged(oldCount);
        } else {
            this._fireIndicesPolluted();
        }
    },
    onGridDataSetRowsInserted: function (ds, row, count) {
        var rowArr = _asArray(row);
        rowArr && (count = rowArr.length);
        if (count < 0) {
            return;
        }
        var i, r, item, items, cnt,
            start = rowArr ? rowArr[0] : row,
            oldCount = this.rowCount(),
            rows = this._rows,
            hiddens = this._hiddens,
            posRow = (!rowArr && row < rows.length) ? rows[row] : null,
            list = [];
        this._sortingDirty = true;
        for (i = 0; i < count; i++) {
            r = rowArr ? rowArr[i] : start + i;
            list.push(item = this.$_createRow(r));
            rows.splice(r, 0, item);
            hiddens.splice(r, 0, false);
        }
        cnt = rows.length;
        for (i = start; i < cnt; i++) {
            rows[i]._dataIndex = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            if (this._filtered) {
                items = this._filteredItems;
                if (rowArr) {
                    for (i = 0; i < list.length; i++) {
                        row = rowArr[i];
                        row = Math.max(0, row < oldCount ? items.indexOf(row) : items.length);
                        items.splice(row + i, 0, list[i]);
                    }
                } else {
                    row = Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                    for (i = 0; i < list.length; i++) {
                        items.splice(row + i, 0, list[i]);
                    }
                }
            }
            if (this._sorted) {
                items = this._sortedItems;
                if (rowArr) {
                    for (i = 0; i < list.length; i++) {
                        row = rowArr[i];
                        row = Math.max(0, row < oldCount ? items.indexOf(row) : items.length);
                        items.splice(row + i, 0, list[i]);
                    }
                } else {
                    row = Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                    for (i = 0; i < list.length; i++) {
                        items.splice(row + i, 0, list[i]);
                    }
                }
            }
            this.$_clearSummary();
            this.$_resetCounts();
            this._resetItemIndices(start);
        }
        ds.$$_cmd && this.onRestoreRows(ds.$$_cmd, list);
        this._fireRefresh();
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowDeleting: function (ds, row) {
        return true;
    },
    onGridDataSetRowDeleted: function (ds, row, rowId) {
        var items, i,
            oldCount = this.rowCount(),
            rows = this._rows,
            item = rows[row];
        this._sortingDirty = true;
        rows.splice(row, 1);
        this._hiddenCount -= this._hiddens[row] ? 1 : 0;
        this._hiddens.splice(row, 1);
        for (i = rows.length - 1; i >= row; i--) {
            rows[i]._dataIndex = i;
        }
        ds.$$_cmd && this.onSaveRow(ds.$$_cmd, item, row);
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            if (this._filtered) {
                items = this._filteredItems;
                row = items.indexOf(item);
                row >= 0 && items.splice(row, 1);
            }
            if (this._sorted) {
                items = this._sortedItems;
                row = items.indexOf(item);
                row >= 0 && items.splice(row, 1);
            }
            this.$_clearSummary();
            this.$_resetCounts();
            this._resetItemIndices(row);
        }
        item.$_rowId = rowId;
        this._fireItemDeleted(item);
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowsDeleting: function (ds, rows) {
        return true;
    },
    onGridDataSetRowsDeleted: function (ds, rows) {
        if (!rows || rows.length < 1) {
            return;
        }
        this._sortingDirty = true;
        if (rows.length > 1) {
            rows.sort(function (v1, v2) {
                return v1 - v2;
            });
        }
        var i, r, item,
            oldCount = this.rowCount(),
            items = this._rows,
            hiddens = this._hiddens,
            row = rows[0],
            list = [];
        for (i = rows.length - 1; i >= 0; i--) {
            r = rows[i];
            list.push(items[r]);
            items.splice(r, 1);
            this._hiddenCount -= hiddens[r] ? 1 : 0;
            hiddens.splice(r, 1);
        }
        ds.$$_cmd && this.onSaveRows(ds.$$_cmd, list);
        for (i = this._rows.length - 1; i >= row; i--) {
            items[i]._dataIndex = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            if (this._filtered) {
                items = this._filteredItems;
                for (i = 0; i < list.length; i++) {
                    item = list[i];
                    row = items.indexOf(item);
                    row >= 0 && items.splice(row, 1);
                }
            }
            if (this._sorted) {
                items = this._sortedItems;
                for (i = 0; i < list.length; i++) {
                    item = list[i];
                    row = items.indexOf(item);
                    row >= 0 && items.splice(row, 1);
                }
            }
            this.$_clearSummary();
            this.$_resetCounts();
            this._resetItemIndices(row);
        }
        this._fireRefresh();
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowUpdating: function (ds, row, values) {
        var i, cnt,
            oldValues = ds.getRow(row),
            fields = ds.fields();
        for (i = 0, cnt = fields.length; i < cnt; i++) {
            if (!fields[i].equalValues(oldValues[i], values[i])) {
                if (this._sortFields.indexOf(i) > -1 || this.alwaysSorting()) {
                    this._sortingDirty = true;
                    break;
                }
            }
        }
        return true;
    },
    onGridDataSetRowUpdated: function (ds, row) {
        var oldCount = this.rowCount();
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            this.$_clearSummary();
        }
        this._fireItemUpdated(this._rows[row]);
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowsUpdated: function (ds, rows) {
        var oldCount = this.rowCount();
        this._sortingDirty = true;
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            this.$_clearSummary();
        }
        this._fireRefresh();
        this._fireCountChanged(oldCount);
    },
    onGridDataSetValueChanging: function (ds, row, field, value) {
        if (this._sortFields.indexOf(field) > -1 || this.alwaysSorting()) {
            this._sortingDirty = true;
        }
        return true;
    },
    onGridDataSetValueChanged: function (ds, row, field) {
        var oldCount = this.rowCount();
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildMaxItems();
        } else if (this.maxItemCount() > 0) {
            this.$_buildRows(true);
        } else {
            this.$_clearSummary();
        }
        this._fireItemUpdated(this._rows[row]);
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowMoving: function (ds, row, newRow) {
        return true;
    },
    onGridDataSetRowMoved: function (ds, row, newRow) {
        var t,
            oldCount = this.rowCount(),
            hiddens = this._hiddens;
        this.refreshItems(true);
        if (hiddens[row] != hiddens[newRow]) {
            t = hiddens[row];
            hiddens[row] = hiddens[newRow];
            hiddens[newRow] = t;
        }
        this._fireCountChanged(oldCount);
    },
    onGridDataSetRowsMoving: function (ds, row, count, newRow) {
        return true;
    },
    onGridDataSetRowsMoved: function (ds, row, count, newRow) {
        var rows, i,
            hiddens = this._hiddens,
            oldCount = this.rowCount();
        if (this._hiddenCount > 0) {
            hiddens.length = Math.max(hiddens.length, newRow + count + 1);
            rows = hiddens.splice(row, count);
            for (i = 0; i < count; i++) {
                hiddens.splice(newRow + i, 0, rows[i]);
            }
        }
        this.refreshItems(true);
        this._fireCountChanged(oldCount);
    },
    onGridDataSetStateChanged: function (ds, row, oldState, updating) {
        if (updating) return;
        var oldCount = this.rowCount(),
            r = this._rows[row];
        if (r) {
            if (this.$_needFilter() && this._dataStateFiltering) {
                this.$_buildMaxItems();
                this._fireRefresh();
            } else if (this._hideDeleted) {
                if (DataRowState.isDeleted(oldState) || DataRowState.isDeleted(r.dataState())) {
                    if (this.$_needSort() || this._paging) {
                        this.$_buildMaxItems();
                    } else {
                        this.$_buildMaxItems(true, true);
                    }
                    this._fireRefresh();
                }
            }
            this._fireRowStateChanged(r);
        }
        this._fireCountChanged(oldCount);
    },
    onGridDataSetStatesChanged: function (ds, rows, deletedInc, updating) {
        if (updating) return;
        var i, cnt, removed, r,
            oldCount = this.rowCount();
        if (this.$_needFilter() && this._dataStateFiltering) {
            this.$_buildMaxItems();
            this._fireRefresh();
        } else if (this._hideDeleted && deletedInc) {
            if (this.$_needSort() || this._paging) {
                this.$_buildMaxItems();
            } else {
                this.$_buildMaxItems(true, true);
            }
            this._fireRefresh();
        }
        this._fireRowStatesChanged(this.getItemsOfRows(rows));
        this._fireCountChanged(oldCount);
    },
    onDataSetStatesCleared: function (ds) {
        var removed, i, cnt, r,
            oldCount = this.rowCount();
        if (this.$_needFilter() && this._dataStateFiltering) {
            this.$_buildMaxItems();
            this._fireRefresh();
        } else if (this._hideDeleted) {
            if (this.$_needSort() || this._paging) {
                this.$_buildMaxItems();
            } else {
                this.$_buildMaxItems(true, true);
            }
            this._fireRefresh();
        }
        this._fireRowStatesCleared();
        this._fireCountChanged(oldCount);
    },
    onGridDataSetTagChanged: function (ds, row) {
        var oldCount,
            filtering = this._dataTagFiltering && this.$_needFilter();
        if (filtering) {
            oldCount = this.rowCount();
            this.$_buildMaxItems();
            this._fireRefresh();
        }
        this._fireRowTagChanged(this._rows[row]);
        filtering && this._fireCountChanged(oldCount);
    },
    onGridDataSetTagsChanged: function (ds, rows) {
        var oldCount,
            filtering = this._dataTagFiltering && this.$_needFilter();
        if (filtering) {
            oldCount = this.rowCount();
            this.$_buildMaxItems();
            this._fireRefresh();
        }
        this._fireRowTagsChanged(this.getItemsOfRows(rows));
        filtering && this._fireCountChanged(oldCount);
    },
    onDataSetTagsCleared: function (ds) {
        var oldCount,
            filtering = this._dataTagFiltering && this.$_needFilter();
        if (filtering) {
            oldCount = this.rowCount();
            this.$_buildMaxItems();
            this._fireRefresh();
        }
        this._fireRowTagsCleared();
        filtering && this._fireCountChanged(oldCount);
    }
});
var $$_DRPP = DefaultRowProvider.prototype;
/** @abstract */
var ProxyRowProvider = defineClass("ProxyRowProvider", RowProvider, {
	init: function (source, indexing) {
		this._super(indexing);
		this._initialize();
		this.setSource(source);
	},
    source: null,
	setSource: function (value) {
		if (value != this._source) {
			if (this._source) {
				this._source.removeListener(this);
			}
			this._clearItems();
			this._source = value;
			if (this._source) {
				this._populateItems();
				this._source.addListener(this);
			}
		}
	},
	dataSource: function () {
		return this._source ? this._source.dataSource() : null;
	},
	fixedCount: function () {
		return this._source ? this._source.fixedCount() : 0;
	},
	maxItemCount: function () {
		return this._source ? this._source.maxItemCount() : 0;
	},
	setMaxItemCount: function (value) {
		if (this._source) {
			this._source.setMaxItemCount(value);
		}
	},
	rowFilter: function () {
		return this._source && this._source.rowFilter();
	},
	setRowFilter: function (value) {
		this._source && this._source.setRowFilter(value);
	},
	setFixed: function (count, sorting, filtering) {
		if (this._source) {
			this._source.setFixed(count, sorting, filtering);
		}
	},
	setAlwaysSorting: function (value) {
		this._source && this._source.setAlwaysSorting(value);
	},
	getIndexOfRow: function (dataRow) {
		return this._source ? this._source.getIndexOfRow(dataRow) : -1;
	},
	getItemOfRow: function (dataRow) {
		return this._source ? this._source.getItemOfRow(dataRow) : null;
	},
	refreshItems: function () {
		this._source &&	this._source.refreshItems();
	},
	_clearDisplayLevels: function () {
		this._source && this._source._clearDisplayLevels();
	},
	setCellStyle: function (row, field, style) {
		this._source && this._source.setCellStyle(row, field, style);
	},
	removeCellStyle: function (style) {
		this._source && this._source.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._source && this._source.clearCellStyles();
	},
    visitAll: function (callback, visibleOnly) {
        return this._source && this._source.visitAll(callback, visibleOnly);
    },
    canInsert: function (row) {
        return this._source && this._source.canInsert(row);
    },
	_initialize: function () {
	},
	_clearItems: function () {
	},
	_populateItems: function () {
		this._resetItemIndices(0);
	},
	onRowProviderReset: function (itemProvider) {
		this._populateItems();
		this._fireReset();
	},
	onRowProviderRefresh: function (itemProvider) {
		this._populateItems();
		this._fireRefresh();
	},
	onRowProviderIndicesPolluted: function (itemProvider) {
		this._resetItemIndices(0);
		this._fireIndicesPolluted();
	},
	onRowProviderUndoStateChanged: function (itemProvider, canUndo, canRedo) {
		this._fireUndoStateChanged(canUndo, canRedo);
	},
	onRowProviderCountChanged: function (itemProvider, oldCount, newCount) {
		this._fireCountChanged(oldCount, newCount);
	},
	onRowProviderDataCountChanged: function (itemProvider, oldCount, newCount) {
		this._fireDataCountChanged(oldCount, newCount);
	},
	onRowProviderDataCalculated: function (rows) {
		this._fireDataCalculated(rows);
	},
	onRowProviderItemInserted: function (itemProvider, item) {
		this._resetItemIndices(0);
		this._fireItemInserted(item);
	},
	onRowProviderItemDeleted: function (itemProvider, item) {
		this._resetItemIndices(0);
		this._fireItemDeleted(item);
	},
	onRowProviderItemUpdated: function (itemProvider, item) {
		this._resetItemIndices(0);
		this._fireItemUpdated(item);
	},
	onRowProviderCheckableChanged: function (itemProvider, item) {
		this._fireCheckableChanged(item);
	},
	onRowProviderItemChecked: function (itemProvider, item) {
		this._fireItemChecked(item);
	},
	onRowProviderItemsChecked: function (itemProvider, items, checked) {
		this._fireItemsChecked(items, checked);
	},
	onRowProviderItemAllChecked: function (itemProvider, checked) {
		this._fireItemAllChecked(checked);
	},
	onRowProviderRowStateChanged: function (itemProvider, item) {
		this._fireRowStateChanged(item);
	},
	onRowProviderRowStatesChanged: function (itemProvider, items) {
		this._fireRowStatesChanged(items);
	},
	onRowProviderRowStatesCleared: function (itemProvider) {
		this._fireRowStatesCleared();
	},
    onRowProviderRowTagChanged: function (itemProvider, item) {
        this._fireRowTagChanged(item);
    },
    onRowProviderRowTagsChanged: function (itemProvider, items) {
        this._fireRowTagsChanged(items);
    },
    onRowProviderRowTagsCleared: function (itemProvider) {
        this._fireRowTagsCleared();
    },
	onRowProviderFilterAdded: function (itemProvider, field, expression) {
		this._fireFilterAdded(field, expression);
	},
	onRowProviderFilterRemoved: function (itemProvider, field, expression) {
		this._fireFilterRemoved(field, expression);
	},
	onRowProviderFilterCleared: function (itemProvider, field) {
		this._fireFilterCleared(field);
	},
	onRowProviderFilterAllCleared: function (itemProvider) {
		this._fireFilterAllCleared();
	},
	onRowProviderFiltering: function (itemProvider) {
		return this._fireFiltering();
	},
	onRowProviderFiltered: function (itemProvider) {
		this._fireFiltered();
	},
	onRowProviderSorting: function (itemProvider, fields, directions, cases) {
		return this._fireSorting(fields, directions, cases);
	},	
	onRowProviderSorted: function (itemProvider) {
		this._fireSorted();
	},
	onRowProviderPaged: function (itemProvider, paged) {
		this._firePaged(paged);
	},
	onRowProviderPageCountChanged: function (itemProvider, oldCount, newCount) {
		this._firePageCountChanged(oldCount, newCount);
	},
	onRowProviderPageIndexChanging: function (itemProvider, oldPage, newPage) {
		return this._firePageIndexChanging(oldPage, newPage);
	},
	onRowProviderPageIndexChanged: function (itemProvider, oldPage, newPage) {
		this._firePageIndexChanged(oldPage, newPage);
	}
});
var GroupRowImpl = defineClass("GroupRowImpl", GroupRow, {
	init: function (field, value) {
		this._super();
		this._groupField = field;
        this._value = value;
		this._footer = null;
		this._header = null;
	},
	groupField: function () {
		return this._groupField;
	},
    groupValue: function () {
        return this._value;
    },
	footer: function () {
		return this._footer;
	},
	_addChild: function (item, index, counts) {
		this._super(item, index, counts);
		if (item instanceof GroupFooter) {
			this._footer = item;
		}
	}
});
/** @internal */
var GroupedVisibleItems = function (provider) {
	var _provider = provider,
		_fixedCount = 0,
		_items = [],
		_list = [];
	var _collectChildren = function (parent, list, recursive, setFlag, level) {
		var i, cnt, item, group, f,
			footer = parent.footer(),
        	root = parent instanceof RootRow,
        	expandedAdorns = _provider.expandedAdornments(),
        	collapsedAdorns = _provider.collapsedAdornments();
		if (setFlag && parent instanceof GroupRow) {
			parent._setExpanded(true);
		}
		if (_provider.mergeMode()) {
			if (!root && RowGroupAdornments.isHeader(expandedAdorns)) {
				list.push(parent);
			}
			for (i = 0, cnt = parent.count(); i < cnt; i++) {
				item = parent.getItem(i);
				if (item instanceof GroupRow) {
					group = item;
					if (recursive && item.level() < level || group.expanded()) {
						_collectChildren(group, list, recursive, setFlag, level);
					} else {
						switch (collapsedAdorns) {
							case RowGroupAdornments.BOTH:
								list.push(group);
								if (group.footer && (f = group.footer())) {
									list.push(f);
								}
								break;
							case RowGroupAdornments.FOOTER:
                                f = group.footer();
								f && list.push(group.footer());
								break;
							case RowGroupAdornments.HEADER:
							default:
								list.push(group);
								break;
							/*
							case ROWGROUPADORNMENTS.NONE:
								list.push(group.firstLeaf());
								break;
							*/
						}
					}
				} else if (item != footer) {
					list.push(item);
				}
			}
			if (!root && footer && RowGroupAdornments.isFooter(expandedAdorns)) {
				list.push(footer);
			}
		} else {
			if (!root && RowGroupAdornments.isHeader(expandedAdorns)) {
				list.push(parent);
			}
			for (i = 0, cnt = parent.count(); i < cnt; i++) {
				item = parent.getItem(i);
				if (item instanceof GroupRow) {
					group = item;
					if (recursive && item.level() < level || group.expanded()) {
						_collectChildren(group, list, recursive, setFlag, level);
					} else {
						switch (collapsedAdorns) {
                            case RowGroupAdornments.HEADER:
                                list.push(group);
                                break;
                            case RowGroupAdornments.BOTH:
                            default:
                                list.push(group);
                                if (f = group.footer()) {
                                    list.push(f);
                                }
                                break;
                        }
					}
				} else if (!(item instanceof GroupFooter)) { // footer는 제일 마지막에
					list.push(item);
				}
			}
			if (!root && footer && RowGroupAdornments.isFooter(expandedAdorns)) {
                list.push(footer);
			}
		}
	};
	var _expandItem = function (group, recursive, setFlag, level) {
		var idx, i, f;
		if (group instanceof RootRow) {
			idx = _fixedCount;
		} else if (_provider.mergeMode()) {
			/*
			 * 현재, collapsed 상태에서만 여기가 호출된다고 가정한다.
			 * group item 이 포함되지 않는 경우가 있다.
			 * collapsed style 별로 기존 아이템들을 제거한다.
		     */
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					idx = group.index();
					_items.splice(idx, 2);
					break;
				case RowGroupAdornments.FOOTER:
                    f = group.footer();
                    if (f) {
                        idx = f.index();
                        _items.splice(idx, 1);
                    }
					break;
				case RowGroupAdornments.HEADER:
				default:
					idx = group.index();
					_items.splice(idx, 1);
					break;
			}
			if (setFlag) {
				group._index = -1;
			}
		} else {
			idx = group.index();
			/*
			 * 현재, collapsed 상태에서만 여기가 호출된다고 가정한다.
			 * 기존 group header와 footer를 제거한다.
			 */
			_items.splice(idx, 1);
			if (_provider.collapsedAdornments() != RowGroupAdornments.HEADER) {
				_items.splice(idx, 1);
			}
		}
		_list.splice(0, _list.length);
		_collectChildren(group, _list, recursive, setFlag, level > 0 ? group.level() + level : 1000000);
		for (i = 0, cnt = _list.length; i < cnt; i++) {
			_items.splice(idx + i, 0, _list[i]);
		}
	};
	var _firstIndex = function (group, check) {
		var i, idx, item, g,
			idx = group.index();
		if (idx >= 0) { 
			return idx;
		}
		if (check && group.collapsed()) {
			g = group.footer();
			if (g && (idx = g.index()) >= 0) {
				return idx;
			} else {
				return -1;
			}
		}
		for (i = 0, cnt = group.count(); i < cnt; i++) {
			item = group.getItem(i);
			if ((idx = item.index()) >= 0) {
				return idx;
			}
			g = _cast(item, GroupRow);
			if (g) {
				idx = _firstIndex(g, true);
				if (idx >= 0) {
					return idx;
				}
			}
		}
		return -1;
	};
	this.provider = function () {
		return _provider;
	};
	this.count = function () {
		return _items.length;
	};
	this.fixedCount = function () {
		return _fixedCount;
	};
	this.getItems = function () {
		return _items.slice();
	};
	this.getItem = function (index) {
		return _items[index];
	};
    this.getCheckedItem = function (index) {
        if (index >= 0 && index < _items.length) {
            return _items[index];
        }
        return null;
    };
    this.visitAll = function (callback) {
        for (var i = 0, cnt = _items.length; i < cnt; i++) {
            callback(_items[i]);
        }
    },
	this.clear = function () {
		_items.splice(0, _items.length);
	};
	this.expand = function (group, recursive, setFlag, level) {
		setFlag = arguments.length > 2 ? setFlag : true;
		level = arguments.length > 3 ? level : 0;
		_expandItem(group, recursive, setFlag, level);
		return true;
	};
	this.collapse = function (group, recursive) {
        var idx, item, f;
        if (group instanceof RootRow) {
            if (recursive) {
                for (idx = group.count(); idx--;) {
                    item = group.getChild(idx);
                    if (item instanceof GroupRow) {
                        this.collapse(item, true);
                    }
                }
                return true;
            }
            return false;
        }
		if (group instanceof GroupRow) {
			group._setExpanded(false);
		}
		if (_provider.mergeMode()) {
			idx = group.index();
			if (idx >= 0) {
				_items.splice(idx, 1);
				group._index = -1;
			} else {
				idx = _firstIndex(group);
			}
			while (idx < _items.length) {
				item = _items[idx];
				if (!item.isDescendantOf(group)) {
					break;
				}
				_items.splice(idx, 1);
                item._index = -1;
				if (recursive && item instanceof GroupRow) {
					item._setExpanded(false);
				}
			}
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					group._index = idx;
					_items.splice(idx, 0, group);
                    f = group.footer();
					if (f) {
						f._index = idx + 1;
						_items.splice(idx + 1, 0, f);
					}
					break;
				case RowGroupAdornments.FOOTER:
                    f = group.footer();
					if (f) {
						f._index = idx;
						_items.splice(idx, 0, f);
					}
					break;
				case RowGroupAdornments.HEADER:
				default:
					group._index = idx;
					_items.splice(idx, 0, group);
					break;
			}
		} else {
			idx = group.index();
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.HEADER:
					idx++;
					while (idx < _items.length && _items[idx].level() > group.level()) {
						item = _items[idx];
						_items.splice(idx, 1);
						item._index = -1;
						if (recursive && item instanceof GroupRow) {
							item._setExpanded(false);
						}
					}
					break;
				case RowGroupAdornments.BOTH:
				default:
                    f = group.footer();
					idx++;
					while (idx < _items.length && _items[idx].level() > group.level()) {
						if (f && _items[idx] == f) {
							break;
						}
						item = _items[idx];
						_items.splice(idx, 1);
						item._index = -1;
						if (recursive && item instanceof GroupRow) {
							item._setExpanded(false);
						}
					}
					if (idx >= _items.length || _items[idx] != f) {
						item = idx < _items.length < _items.length ? _items[idx] : null;
						f && _items.splice(idx, 0, f);
						if (item) {
							item._index = -1;
							if (recursive && item instanceof GroupRow) {
								item._setExpanded(false);
							}
						}
					}
					break;
			}
		}
		return true;
	};
	this.getNext = function (item) {
		if (item != null && item.visible() && item.index() < this.count() - 1) {
			return _items[item.index() + 1];
		}
		return null;
	};
	this.getPrior = function (item) {
		if (item != null && item.visible() && item.index() > 0) {
			return _items[item.index() - 1];
		}
		return null;
	};
    this.getNextData = function (item) {
        var i, cnt;
        if (item != null && item.visible() && (i = item.index()) < (cnt = this.count()) - 1) {
            while (++i < cnt) {
                if (_items[i] instanceof DataRow) {
                    return _items[i];
                }
            }
        }
        return null;
    };
	this._clearAndInit = function (source/* RowProvider */, fixedCount) {
		this.clear();
		if (source) {
			_fixedCount = Math.min(fixedCount, source.rowCount());
			for (var i = 0; i < _fixedCount; i++) {
				_items.push(source.getItem(i));
			}
		} else {
			_fixedCount = 0;
		}
	};
	this._resetIndices = function (fromIndex) {
		fromIndex = arguments.length > 0 ? fromIndex : 0;
		for (var i = fromIndex, cnt = _items.length; i < cnt; i++) {
			_items[i]._index = i;
		}
	};
    this._rearrangeGroup = function (group) {
        var i,
            idx = group.index() + 1,
            rows = group._children;
        for (i = 0; i < rows.length; i++) {
            _items[idx + i] = rows[i];
            rows[i]._index = idx + i;
        }
    };
    this._removeItem = function (item) {
        _items.splice(item.index(), 1);
    };
    this._addItem = function (item) {
        var i, child, g = _items[item.parent().index()];
		if (!g) debugger;
        for (i = g.index() + 1; i < _items.length; i++) {
            child = _items[i];
            if (child.parent() != g || child.dataIndex() < 0) {
                _items.splice(i, 0, item);
                return;
            }
        }
        _items.push(item);
    }
};
var GroupInfo = function (startIndex, endIndex, value) {
	this.level = 0;
	this.startIndex = startIndex;
	this.endIndex = endIndex;
    this.value = value;
	this.children = [];
};
var GroupedRowProvider = defineClass("GroupedRowProvider", ProxyRowProvider, {
	init: function (source, indexing) {
		this._super(source, indexing);
	},
    customRowProvider: null,
	expandedAdornments: EnumProp(RowGroupAdornments, RowGroupAdornments.BOTH),
	collapsedAdornments:EnumProp(RowGroupAdornments, RowGroupAdornments.HEADER),
	createFooterCallback: null,
	expandWhenGrouping: false,
	mergeMode: false,
	summaryMode: EnumProp(SummaryMode, SummaryMode.AGGREGATE),
	descendantCount: function () {
		return this._rootItem.descendantDataCount();
	},
    descendantRowCount: function () {
        return this._rootItem.descendantRowCount();
    },
	getDescendantRows: function (visibleOnly, dataOnly) {
		return this._rootItem.getDescendants(visibleOnly, dataOnly);
	},
    visitRows: function (visibleOnly, dataOnly, callback) {
        return this._rootItem.visitRows(visibleOnly, dataOnly, callback);
    },
	grouped: function () {
		return this._grouped;
	},
	groupCount: function () {
		return this._groupFields ? this._groupFields.length : 0;
	},
	setExpandedAdornments: function (value) {
		if (value != this._expandedAdornments) {
			this._expandedAdornments = value;
			if (this._grouped) {
                this.repopulateItems();
			}
		}
	},
	setCollapsedAdornments: function (value) {
		if (value != this._collapsedAdornments) {
			this._collapsedAdornments = value;
            if (this._grouped) {
                this.repopulateItems();
			}
		}
	},
	setCreateFooterCallback: function (value) {
		if (value != this._createFooterCallback) {
			this._createFooterCallback = value;
			if (this._grouped) {
				this.repopulateItems();
			}
		}
	},
	setMergeMode: function (value) {
		if (value != this._mergeMode) {
			this._mergeMode = value;
			if (!value) {
				this._clearDisplayLevels();
			}
            this.repopulateItems();
		}
	},
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
            this.repopulateItems();
		}
	},
    repopulateItems: function () {
		var oldCount = this.rowCount();
        this._populateItems();
		try {
			this._fireRefresh();
		} finally {
			this._fireCountChanged(oldCount, this.rowCount());
		}
    },
    canGrouping: function (fields) {
        return this._fireGrouping(fields);
    },
	groupBy: function (fields) {
		this.groupByMode(fields, this._mergeMode);
	},
	groupByMode: function (fields, mergeMode) {
        var oldCount = this.rowCount();
		if (this._editing) {
			return;
		}
		this._mergeMode = mergeMode;
		this._groupFields = fields ? fields.concat() : null;
		if (!mergeMode) {
			this._clearDisplayLevels();
		}
		this._populateItems(true);
		try {
			this._fireRefresh();
		} finally {
			this._fireGrouped();
            this._fireCountChanged(oldCount, this.rowCount());
		}
	},
	isGroupedField: function (field) {
		if (this._groupFields) {
			for (var i = this._groupFields.length; i--;) {
				if (this._groupFields[i] == field) {
					return true;
				}
			}
		}
		return false;
	},
	getGroupLevel: function (field) {
		if (this._groupFields && field >= 0) {
			for (var i = this._groupFields.length; i--;) {
				if (this._groupFields[i] == field) {
					return i + 1;
				}
			}
		}
		return 0;
	},
	getGroupedFields: function () {
		return this._groupFields ? this._groupFields.concat(): null;
	},
	expand: function (group, recursive, force, level) {
        var i, c,
            oldCount = this.rowCount(),
            expanded = false;
		if (this._editing) {
			return;
		}
        if (!group) {
            if (recursive && force) {
                group = this._rootItem
                if (!this._fireExpand(group)) {
                    return;
                }
                for (i = group.count(); i--;) {
                    c = group.getChild(i);
                    if (c instanceof GroupRow) {
                        if (c.expanded()) {
                            this._visibleItems.collapse(c, false);
                        }
                        expanded = this._visibleItems.expand(c, true) || expanded;
                    }
                }
                if (expanded) {
                    this._resetItemIndices(0);
                }
            }
        } else if (group && (force || !group.expanded())) {
            if (!this._fireExpand(group)) {
                return;
            }
			if (group.expanded()) {
				this._visibleItems.collapse(group, false);
			}
			if (expanded = this._visibleItems.expand(group, recursive)) {
				this._resetItemIndices(group.index());
			}
		}
        if (expanded) {
            try {
                this._fireRefresh();
            } finally {
                this._fireExpanded(group);
                this._fireCountChanged(oldCount, this.rowCount());
            }
        }
	},
	collapse: function (group, recursive, force) {
        var oldCount = this.rowCount();
		if (this._editing) {
			return;
		}
        group = group || this._rootItem;
		if (group && (force || group.expanded())) {
            if (!this._fireCollapse(group)) {
                return;
            }
            if (this._visibleItems.collapse(group, recursive)) {
                this._resetItemIndices(group.index());
                try {
                    this._fireRefresh();
                } finally {
                    this._fireCollapsed(group);
                    this._fireCountChanged(oldCount, this.rowCount());
                }
            }
        }
	},
	reveal: function (row) {
		if (row) {
			if (!row.visible()) {
				var p = row.parent();
				while (p.parent() != this._rootItem) {
					p = p.parent();
				}
				this.expand(p, true, true, row.level() - p.level());
			}
			return row.visible();
		}
	},
    getNextDataRow: function (row) {
        return this._grouped ? this._visibleItems.getNextData(row) : this._source.getItem(row.index() + 1);
    },
	rowCount: function () {
		return this._grouped ? this._visibleItems.count() : this._source.rowCount();
	},
    canInsert: function (row) {
        if (row && !(row instanceof DataRow)) {
            row = this.getNextDataRow(row);
        }
        return this._super(row);
    },
    $_visitChildren: function (parent, callback) {
        for (var i = 0, cnt = parent.count(); i < cnt; i++) {
            var item = parent.getItem(i);
            if (item instanceof GridRow) {
                callback(item);
            }
            if (item instanceof  GroupRow) {
                this.$_visitChildren(item, callback);
            }
        }
    },
    visitAll: function (callback, visibleOnly) {
        if (visibleOnly || !this._grouped) {
            if (this._grouped) {
                this._visibleItems.visitAll(callback);
            } else {
                this._super(callback);
            }
        } else {
            var cnt = this._visibleItems.fixedCount();
            if (cnt > 0) {
                for (var i = 0; i < cnt; i++) {
                    callback(this.getItem(i));
                }
            }
            this.$_visitChildren(this._rootItem, callback);
        }
        this._editItem && callback(this._editItem);
    },
	getItem: function (index) {
		if (this._grouped) {
            return this._visibleItems.getCheckedItem(index);
		} else {
			return this._source.getItem(index);
		}
	},
	getItems: function (index, count) {
		if (this._grouped) {
			var items = [];
			var end = Math.min(this._visibleItems.count(), index + count - 1);
			for (var i = index; i < end; i++) {
				var item = this._visibleItems.getItem(i);
				items.push(item);
			}
			return items;
		} else {
			return this._source.getItems(index, count);
		}
	},
	getAllItems: function () {
        var items;
        if (this._grouped) {
			items = new GroupedVisibleItems(this);
            items._clearAndInit(this._source, this.fixedCount());
			items.expand(this._rootItem, true, false);
			return items.getItems();
		} else if (items = this._source) {
			return items.getAllItems();
		} else {
			return null;
		}
	},
	getTopItems: function () {
		if (this._grouped) {
			return this._rootItem.children();
		} else {
			return this._source.getAllItems();
		}
	},
	getLeafItems: function (visibleOnly, dataOnly) {
		if (this._grouped) {
			return this._rootItem.getLeaves(visibleOnly, dataOnly);
		} else {
			return this._source.getAllItems();
		}
	},
	getDistinctValues: function (field, maxCount, ignoreCase) {
		return this._super(field, maxCount, ignoreCase);
	},
	setFixed: function (count, sorting, filtering) {
		this._super(count, sorting, filtering);
	},
	_initialize: function () {
		this._super();
		this._visibleItems = new GroupedVisibleItems(this);
		this._rootItem = new RootRow(this);
        this._dataGroups = [];
        this._groupFields = null;
        this._groupSorting = false;
        this._summarizing = false;
        this._grouped = false;
        this._editItem = null;
        this._editing = false;
    },
	_clearItems: function () {
		this._visibleItems.clear();
		this._rootItem.clear();
        this._dataGroups = [];
	},
	_populateItems: function (countEvents) {
        var source, ds, i, srcCount,
			oldGrouped = this._grouped;
			oldCount = this._rootItem._descendantRowCount;
		try {
			this._clearItems();
			source = this._source;
			if (!source) {
				return;
			}
			ds = this.dataSource();
			if (!ds) {
				return;
			}
			oldGrouped = this._grouped;
			if (this._groupFields) {
				for (i = this._groupFields.length - 1; i >= 0; i--) {
					if (this._groupFields[i] >= ds.fieldCount()) {
						this._groupFields.splice(i, 1);
					}
				}
				this._grouped = this._groupFields.length > 0;
			} else {
				this._grouped = false;
			}
			srcCount = source.rowCount();
			if (this._grouped && srcCount > 0) {
				this._buildGroupItems(srcCount);
				this.$_resetVisibleItems();
			} else {
				this._rootItem._descendantRowCount = srcCount;
			}
			if (this._grouped != oldGrouped) {
				this.onGroupedChanged && this.onGroupedChanged(this, this._grouped);
			}
		} finally {
			if (countEvents || this._grouped != oldGrouped) {
				srcCount = this._rootItem._descendantRowCount;
				if (srcCount != oldCount) {
					this._fireRowCountChanged(oldCount, srcCount);
				}
			}
		}
	},
	_resetItemIndices: function (fromIndex) {
		if (this.isIndexing() && this._grouped) {
			this._visibleItems._resetIndices(fromIndex);
		} else {
			this._super(fromIndex);
		}
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		var i, item, types, found, c, rows, flds, i, item, found, c, all, sensitive, partial,
			ds = this.dataSource();
		if (!ds) {
			return -1;
		}
		rows = this.rowCount();
		if (rows < 1) {
			return -1;
		}
		flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
        types = [];
        for (i = 0; i < flds; i++) {
            types.push(ds.getField(fields[i]).dataType() == ValueType.TEXT);
        }
		all = !options || options.allFields === undefined || options.allFields;
        textMatch = options && options.textMatch;
		sensitive = options && options.caseSensitive;
		partial = options && options.partialMatch;
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		for (i = startIndex; i <= endIndex; i++) {
			item = this.$_getItem(i);
			found = item.dataIndex() >= 0;
			if (found) {
				for (c = 0; c < flds; c++) {
                    if (textMatch || types[c]) {
                        found = $$_compareTextValue(values[c], item.getValue(fields[c]), sensitive, partial);
                    } else {
                        found = values[c] == item.getValue(fields[c]);
                    }
					if (found && !all) {
						return i;
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
	findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		var rows = this.rowCount();
		if (rows < 1) {
			return null;
		}
		var types, textMatch, sensitive, partial, fldLen, i, item, c, f, found;
		textMatch = options && options.textMatch;
		sensitive = options && options.caseSensitive;
		partial = options && options.partialMatch;
        fldLen = fields.length;
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		startFieldIndex = Math.max(0, startFieldIndex);
		types = [];
		for (i = 0; i < fldLen; i++) {
			types.push(ds.getField(fields[i]).dataType() == ValueType.TEXT);
		}
		if (startFieldIndex >= fields.length) {
			startIndex++;
			startFieldIndex = 0;
		}
		for (i = startIndex; i <= endIndex; i++) {
			item = this.$_getItem(i);
			if (item.dataIndex() >= 0) {
                c = (i > startIndex) ? 0 : startFieldIndex;
				for (; c < fldLen; c++) {
					f = fields[c];
					if (textMatch || types[c]) {
						found = $$_compareTextValue(value, item.getValue(f), sensitive, partial);
					} else {
						found = value == item.getValue(f);
					}
					if (found) {
						return {
							rowIndex: i,
							fieldIndex: f,
							fieldName: ds.getFieldName(f),
							searchFieldIndex: c
						};
					}
				}
			}
		}
		return null;
	},
	onRowProviderReset: function (itemProvider) {
        var oldRows = this._rootItem.descendantRowCount();
		var oldCount = this.rowCount();
		this._super(itemProvider);
		this._fireRowCountChanged(oldRows, this._rootItem.descendantRowCount());
		this._fireCountChanged(oldCount, this.rowCount());
	},
	onRowProviderRefresh: function (itemProvider) {
        var oldRows = this._rootItem.descendantRowCount();
		var oldCount = this.rowCount();
		this._super(itemProvider);
        this._fireRowCountChanged(oldRows, this._rootItem.descendantRowCount());
		this._fireCountChanged(oldCount, this.rowCount());
	},
	onRowProviderSummaryCleared: function (rs) {
		this._grouped && this._rootItem._clearSummary();
	},
	onRowProviderCountChanged: function (itemProvider, oldCount, newCount) {
		this._fireDataCountChanged(oldCount, newCount);
		!this._grouped && this._fireCountChanged(oldCount, newCount);
	},
	onRowProviderItemInserted: function (itemProvider, item) {
        var g, i, r, oldRows,
            visItems = this._visibleItems,
            oldCount = this.rowCount();
        if (this._grouped) {
            g = this.$_findDataParent(item);
            if (g) {
				oldRows = this._rootItem.descendantRowCount();
                for (i = g.count(); i--;) {
					r = g.getChild(i).dataIndex();
                    if (r >= 0 && r < item.dataIndex()) {
                        break;
                    }
                }
                g.insert(i + 1, item, true);
				this._groupSorting && this.$_sortDataGroup(g);
				if (this.$_isVisibleDataParent(g)) {
                    visItems._addItem(item);
                    visItems._rearrangeGroup(g);
                }
				this._incDescendants(g, 1, 0);
				this._super(itemProvider, item);
				this._fireRowCountChanged(oldRows, this._rootItem.descendantRowCount());
            } else {
                this._populateItems(true);
            }
			this._fireRefresh();
			this._fireCountChanged(oldCount, this.rowCount());
		} else {
			this._super(itemProvider, item);
			this._fireRowCountChanged(oldCount - 1, this.rowCount());
		}
	},
	onRowProviderItemDeleted: function (itemProvider, item) {
        var g,
            visItems = this._visibleItems,
		    oldCount = this.rowCount();
		if (this._grouped) {
			g = item.parent();
			if (g) {
				if (g.descendantDataCount() > 1) {
					oldRows = this._rootItem._descendantRowCount;
					g.remove(item);
					if (this.$_isVisibleDataParent(g)) {
						visItems._removeItem(item);
						visItems._rearrangeGroup(g);
					}
					this._incDescendants(g, -1, 0);
					this._super(itemProvider, item);
					this._fireRowCountChanged(oldRows, this._rootItem._descendantRowCount);
				} else {
					this._populateItems(true);
				}
				this._fireRefresh();
			}
			this._fireCountChanged(oldCount, this.rowCount());
		} else {
			this._super(itemProvider, item);
			this._fireRowCountChanged(oldCount + 1, this.rowCount());
		}
	},
	onRowProviderItemUpdated: function (itemProvider, item) {
		var g, gOld, rows, i,
            visItems = this._visibleItems,
            oldCount = this.rowCount();
        if (this._grouped) {
            if (this.$_isValidChild(item)) {
                g = item.parent();
				this._groupSorting && this.$_sortDataGroup(g);
                if (this.$_isVisibleDataParent(g)) {
                    visItems._rearrangeGroup(g);
                }
            } else {
                gOld = item.parent();
                g = this.$_findDataParent(item);
                if (g) {
                    gOld.remove(item);
                    for (i = g.count(); i--;) {
                        if (g.getChild(i).dataIndex() >= 0) {
                            break;
                        }
                    }
                    g.insert(i + 1, item);
                    if (this.$_isVisibleDataParent(gOld)) {
                        visItems._removeItem(item);
                        visItems._rearrangeGroup(gOld);
                    }
					this._incDescendants(gOld, 1, 0);
                    this.$_sortDataGroup(g);
                    if (this.$_isVisibleDataParent(g)) {
                        visItems._addItem(item);
                        visItems._rearrangeGroup(g);
                    }
					this._incDescendants(gOld, -1, 0);
					this._super(itemProvider, item);
                } else {
                    this._populateItems(true);
                }
            }
            this._fireRefresh();
			this._fireCountChanged(oldCount, this.rowCount());
		} else {
			this._super(itemProvider, item);
		}
	},
	$_setEditing: function (value) {
		this._editing = value;
	},
	$_getItem: function (index) {
		return this._grouped ? this._visibleItems.getItem(index) : this._source.getItem(index);
	},
	$_resetVisibleItems: function () {
		this._visibleItems._clearAndInit(this._source, this.fixedCount());
		if (this._source) {
			if (this._source.rowCount() > this._visibleItems.fixedCount()) {
				this._visibleItems.expand(this._rootItem, false);
			}
		}
		this._resetItemIndices(0);
	},
    $_isChildOf: function (row, group, ds, fields) {
        var i, f, v, gv, ds, flds, g;
        ds = ds || this.dataSource(),
        flds = fields || this._groupFields,
        g = group || row.parent();
        for (i = flds.length; i--;) {
            f = flds[i];
            v = row.getValue(f);
            gv = g.groupValue();
            if (!ds.getField(f).equalValues(v, gv)) {
                return false;
            }
            g = g.parent();
        }
        return true;
    },
    $_isValidChild: function (row) {
        return this.$_isChildOf(row);
    },
	$_isVisibleDataParent: function (group) {
		if (group.expanded()) {
			var p = group.parent();
			while (p) {
				if (!p.expanded()) return false;
				p = p.parent();
			}
			return true;
		}
	},
    $_findDataParent: function (row) {
        var i,
            ds = this.dataSource(),
            flds = this._groupFields,
            groups = this._dataGroups;
        for (i = groups.length; i--;) {
            if (this.$_isChildOf(row, groups[i], ds, flds)) {
                return groups[i];
            }
        }
        return null;
    },
    $_sortDataGroup: function (group) {
        var rows = group._children,
            i = 0,
            j = rows.length - 1;
        while (i < j) {
            if (!(rows[i] instanceof DataRow)) {
                i++;
            } else {
                break;
            }
        }
        while (i < j) {
            if (!(rows[j] instanceof DataRow)) {
                j--;
            } else {
                break;
            }
        }
        this._source.$_sortLevel(this._groupFields.length, i, j, rows);
    },
	_buildGroupItems: function (sourceCount) {
		if (sourceCount > this.fixedCount()) {
			var ginfo = new GroupInfo(this.fixedCount(), sourceCount - 1);
			this._buildGroups(ginfo, this._source, this._groupFields);
			this._buildItems(this._rootItem, ginfo, this._groupFields, this._createFooterCallback);
			if (this._mergeMode) {
				this._clearDisplayLevels();
				this.$_resetDisplayLevels(this._rootItem);
			}
		}
	},
	$_resetDisplayLevels: function (group) {
		for (var i = 0, cnt = group.count(); i < cnt; i++) {
			var g = _cast(group.getItem(i), GroupRow);
			if (g) {
				var row = _cast(g.firstLeaf(), DataRow);
				if (row && row._displayLevel < 0) {
					row._displayLevel = g.level;
				}
				this.$_resetDisplayLevels(g);
			}
		}
	},
	_buildGroups: function (parent, source, groupFields) {
		var startIndex, endIndex, level, field, fld, ginfo, priorVal, i, val, cnt;
		if (groupFields.length <= parent.level) {
			return;
		}
		startIndex = parent.startIndex;
		endIndex = parent.endIndex;
		if (endIndex < startIndex) {
			return;
		}
		level = parent.level + 1;
		field = groupFields[parent.level];
        fld = this.dataSource().getField(field);
        priorVal = source.getItem(startIndex).getValue(field);
		ginfo = new GroupInfo(startIndex, startIndex, priorVal);
		ginfo.level = level;
		parent.children.push(ginfo);
		for (i = startIndex + 1; i <= endIndex; i++) {
			val = source.getItem(i).getValue(field);
            if (!fld.equalValues(val, priorVal)) {
                ginfo.endIndex = i - 1;
				ginfo = new GroupInfo(i, i, val);
				ginfo.level = level;
				parent.children.push(ginfo);
			}
			priorVal = val;
		}
        ginfo.endIndex = endIndex;
		cnt = parent.children.length;
		for (i = 0; i < cnt; i++) {
			this._buildGroups(parent.children[i], source, groupFields);
		}
	},
	_buildItems: function (parent, info, groupFields, footerCalback) {
        var list, cnt, field, i, group, child, rows, items, footer,
            merged = this._mergeMode,
		    level = parent.level();
		if (level > 0) {
			if (this._customRowProvider) {
				list = [];
				this._customRowProvider.getCustomHeaderRows(parent, list);
				if (list.length > 0) {
                    parent.addAll(list);
                    this._incDescendants(parent, 0, list.length);
                }
			}
		}
		cnt = info.children.length;
		if (cnt > 0) {
			field = groupFields[info.level];
			for (i = 0; i < cnt; i++) {
                child = info.children[i];
				group = merged ? new MergedGroupHeader(field, child.value) : new GroupRowImpl(field, child.value);
				group._setExpanded(this.expandWhenGrouping());
				parent.add(group);
                this._incDescendants(parent, 0, 1);
				this._buildItems(group, child, groupFields, footerCalback);
			}
            if (level == groupFields.length - 1) {
                for (i = 0; i < cnt; i++) {
                    this._dataGroups.push(parent.getChild(i));
                }
            }
		} else {
			rows = info.endIndex - info.startIndex + 1;
			items = this._source.getItems(info.startIndex, rows);
			parent.addAll(items);
			this._incDescendants(parent, items.length, 0);
		}
		if (level > 0) { // excepts root
            if (this._customRowProvider) {
                list = [];
                this._customRowProvider.getCustomFooterRows(parent, list);
                if (list.length > 0) {
                    parent.addAll(list);
                    this._incDescendants(parent, 0, list.length);
                }
            }
			if (!footerCalback || footerCalback(parent, merged) !== false) {
				footer = merged ? new MergedGroupFooter() : new GroupFooter();
				parent.add(footer);
				this._incDescendants(parent, 0, 1);
			}
		}
	},
	_setEditItem: function (item) {
		this._editItem = item;
	},
	_fireGrouping: function (fields) {
		return this.fireConfirmEvent(GroupedRowProvider.GROUPING, fields);
	},
	_fireGrouped: function () {
		this.fireEvent(GroupedRowProvider.GROUPED);
	},
	_fireExpand: function (group) {
		return this.fireConfirmEvent(GroupedRowProvider.EXPAND, group);
	},
	_fireExpanded: function (group) {
		this.fireEvent(GroupedRowProvider.EXPANDED, group);
	},
	_fireCollapse: function (group) {
		return this.fireConfirmEvent(GroupedRowProvider.COLLAPSE, group);
	},
	_fireCollapsed: function (group) {
		this.fireEvent(GroupedRowProvider.COLLAPSED, group);
	}
}, {
    GROUPING: "onGroupedRowProviderGrouping",
    GROUPED: "onGroupedRowProviderGrouped",
    EXPAND: "onGroupedRowProviderExpand",
    EXPANDED: "onGroupedRowProviderExpanded",
    COLLAPSE: "onGroupedRowProviderCollapse",
    COLLAPSED: "onGroupedRowProviderCollapsed"
});
var OP_NONE = 0;
var OP_EDIT = 1;
var OP_INSERT = 2;
var OP_APPEND = 3;
var OP_COMMIT = 4;
var OP_CANCEL = 5;
/** @abstract */
var EditableRowProvider = defineClass("EditableRowProvider", ProxyRowProvider, {
	init: function (source, indexing) {
		this._super(source, indexing);
		this._currentIndex = -1;
		this._currentChanging = false;
        this._currentValues = {};
		this._operation = OP_NONE;
		this._orgItem = null;
		this._editingItem = null;
		this._insertMode = 0;
		this._modified = false;
		this._commiting = false;
		this._saveDs = null;
		if (source && (this._saveDs = source.dataSource())) {
			this._saveDs.registerClient(this);
		}
        this._editCommands = new EditCommandStack(this);
	},
	isDataEditing: function (ds) {
        if (this._autoCommit) {
            this.commit();
        }
		return this.isEditing();
	},
	cancelDataEditing: function (ds) {
		if (this.isEditing()) {
			this._fireCancelRequest(ds);
		}
	},
	commitDataEditing: function (ds) {
		if (this.isEditing()) {
			this._fireCommitRequest();
		}
	},
	dataRefreshRequested: function (ds) {
		this._fireRefresh();
	},
    onEditCommandStackChanged: function (stack, canUndo, canRedo) {
        var ds = this._saveDs;
        if (ds) {
            this._fireUndoStateChanged(canUndo || ds.canUndo(), canRedo || ds.canRedo());
        } else {
            this._fireUndoStateChanged(canUndo, canRedo);
        }
    },
    onCurrentChanged: null,
    undoable: false,
    autoCommit: false,
    cancelWhenUndo: true,
    editingState: EnumProp(GridRowState, GridRowState.NORMAL),
    checkDiff: false,
    checkCellDiff: false,
    strictDiff: false,
    currentIndex: -1,
    setUndoable: function (value) {
        if (value != this._undoable) {
            this._undoable = value;
            this._editCommands.flush();
        }
    },
    setEditingState: function (value) {
        if (value != this._editingState) {
            var oldState = this._editingState;
            this._editingState = value;
            this._editingStateChanged(oldState, value);
        }
    },
    isUpdating: function () {
        return this._editingState == GridRowState.UPDATING;
    },
    isInserting: function () {
        return this._editingState == GridRowState.INSERTING;
    },
    isAppending: function () {
        return this._editingState == GridRowState.APPENDING;
    },
    isAdding: function () {
        return this._editingState == GridRowState.INSERTING || this._editingState == GridRowState.APPENDING;
    },
	setCurrentIndex: function (value) {
		if (!this._currentChanging) {
            value = value instanceof GridRow ? value.index() : parseInt(value);
            if (!isNaN(value)) {
                this._currentChanging = true;
                try {
                    this._doSetCurrent(value);
                } finally {
                    this._currentChanging = false;
                }
            }
		}
		return this;
	},
    /** @deprecated Use currentIndex */
    current: function () { return this.currentIndex(); },
    /** @deprecated Use setCurrentIndex */
    setCurrent: function (value) { this.setCurrentIndex(value); },
    currentRow: function () {
        var curr = this._currentIndex;
        return curr >= 0 && curr < this.rowCount() ? this.getItem(curr) : null;
    },
    currentDataRow: function () {
        var curr = this._currentIndex;
        return curr >= 0 && curr < this.rowCount() ? _cast(this.getItem(curr), DataRow) : null;
    },
    currentValues: function () {
        return this._currentValues;
    },
	editingItem: function () {
		return (this._commiting || this.isEditing()) ? this._editingItem : null;
	},
    execute: function (command) {
        this.undoable() ? this._editCommands.execute(command) : command.execute();
    },
    canUndo: function () {
        return this._editCommands.canUndo() || this._saveDs && this._saveDs.canUndo();
    },
    canRedo: function () {
        return this._editCommands.canRedo() || this._saveDs && this._saveDs.canRedo();
    },
    undo: function () {
        if (this.isEditing()) {
            if (this._editCommands._current > 0 || this._cancelWhenUndo) {
                this._editCommands.undo();
            }
        } else if (this._saveDs) {
            this._saveDs.undo();
        }
        return this;
    },
    redo: function () {
        this.isEditing() ? this._editCommands.redo() : (this._saveDs && this._saveDs.redo());
        return this;
    },
    clearUndo: function (clearData) {
        this._editCommands.flush();
        clearData && this._saveDs && this._saveDs.clearUndo();
    },
	update: function () {
        if (this.isUpdating()) {
            return true;
        }
        if (!this.isEditing() && this._currentIndex >= 0 && this._currentIndex < this.rowCount()) {
            try {
                return this.$_beginUpdate(this.getItem(this._currentIndex));
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	append: function (defaultValues, useViewDefaults) {
        if (this.isAppending()) {
            return true;
        }
		if (!this.isEditing()) {
            try {
                return this.$_beginAppend(defaultValues, useViewDefaults);
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	insert: function (defaultValues, useViewDefaults, shift, ctrl) {
        if (this.isInserting()) {
            return true;
        }
		if (!this.isEditing() && this._currentIndex >= 0 && this._currentIndex < this.rowCount()) {
            try {
                return this.$_beginInsert(this.getItem(this._currentIndex), defaultValues, useViewDefaults, shift, ctrl);
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	remove: function (item) {},
	removeAll: function (item) {},
	getRemovableRows: function (items) { return null; },
	removeRows: function (rows) {},
	cancel: function () {
		if (this.isEditing()) {
			return this._cancelEdit();
		}
        return false;
	},
	commit: function (field) {
        var ds, values, cnt, diff, strict, i;
		if (this.isEditing()) {
			this._commiting = true;
			try {
                ds = this.dataSource();
                if (ds) {
                    if (this.isUpdating() && this.checkDiff()) {
                        diff = false;
                        strict = this.strictDiff();
                        values = this._editingItem.values();
                        if (field >= 0) { // cell commit
                            if (strict) {
                                diff = !ds.getField(field).equalValues(this._orgItem.getValue(field), values[field]);
                            } else {
                                diff = !ds.getField(field).sameValues(this._orgItem.getValue(field), values[field]);
                            }
                        } else {
                            cnt = values.length;
                            for (i = 0; i < cnt; i++) {
                                if (strict) {
                                    if (!ds.getField(i).equalValues(this._orgItem.getValue(i), values[i])) {
                                        diff = true;
                                        break;
                                    }
                                } else {
                                    if (!ds.getField(i).sameValues(this._orgItem.getValue(i), values[i])) {
                                        diff = true;
                                        break;
                                    }
                                }
                            }
                            if (!diff) {
                                this._cancelEdit();
                                return true;
                            }
                        }
                    }
                    return this.$_commitEdit(ds, field);
                }
			} finally {
				this._commiting = false;
			}
		}
		return false;
	},
	isEditing: function (row) {
		return GridRowState.isEditing(this._editingState) && (!row || row === this._editingItem || (GridRowState.isUpdating(this._editingState) && row === this._orgItem));
	},
	isEdited: function (row) {
		return GridRowState.isEditing(this._editingState) && (!row || row === this._editingItem || (GridRowState.isUpdating(this._editingState) && row === this._orgItem)) && this._modified;
	},
    isCellEdited: function (row, field) {
        return this.isEdited(row) && row.isValueEdited(field);
    },
    setDiffs: function (check, cell, strict) {
        this._checkDiff = check;
        this._checkCellDiff = cell;
        this._strictDiff = strict;
        if (this.isEditing()) {
            this._editingItem.setDiffs(cell, strict);
        }
    },
	rowCount: function () {
		return this.source().rowCount();
	},
	onRowProviderReset: function (itemProvider) {
        var ds = this.dataSource();
        if (!ds) {
            this._editingState = GridRowState.NORMAL;
            this._editingItem = null;
        }
		this._super(itemProvider);
		if (ds != this._saveDs) {
			this._saveDs && this._saveDs.unregisterClient(this);
			this._saveDs = ds;
			this._saveDs && this._saveDs.registerClient(this);
            this._currentValues = ds ? ds.getEmptyObject() : {};
		}
	},
    onRowProviderRefresh: function (itemProvider) {
        if (this.isEditing()) {
            var r, item,
                ds = this.dataSource(),
                editItem = this._editingItem;
            this._resetItemIndices(0);
            if (this.isUpdating()) {
                r = ds.getRowById(editItem._rowId);
                if (r < 0) {
                    this._cancelEdit();
                } else {
                    item = itemProvider.getItemOfRow(r);
                    editItem._dataIndex = item.dataIndex();
                }
            } else if (this.isInserting()) {
                r = ds.getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                editItem._dataIndex = item.dataIndex();
            } else if (this.isAppending()) {
            }
            this._editingItem && this.$_checkCurrent(this._editingItem._index, true);
        }
        this._super(itemProvider);
    },
    onRowProviderUndoStateChanged: function (itemProvider, canUndo, canRedo) {
        var stack = this._editCommands;
        this._fireUndoStateChanged(canUndo || stack.canUndo(), canRedo || stack.canRedo());
    },
    onRowProviderItemInserted: function (itemProvider, item) {
        if (this.isEditing()) {
            var r,
                ds = this.dataSource(),
                editItem = this._editingItem;
            this._resetItemIndices(0);
            if (this.isUpdating()) {
                r = ds.getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                editItem._index = item.index();
                editItem._dataIndex = item.dataIndex();
            } else if (this.isInserting()) {
                r = ds.getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                editItem._index = item.index();
                editItem._dataIndex = item.dataIndex();
            } else if (this.isAppending()) {
                editItem._index = Math.min(editItem._index, this.rowCount() - 1);
            }
            this._editingItem && this.$_checkCurrent(this._editingItem._index, true);
        }
        this._super(itemProvider, item);
    },
    onRowProviderItemDeleted: function (itemProvider, item) {
        if (this.isEditing()) {
            var r,
                editItem = this._editingItem;
            this._resetItemIndices(0);
            if (this.isUpdating()) {
                if (item.$_rowId == editItem._rowId) {
                    this._cancelEdit();
                } else {
                    r = this.dataSource().getRowById(editItem._rowId);
                    item = itemProvider.getItemOfRow(r);
                    editItem._index = item.index();
                    editItem._dataIndex = item.dataIndex();
                }
            } else if (this.isInserting()) {
                r = this.dataSource().getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                editItem._index = item.index();
                editItem._dataIndex = item.dataIndex();
            } else if (this.isAppending()) {
                editItem._index = Math.min(editItem._index, this.rowCount() - 1);
            }
            this._editingItem && this.$_checkCurrent(this._editingItem._index, true);
        }
        EditableRowProvider.Base.onRowProviderItemDeleted.call(this, itemProvider, item);
    },
    onRowProviderItemUpdated: function (itemProvider, item) {
        if (this.isEditing()) {
            var r,
                editItem = this._editingItem;
            this._resetItemIndices(0);
            if (this.isUpdating()) {
                r = this.dataSource().getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                if (item) {
                    editItem._index = item.index();
                    editItem._dataIndex = item.dataIndex();
                } else {
                    this._cancelEdit();
                }
            } else if (this.isInserting()) {
                r = this.dataSource().getRowById(editItem._rowId);
                item = itemProvider.getItemOfRow(r);
                if (item) {
                    editItem._index = Math.max(0, item.index() - 1);
                    editItem._dataIndex = item.dataIndex();
                } else {
                    var i = Math.max(0, Math.min(itemProvider.rowCount(), editItem._index));
                    editItem._index = i;
                    editItem._dataIndex = itemProvider.getRow(i).dataIndex();
                }
            } else if (this.isAppending()) {
                editItem._index = Math.min(editItem._index, this.rowCount() - 1);
            }
            this._editingItem && this.$_checkCurrent(this._editingItem._index, true);
        }
        this._super(itemProvider, item);
    },
	_doSetCurrent: function (value) {
		var oldIndex = this._currentIndex;
		value = Math.max(-1, Math.min(value, this.rowCount() - 1));
		if (value == oldIndex) {
			return;
		}
		try {
			if (!this.fireConfirmEvent(EditableRowProvider.CURRENT_CHANGING, oldIndex, value)) {
				return;
			}
			oldIndex = this._currentIndex;
			if (value == oldIndex) {
				return;
			}
			if (this.isEditing() && value != this._editingItem.index()) {
				if (!this.commit()) {
                    if (this.isEdited()) {
                        return;
                    }
                    this.cancel();
				}
			}
		} catch (err) {
			if (err instanceof ValidationError) {
				_alert(err.message ? err.message : err.toString());
				_throwDebug(err);
				return;
			}
			if (err instanceof AbortError) {
				return;
			}
			throw err;
		}
        this._currentIndex = value;
        this.$_refreshCurrentValues();
        this.fireEvent(EditableRowProvider.CURRENT_CHANGED, oldIndex, value);
        this.onCurrentChanged && this.onCurrentChanged(this, value, oldIndex);
	},
    $_refreshCurrentValues: function () {
        var item, p,
            vals = this._currentValues,
            idx = this._currentIndex;
        if (idx >= 0) {
            item = this.getItem(idx);
            if (item) {
                return item.copyToObject(vals);
            }
        }
        for (p in vals) {
            vals[p] = undefined;
        }
    },
	_editingStateChanged: function (oldState, newState) {
	},
	_checkEditing: function () {
		if (!this.isEditing()) {
			throw new Error("itemProvider is not editing");
		}
	},
	_checkNotEditing: function () {
		if (this.isEditing()) {
			throw new Error("itemProvider is already editing");
		}
	},
	$_checkCurrent: function (index, noCommit) {
		if (index != this._currentIndex) {
			var oldIndex = this._currentIndex;
			this._currentIndex = index;
			this._fireCurrentChanged(oldIndex, index, noCommit);
		}
	},
	$_beginUpdate: function (row) {
		if (!row || !this._fireUpdating(row)) {
			return false;
		}
		if (DataRowState.isDeleted(row.dataState())) {
			return false;
		}
        this._orgItem = null;
		this._modified = false;
		this._editingItem = this._doBeginUpdate(row);
		if (this._editingItem) {
			this._editingItem.beginEdit(this.checkCellDiff(), this.strictDiff());
			this._orgItem = row;
			this.setEditingState(GridRowState.UPDATING);
			this._doEditingStarted(this._editingItem);
            this.$_checkCurrent(this._editingItem.index());
            this._fireUpdateStarted(this._editingItem);
            return true;
		}
        return false;
	},
	_doBeginUpdate: function (row) {
		return null;
	},
	$_beginAppend: function (defaultValues, useViewDefaults) {
        var oldIndex,
            defs = useViewDefaults ? [] : undefined;
        if (!this._fireAppending(defs)) {
            return false;
        }
        if (defs) {
            if (_isArray(defaultValues)) {
            } else {
                defaultValues = defs;
            }
        }
        oldIndex = this._currentIndex;
        this._modified = false;
		this._editingItem = this._doBeginAppend(defaultValues);
		if (this._editingItem) {
			this._editingItem.beginEdit(this.checkCellDiff(), this.strictDiff());
			this.setEditingState(GridRowState.APPENDING);
			this._resetItemIndices(0);//this._editingItem.index());
            this._doEditingStarted(this._editingItem);
            this.$_checkCurrent(this._editingItem.index());
            this._fireAppendStarted(this._editingItem);
            return true;
		}
        return false;
	},
	_doBeginAppend: function (defaultValues) {
		return null;
	},
	$_beginInsert: function (row, defaultValues, useViewDefaults, shift, ctrl) {
        var defs = useViewDefaults ? [] : undefined;
        if (!row || !this._fireInserting(row, defs, shift, ctrl)) {
            return false;
        }
        if (defs) {
            if (_isArray(defaultValues)) {
            } else {
                defaultValues = defs;
            }
        }
		this._modified = false;
		this._editingItem = this._doBeginInsert(row, defaultValues, shift, ctrl);
		if (this._editingItem) {
			this._editingItem.beginEdit(this.checkCellDiff(), this.strictDiff());
			this.setEditingState(GridRowState.INSERTING);
			this._resetItemIndices(0);//this._editingItem.index());
			this._doEditingStarted(this._editingItem);
            this.$_checkCurrent(this._editingItem.index());
            this._fireInsertStarted(this._editingItem);
            return true;
		}
        return false;
	},
	_doBeginInsert: function (row, defaultValues, useViewDefaults) {
		return null;
	},
	_cancelEdit: function () {
		this._checkEditing();
		var index, item,
            saveState = this._editingState;
		try {
            index = this._editingItem.index() - (this.isAppending() ? 1 : 0);
			this.setEditingState(GridRowState.NORMAL);
			this._doCancelEdit(saveState, this._orgItem);
		} catch (err) {
			this._editingState = saveState;
			throw err;
		}
        item = this._orgItem;
		this._modified = false;
		this._orgItem = null;
		this._doEditingFinished(false);
        this._editingItem = null;
        try {
            this._editCommands.flush();
            this._fireCanceled(item, saveState);
        } finally {
            this.$_checkCurrent(Math.min(index, this.rowCount() - 1));
        }
	},
	_doCancelEdit: function (state, orgItem) {
			this._resetItemIndices(0);
        return true;
	},
	_updateEditingRow: function (orgItem) {
		return false;
	},
	_insertEditingRow: function (appending) {
		return false;
	},
	$_commitEdit: function (ds, field) {
		try {
			if (!this._fireCommitting(this._editingItem, this._editingState)) {
                return false;
            }
		} catch (err) {
			throw err;
		}
		var saveState = this._editingState,
		    completed = false;
		if (this.isUpdating()) {
			try {
				this.setEditingState(GridRowState.NORMAL);
				completed = this._doCompleteUpdate(this._orgItem, field);
			} catch (err) {
				this.setEditingState(saveState);
				throw err;
			}
		} else {
			try {
				this.setEditingState(GridRowState.NORMAL);
				completed = this._doCompleteInsert(saveState == GridRowState.APPENDING, field);
			} catch (err) {
				this.setEditingState(saveState);
				throw err;
			}
		}
        if (completed) {
            this._modified = false;
            this._doCommitEdit(saveState, this._orgItem);
            this._doEditingFinished(true);
            var item = this._editingItem;
            this._editingItem = null;
            this._orgItem = null;
            try {
                this._editCommands.flush();
                this._fireCommitted(item, saveState);
            } finally {
                this.$_checkCurrent(item.index());
            }
        } else {
            this.setEditingState(saveState);
        }
		return completed;
	},
    _doCompleteUpdate: function (orgItem, field) {
        return false;
    },
    _doCompleteInsert: function (appending, field) {
        return false;
    },
	_doCommitEdit: function (state, orgItem) {
		return false;
	},
	_editItemCellUpdated: function (item, field, oldValue, newValue) {
		if (this.isEditing(item)) {
			this._modified = true;
			this._fireCellUpdated(item, field, oldValue, newValue);
		}
	},
	_doEditingStarted: function (editItem) {
	},
	_doEditingFinished: function (completed) {
	},
	_fireCurrentChanging: function (oldIndex, newIndex) {
		if (this.fireConfirmEvent(EditableRowProvider.CURRENT_CHANGING, oldIndex, value)) {
			if (this.onCurrentChanging) {
				var r = this.onCurrentChanging(this, newIndex, oldIndex);
				if (r === false) {
					return false;
				}
			}
			return true;
		}
		return false;
	},
	_fireCurrentChanged: function (oldIndex, newIndex, noCommit) {
		this.onCurrentChanged && this.onCurrentChanged(this, newIndex, oldIndex);
		this.fireEvent(EditableRowProvider.CURRENT_CHANGED, oldIndex, newIndex, noCommit);
	},
	_fireUpdating: function (item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(EditableRowProvider.UPDATING, item);
		}
		return true;
	},
	_fireUpdateStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableRowProvider.UPDATE_STARTED, item);
		} 
	},
	_fireAppending: function (defaults) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(EditableRowProvider.APPENDING, defaults);
		}
		return true;
	},
	_fireAppendStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableRowProvider.APPEND_STARTED, item);
		} 
	},
	_fireInserting: function (row, defaults) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(EditableRowProvider.INSERTING, row, defaults);
		}
		return true;
	},
	_fireInsertStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableRowProvider.INSERT_STARTED, item);
		} 
	},
	_fireCellUpdated: function (item, field, oldValue, newValue) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableRowProvider.CELL_UPDATED, item, field, oldValue, newValue);
		} 
	},
	_fireCommitting: function (item, editingState) {
		return this.fireConfirmEvent(EditableRowProvider.COMMITTING, item, editingState);
	},
	_fireCommitted: function (item, editingState) {
    	this.fireEvent(EditableRowProvider.COMMITTED, item, editingState);
	},
    _fireCanceling: function (item, editingState) {
        return this.fireConfirmEvent(EditableRowProvider.CANCELING, item, editingState);
    },
	_fireCanceled: function (orgItem, editingState) {
    	this.fireEvent(EditableRowProvider.CANCELED, orgItem, editingState);
	},
	_fireCommitRequest: function () {
		this.fireEvent(EditableRowProvider.COMMIT_REQUEST);
	},
	_fireCancelRequest: function () {
		this.fireEvent(EditableRowProvider.CANCEL_REQUEST);
	}
});
EditableRowProvider.CURRENT_CHANGING = "onItemEditCurrentChanging";
EditableRowProvider.CURRENT_CHANGED = "onItemEditCurrentChanged";
EditableRowProvider.UPDATING = "onItemEditUpdating";
EditableRowProvider.UPDATE_STARTED = "onItemEditUpdateStarted";
EditableRowProvider.APPENDING = "onItemEditAppending";
EditableRowProvider.APPEND_STARTED = "onItemEditAppendStarted";
EditableRowProvider.INSERTING = "onItemEditInserting";
EditableRowProvider.INSERT_STARTED = "onItemEditInsertStarted";
EditableRowProvider.CELL_UPDATED = "onItemEditCellUpdated";
EditableRowProvider.COMMITTING = "onItemEditCommitting";
EditableRowProvider.COMMITTED = "onItemEditCommitted";
EditableRowProvider.CANCELING = "onItemEditCanceling";
EditableRowProvider.CANCELED = "onItemEditCanceled";
EditableRowProvider.COMMIT_REQUEST = "onItemEditCommitRequest";
EditableRowProvider.CANCEL_REQUEST = "onItemEditCancelRequest";
var EditRow = defineClass("EditRow", DataRow, {
	init: function (provider, target/*GridRow*/, index, dataRow, rowId, state/*ItemState*/) {
		this._super(dataRow);
		this._target = target;
		provider.attachItem(this);
		this._index = index;
        this._dataRow = dataRow;
		this._rowId = rowId;
		this._state = state;
		this._values = [];
		this._displayLevel = target ? target.displayLevel() : 0;
		this._started = false;
		this._checkDiff = false;
		this._strictDiff = false;
	},
	values: null,
	target: function () {
		return this._target;
	},
	values_: function () {
		return this._values.concat();
	},
	setValues: function (vals) {
		var i, f, fld, oldValue, newValue,
			provider = this.provider(),
			ds = this.dataSource(),
			cnt = ds.fieldCount();
		if (_isArray(vals)) {
			cnt = Math.min(cnt, vals.length);
			for (i = 0; i < cnt; i++) {
				fld = ds.getField(i);
				oldValue = this._values[i];
				newValue = fld.readValue(vals[i]);
				this._values[i] = newValue;
				if (this._started && !fld.equalValues(oldValue, newValue)) {
					provider._editItemCellUpdated(this, i, oldValue, newValue);
				}
			}
		} else if (vals) {
			for (i = 0; i < cnt; i++) {
				f = ds.getFieldName(i);
				if (vals.hasOwnProperty(f)) {
					fld = ds.getField(i);
					oldValue = this._values[i];
					newValue = fld.readValue(vals[f]);
					this._values[i] = newValue;
					if (this._started && !fld.equalValues(oldValue, newValue)) {
						provider._editItemCellUpdated(this, i, oldValue, newValue);
					}
				}
			}
		}
	},
	setDiffs: function (checkDiff, strictDiff) {
		this._checkDiff = checkDiff;
		this._strictDiff = strictDiff;
	},
	beginEdit: function (checkDiff, strictDiff) {
		this._started = true;
		this.setDiffs(checkDiff, strictDiff);
	},
	setEditValue: function (fieldIndex, value, noCalc) {
		var fld, oldValue, ds = this.dataSource();
		if (fieldIndex < 0 && fieldIndex >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + fieldIndex);
		}
		fld = ds.getField(fieldIndex);
		oldValue = this._values[fieldIndex];
		value = fld.readValue(value);
		this._values[fieldIndex] = value;
        !noCalc && ds.updateDerivedValues(this._dataRow, this._values, fieldIndex);
		if (this._started && !fld.equalValues(oldValue, value)) {
			this.provider()._editItemCellUpdated(this, fieldIndex, oldValue, value);
		}
	},
    isValueEdited: function (field) {
        var ds;
        return GridRowState.isInserting(this._state) ||
                !(ds = this.dataSource()).getField(field).equalValues(ds.getValue(this._dataRow, field), this._values[field]);
    },
	isEditing: function () {
		return true;
	},
	rowState: function () {
		return this._state;
	},
	getValue: function (field) {
        var ds = this.dataSource();
        field = ds.getFieldIndexEx(field);
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		return this._values[field];
	},
	setValue: function (field, value, noCalc) {
		var fld, oldValue, can,
			ds = this.dataSource();
        field = ds.getFieldIndexEx(field);
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		fld = ds.getField(field);
		oldValue = this._values[field];
		value = fld.readValue(value);
		can = !this._checkDiff;
		if (!can) {
			if (this._strictDiff) {
				can = !fld.equalValues(oldValue, value);
			} else {
				can = !fld.sameValues(oldValue, value);
			}
		}
		if (can) {
			this._values[field] = value;
            !noCalc && ds.updateDerivedValues(this._dataRow, this._values, field);
			this.provider()._editItemCellUpdated(this, field, oldValue, value);
		}
	},
	getRowData: function ()  {
		return this._values.concat();
	},
	getRowObject: function () {
		var cnt, row, i, fld,
			ds = this.dataSource();
		if (ds) {
			cnt = ds.fieldCount();
			row = {};
			for (i = 0; i < cnt; i++) {
				fld = ds.getFieldName(i);
				row[fld] = this._values[i];
			}
			return row;
		}
		return null;
	},
    copyToObject: function (vals) {
        var cnt, i, fld, ds = this.dataSource();
        if (ds) {
            cnt = ds.fieldCount();
            for (i = 0; i < cnt; i++) {
                fld = ds.getFieldName(i);
                vals[fld] = this._values[i];
            }
        }
    },
	_clearDisplayLevels: function () {
		var i,
			cnt = this._rows.length;
		for (i = 0; i < cnt; i++) {
			this._rows[i]._displayLevel = -1;
		}
	}
});
var EditableRowProviderImpl = defineClass("EditableRowProviderImpl", EditableRowProvider, {
	init: function (source, indexing) {
		this._super(source, indexing);
		this._insertRow = -1;
	},
	_resetItemIndices: function (startIndex) {
		this._super(startIndex);
		if (this._indexing) {
			if (this.isUpdating()) {
				var i = this._editingItem.index();
				if (i < this.source().rowCount()) {
					this.source().getItem(i)._index = i;
				}
			}
		}
	},
	rowCount: function () {
		var cnt = this.source().rowCount();
		return (this.isInserting() || this.isAppending()) ? cnt + 1 : cnt;
	},
	descendantCount: function () {
		return this.source().descendantCount();
	},
	getItem: function (index) {
        var i = this._editingItem._index;
		if (this.isEditing() && i == index) {
			return this._editingItem;
		} else if (this.isAdding()) {
			if (index > i) {
				return this.source().getItem(index - 1);
			} else {
				return this.source().getItem(index);
			}
		} else {
			return this.source().getItem(index);
		}
	},
	_doBeginUpdate: function (item) {
		this._editingItem = this._createEditItem(item, GridRowState.UPDATING, null);
		return this._editingItem;
	},
	_doBeginAppend: function (defaultValues) {
		this._editingItem = this._createEditItem(null, GridRowState.APPENDING, defaultValues);
		return this._editingItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		this._editingItem = this._createEditItem(item, GridRowState.INSERTING, defaultValues, shift, ctrl);
		return this._editingItem;
	},
	_doCancelEdit: function (state, orgItem) {
		this._super(state, orgItem);
	},
	_doCommitEdit: function (state, orgItem) {
		this._super(state, orgItem);
	},
	_doCompleteUpdate: function (orgItem, field) {
		var ds = this.dataSource();
		if (ds) {
			var editItem = this._editingItem;
			this._copyExtents(editItem, orgItem);
            if (field >= 0) {
                return ds.setValue(editItem.dataIndex(), field, editItem.getValue(field));
            } else {
                return ds.updateRow(editItem.dataIndex(), editItem.values());
            }
		}
		return false;
	},
	_doCompleteInsert: function (appending, field) {
        var editItem, r, values, i, item,
		    rslt = false,
		    ds = this.dataSource();
		if (ds) {
			editItem = this._editingItem;
			r = appending ? ds.rowCount() : this._insertRow;
			values = editItem.values();
            if (r < 0) {
                for (i = editItem.index() - 1; i >= 0; i--) {
                    if ((r = this.getItem(i).dataIndex()) > 0) {
                        r++;
                        break;
                    }
                }
                r = Math.max(0, r);
            }
			rslt = ds.insertRow(r, values, field);
			if (rslt) {
				item = this.getItemOfRow(r);
				this._copyExtents(editItem, item);
			}
		}
		return rslt;
	},
	remove: function (row) {
		var r, ds = this.dataSource();
        if (row && !this.isEditing(row) && ds) {
			r = row.dataIndex();
			if (r >= 0) {
				ds.deleteRow(r);
			}
		}
	},
	removeAll: function (items) {
		if (!items || items.length == 0) {
			return;
		}
		var cnt, row, rows, i,
            ds = this.dataSource();
		if (!ds) {
			return;
		}
		cnt = items.length;
		if (cnt > 1) {
			rows = [];
			for (i = 0; i < cnt; i++) {
				row = this.getItem(items[i]).dataIndex();
				if (row >= 0) {
					rows.push(row);
				}
			}
			if (rows.length > 1) {
				ds.deleteRows(rows);
			} else if (rows.length == 1) {
				ds.deleteRow(rows[0]);
			}
		} else if (cnt == 1) {
			row = this.getItem(items[0]).dataIndex();
			row >= 0 && ds.deleteRow(row);
		}
	},
	revert: function (item) {
        var ds, r, st;
		if (!(item instanceof GridRow)) {
			item = this.getItem(item);
		}
		if (item) {
			ds = this.dataSource();
			if (ds) {
				r = item.dataIndex();
				st = ds.getRowState(r);
				if (st == DataRowState.DELETED) {
					ds.setRowState(r, DataRowState.NONE);
				} else if (st == DataRowState.CREATE_AND_DELETED) {
					ds.setRowState(r, DataRowState.CREATED);
				}
			}
		}
	},
	revertAll: function (items) {
		if (!items || items.length == 0) {
			return;
		}
		var i, item, r, st,
            ds = this.dataSource();
		if (!ds) {
			return;
		}
		for (i = items.length; i--;) {
			item = this.getItem(items[i]);
			if (item) {
				r = item.dataIndex();
				if (r >= 0) {
					st = ds.getRowState(r);
					if (st == DataRowState.DELETED) {
						ds.setRowState(r, DataRowState.NONE);
					} else if (st == DataRowState.CREATE_AND_DELETED) {
						ds.setRowState(r, DataRowState.CREATED);
					}
				}
			}
		}
	},
	getRemovableRows: function (items) {
		if (!items || items.length == 0) {
			return null;
		}
		var i, cnt, row, rows = [];
		for (i = 0, cnt = items.length; i < cnt; i++) {
			row = this.getItem(items[i]).dataIndex();
			row >= 0 &&	rows.push(row);
		}
		return rows;
	},
	removeRows: function (dataRows) {
		if (dataRows) {
			if (dataRows.length > 1) {
				this.dataSource().deleteRows(dataRows);
			} else {
				this.dataSource().deleteRow(dataRows[0]);
			}
		}
	},
	_createEditItem: function (target, state, defaultValues) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
        var i,
		    item = null,
		    flds = ds.fieldCount();
		switch (state) {
			case GridRowState.UPDATING:
				item = new EditRow(this, target, target.index(), target.dataIndex(), target.dataId(), state);
				for (i = 0; i < flds; i++) {
					item.setEditValue(i, target.getValue(i), true);
				}
				this._copyExtents(target, item);
				break;
			case GridRowState.INSERTING:
			case GridRowState.APPENDING:
				item = (state == GridRowState.APPENDING) ? new EditRow(this, null, this.rowCount(), -1, -1, state) :
					new EditRow(this, target, target.index(), -1, target.dataId(), state);
				if (state == GridRowState.INSERTING) {
					this._insertRow = target.dataIndex();
				}
				if (defaultValues) {
					for (i = 0; i < flds; i++) {
						if (defaultValues.length > i) {
							item.setEditValue(i, defaultValues[i], true);
						}
					}
                    item && ds.updateDerivedValues(item._dataRow, item._values, -1);
				}
				break;
		}
		return item;
	}
});
var GridRowProvider = defineClass("GridRowProvider", EditableRowProviderImpl, {
	init: function (indexing) {
		this._super(null, indexing);
		this._pubItems = this;
		this._groupSorting = true;
		this._groupSortDirection = SortDirection.ASCENDING;
        this._groupSortCase = SortCase.SENSITIVE;
		var rs = this._itemProvider = new DefaultRowProvider(false);
		rs.onSaveRow = function (scope, item, rowId) {
			this.fireEvent(GridRowProvider.SAVE_ROW, scope, item, rowId);
		}.bind(this);
		rs.onSaveRows = function (scope, items) {
			this.fireEvent(GridRowProvider.SAVE_ROWS, scope, items);
		}.bind(this);
		rs.onRestoreRow = function (scope, item, rowId) {
			this.fireEvent(GridRowProvider.RESTORE_ROW, scope, item, rowId);
		}.bind(this);
		rs.onRestoreRows = function (scope, items) {
			this.fireEvent(GridRowProvider.RESTORE_ROWS, scope, items);
		}.bind(this);
		this._groupedProvider = new GroupedRowProvider(rs, false);
		this.setSource(this._groupedProvider);
		this._groupedProvider.onGroupedChanged = function (provider, grouped) {
			this.$_resetPubItems();
		}.bind(this);
		this._summarizer = new DefaultSummarizer(rs);
		this.$_resetPubItems();
	},
	passiveFiltering: false,
	setCustomRowProvider: function (value) {
		this._groupedProvider.setCustomRowProvider(value);
	},
	hideDeleted: function () {
		return this._itemProvider.hideDeleted();
	},
	setHideDeleted: function (value) {
		this._itemProvider.setHideDeleted(value);
	},
	setSummaryMode: function (value) {
		this._itemProvider.setSummaryMode(value);
	},
	setRowGroupSummaryMode: function (value) {
		this._groupedProvider.setSummaryMode(value);
	},
	setMergeMode: function (value) {
		this._groupedProvider.setMergeMode(value);
	},
    sortMode: function () {
        return this._itemProvider.sortMode();
    },
    setSortMode: function (value) {
        this._itemProvider.setSortMode(value);
    },
    filterMode: function () {
        return this._itemProvider.filterMode();
    },
    setFilterMode: function (value) {
        this._itemProvider.setFilterMode(value);
    },
    pageSorting: function () {
        return this._itemProvider.pageSorting();
    },
    setPageSorting: function (value) {
        return this._itemProvider.setPageSorting(value);
    },
    pageFiltering: function () {
        return this._itemProvider.pageFiltering();
    },
    setPageFiltering: function (value) {
        return this._itemProvider.setPageFiltering(value);
    },
    isGrouped: function () {
		return this._groupedProvider.grouped();
	},
    isMergedRowGrouped: function () {
        return this._groupedProvider.grouped() && this._groupedProvider.mergeMode();
    },
	groupLevels: function () {
		return this._groupedProvider.groupCount();
	},
	groupByFields: function () {
		return this._groupedProvider.getGroupedFields();
	},
	summarizer: function () {
		return this._summarizer;
	},
	dataStateFiltering: function () {
		return this._itemProvider.dataStateFiltering();
	},
	setDataStateFiltering: function (value) {
		return this._itemProvider.setDataStateFiltering(value);
	},
	dataTagFiltering: function () {
		return this._itemProvider.dataTagFiltering();
	},
	setDataTagFiltering: function (value) {
		return this._itemProvider.setDataTagFiltering(value);
	},
	sortFirst: function () {
		return this._itemProvider.sortFirst();
	},
	setSortFirst: function (value) {
		return this._itemProvider.setSortFirst(value);
	},
    isSorted: function () {
        return this._itemProvider.isSorted();
    },
    isFiltered: function () {
        return this._itemProvider.isFiltered();
    },
	setDataSource: function (value) {
		this._itemProvider.setDataSource(value);
	},
	getRowsOfDataRows: function (dataRows, all) {
		return this._itemProvider.getItemsOfRows(dataRows, all);
	},
	clearSummary: function () {
		this._itemProvider.$_clearSummary();
	},
	resetCustomGroupItems: function (item) {
		this._groupedProvider.repopulateItems();
	},
	getFieldDomain: function (field) {
		this._itemProvider.getFieldDomain(field);
	},
    canFiltering: function () {
        return !this.isEditing();
    },
	addFilter: function (field, expression) {
        if (this.canFiltering()) {
            this._itemProvider.addFilter(field, expression);
        }
	}, 
	removeFilter: function (field, filter) {
        if (this.canFiltering()) {
            this._itemProvider.removeFilter(filter);
        }
	},
	clearFilters: function (field) {
        if (this.canFiltering()) {
            this._itemProvider.clearFilters(field);
        }
	},
	clearAllFilters: function () {
        if (this.canFiltering()) {
            this._itemProvider.clearAllFilters();
        }
	},
	beginFiltering: function () {
        if (this.canFiltering()) {
            this._itemProvider.beginFilter();
        }
	},
	endFiltering: function () {
        if (this.canFiltering()) {
            this._itemProvider.endFilter();
        }
	},
    canSorting: function (fields, directions, cases) {
        return !this.isEditing();
    },
	orderBy: function (fields, directions, cases) {
        if (!this.canSorting(fields, directions, cases)) {
            return;
        }
		if (this._groupedProvider.grouped()) {
            var i, cnt, fld, g, dir, c,
                len = directions ? directions.length : 0,
                clen = cases ? cases.length : 0,
			    groupFields = this._groupedProvider.getGroupedFields(),
			    groupDirs = this._itemProvider.getSortDirections(),
                groupCases = this._itemProvider.getSortCases(),
			    list = [];
			for (i = 0, cnt = groupFields.length; i < cnt; i++) {
				list.push(groupFields[i]);
			}
			for (i = 0, cnt = fields.length; i < cnt; i++) {
				fld = fields[i];
				g = list.indexOf(fld);
				if (len > i) {
					dir = directions[i];
				} else if (len > 0) { // 바로 앞의 것을 따라간다.
					dir = directions[len - 1];
				} else {
					dir = SortDirection.ASCENDING;
				}
                if (clen > i) {
                    c = cases[i];
                } else if (clen > 0) {
                    c = cases[clen - 1];
                } else {
                    c = SortCase.SENSITIVE;
                }
				if (g < 0) {
					list.push(fld);
					groupDirs[list.length - 1] = dir;
                    groupCases[list.length - 1] = c;
				} else {
					groupDirs[g] = dir;
                    groupCases[g] = c;
				}
			}
			groupFields = list;
			this._itemProvider.orderBy(groupFields, groupDirs, groupCases);
		} else {
			this._itemProvider.orderBy(fields, directions, cases);
		}
	},
	getSortFieldCount: function () {
		return this._itemProvider.getSortFieldCount();
	},
	getSortFields: function () {
		return this._itemProvider.getSortFields();
	},
	getSortDirections: function () {
		return this._itemProvider.getSortDirections();
	},
    getSortCases: function () {
        return this._itemProvider.getSortCases();
    },
    canGrouping: function (fields) {
        return !this.isEditing() && this._groupedProvider.canGrouping(fields);
    },
	groupBy: function (fields, sorting, direction, textCase) {
        if (!this.canGrouping(fields)) {
            return;
        }
		if ((!fields || fields.length < 1) && !this._groupedProvider.grouped()) {
			return;
		}
		this._groupSorting = sorting;
		this._groupSortDirection = direction;
        this._groupSortCase = textCase || SortCase.SENSITIVE;
		if (sorting) {// && fields && fields.length > 0) {
			this._itemProvider.orderBy(fields, [direction], [this._groupSortCase], false);
		}
		this._groupedProvider.groupBy(fields);
	},
	groupByMode: function (fields, mergeMode) {
        if (!this.canGrouping(fields)) {
            return;
        }
		if (this._groupSorting) {// && fields && fields.length > 0) {
			this._itemProvider.orderBy(fields, [this._groupSortDirection], [this._groupSortCase], false);
		}
		this._groupedProvider.groupByMode(fields, mergeMode);
	},
	addGroupBy: function (index, field, sorting, direction, textCase) {
		var fields;
		if (this._groupedProvider.groupCount() < 1) {
			fields = [field];
		} else {
			fields = this._groupedProvider.getGroupedFields();
            index = parseInt(index);
            if (!isNaN(index)) {
                index = Math.max(0, Math.min(fields.length, index));
                fields.splice(index, 0, field);
            } else {
                fields.push(field);
            }
		}
        if (!this.canGrouping(fields)) {
            return;
        }
		this._groupSorting = sorting;
		this._groupSortDirection = direction;
		this._groupSortCase = textCase;
		if (sorting) {
			this._itemProvider.orderBy(fields, [direction], [textCase], false);
		}
		this._groupedProvider.groupBy(fields);
	},
	removeGroupBy: function (field) {
		if (!this._groupedProvider.grouped()) {
			return;
		}
		var i,
			idx = -1,
			fields = this._groupedProvider.getGroupedFields(),
			cnt = fields.length;
		for (i = cnt - 1; i >= 0; i--) {
			if (fields[i] == field) {
				idx = i;
				break;
			}
		}
		if (idx >= 0) {
			fields.splice(idx, 1);
            if (!this.canGrouping(fields)) {
                return;
            }
            if (this._groupSorting) {
				this._itemProvider.orderBy(fields, [this._groupSortDirection], null, false);
			}
			this._groupedProvider.groupBy(fields);				
		} else {
            if (!this.canGrouping(null)) {
                return;
            }
            if (this._groupSorting) {
				this._itemProvider.orderBy(null, null, null, false);
			}
		}
	},
	getGroupLevels: function () {
		return this._groupedProvider.groupCount();
	},
	isGroupedField: function (field) {
		return this._groupedProvider.isGroupedField(field);
	},
	getGroupLevel: function (field) {
		return this._groupedProvider.getGroupLevel(field);
	},
	getGroupByFieldCount: function () {
		return this._groupedProvider.groupCount();
	},
	setExpandWhenGrouping: function (value) {
		this._groupedProvider.setExpandWhenGrouping(value);
	},
	setGroupedStyle: function (expandedAdornments, collapsedAdornments, createFooterCallback) {
		this._groupedProvider.setExpandedAdornments(expandedAdornments);
		this._groupedProvider.setCollapsedAdornments(collapsedAdornments);
		this._groupedProvider.setCreateFooterCallback(createFooterCallback);
	},
	expand: function (group, recursive, force) {
		this._groupedProvider.expand(group, recursive, force);
	},
	collapse: function (group, recursive, force) {
		this._groupedProvider.collapse(group, recursive, force);
	},
	reveal: function (row) {
		if (this._pubItems === this._groupedProvider) {
			return this._pubItems.reveal(row);
		}
		return true;
	},
    canPaging: function () {
        return !this.isEditing();
    },
	setPaging: function (paging, pageSize, pageCount, pageOffset) {
        if (this.canPaging()) {
            this._itemProvider.setPaging(paging, pageSize, pageCount, pageOffset);
        }
        return this;
	},
    isPaging: function () {
        return this._itemProvider.isPaging();
    },
    pageIndex: function () {
        return this._itemProvider.page();
    },
    setPageIndex: function (value) {
        if (this.canPaging()) {
            this._itemProvider.setPage(value);
        }
        return this;
    },
    pageSize: function () {
        return this._itemProvider.pageSize();
    },
    setPageSize: function (value) {
        if (this.canPaging()) {
            this._itemProvider.setPageSize(value);
        }
        return this;
    },
	pageCount: function () {
		return this._itemProvider.pageCount();
	},
	setPageCount: function (value) {
        if (this.canPaging()) {
            this._itemProvider.setPageCount(value);
        }
        return this;
	},
    pageOffset: function () {
        return this._itemProvider.pageOffset();
    },
    setPageOffset: function (value) {
        if (this.canPaging()) {
            this._itemProvider.setPageOffset(value);
        }
        return this;
    },
    setPageAndOffset: function (index, offset) {
        if (this.canPaging()) {
            this._itemProvider.setPageAndOffset(index, offset);
        }
        return this;
    },
    pageRows: function () {
        return this._itemProvider.pageRows();
    },
    setPageRows: function (value) {
        if (this.canPaging()) {
            this._itemProvider.setPageRows(value);
        }
        return this;
    },
    setPageAndRows: function (index, rows) {
        if (this.canPaging()) {
            this._itemProvider.setPageAndRows(index, rows);
        }
        return this;
    },
	getDisplayItemIndex: function (item) {
		return this._itemProvider.isPaging() ? item.index() + this._itemProvider.pageStartIndex() : item.index(); 
	},
	setExpandWhenGrouping: function (value) {
		this._groupedProvider.setExpandWhenGrouping(value);
	},
    getDataRow: function (dataIndex) {
        return this._itemProvider.getDataRow(dataIndex);
    },
    isRowHidden: function (row) {
        return  this._itemProvider.isRowHidden(row);
    },
	setHiddenRow: function (row, hidden) {
		return this._itemProvider.setHiddenRow(row, hidden);
	},
    getHiddenRows: function () {
        return this._itemProvider.getHiddenRows();
    },
	setHiddenRows: function (rows, hidden) {
		return this._itemProvider.setHiddenRows(rows, hidden);
	},
    unhideAllRows: function () {
        return this._itemProvider.unhideAllRows();
    },
    hiddenRowCount: function () {
        return this._itemProvider.hiddenCount();
    },
	dataSource: function () {
		return this._itemProvider.dataSource();
	},
	setDataSource: function (value) {
		this._itemProvider.setDataSource(value);
	},
	getItem: function (rowIndex) {
		if (this._pubItems === this) {
			return this._super(rowIndex);
		}
		return this._pubItems.getItem(rowIndex);
	},
	_editingStateChanged: function (oldState, newState) {
		this.$_resetPubItems();
	},
	getAllItems: function () {
		return this._groupedProvider.getAllItems();
	},
	getTopItems: function () {
		return this._groupedProvider.getTopItems();
	},
	getLeafItems: function (visibleOnly, dataOnly) {
		return this._groupedProvider.getLeafItems(visibleOnly, dataOnly);
	},
	getDistinctValues: function (field, maxCount, ignoreCase) {
		return this._itemProvider.getDistinctValues(field, maxCount, ignoreCase);
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		return this._groupedProvider.findItem(fields, values, options, startIndex, endIndex);
	},
	findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
		return this._groupedProvider.findCell(fields, value, options, startIndex, endIndex, startFieldIndex);
	},
    /*
	hasCellStyle: function () {
		return this._itemProvider.hasCellStyle();
	},
	setCellStyle: function (row, field, style) {
		this._itemProvider.setCellStyle(row, field, style);
	},
	setCellStyles: function (provider, rows, fieldMap, startRow, count) {
		this._itemProvider.setCellStyles(provider, rows, fieldMap, startRow, count);
	},
	clearCellStyles: function () {
		this._itemProvider.clearCellStyles();
	},
	removeCellStyle: function (style) {
		this._itemProvider.removeCellStyle(style);
	},
	getCellStyle: function (dataRow, field) {
		return this._itemProvider.getCellStyle(dataRow, field);
	},
	*/
	getIndexOfRow: function (dataRow) {
		return this._itemProvider.getIndexOfRow(dataRow);
	},
	getItemOfRow: function (dataRow, all) {
		return this._itemProvider.getItemOfRow(dataRow, all);
	},
	_doEditingStarted: function (editItem) {
        this._itemProvider.$_setEditing(true);
        this._groupedProvider.$_setEditing(true);
	},
	_doEditingFinished: function (completed) {
        this._itemProvider.$_setEditing(false);
        this._groupedProvider.$_setEditing(false);
	},
	_doBeginUpdate: function (item) {
		var editItem = this._super(item);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doBeginAppend: function (defaultValues) {
		var editItem = this._super(defaultValues);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		var editItem = this._super(item, defaultValues, shift, ctrl);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doCancelEdit: function (state, orgItem) {
		this._super(state, orgItem);
		this._groupedProvider._setEditItem(null);
	},
	_doCommitEdit: function (state, orgItem) {
		this._super(state, orgItem);
		this._groupedProvider._setEditItem(null);
	},
	$_resetPubItems: function () {
        if (!_isValidAddr(_licdom, _runloc)) delete GroupedRowProvider.prototype['grouped'];
		if (GridRowState.isEditing(this._editingState)) {
			this._pubItems = this;
		} else {
			if (this._groupedProvider.grouped()) {
				this._pubItems = this._groupedProvider;
			} else {
				this._pubItems = this._itemProvider;
			}
		}
	},
	descendantCount: function () {
        return this._pubItems == this._itemProvider ? this._pubItems.descendantCount()
            : this._groupedProvider.descendantCount();
	},
    descendantRowCount: function () {
        return this._pubItems == this._itemProvider ? this._pubItems.descendantRowCount()
            : this._groupedProvider.descendantRowCount();
    },
	getDescendantRows: function (visibleOnly, dataOnly) {
		return this._pubItems == this._itemProvider ? this._pubItems.getDescendantRows(visibleOnly, dataOnly)
            : this._groupedProvider.getDescendantRows(visibleOnly, dataOnly);
	},
    visitRows: function (visibleOnly, dataOnly, callback) {
        return this._pubItems == this._itemProvider ? this._pubItems.visitRows(visibleOnly, dataOnly, callback)
            : this._groupedProvider.visitRows(visibleOnly, dataOnly, callback);
    },
	onRowProviderDataCountChanged: function (rs, oldCount, newCount) {
		this._fireDataCountChanged(oldCount, newCount);
	},
	onRowProviderRowCountChanged: function (rs, oldCount, newCount) {
		this._fireRowCountChanged(oldCount, newCount);
	},
	onGroupedRowProviderGrouping: function (provider, fields) {
		return this.fireConfirmEvent(GroupedRowProvider.GROUPING, fields);
	},
	onGroupedRowProviderGrouped: function (provider) {
		this.fireEvent(GroupedRowProvider.GROUPED);
	},
	onGroupedRowProviderExpand: function (provider, group) {
		return this.fireConfirmEvent(GroupedRowProvider.EXPAND, group);
	},
	onGroupedRowProviderExpanded: function (provider, group) {
		this.fireEvent(GroupedRowProvider.EXPANDED, group);
	},
	onGroupedRowProviderCollapse: function (provider, group) {
		return this.fireConfirmEvent(GroupedRowProvider.COLLAPSE, group);
	},
	onGroupedRowProviderCollapsed: function (provider, group) {
		this.fireEvent(GroupedRowProvider.COLLAPSED, group);
	}
}, {
	SAVE_ROW: "onGridRowProviderSaveRow",
	SAVE_ROWS: "onGridRowProviderSaveRows",
	RESTORE_ROW: "onGridRowProviderRestoreRow",
	RESTORE_ROWS: "onGridRowProviderRestoreRows"
});
var TextWrap = _enum('TextWrap', {
	NONE: "none",
	EXPLICIT: "explicit",
	NORMAL: "normal"
});
var TextOverflow = _enum('TextOverflow', {
	CLIP: "clip",
	ELLIPSIS: "ellipsis",
	PATH: "path"
});
var Alignment = _enum('Alignment', {
	NEAR: "near",
	CENTER: "center",
	FAR: "far"
});
var _alignmentToText = function (a) {
	switch (a) {
		case Alignment.FAR: return "right";
		case Alignment.NEAR: return "left";
		default: return "center";
	}
};
var _alignmentToLine = function (a) {
	switch (a) {
		case Alignment.FAR: return "bottom";
		case Alignment.NEAR: return "top";
		default: return "middle";
	}
};
var TextDecoration = _enum('TextDecoration', {
	NONE: "none",
	UNDERLINE: "underline",
	OVERLINE: "overline",
	LINE_THROUGH: "lineThrough"
})
var IconLocation = _enum('IconLocation', {
	LEFT: "left",
	RIGHT: "right",
	TOP: "top",
	BOTTOM: "bottom",
    LEFT_SIDE: "leftSide",
    RIGHT_SIDE: "rightSide",
    TOP_SIDE: "topSide",
    BOTTOM_SIDE: "bottomSide",
	CENTER: "center",
	CENTER_BACK: "centerBack",
	NONE: "none"
}, {
    isHorz: function (value) {
        return value == IconLocation.LEFT || value == IconLocation.RIGHT || value == IconLocation.LEFT_SIDE || value == IconLocation.RIGHT_SIDE || value == IconLocation.CENTER || value == IconLocation.CENTER_BACK;
    },
    isVert: function (value) {
        return value == IconLocation.TOP || value == IconLocation.BOTTOM || value == IconLocation.TOP_SIDE || value == IconLocation.BOTTOM_SIDE || value == IconLocation.CENTER || value == IconLocation.CENTER_BACK;
    },
    isStrictVert: function (value) {
        return value == IconLocation.TOP || value == IconLocation.BOTTOM || value == IconLocation.TOP_SIDE || value == IconLocation.BOTTOM_SIDE;
    },
	isCenter: function (value) {
		return value == IconLocation.CENTER || value == IconLocation.CENTER_BACK;
	}
});
var Dimension = defineClass("Dimension", null, {
    init: function (size) {
        this._super();
        this._value = NaN;
        this._valuePercent = false;
        if (size) {
            this.setSize(size);
        }
    },
    size: null,
    minSize: null,
    maxSize: null,
    setSize: function (value) {
        if (value != this.size) {
            this._size = value;
            var sz = this.parse(value);
            this._value = sz.value;
            this._valuePercent = sz.percent;
        }
    },
    fixed: function () {
        return !this._valuePercent && !isNaN(this._value);
    },
    getDimension: function (bounds) {
        var	d = bounds;
        var v;
        if (!isNaN(this._value)) {
            d = this._value ? (this._valuePercent ? this._value * bounds / 100 : this._value) : 0;
        }
        return d;
    },
    equals: function (d) {
        return this._value == d._value &&
            this._valuePercent == d._valuePercent;
    },
    toString: function () {
        return this._size || "";
    },
    parse: function (size) {
        var len,
            v = { value: NaN, percent:false };
        if (size) {
            size = String(size).trim();
            if (size) {
                len = size.length;
                v.percent = size.charAt(len - 1) == "%";
                if (v.percent) {
                    size = size.substring(0, len - 1);
                    len = size.length;
                    if (len > 0) {
                        v.value = Number(size);
                    }
                } else {
                    v.value = Number(size);
                }
            }
        }
        return v;
    }
}, {
    areEquals: function (v1, v2) {
        if (v1 === v2) return true;
        if (!v1 || !v2) return false;
        return v1.equals(v2);
    },
}, function (f) {
    f.NULL = new f();
});
var $$_FONT_REG = new RegExp("\\s*,\\s*");
var $$_STYLE_PROP_MAP = {
    "renderer": "setRenderer",
	background: "setBackground",
    inactiveBackground: "setInactiveBackground",
	selectedBackground: "setSelectedBackground",
    hoveredBackground: "setHoveredBackground",
    color: "setColor",
    inactiveColor: "setInactiveColor",
    selectedColor: "setSelectedColor",
    hoveredColor: "setHoveredColor",
	border: "setBorder",
	borderLeft: "setBorderLeft",
	borderRight: "setBorderRight",
	borderTop: "setBorderTop",
	borderBottom: "setBorderBottom",
    borderLeftSize: "setBorderLeftSize",
    borderRightSize: "setBorderRightSize",
    borderTopSize: "setBorderTopSize",
    borderBottomSize: "setBorderBottomSize",
    borderRadius: "setBorderRadius",
	line: "setLine",
    textAlignment: "setTextAlignment",
    lineAlignment: "setLineAlignment",
    textWrap: "setTextWrap",
    textFormat: "setTextFormat",
    numberFormat: "setNumberFormat",
    datetimeFormat: "setDatetimeFormat",
    booleanFormat: "setBooleanFormat",
    prefix: "setPrefix",
    suffix: "setSuffix",
    font: "setFont",
	fontName: "setFontName",
	fontSize: "setFontSize",
	fontBold: "setFontBold",
	fontItalic: "setFontItalic",
	textDecoration: "setTextDecoration",
	textDecorationColor: "setTextDecorationColor",
	textShadow: "setTextShadow",
	marginLeft: "setMarginLeft",
	marginRight: "setMarginRight",
	marginTop: "setMarginTop",
	marginBottom: "setMarginBottom",
	paddingLeft: "setPaddingLeft",
	paddingRight: "setPaddingRight",
	paddingTop: "setPaddingTop",
	paddingBottom: "setPaddingBottom",
	iconIndex: "setIconIndex",
	iconLocation: "setIconLocation",
	iconAlignment: "setIconAlignment",
	iconOffset: "setIconOffset",
	iconPadding: "setIconPadding",
    iconAlpha: "setIconAlpha",
    shapeName: "setShapeName",
	shapeColor: "setShapeColor",
    shapeColors: "setShapeColors",
    shapeInactiveColor: "setShapeInactiveColor",
    shapeSelectedColor: "setShapeSelectedColor",
    shapeHoveredColor: "setShapeHoveredColor",
	shapeBorder: "setShapeBorder",
    shapeInactiveBorder: "setShapeInactiveBorder",
    shapeSelectedBorder: "setShapeSelectedBorder",
    shapeHoveredBorder: "setShapeHoveredBorder",
    shapeLocation: "setShapeLocation",
    shapeAlignment: "setShapeAlignment",
    shapeOffset: "setShapeOffset",
    shapePadding: "setShapePadding",
	shapeSize: "setShapeSize",
	shapeRotate: "setShapeRotate",
    shapeInnerName: "setShapeInnerName",
    shapeInnerColor: "setShapeInnerColor",
    shapeInnerSize: "setShapeInnerSize",
    shapeInnerRotate: "setShapeInnerRotate"
};
var GridStyles = defineClass("GridStyles", null, {
	init: function (owner, name, source, fireEvents) {
		this._super(true);
		this._owner = owner;
		this._name = name;
		this._parent = null;
		this._sysDefault = null;
		this._values = [];
		this._updateLock = 0;
		if (fireEvents !== undefined) {
			this._fireEvents = fireEvents;
		}
		this._scope = owner && owner.getPaletteScope && owner.getPaletteScope();
		source && this.extend(source, false);
	},
	name: null,
	fireEvents: true,
    parent: function () { return this._parent; },
    sysDefault: function () { return this._sysDefault; },
	setParent: function (value, fireEvent) {
		if (value !== this._parent) {
			this._parent = value;
			if ((fireEvent === undefined || fireEvent) && this._fireEvents) {
				this.changed(GridStyles.STYLE_ALL);
			}
		}
        return this;
	},
	setSysDefault: function (value, fireEvent) {
		if (value !== this._sysDefault) {
			this._sysDefault = value;
			if ((fireEvent === undefined || fireEvent) && this._fireEvents) {
				this.changed(GridStyles.STYLE_ALL);
			}
		}
        return this;
	},
    isEmpty: function () {
        return this._values.length <= 0;
    },
    renderer: undefined,
    renderer_: function () {
        return this.searchStyles(GridStyles.RENDERER)._renderer;
    },
    setRenderer: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.RENDERER] || v !== this._renderer) {
                this._renderer = v;
                this._values[GridStyles.RENDERER] = true;
                this._fireEvents && this.changed(GridStyles.RENDERER);
            }
        } else if (this._values[GridStyles.RENDERER]) {
            delete this._renderer;
            this._values[GridStyles.RENDERER] = false;
            this._fireEvents && this.changed(GridStyles.RENDERER);
        }
    },
	background: undefined,
	background_: function () {
		var fill = this.searchStyles(GridStyles.BACKGROUND)._background;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
	},
	setBackground: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BACKGROUND] || v !== this._background) {
                v = _createFill(v, this._scope);
				this._background = v;
				this._values[GridStyles.BACKGROUND] = true;
				this._fireEvents && this.changed(GridStyles.BACKGROUND);
			}
		} else if (this._values[GridStyles.BACKGROUND]) {
			delete this._background;
			this._values[GridStyles.BACKGROUND] = false;
			this._fireEvents && this.changed(GridStyles.BACKGROUND);
		}
	},
	$_setBackground: function (v) {
		this._background = v;
		this._values[GridStyles.BACKGROUND] = true;
	},
    inactiveBackground: undefined,
    inactiveBackground_: function () {
        var fill = this.searchStyles(GridStyles.INACTIVE_BACKGROUND)._inactiveBackground;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setInactiveBackground: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.INACTIVE_BACKGROUND] || v !== this._inactiveBackground) {
                v = _createFill(v, this._scope);
                this._inactiveBackground = v;
                this._values[GridStyles.INACTIVE_BACKGROUND] = true;
                this._fireEvents && this.changed(GridStyles.INACTIVE_BACKGROUND);
            }
        } else if (this._values[GridStyles.INACTIVE_BACKGROUND]) {
            delete this._inactiveBackground;
            this._values[GridStyles.INACTIVE_BACKGROUND] = false;
            this._fireEvents && this.changed(GridStyles.INACTIVE_BACKGROUND);
        }
    },
	selectedBackground: undefined,
	selectedBackground_: function () {
        var fill = this.searchStyles(GridStyles.SELECTED_BACKGROUND)._selectedBackground;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
	},
	setSelectedBackground: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.SELECTED_BACKGROUND] || v !== this._selectedBackground) {
                v = _createFill(v, this._scope);
				this._selectedBackground = v;
				this._values[GridStyles.SELECTED_BACKGROUND] = true;
				this._fireEvents && this.changed(GridStyles.SELECTED_BACKGROUND);
			}
		} else if (this._values[GridStyles.SELECTED_BACKGROUND]) {
			delete this._selectedBackground;
			this._values[GridStyles.SELECTED_BACKGROUND] = false;
			this._fireEvents && this.changed(GridStyles.SELECTED_BACKGROUND);
		}
	},
    hoveredBackground: undefined,
    hoveredBackground_: function () {
        var fill = this.searchStyles(GridStyles.HOVERED_BACKGROUND)._hoveredBackground;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setHoveredBackground: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.HOVERED_BACKGROUND] || v !== this._hoveredBackground) {
                v = _createFill(v, this._scope);
                this._hoveredBackground = v;
                this._values[GridStyles.HOVERED_BACKGROUND] = true;
                this._fireEvents && this.changed(GridStyles.HOVERED_BACKGROUND);
            }
        } else if (this._values[GridStyles.HOVERED_BACKGROUND]) {
            delete this._hoveredBackground;
            this._values[GridStyles.HOVERED_BACKGROUND] = false;
            this._fireEvents && this.changed(GridStyles.HOVERED_BACKGROUND);
        }
    },
    color: undefined,
    color_: function () {
        var fill = this.searchStyles(GridStyles.COLOR)._color;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.COLOR] || v !== this._color) {
                v = _createFill(v, this._scope);
                this._color = v;
                this._values[GridStyles.COLOR] = true;
                this._fireEvents && this.changed(GridStyles.COLOR);
            }
        } else if (this._values[GridStyles.COLOR]) {
            delete this._color;
            this._values[GridStyles.COLOR] = false;
            this._fireEvents && this.changed(GridStyles.COLOR);
        }
    },
    inactiveColor: undefined,
    inactiveColor_: function () {
        var fill = this.searchStyles(GridStyles.INACTIVE_COLOR)._inactiveColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setInactiveColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.INACTIVE_COLOR] || v !== this._inactiveColor) {
                v = _createFill(v, this._scope);
                this._inactiveColor = v;
                this._values[GridStyles.INACTIVE_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.INACTIVE_COLOR);
            }
        } else if (this._values[GridStyles.INACTIVE_COLOR]) {
            delete this._inactiveColor;
            this._values[GridStyles.INACTIVE_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.INACTIVE_COLOR);
        }
    },
    selectedColor: undefined,
    selectedColor_: function () {
        var fill = this.searchStyles(GridStyles.SELECTED_COLOR)._selectedColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setSelectedColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SELECTED_COLOR] || v !== this._selectedColor) {
                v = _createFill(v, this._scope);
                this._selectedColor = v;
                this._values[GridStyles.SELECTED_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.SELECTED_COLOR);
            }
        } else if (this._values[GridStyles.SELECTED_COLOR]) {
            delete this._selectedColor;
            this._values[GridStyles.SELECTED_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.SELECTED_COLOR);
        }
    },
    hoveredColor: undefined,
    hoveredColor_: function () {
        var fill = this.searchStyles(GridStyles.HOVERED_COLOR)._hoveredColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setHoveredColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.HOVERED_COLOR] || v !== this._hoveredColor) {
                v = _createFill(v, this._scope);
                this._hoveredColor = v;
                this._values[GridStyles.HOVERED_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.HOVERED_COLOR);
            }
        } else if (this._values[GridStyles.HOVERED_COLOR]) {
            delete this._hoveredColor;
            this._values[GridStyles.HOVERED_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.HOVERED_COLOR);
        }
    },
	border: undefined,
	border_: function () {
        var stroke = this.searchStyles(GridStyles.BORDER)._border;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setBorder: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BORDER] || v !== this._border) {
                v = _createStroke(v);
				this._border = v;
				this._values[GridStyles.BORDER] = true;
				this._fireEvents && this.changed(GridStyles.BORDER);
			}
		} else if (this._values[GridStyles.BORDER]) {
			delete this._border;
			this._values[GridStyles.BORDER] = false;
			this._fireEvents && this.changed(GridStyles.BORDER);
		}
	},
    borderWidth: function () {
        var stroke = this.border();
        return stroke ? stroke.width() : 0;
    },
	borderLeft: undefined,
	borderLeft_: function () {
        var stroke = this.searchStyles(GridStyles.BORDER_LEFT)._borderLeft;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setBorderLeft: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BORDER_LEFT] || v !== this._borderLeft) {
                v = _createStroke(v);
				this._borderLeft = v;
				this._values[GridStyles.BORDER_LEFT] = true;
				this._fireEvents && this.changed(GridStyles.BORDER_LEFT);
			}
		} else if (this._values[GridStyles.BORDER_LEFT]) {
			delete this._borderLeft;
			this._values[GridStyles.BORDER_LEFT] = false;
			this._fireEvents && this.changed(GridStyles.BORDER_LEFT);
		}
	},
	borderLeftWidth: function () {
		var stroke = this.borderLeft();
		return stroke ? stroke.width() : 0;
	},
	borderRight: undefined,
	borderRight_: function () {
        var stroke = this.searchStyles(GridStyles.BORDER_RIGHT)._borderRight;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setBorderRight: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BORDER_RIGHT] || v !== this._borderRight) {
                v = _createStroke(v);
				this._borderRight = v;
				this._values[GridStyles.BORDER_RIGHT] = true;
				this._fireEvents && this.changed(GridStyles.BORDER_RIGHT);
			}
		} else if (this._values[GridStyles.BORDER_RIGHT]) {
			delete this._borderRight;
			this._values[GridStyles.BORDER_RIGHT] = false;
			this._fireEvents && this.changed(GridStyles.BORDER_RIGHT);
		}
	},
	borderRightWidth: function () {
		var stroke = this.borderRight();
		return stroke ? stroke.width() : 0;
	},
	borderHorzWidth: function () {
		var stroke = this.borderLeft();
		var w = stroke ? stroke.width() : 0;
		stroke = this.borderRight();
		stroke && (w += stroke.width());
		return w;
	},
	borderTop: undefined,
	borderTop_: function () {
        var stroke = this.searchStyles(GridStyles.BORDER_TOP)._borderTop;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setBorderTop: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BORDER_TOP] || v !== this._borderTop) {
                v = _createStroke(v);
				this._borderTop = v;
				this._values[GridStyles.BORDER_TOP] = true;
				this._fireEvents && this.changed(GridStyles.BORDER_TOP);
			}
		} else if (this._values[GridStyles.BORDER_TOP]) {
			delete this._borderTop;
			this._values[GridStyles.BORDER_TOP] = false;
			this._fireEvents && this.changed(GridStyles.BORDER_TOP);
		}
	},
	borderTopWidth: function () {
		var stroke = this.borderTop();
		return stroke ? stroke.width() : 0;
	},
	borderBottom: undefined,
	borderBottom_: function () {
        var stroke = this.searchStyles(GridStyles.BORDER_BOTTOM)._borderBottom;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setBorderBottom: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BORDER_BOTTOM] || v !== this._borderBottom) {
                v = _createStroke(v);
				this._borderBottom = v;
				this._values[GridStyles.BORDER_BOTTOM] = true;
				this._fireEvents && this.changed(GridStyles.BORDER_BOTTOM);
			}
		} else if (this._values[GridStyles.BORDER_BOTTOM]) {
			delete this._borderBottom;
			this._values[GridStyles.BORDER_BOTTOM] = false;
			this._fireEvents && this.changed(GridStyles.BORDER_BOTTOM);
		}
	},
	borderBottomWidth: function () {
		var stroke = this.borderBottom();
		return stroke ? stroke.width() : 0;
	},
    borderVertWidth: function () {
        var stroke = this.borderTop();
        var w = stroke ? stroke.width() : 0;
        stroke = this.borderBottom();
        stroke && (w += stroke.width());
        return w;
    },
    borderLeftSize: undefined,
    borderLeftSize_: function () {
        return this.searchStyles(GridStyles.BORDER_LEFT_SIZE)._borderLeftSize;
    },
    setBorderLeftSize: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.BORDER_LEFT_SIZE] || v !== this._borderLeft) {
                this._borderLeftSize = GridStyles.getDimension(v);
                this._values[GridStyles.BORDER_LEFT_SIZE] = true;
                this._fireEvents && this.changed(GridStyles.BORDER_LEFT_SIZE);
            }
        } else if (this._values[GridStyles.BORDER_LEFT_SIZE]) {
            delete this._borderLeftSize;
            this._values[GridStyles.BORDER_LEFT_SIZE] = false;
            this._fireEvents && this.changed(GridStyles.BORDER_LEFT_SIZE);
        }
    },
    borderRightSize: undefined,
    borderRightSize_: function () {
        return this.searchStyles(GridStyles.BORDER_RIGHT_SIZE)._borderRightSize;
    },
    setBorderRightSize: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.BORDER_RIGHT_SIZE] || v !== this._borderRight) {
                this._borderRightSize = GridStyles.getDimension(v);
                this._values[GridStyles.BORDER_RIGHT_SIZE] = true;
                this._fireEvents && this.changed(GridStyles.BORDER_RIGHT_SIZE);
            }
        } else if (this._values[GridStyles.BORDER_RIGHT_SIZE]) {
            delete this._borderRightSize;
            this._values[GridStyles.BORDER_RIGHT_SIZE] = false;
            this._fireEvents && this.changed(GridStyles.BORDER_RIGHT_SIZE);
        }
    },
    borderTopSize: undefined,
    borderTopSize_: function () {
        return this.searchStyles(GridStyles.BORDER_TOP_SIZE)._borderTopSize;
    },
    setBorderTopSize: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.BORDER_TOP_SIZE] || v !== this._borderTop) {
                this._borderTopSize = GridStyles.getDimension(v);
                this._values[GridStyles.BORDER_TOP_SIZE] = true;
                this._fireEvents && this.changed(GridStyles.BORDER_TOP_SIZE);
            }
        } else if (this._values[GridStyles.BORDER_TOP_SIZE]) {
            delete this._borderTopSize;
            this._values[GridStyles.BORDER_TOP_SIZE] = false;
            this._fireEvents && this.changed(GridStyles.BORDER_TOP_SIZE);
        }
    },
    borderBottomSize: undefined,
    borderBottomSize_: function () {
        return this.searchStyles(GridStyles.BORDER_BOTTOM_SIZE)._borderBottomSize;
    },
    setBorderBottomSize: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.BORDER_BOTTOM_SIZE] || v !== this._borderBottom) {
                this._borderBottomSize = GridStyles.getDimension(v);
                this._values[GridStyles.BORDER_BOTTOM_SIZE] = true;
                this._fireEvents && this.changed(GridStyles.BORDER_BOTTOM_SIZE);
            }
        } else if (this._values[GridStyles.BORDER_BOTTOM_SIZE]) {
            delete this._borderBottomSize;
            this._values[GridStyles.BORDER_BOTTOM_SIZE] = false;
            this._fireEvents && this.changed(GridStyles.BORDER_BOTTOM_SIZE);
        }
    },
    borderRadius: undefined,
    borderRadius_: function () {
        return this.searchStyles(GridStyles.BORDER_RADIUS)._borderRadius;
    },
    setBorderRadius: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.BORDER_RADIUS] || v !== this._borderRadius) {
                this._borderRadius = v;
                this._values[GridStyles.BORDER_RADIUS] = true;
                this._fireEvents && this.changed(GridStyles.BORDER_RADIUS);
            }
        } else if (this._values[GridStyles.BORDER_RADIUS]) {
            delete this._borderRadius;
            this._values[GridStyles.BORDER_RADIUS] = false;
            this._fireEvents && this.changed(GridStyles.BORDER_RADIUS);
        }
    },
	line: undefined,
	line_: function () {
        var stroke = this.searchStyles(GridStyles.LINE)._line;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setLine: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.LINE] || v !== this._line) {
                v = _createStroke(v);
				this._line = v;
				this._values[GridStyles.LINE] = true;
				this._fireEvents && this.changed(GridStyles.LINE);
			}
		} else if (this._values[GridStyles.LINE]) {
			delete this._line;
			this._values[GridStyles.LINE] = false;
			this._fireEvents && this.changed(GridStyles.LINE);
		}
	},
	lineWidth: function () {
		var stroke = this.lineBottom();
		return stroke ? stroke.width() : 0;
	},
	fontName: undefined,
	fontName_: function () {
		return this.searchStyles(GridStyles.FONT_NAME)._fontName;
	},
    setFontName: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.FONT_NAME] || v !== this._fontName) {
				this._fontName = v;
				this._values[GridStyles.FONT_NAME] = true;
				this._fireEvents && this.changed(GridStyles.FONT_NAME);
			}
		} else if (this._values[GridStyles.FONT_NAME]) {
			delete this._fontName;
			this._values[GridStyles.FONT_NAME] = false;
			this._fireEvents && this.changed(GridStyles.FONT_NAME);
		}
    },
	fontSize: undefined,
	fontSize_: function () {
		return this.searchStyles(GridStyles.FONT_SIZE)._fontSize;
	},
	setFontSize: function (v) {
		if (v !== undefined) {
            if (_isFontText(v)) {
                v = parseFloat(v.substr(0, v.length - 2));
                if (!isNaN(v)) {
                    v = Math.round(v * 97 / 76);
                }
            } else {
                v = parseInt(v);
            }
			if (!this._values[GridStyles.FONT_SIZE] || v !== this._fontSize) {
				this._fontSize = v;
				this._values[GridStyles.FONT_SIZE] = true;
				this._fireEvents && this.changed(GridStyles.FONT_SIZE);
			}
		} else if (this._values[GridStyles.FONT_SIZE]) {
			delete this._fontSize;
			this._values[GridStyles.FONT_SIZE] = false;
			this._fireEvents && this.changed(GridStyles.FONT_SIZE);
		}
	},
	fontBold: undefined,
	fontBold_: function () {
		return this.searchStyles(GridStyles.FONT_BOLD)._fontBold;
	},
	setFontBold: function (v) {
		if (v !== undefined) {
			v = v && v !== "false";
			if (!this._values[GridStyles.FONT_BOLD] || v !== this._fontBold) {
				this._fontBold = v;
				this._values[GridStyles.FONT_BOLD] = true;
				this._fireEvents && this.changed(GridStyles.FONT_BOLD);
			}
		} else if (this._values[GridStyles.FONT_BOLD]) {
			delete this._fontBold;
			this._values[GridStyles.FONT_BOLD] = false;
			this._fireEvents && this.changed(GridStyles.FONT_BOLD);
		}
	},
	fontItalic: undefined,
	fontItalic_: function () {
		return this.searchStyles(GridStyles.FONT_ITALIC)._fontItalic;
	},
	setFontItalic: function (v) {
		if (v !== undefined) {
			v = v && v !== "false";
			if (!this._values[GridStyles.FONT_ITALIC] || v !== this._fontItalic) {
				this._fontItalic = v;
				this._values[GridStyles.FONT_ITALIC] = true;
				this._fireEvents && this.changed(GridStyles.FONT_ITALIC);
			}
		} else if (this._values[GridStyles.FONT_ITALIC]) {
			delete this._fontItalic;
			this._values[GridStyles.FONT_ITALIC] = false;
			this._fireEvents && this.changed(GridStyles.FONT_ITALIC);
		}
	},
	textDecoration: undefined,
	textDecoration_: function () {
		return this.searchStyles(GridStyles.TEXT_DECORATION)._textDecoration;
	},
	setTextDecoration: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.TEXT_DECORATION] || v !== this._textDecoration) {
				this._textDecoration = v;
				this._values[GridStyles.TEXT_DECORATION] = true;
				this._fireEvents && this.changed(GridStyles.TEXT_DECORATION);
			}
		} else if (this._values[GridStyles.TEXT_DECORATION]) {
			delete this._textDecoration;
			this._values[GridStyles.TEXT_DECORATION] = false;
			this._fireEvents && this.changed(GridStyles.TEXT_DECORATION);
		}
	},
	textDecorationColor: undefined,
	textDecorationColor_: function () {
		return this.searchStyles(GridStyles.TEXT_DECORATION_COLOR)._textDecorationColor;
	},
	setTextDecorationColor: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.TEXT_DECORATION_COLOR] || v !== this._textDecorationColor) {
                v = _createStroke(v);
				this._textDecorationColor = v;
				this._values[GridStyles.TEXT_DECORATION_COLOR] = true;
				this._fireEvents && this.changed(GridStyles.TEXT_DECORATION_COLOR);
			}
		} else if (this._values[GridStyles.TEXT_DECORATION_COLOR]) {
			delete this._textDecorationColor;
			this._values[GridStyles.TEXT_DECORATION_COLOR] = false;
			this._fireEvents && this.changed(GridStyles.TEXT_DECORATION_COLOR);
		}
	},
	textShadow: undefined,
	textShadow_: function () {
		return this.searchStyles(GridStyles.TEXT_SHADOW)._textShadow;
	},
	setTextShadow: function (v) {
		if (v !== undefined) {
			v = _createShadow(v);
			if (!this._values[GridStyles.TEXT_SHADOW] || v !== this._textShadow) {
				this._textShadow = v;
				this._values[GridStyles.TEXT_SHADOW] = true;
				this._fireEvents && this.changed(GridStyles.TEXT_SHADOW);
			}
		} else if (this._values[GridStyles.TEXT_SHADOW]) {
			delete this._textShadow;
			this._values[GridStyles.TEXT_SHADOW] = false;
			this._fireEvents && this.changed(GridStyles.TEXT_SHADOW);
		}
	},
	textAlignment: undefined,
	textAlignment_: function () {
		return this.searchStyles(GridStyles.TEXT_ALIGNMENT)._textAlignment;
	},
	setTextAlignment: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.TEXT_ALIGNMENT] || v !== this._textAlignment) {
				this._textAlignment = v;
				this._values[GridStyles.TEXT_ALIGNMENT] = true;
				this._fireEvents && this.changed(GridStyles.TEXT_ALIGNMENT);
			}
		} else if (this._values[GridStyles.TEXT_ALIGNMENT]) {
			delete this._textAlignment;
			this._values[GridStyles.TEXT_ALIGNMENT] = false;
			this._fireEvents && this.changed(GridStyles.TEXT_ALIGNMENT);
		}
	},
	lineAlignment: undefined,
	lineAlignment_: function () {
		return this.searchStyles(GridStyles.LINE_ALIGNMENT)._lineAlignment;
	},
	setLineAlignment: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.LINE_ALIGNMENT] || v !== this._lineAlignment) {
				this._lineAlignment = v;
				this._values[GridStyles.LINE_ALIGNMENT] = true;
				this._fireEvents && this.changed(GridStyles.LINE_ALIGNMENT);
			}
		} else if (this._values[GridStyles.LINE_ALIGNMENT]) {
			delete this._lineAlignment;
			this._values[GridStyles.LINE_ALIGNMENT] = false;
			this._fireEvents && this.changed(GridStyles.LINE_ALIGNMENT);
		}
	},
    textWrap: undefined,
    textWrap_: function () {
        return this.searchStyles(GridStyles.TEXT_WRAP)._textWrap;
    },
    setTextWrap: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.TEXT_WRAP] || v !== this._textWrap) {
                this._textWrap = v;
                this._values[GridStyles.TEXT_WRAP] = true;
                this._fireEvents && this.changed(GridStyles.TEXT_WRAP);
            }
        } else if (this._values[GridStyles.TEXT_WRAP]) {
            delete this._textWrap;
            this._values[GridStyles.TEXT_WRAP] = false;
            this._fireEvents && this.changed(GridStyles.TEXT_WRAP);
        }
    },
    textFormat: undefined,
    textFormat_: function () {
        return this.searchStyles(GridStyles.TEXT_FORMAT)._textFormat;
    },
    setTextFormat: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.TEXT_FORMAT] || v !== this._textFormat) {
                this._textFormat = v;
                this._values[GridStyles.TEXT_FORMAT] = true;
                this._fireEvents && this.changed(GridStyles.TEXT_FORMAT);
            }
        } else if (this._values[GridStyles.TEXT_FORMAT]) {
            delete this._textFormat;
            this._values[GridStyles.TEXT_FORMAT] = false;
            this._fireEvents && this.changed(GridStyles.TEXT_FORMAT);
        }
    },
	numberFormat: undefined,
	numberFormat_: function () {
		return this.searchStyles(GridStyles.NUMBER_FORMAT)._numberFormat;
	},
	setNumberFormat: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.NUMBER_FORMAT] || v !== this._numberFormat) {
				this._numberFormat = v;
				this._values[GridStyles.NUMBER_FORMAT] = true;
				this._fireEvents && this.changed(GridStyles.NUMBER_FORMAT);
			}
		} else if (this._values[GridStyles.NUMBER_FORMAT]) {
			delete this._numberFormat;
			this._values[GridStyles.NUMBER_FORMAT] = false;
			this._fireEvents && this.changed(GridStyles.NUMBER_FORMAT);
		}
	},
	datetimeFormat: undefined,
	datetimeFormat_: function () {
		return this.searchStyles(GridStyles.DATETIME_FORMAT)._datetimeFormat;
	},
	setDatetimeFormat: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.DATETIME_FORMAT] || v !== this._datetimeFormat) {
				this._datetimeFormat = v;
				this._values[GridStyles.DATETIME_FORMAT] = true;
				this._fireEvents && this.changed(GridStyles.DATETIME_FORMAT);
			}
		} else if (this._values[GridStyles.DATETIME_FORMAT]) {
			delete this._datetimeFormat;
			this._values[GridStyles.DATETIME_FORMAT] = false;
			this._fireEvents && this.changed(GridStyles.DATETIME_FORMAT);
		}
	},
	booleanFormat: undefined,
	booleanFormat_: function () {
		return this.searchStyles(GridStyles.BOOLEAN_FORMAT)._booleanFormat;
	},
	setBooleanFormat: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.BOOLEAN_FORMAT] || v !== this._booleanFormat) {
				this._booleanFormat = v;
				this._values[GridStyles.BOOLEAN_FORMAT] = true;
				this._fireEvents && this.changed(GridStyles.BOOLEAN_FORMAT);
			}
		} else if (this._values[GridStyles.BOOLEAN_FORMAT]) {
			delete this._booleanFormat;
			this._values[GridStyles.BOOLEAN_FORMAT] = false;
			this._fireEvents && this.changed(GridStyles.BOOLEAN_FORMAT);
		}
	},
	prefix: undefined,
	prefix_: function () {
		return this.searchStyles(GridStyles.PREFIX)._prefix;
	},
	setPrefix: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.PREFIX] || v !== this._prefix) {
				this._prefix = v;
				this._values[GridStyles.PREFIX] = true;
				this._fireEvents && this.changed(GridStyles.PREFIX);
			}
		} else if (this._values[GridStyles.PREFIX]) {
			delete this._prefix;
			this._values[GridStyles.PREFIX] = false;
			this._fireEvents && this.changed(GridStyles.PREFIX);
		}
	},
	suffix: undefined,
	suffix_: function () {
		return this.searchStyles(GridStyles.SUFFIX)._suffix;
	},
	setSuffix: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.SUFFIX] || v !== this._suffix) {
				this._suffix = v;
				this._values[GridStyles.SUFFIX] = true;
				this._fireEvents && this.changed(GridStyles.SUFFIX);
			}
		} else if (this._values[GridStyles.SUFFIX]) {
			delete this._suffix;
			this._values[GridStyles.SUFFIX] = false;
			this._fireEvents && this.changed(GridStyles.SUFFIX);
		}
	},
	marginLeft: undefined,
	marginLeft_: function () {
		return this.searchStyles(GridStyles.MARGIN_LEFT)._marginLeft;
	},
	setMarginLeft: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.MARGIN_LEFT] || v !== this._marginLeft) {
				this._marginLeft = v;
				this._values[GridStyles.MARGIN_LEFT] = true;
				this._fireEvents && this.changed(GridStyles.MARGIN_LEFT);
			}
		} else if (this._values[GridStyles.MARGIN_LEFT]) {
			delete this._marginLeft;
			this._values[GridStyles.MARGIN_LEFT] = false;
			this._fireEvents && this.changed(GridStyles.MARGIN_LEFT);
		}
	},
	marginRight: undefined,
	marginRight_: function () {
		return this.searchStyles(GridStyles.MARGIN_RIGHT)._marginRight;
	},
	setMarginRight: function (v) {
		if (v !== undefined) {
            v = parseInt(v);
			if (!this._values[GridStyles.MARGIN_RIGHT] || v !== this._marginRight) {
				this._marginRight = v;
				this._values[GridStyles.MARGIN_RIGHT] = true;
				this._fireEvents && this.changed(GridStyles.MARGIN_RIGHT);
			}
		} else if (this._values[GridStyles.MARGIN_RIGHT]) {
			delete this._marginRight;
			this._values[GridStyles.MARGIN_RIGHT] = false;
			this._fireEvents && this.changed(GridStyles.MARGIN_RIGHT);
		}
	},
	marginTop: undefined,
	marginTop_: function () {
		return this.searchStyles(GridStyles.MARGIN_TOP)._marginTop;
	},
	setMarginTop: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.MARGIN_TOP] || v !== this._marginTop) {
				this._marginTop = v;
				this._values[GridStyles.MARGIN_TOP] = true;
				this._fireEvents && this.changed(GridStyles.MARGIN_TOP);
			}
		} else if (this._values[GridStyles.MARGIN_TOP]) {
			delete this._marginTop;
			this._values[GridStyles.MARGIN_TOP] = false;
			this._fireEvents && this.changed(GridStyles.MARGIN_TOP);
		}
	},
	marginBottom: undefined,
	marginBottom_: function () {
		return this.searchStyles(GridStyles.MARGIN_BOTTOM)._marginBottom;
	},
	setMarginBottom: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.MARGIN_BOTTOM] || v !== this._marginBottom) {
				this._marginBottom = v;
				this._values[GridStyles.MARGIN_BOTTOM] = true;
				this._fireEvents && this.changed(GridStyles.MARGIN_BOTTOM);
			}
		} else if (this._values[GridStyles.MARGIN_BOTTOM]) {
			delete this._marginBottom;
			this._values[GridStyles.MARGIN_BOTTOM] = false;
			this._fireEvents && this.changed(GridStyles.MARGIN_BOTTOM);
		}
	},
	marginHorz: function () {
		return this.marginLeft() + this.marginRight();
	},
	marginVert: function () {
		return this.marginTop() + this.marginBottom();
	},
	paddingLeft: undefined,
	paddingLeft_: function () {
		return this.searchStyles(GridStyles.PADDING_LEFT)._paddingLeft;
	},
	setPaddingLeft: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.PADDING_LEFT] || v !== this._paddingLeft) {
				this._paddingLeft = v;
				this._values[GridStyles.PADDING_LEFT] = true;
				this._fireEvents && this.changed(GridStyles.PADDING_LEFT);
			}
		} else if (this._values[GridStyles.PADDING_LEFT]) {
			delete this._paddingLeft;
			this._values[GridStyles.PADDING_LEFT] = false;
			this._fireEvents && this.changed(GridStyles.PADDING_LEFT);
		}
	},
	paddingRight: undefined,
	paddingRight_: function () {
		return this.searchStyles(GridStyles.PADDING_RIGHT)._paddingRight;
	},
	setPaddingRight: function (v) {
		if (v !== undefined) {
            v = parseInt(v);
			if (!this._values[GridStyles.PADDING_RIGHT] || v !== this._paddingRight) {
				this._paddingRight = v;
				this._values[GridStyles.PADDING_RIGHT] = true;
				this._fireEvents && this.changed(GridStyles.PADDING_RIGHT);
			}
		} else if (this._values[GridStyles.PADDING_RIGHT]) {
			delete this._paddingRight;
			this._values[GridStyles.PADDING_RIGHT] = false;
			this._fireEvents && this.changed(GridStyles.PADDING_RIGHT);
		}
	},
	paddingTop: undefined,
	paddingTop_: function () {
		return this.searchStyles(GridStyles.PADDING_TOP)._paddingTop;
	},
	setPaddingTop: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.PADDING_TOP] || v !== this._paddingTop) {
				this._paddingTop = v;
				this._values[GridStyles.PADDING_TOP] = true;
				this._fireEvents && this.changed(GridStyles.PADDING_TOP);
			}
		} else if (this._values[GridStyles.PADDING_TOP]) {
			delete this._paddingTop;
			this._values[GridStyles.PADDING_TOP] = false;
			this._fireEvents && this.changed(GridStyles.PADDING_TOP);
		}
	},
	paddingBottom: undefined,
	paddingBottom_: function () {
		return this.searchStyles(GridStyles.PADDING_BOTTOM)._paddingBottom;
	},
	setPaddingBottom: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.PADDING_BOTTOM] || v !== this._paddingBottom) {
				this._paddingBottom = v;
				this._values[GridStyles.PADDING_BOTTOM] = true;
				this._fireEvents && this.changed(GridStyles.PADDING_BOTTOM);
			}
		} else if (this._values[GridStyles.PADDING_BOTTOM]) {
			delete this._paddingBottom;
			this._values[GridStyles.PADDING_BOTTOM] = false;
			this._fireEvents && this.changed(GridStyles.PADDING_BOTTOM);
		}
	},
	paddingHorz: function () {
		return this.paddingLeft() + this.paddingRight();
	},
	paddingVert: function () {
		return this.paddingTop() + this.paddingBottom();
	},
	spaceLeft: function () {
		return this.paddingLeft() + this.marginLeft();
	},
	spaceRight: function () {
		return this.paddingRight() + this.marginRight();
	},
    spaceHorz: function () {
        return this.paddingLeft() + this.paddingRight() + this.marginLeft() + this.marginRight();
    },
	spaceTop: function () {
		return this.paddingTop() + this.marginTop();
	},
	spaceBottom: function () {
		return this.paddingBottom() + this.marginBottom();
	},
    spaceVert: function () {
        return this.paddingTop() + this.paddingBottom() + this.marginTop() + this.marginBottom();
    },
	iconIndex: undefined,
	iconIndex_: function () {
		return this.searchStyles(GridStyles.ICON_INDEX)._iconIndex;
	},
	setIconIndex: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.ICON_INDEX] || v !== this._iconIndex) {
				this._iconIndex = v;
				this._values[GridStyles.ICON_INDEX] = true;
				this._fireEvents && this.changed(GridStyles.ICON_INDEX);
			}
		} else if (this._values[GridStyles.ICON_INDEX]) {
			delete this._iconIndex;
			this._values[GridStyles.ICON_INDEX] = false;
			this._fireEvents && this.changed(GridStyles.ICON_INDEX);
		}
	},
	iconLocation: undefined,
	iconLocation_: function () {
		return this.searchStyles(GridStyles.ICON_LOCATION)._iconLocation;
	},
	setIconLocation: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.ICON_LOCATION] || v !== this._iconLocation) {
				this._iconLocation = v;
				this._values[GridStyles.ICON_LOCATION] = true;
				this._fireEvents && this.changed(GridStyles.ICON_LOCATION);
			}
		} else if (this._values[GridStyles.ICON_LOCATION]) {
			delete this._iconLocation;
			this._values[GridStyles.ICON_LOCATION] = false;
			this._fireEvents && this.changed(GridStyles.ICON_LOCATION);
		}
	},
	iconAlignment: undefined,
	iconAlignment_: function () {
		return this.searchStyles(GridStyles.ICON_ALIGNMENT)._iconAlignment;
	},
	setIconAlignment: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.ICON_ALIGNMENT] || v !== this._iconAlignment) {
				this._iconAlignment = v;
				this._values[GridStyles.ICON_ALIGNMENT] = true;
				this._fireEvents && this.changed(GridStyles.ICON_ALIGNMENT);
			}
		} else if (this._values[GridStyles.ICON_ALIGNMENT]) {
			delete this._iconAlignment;
			this._values[GridStyles.ICON_ALIGNMENT] = false;
			this._fireEvents && this.changed(GridStyles.ICON_ALIGNMENT);
		}
	},
	iconOffset: undefined,
	iconOffset_: function () {
		return this.searchStyles(GridStyles.ICON_OFFSET)._iconOffset;
	},
	setIconOffset: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.ICON_OFFSET] || v !== this._iconOffset) {
				this._iconOffset = v;
				this._values[GridStyles.ICON_OFFSET] = true;
				this._fireEvents && this.changed(GridStyles.ICON_OFFSET);
			}
		} else if (this._values[GridStyles.ICON_OFFSET]) {
			delete this._iconOffset;
			this._values[GridStyles.ICON_OFFSET] = false;
			this._fireEvents && this.changed(GridStyles.ICON_OFFSET);
		}
	},
	iconPadding: undefined,
	iconPadding_: function () {
		return this.searchStyles(GridStyles.ICON_PADDING)._iconPadding;
	},
	setIconPadding: function (v) {
		if (v !== undefined) {
			v = parseInt(v);
			if (!this._values[GridStyles.ICON_PADDING] || v !== this._iconPadding) {
				this._iconPadding = v;
				this._values[GridStyles.ICON_PADDING] = true;
				this._fireEvents && this.changed(GridStyles.ICON_PADDING);
			}
		} else if (this._values[GridStyles.ICON_PADDING]) {
			delete this._iconPadding;
			this._values[GridStyles.ICON_PADDING] = false;
			this._fireEvents && this.changed(GridStyles.ICON_PADDING);
		}
	},
    iconAlpha: undefined,
    iconAlpha_: function () {
        return this.searchStyles(GridStyles.ICON_ALPHA)._iconAlpha;
    },
    setIconAlpha: function (v) {
        if (v !== undefined) {
            v = parseFloat(v);
            if (!this._values[GridStyles.ICON_ALPHA] || v !== this._iconAlpha) {
                this._iconAlpha = v;
                this._values[GridStyles.ICON_ALPHA] = true;
                this._fireEvents && this.changed(GridStyles.ICON_ALPHA);
            }
        } else if (this._values[GridStyles.ICON_ALPHA]) {
            delete this._iconAlpha;
            this._values[GridStyles.ICON_ALPHA] = false;
            this._fireEvents && this.changed(GridStyles.ICON_ALPHA);
        }
    },
    shapeName: undefined,
    shapeName_: function () {
        return this.searchStyles(GridStyles.SHAPE_NAME)._shapeName;
    },
    setShapeName: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_NAME] || v !== this._shapeName) {
                this._shapeName = v;
                this._values[GridStyles.SHAPE_NAME] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_NAME);
            }
        } else if (this._values[GridStyles.SHAPE_NAME]) {
            delete this._shapeName;
            this._values[GridStyles.SHAPE_NAME] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_NAME);
        }
    },
	shapeColor: undefined,
	shapeColor_: function () {
		var fill = this.searchStyles(GridStyles.SHAPE_COLOR)._shapeColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
	},
	setShapeColor: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.SHAPE_COLOR] || v !== this._shapeColor) {
                v = _createFill(v, this._scope);
				this._shapeColor = v;
				this._values[GridStyles.SHAPE_COLOR] = true;
				this._fireEvents && this.changed(GridStyles.SHAPE_COLOR);
			}
		} else if (this._values[GridStyles.SHAPE_COLOR]) {
			delete this._shapeColor;
			this._values[GridStyles.SHAPE_COLOR] = false;
			this._fireEvents && this.changed(GridStyles.SHAPE_COLOR);
		}
	},
    shapeColors: undefined,
    shapeColors_: function () {
        var colors = this.searchStyles(GridStyles.SHAPE_COLORS)._shapeColors;
        if (colors && !(colors instanceof FillPalette) && this._scope) {
            colors = this._scope.getPalette(colors);
        }
        return colors;
    },
    setShapeColors: function (v) {
        if (v !== undefined) {
            v = typeof v == "string" ? v : _isArray(v) ? new FillPalette(this, v) : null;
            if (!this._values[GridStyles.SHAPE_COLORS] || v !== this._shapeColors) {
                this._shapeColors = v;
                this._values[GridStyles.SHAPE_COLORS] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_COLORS);
            }
        } else if (this._values[GridStyles.SHAPE_COLORS]) {
            delete this._shapeColors;
            this._values[GridStyles.SHAPE_COLORS] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_COLORS);
        }
    },
    shapeInactiveColor: undefined,
    shapeInactiveColor_: function () {
        var fill = this.searchStyles(GridStyles.SHAPE_INACTIVE_COLOR)._shapeInactiveColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setShapeInactiveColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INACTIVE_COLOR] || v !== this._shapeInactiveColor) {
                v = _createFill(v, this._scope);
                this._shapeInactiveColor = v;
                this._values[GridStyles.SHAPE_INACTIVE_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INACTIVE_COLOR);
            }
        } else if (this._values[GridStyles.SHAPE_INACTIVE_COLOR]) {
            delete this._shapeInactiveColor;
            this._values[GridStyles.SHAPE_INACTIVE_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INACTIVE_COLOR);
        }
    },
    shapeSelectedColor: undefined,
    shapeSelectedColor_: function () {
        var fill = this.searchStyles(GridStyles.SHAPE_SELECTED_COLOR)._shapeSelectedColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setShapeSelectedColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_SELECTED_COLOR] || v !== this._shapeSelectedColor) {
                v = _createFill(v, this._scope);
                this._shapeSelectedColor = v;
                this._values[GridStyles.SHAPE_SELECTED_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_SELECTED_COLOR);
            }
        } else if (this._values[GridStyles.SHAPE_SELECTED_COLOR]) {
            delete this._shapeSelectedColor;
            this._values[GridStyles.SHAPE_SELECTED_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_SELECTED_COLOR);
        }
    },
    shapeHoveredColor: undefined,
    shapeHoveredColor_: function () {
        var fill = this.searchStyles(GridStyles.SHAPE_HOVERED_COLOR)._shapeHoveredColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setShapeHoveredColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_HOVERED_COLOR] || v !== this._shapeHoveredColor) {
                v = _createFill(v, this._scope);
                this._shapeHoveredColor = v;
                this._values[GridStyles.SHAPE_HOVERED_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_HOVERED_COLOR);
            }
        } else if (this._values[GridStyles.SHAPE_HOVERED_COLOR]) {
            delete this._shapeHoveredColor;
            this._values[GridStyles.SHAPE_HOVERED_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_HOVERED_COLOR);
        }
    },
	shapeBorder: undefined,
	shapeBorder_: function () {
        var stroke = this.searchStyles(GridStyles.SHAPE_BORDER)._shapeBorder;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
	},
	setShapeBorder: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.SHAPE_BORDER] || v !== this._shapeBorder) {
                v = _createStroke(v);
				this._shapeBorder = v;
				this._values[GridStyles.SHAPE_BORDER] = true;
				this._fireEvents && this.changed(GridStyles.SHAPE_BORDER);
			}
		} else if (this._values[GridStyles.SHAPE_BORDER]) {
			delete this._shapeBorder;
			this._values[GridStyles.SHAPE_BORDER] = false;
			this._fireEvents && this.changed(GridStyles.SHAPE_BORDER);
		}
	},
    shapeInactiveBorder: undefined,
    shapeInactiveBorder_: function () {
        var stroke = this.searchStyles(GridStyles.SHAPE_INACTIVE_BORDER)._shapeInactiveBorder;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
    },
    setShapeInactiveBorder: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INACTIVE_BORDER] || v !== this._shapeInactiveBorder) {
                v = _createStroke(v);
                this._shapeInactiveBorder = v;
                this._values[GridStyles.SHAPE_INACTIVE_BORDER] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INACTIVE_BORDER);
            }
        } else if (this._values[GridStyles.SHAPE_INACTIVE_BORDER]) {
            delete this._shapeInactiveBorder;
            this._values[GridStyles.SHAPE_INACTIVE_BORDER] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INACTIVE_BORDER);
        }
    },
    shapeSelectedBorder: undefined,
    shapeSelectedBorder_: function () {
        var stroke = this.searchStyles(GridStyles.SHAPE_SELECTED_BORDER)._shapeSelectedBorder;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
    },
    setShapeSelectedBorder: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_SELECTED_BORDER] || v !== this._shapeSelectedBorder) {
                v = _createStroke(v);
                this._shapeSelectedBorder = v;
                this._values[GridStyles.SHAPE_SELECTED_BORDER] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_SELECTED_BORDER);
            }
        } else if (this._values[GridStyles.SHAPE_SELECTED_BORDER]) {
            delete this._shapeSelectedBorder;
            this._values[GridStyles.SHAPE_SELECTED_BORDER] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_SELECTED_BORDER);
        }
    },
    shapeHoveredBorder: undefined,
    shapeHoveredBorder_: function () {
        var stroke = this.searchStyles(GridStyles.SHAPE_HOVERED_BORDER)._shapeHoveredBorder;
        return stroke && stroke.fetch ? stroke.fetch(this._scope) : stroke;
    },
    setShapeHoveredBorder: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_HOVERED_BORDER] || v !== this._shapeHoveredBorder) {
                v = _createStroke(v);
                this._shapeHoveredBorder = v;
                this._values[GridStyles.SHAPE_HOVERED_BORDER] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_HOVERED_BORDER);
            }
        } else if (this._values[GridStyles.SHAPE_HOVERED_BORDER]) {
            delete this._shapeHoveredBorder;
            this._values[GridStyles.SHAPE_HOVERED_BORDER] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_HOVERED_BORDER);
        }
    },
    shapeLocation: undefined,
    shapeLocation_: function () {
        return this.searchStyles(GridStyles.SHAPE_LOCATION)._shapeLocation;
    },
    setShapeLocation: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_LOCATION] || v !== this._shapeLocation) {
                this._shapeLocation = v;
                this._values[GridStyles.SHAPE_LOCATION] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_LOCATION);
            }
        } else if (this._values[GridStyles.SHAPE_LOCATION]) {
            delete this._shapeLocation;
            this._values[GridStyles.SHAPE_LOCATION] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_LOCATION);
        }
    },
    shapeAlignment: undefined,
    shapeAlignment_: function () {
        return this.searchStyles(GridStyles.SHAPE_ALIGNMENT)._shapeAlignment;
    },
    setShapeAlignment: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_ALIGNMENT] || v !== this._shapeAlignment) {
                this._shapeAlignment = v;
                this._values[GridStyles.SHAPE_ALIGNMENT] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_ALIGNMENT);
            }
        } else if (this._values[GridStyles.SHAPE_ALIGNMENT]) {
            delete this._shapeAlignment;
            this._values[GridStyles.SHAPE_ALIGNMENT] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_ALIGNMENT);
        }
    },
    shapeOffset: undefined,
    shapeOffset_: function () {
        return this.searchStyles(GridStyles.SHAPE_OFFSET)._shapeOffset;
    },
    setShapeOffset: function (v) {
        if (v !== undefined) {
            v = parseInt(v);
            if (!this._values[GridStyles.SHAPE_OFFSET] || v !== this._shapeOffset) {
                this._shapeOffset = v;
                this._values[GridStyles.SHAPE_OFFSET] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_OFFSET);
            }
        } else if (this._values[GridStyles.SHAPE_OFFSET]) {
            delete this._shapeOffset;
            this._values[GridStyles.SHAPE_OFFSET] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_OFFSET);
        }
    },
    shapePadding: undefined,
    shapePadding_: function () {
        return this.searchStyles(GridStyles.SHAPE_PADDING)._shapePadding;
    },
    setShapePadding: function (v) {
        if (v !== undefined) {
            v = parseInt(v);
            if (!this._values[GridStyles.SHAPE_PADDING] || v !== this._shapePadding) {
                this._shapePadding = v;
                this._values[GridStyles.SHAPE_PADDING] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_PADDING);
            }
        } else if (this._values[GridStyles.SHAPE_PADDING]) {
            delete this._shapePadding;
            this._values[GridStyles.SHAPE_PADDING] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_PADDING);
        }
    },
	shapeSize: undefined,
	shapeSize_: function () {
		return this.searchStyles(GridStyles.SHAPE_SIZE)._shapeSize;
	},
	setShapeSize: function (v) {
		if (v !== undefined) {
			if (!this._values[GridStyles.SHAPE_SIZE] || v !== this._shapeSize) {
				this._shapeSize = GridStyles.getDimension(v);
				this._values[GridStyles.SHAPE_SIZE] = true;
				this._fireEvents && this.changed(GridStyles.SHAPE_SIZE);
			}
		} else if (this._values[GridStyles.SHAPE_SIZE]) {
			delete this._shapeSize;
			this._values[GridStyles.SHAPE_SIZE] = false;
			this._fireEvents && this.changed(GridStyles.SHAPE_SIZE);
		}
	},
	shapeRotate: undefined,
	shapeRotate_: function () {
		return this.searchStyles(GridStyles.SHAPE_ROTATE)._shapeRotate;
	},
	setShapeRotate: function (v) {
		if (v !== undefined) {
            v = parseFloat(v);
			if (!this._values[GridStyles.SHAPE_ROTATE] || v !== this._shapeRotate) {
				this._shapeRotate = v;
				this._values[GridStyles.SHAPE_ROTATE] = true;
				this._fireEvents && this.changed(GridStyles.SHAPE_ROTATE);
			}
		} else if (this._values[GridStyles.SHAPE_ROTATE]) {
			delete this._shapeRotate;
			this._values[GridStyles.SHAPE_ROTATE] = false;
			this._fireEvents && this.changed(GridStyles.SHAPE_ROTATE);
		}
	},
    shapeInnerName: undefined,
    shapeInnerName_: function () {
        return this.searchStyles(GridStyles.SHAPE_INNER_NAME)._shapeInnerName;
    },
    setShapeInnerName: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INNER_NAME] || v !== this._shapeInnerName) {
                this._shapeInnerName = v;
                this._values[GridStyles.SHAPE_INNER_NAME] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INNER_NAME);
            }
        } else if (this._values[GridStyles.SHAPE_INNER_NAME]) {
            delete this._shapeInnerName;
            this._values[GridStyles.SHAPE_INNER_NAME] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INNER_NAME);
        }
    },
    shapeInnerColor: undefined,
    shapeInnerColor_: function () {
        var fill = this.searchStyles(GridStyles.SHAPE_INNER_COLOR)._shapeInnerColor;
        return fill && fill.fetch ? fill.fetch(this._scope) : fill;
    },
    setShapeInnerColor: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INNER_COLOR] || v !== this._shapeInnerColor) {
                v = _createFill(v, this._scope);
                this._shapeInnerColor = v;
                this._values[GridStyles.SHAPE_INNER_COLOR] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INNER_COLOR);
            }
        } else if (this._values[GridStyles.SHAPE_INNER_COLOR]) {
            delete this._shapeInnerColor;
            this._values[GridStyles.SHAPE_INNER_COLOR] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INNER_COLOR);
        }
    },
    shapeInnerSize: undefined,
    shapeInnerSize_: function () {
        return this.searchStyles(GridStyles.SHAPE_INNER_SIZE)._shapeInnerSize;
    },
    setShapeInnerSize: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INNER_SIZE] || v !== this._shapeInnerSize) {
                this._shapeInnerSize = Math.max(0, Math.min(1, v));
                this._values[GridStyles.SHAPE_INNER_SIZE] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INNER_SIZE);
            }
        } else if (this._values[GridStyles.SHAPE_INNER_SIZE]) {
            delete this._shapeInnerSize;
            this._values[GridStyles.SHAPE_INNER_SIZE] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INNER_SIZE);
        }
    },
    shapeInnerRotate: undefined,
    shapeInnerRotate_: function () {
        return this.searchStyles(GridStyles.SHAPE_INNER_ROTATE)._shapeInnerRotate;
    },
    setShapeInnerRotate: function (v) {
        if (v !== undefined) {
            if (!this._values[GridStyles.SHAPE_INNER_ROTATE] || v !== this._shapeInnerRotate) {
                this._shapeInnerRotate = v;
                this._values[GridStyles.SHAPE_INNER_ROTATE] = true;
                this._fireEvents && this.changed(GridStyles.SHAPE_INNER_ROTATE);
            }
        } else if (this._values[GridStyles.SHAPE_INNER_ROTATE]) {
            delete this._shapeInnerRotate;
            this._values[GridStyles.SHAPE_INNER_ROTATE] = false;
            this._fireEvents && this.changed(GridStyles.SHAPE_INNER_ROTATE);
        }
    },
	font: function () {
            var name, s, line, d,
                font = [],
                sz = this.fontSize(),
                i = this.fontItalic(),
                b = this.fontBold();
            i && font.push("italic");
            b && font.push("bold");
            font.push(sz + "px");
            if (name = this.fontName()) {
                font.push(name);
            }
            s = font.join(" ");
            line = '';
            d = this.textDecoration();
            if (d) {
                if (d === "lineThrough") d = "line-through";
                line = this.textDecorationColor();
                line = line ? line._color : '';
            }
            return { font: s, size: sz, /*bold: b, italic: i,*/ deco: d, line: line };
	},
	setFont: function (value) {
        var arr, len, i,s;
		value = value && value.trim();
        if (value) {
			arr = value.split($$_FONT_REG);
			len = arr.length;
			if (len > 0 && arr[0]) {
				this.fontName(arr[0]);
			}
			if (len > 1 && arr[1]) {
				this.fontSize(arr[1]);
			}
			for (i = 2; i < len; i++) {
				s = arr[i];
				if (s) {
					s = s.toLowerCase();
					switch (s) {
						case "bold":
							this.setFontBold(true);
							break;
						case "italic":
							this.setFontItalic(true);
							break;
						case "underline":
						case "lineThrough":
						case "line-through":
							this.setTextDecoration(s);
							break;
					}
				}
			}
		}
	},
    clone: function () {
        var s = new GridStyles();
        s._owner = this._owner;
        s._name = this._name;
        s._parent = this._parent;
        s._sysDefault = this._sysDefault;
        s._values = this._values.concat();
        s._fireEvents = this.fireEvents;
        s._scope = this._scope;
        return s;
    },
	setParentAndDefault: function (parent, sysDefault) {
		this._parent = parent;
		this._sysDefault = sysDefault;
        return this;
	},
	beginUpdate: function () {
		this._updateLock++;
	},
	endUpdate: function (fireEvent) {
		fireEvent = arguments.length > 0 ? fireEvent : true;
		this._updateLock--;
		if (this._updateLock == 0 && this._fireEvents) {
			this.changed(GridStyles.STYLE_ALL, fireEvent);
		}
	},
	hasValue: function (entry) {
		return typeof entry === "string" ? this._values[GridStyles.STYLE_NAMES[entry]] : this._values[entry];
	},
    getValue: function (entry) {
        return this["_" + entry];
    },
    clearValue: function (entry) {
        if (typeof entry != "number") {
            entry = GridStyles.STYLE_NAMES[entry];
        }
        entry = _int(entry);
        if (!isNaN(entry) && entry >= 0) {// && entry < GridStyles.STYLE_LAST) {
            delete this._values[entry];
        }
    },
	clearValues: function () {
		this._values = [];
	},
	initialize: function (source) {
		this._values = [];
		source && this.extend(source);
	},
	extend: function (source, fireEvent) {
		fireEvent = arguments.length > 1 ? fireEvent : true;
		this.beginUpdate();
		try {
			if (source instanceof GridStyles) {
				var values = source._values;
				if (values[GridStyles.RENDERER]) {
					this.setRenderer(source._renderer);
				}
				if (values[GridStyles.BACKGROUND]) {
					this.setBackground(source._background);
				}
				if (values[GridStyles.INACTIVE_BACKGROUND]) {
					this.setInactiveBackground(source._inactiveBackground);
				}
				if (values[GridStyles.SELECTED_BACKGROUND]) {
					this.setSelectedBackground(source._selectedBackground);
				}
				if (values[GridStyles.HOVERED_BACKGROUND]) {
					this.setHoveredBackground(source._hoveredBackground);
				}
				if (values[GridStyles.COLOR]) {
					this.setColor(source._color);
				}
				if (values[GridStyles.INACTIVE_COLOR]) {
					this.setInactiveColor(source._inactiveColor);
				}
				if (values[GridStyles.SELECTED_COLOR]) {
					this.setSelectedColor(source._selectedColor);
				}
				if (values[GridStyles.HOVERED_COLOR]) {
					this.setHoveredColor(source._hoveredColor);
				}
				if (values[GridStyles.BORDER]) {
					this.setBorder(source._border);
				}
				if (values[GridStyles.BORDER_LEFT]) {
					this.setBorderLeft(source._borderLeft);
				}
				if (values[GridStyles.BORDER_RIGHT]) {
					this.setBorderRight(source._borderRight);
				}
				if (values[GridStyles.BORDER_TOP]) {
					this.setBorderTop(source._borderTop);
				}
				if (values[GridStyles.BORDER_BOTTOM]) {
					this.setBorderBottom(source._borderBottom);
				}
                if (values[GridStyles.BORDER_LEFT_SIZE]) {
                    this.setBorderLeftSize(source._borderLeftSize);
                }
                if (values[GridStyles.BORDER_RIGHT_SIZE]) {
                    this.setBorderRightSize(source._borderRightSize);
                }
                if (values[GridStyles.BORDER_TOP_SIZE]) {
                    this.setBorderTopSize(source._borderTopSize);
                }
                if (values[GridStyles.BORDER_BOTTOM_SIZE]) {
                    this.setBorderBottomSize(source._borderBottomSize);
                }
                if (values[GridStyles.BORDER_RADIUS]) {
                    this.setBorderRadius(source._borderRadius);
                }
				if (values[GridStyles.LINE]) {
					this.setLine(source._line);
				}
				if (values[GridStyles.FONT_NAME]) {
					this.setFontName(source._fontName);
				}
				if (values[GridStyles.FONT_SIZE]) {
					this.setFontSize(source._fontSize);
				}
				if (values[GridStyles.FONT_BOLD]) {
					this.setFontBold(source._fontBold);
				}
				if (values[GridStyles.FONT_ITALIC]) {
					this.setFontItalic(source._fontItalic);
				}
				if (values[GridStyles.TEXT_DECORATION]) {
					this.setTextDecoration(source._textDecoration);
				}
				if (values[GridStyles.TEXT_DECORATION_COLOR]) {
					this.setTextDecorationColor(source._textDecorationColor);
				}
                if (values[GridStyles.TEXT_SHADOW]) {
                    this.setTextShadow(source._textShadow);
                }
				if (values[GridStyles.TEXT_ALIGNMENT]) {
					this.setTextAlignment(source._textAlignment);
				}
				if (values[GridStyles.LINE_ALIGNMENT]) {
					this.setLineAlignment(source._lineAlignment);
				}
				if (values[GridStyles.TEXT_WRAP]) {
					this.setTextWrap(source._textWrap);
				}
				if (values[GridStyles.NUMBER_FORMAT]) {
					this.setNumberFormat(source._numberFormat);
				}
                if (values[GridStyles.TEXT_FORMAT]) {
                    this.setTextFormat(source._textFormat);
                }
				if (values[GridStyles.DATETIME_FORMAT]) {
					this.setDatetimeFormat(source._datetimeFormat);
				}
				if (values[GridStyles.BOOLEAN_FORMAT]) {
					this.setBooleanFormat(source._booleanFormat);
				}
				if (values[GridStyles.PREFIX]) {
					this.setPrefix(source._prefix);
				}
				if (values[GridStyles.SUFFIX]) {
					this.setSuffix(source._suffix);
				}
				if (values[GridStyles.MARGIN_LEFT]) {
					this.setMarginLeft(source._marginLeft);
				}
				if (values[GridStyles.MARGIN_RIGHT]) {
					this.setMarginRight(source._marginRight);
				}
				if (values[GridStyles.MARGIN_TOP]) {
					this.setMarginTop(source._marginTop);
				}
				if (values[GridStyles.MARGIN_BOTTOM]) {
					this.setMarginBottom(source._marginBottom);
				}
				if (values[GridStyles.PADDING_LEFT]) {
					this.setPaddingLeft(source._paddingLeft);
				}
				if (values[GridStyles.PADDING_RIGHT]) {
					this.setPaddingRight(source._paddingRight);
				}
				if (values[GridStyles.PADDING_TOP]) {
					this.setPaddingTop(source._paddingTop);
				}
				if (values[GridStyles.PADDING_BOTTOM]) {
					this.setPaddingBottom(source._paddingBottom);
				}
                if (values[GridStyles.PADDING_BOTTOM]) {
                    this.setPaddingBottom(source._paddingBottom);
                }
				if (values[GridStyles.ICON_INDEX]) {
					this.setIconIndex(source._iconIndex);
				}
				if (values[GridStyles.ICON_LOCATION]) {
					this.setIconLocation(source._iconLocation);
				}
				if (values[GridStyles.ICON_ALIGNMENT]) {
					this.setIconAlignment(source._iconAlignment);
				}
				if (values[GridStyles.ICON_OFFSET]) {
					this.setIconOffset(source._iconOffset);
				}
				if (values[GridStyles.ICON_PADDING]) {
					this.setIconPadding(source._iconPadding);
				}
                if (values[GridStyles.ICON_ALPHA]) {
                    this.setIconAlpha(source._iconAlpha);
                }
				if (values[GridStyles.SHAPE_NAME]) {
					this.setShapeName(source._shapeName);
				}
				if (values[GridStyles.SHAPE_COLOR]) {
					this.setShapeColor(source._shapeColor);
				}
                if (values[GridStyles.SHAPE_COLORS]) {
                    this.setShapeColors(source._shapeColors);
                }
				if (values[GridStyles.SHAPE_INACTIVE_COLOR]) {
					this.setShapeInactiveColor(source._shapeInactiveColor);
				}
				if (values[GridStyles.SHAPE_SELECTED_COLOR]) {
					this.setShapeSelectedColor(source._shapeSelectedColor);
				}
				if (values[GridStyles.SHAPE_HOVERED_COLOR]) {
					this.setShapeHoveredColor(source._shapeHoveredColor);
				}
				if (values[GridStyles.SHAPE_BORDER]) {
					this.setShapeBorder(source._shapeBorder);
				}
				if (values[GridStyles.SHAPE_INACTIVE_BORDER]) {
					this.setShapeInactiveBorder(source._shapeInactiveBorder);
				}
				if (values[GridStyles.SHAPE_SELECTED_BORDER]) {
					this.setShapeSelectedBorder(source._shapeSelectedBorder);
				}
				if (values[GridStyles.SHAPE_HOVERED_BORDER]) {
					this.setShapeHoveredBorder(source._shapeHoveredBorder);
				}
                if (values[GridStyles.SHAPE_LOCATION]) {
                    this.setShapeLocation(source._shapeLocation);
                }
                if (values[GridStyles.SHAPE_ALIGNMENT]) {
                    this.setShapeAlignment(source._shapeAlignment);
                }
                if (values[GridStyles.SHAPE_OFFSET]) {
                    this.setShapeOffset(source._shapeOffset);
                }
                if (values[GridStyles.SHAPE_PADDING]) {
                    this.setShapePadding(source._shapePadding);
                }
				if (values[GridStyles.SHAPE_SIZE]) {
					this.setShapeSize(source._shapeSize);
				}
				if (values[GridStyles.SHAPE_ROTATE]) {
					this.setShapeRotate(source._shapeRotate);
				}
                if (values[GridStyles.SHAPE_INNER_NAME]) {
                    this.setShapeInnerName(source._shapeInnerName);
                }
                if (values[GridStyles.SHAPE_INNER_COLOR]) {
                    this.setShapeInnerColor(source._shapeInnerColor);
                }
                if (values[GridStyles.SHAPE_INNER_SIZE]) {
                    this.setShapeInnerSize(source._shapeInnerSize);
                }
                if (values[GridStyles.SHAPE_INNER_ROTATE]) {
                    this.setShapeInnerRotate(source._shapeInnerRotate);
                }
			} else if (_isObject(source)) {
				var v = source.margin;
				if (v !== undefined) {
					this.setMarginLeft(v);
					this.setMarginRight(v);
					this.setMarginTop(v);
					this.setMarginBottom(v);
				}
				v = source.padding;
				if (v !== undefined) {
					this.setPaddingLeft(v);
					this.setPaddingRight(v);
					this.setPaddingTop(v);
					this.setPaddingBottom(v);
				}
				for (var p in source) {
					var setter = this[$$_STYLE_PROP_MAP[p]];
					if (setter instanceof Function) {
						setter.call(this, source[p]);
					}
				}
			} else if (_isString(source)) {
				var props = source.split(';');
				for (var p in props) {
                    if (props[p]) {
                        var arr = props[p].split(':');
                        if (arr.length == 2) {
                            var prop = arr[0];
                            var val = arr[1];
                            if (prop === 'margin') {
								this.setMarginLeft(val);
								this.setMarginRight(val);
								this.setMarginTop(val);
								this.setMarginBottom(val);
							} else if (prop == 'padding') {
								this.setPaddingLeft(val);
								this.setPaddingRight(val);
								this.setPaddingTop(val);
								this.setPaddingBottom(val);
                            } else {
                                var setter2 = this[$$_STYLE_PROP_MAP[prop]];
                                if (setter2 instanceof Function) {
                                    setter2.call(this, val);
                                }
                            }
                        }
                    }
				}
			}
		} finally {
			this.endUpdate(fireEvent);
		}
	},
    proxy: function () {
        return {
            name: this._name,
            renderer: this._renderer,
            background: this._background,
            inactiveBackground: this._inactiveBackground,
            selectedBackground: this._selectedBackground,
            hoveredBackground: this._hoveredBackground,
            color: this._color,
            inactiveColor: this._inactiveColor,
            selectedColor: this._selectedColor,
            hoveredColor: this._hoveredColor,
            border: this._border,
            borderLeft: this._borderLeft,
            borderRight: this._borderRight,
            borderTop: this._borderTop,
            borderBottom: this._borderBottom,
            borderLeftSize: this._borderLeftSize,
            borderRightSize: this._borderRightSize,
            borderTopSize: this._borderTopSize,
            borderBottomSize: this._borderBottomSize,
            borderRadius: this._borderRadius,
            line: this._line,
            fontName: this._fontName,
            fontSize: this._fontSize,
            fontBold: this._fontBold,
            fontItalic: this._fontItalic,
            textDecoration: this._textDecoration,
			textDecorationColor: this._textDecorationColor,
            textShadow: this._textShadow,
            textAlignment: this._textAlignment,
            lineAlignment: this._lineAlignment,
            textWrap: this._textWrap,
            textFormat: this._textFormat,
            numberFormat: this._numberFormat,
            datetimeFormat: this._datetimeFormat,
            booleanFormat: this._booleanFormat,
            prefix: this._prefix,
            suffix: this._suffix,
            marginLeft: this._marginLeft,
            marginRight: this._marginRight,
            marginTop: this._marginTop,
            marginBottom: this._marginBottom,
            paddingLeft: this._paddingLeft,
            paddingRight: this._paddingRight,
            paddingTop: this._paddingTop,
            paddingBottom: this._paddingBottom,
            iconIndex: this._iconIndex,
            iconLocation: this._iconLocation,
            iconAlignment: this._iconAlignment,
            iconOffset: this._iconOffset,
            iconPadding: this._iconPadding,
            iconAlpha: this._iconAlpha,
            shapeName: this._shapeName,
            shapeColor: this._shapeColor,
            shapeColors: this._shapeColors,
            shapeInactiveColor: this._shapeInactiveColor,
            shapeSelectedColor: this._shapeSelectedColor,
            shapeHoveredColor: this._shapeHoveredColor,
            shapeBorder: this._shapeBorder,
            shapeInactiveBorder: this._shapeInactiveBorder,
            shapeSelectedBorder: this._shapeSelectedBorder,
            shapeHoveredBorder: this._shapeHoveredBorder,
            shapeLocation: this._shapeLocation,
            shapeAlignment: this._shapeAlignment,
            shapeOffset: this._shapeOffset,
            shapePadding: this._shapePadding,
            shapeSize: this._shapeSize,
            shapeRotate: this._shapeRotate,
            shapeInnerName: this._shapeInnerName,
            shapeInnerColor: this._shapeInnerColor,
            shapeInnerSize: this._shapeInnerSize,
            shapeInnerRotate: this._shapeInnerRotate
        };
    },
	deflatePaddings: function (r) {
		var v;
		r.x += (v = this.paddingLeft());
		r.width -= v + this.paddingRight();
		r.y += (v = this.paddingTop());
		r.height -= v + this.paddingBottom();
		return r;
	},
	inflatePaddings: function (r) {
		var v;
		r.x -= (v = this.paddingLeft());
		r.width += v + this.paddingRight();
		r.y -= (v = this.paddingTop());
		r.height += v + this.paddingBottom();
		return r;
	},
    deflateMargins: function (r) {
        var v;
        r.x += (v = this.marginLeft());
        r.width -= v + this.marginRight();
        r.y += (v = this.marginTop());
        r.height -= v + this.marginBottom();
        return r;
    },
    inflateMargins: function (r) {
        var v;
        r.x -= (v = this.marginLeft());
        r.width += v + this.marginRight();
        r.y -= (v = this.marginTop());
        r.height += v + this.marginBottom();
        return r;
    },
    deflateSpaces: function (r) {
        var v;
        r.x += (v = this.paddingLeft() + this.marginLeft());
        r.width -= v + this.paddingRight() + this.marginRight();
        r.y += (v = this.paddingTop() + this.marginTop());
        r.height -= v + this.paddingBottom() + this.marginBottom();
        return r;
    },
    inflateSpaces: function (r) {
        var v;
        r.x -= (v = this.paddingLeft() + this.marginLeft());
        r.width += v + this.paddingRight() + this.marginRight();
        r.y -= (v = this.paddingTop() + this.marginTop());
        r.height += v + this.paddingBottom() + this.marginBottom();
        return r;
    },
    paddings: function () {
        return this.paddingTop() + 'px ' +
                this.paddingRight() + 'px ' +
                this.paddingBottom() + 'px ' +
                this.paddingLeft() + 'px';
    },
	searchStyles: function (entry) {
		if (this._values[entry]) {
			return this;
		}
		var p = this._parent;
		while (p) {
			if (p._values[entry]) {
				return p;
			}
			p = p._parent;
		}
		if (this._sysDefault && this._sysDefault._values[entry]) {
			return this._sysDefault;
		}
		p = this._parent;
		while (p) {
			if (p._sysDefault && p._sysDefault._values[entry]) {
				return p._sysDefault;
			}
			p = p._parent;
		}
		return GridStyles.Default;
	},
	changed: function (entry, fireEvent) {
		fireEvent = arguments.length > 1 ? fireEvent : true;
		if (this._owner && this._updateLock == 0 && fireEvent) {
			this._owner.stylesChanged(this, entry);
		}
	}
}, {
	STYLE_ALL: -1,
    RENDERER: 0,
    BACKGROUND: 1,
    INACTIVE_BACKGROUND: 2,
	SELECTED_BACKGROUND: 3,
    HOVERED_BACKGROUND: 4,
    COLOR: 5,
    INACTIVE_COLOR: 6,
    SELECTED_COLOR: 7,
    HOVERED_COLOR: 8,
	BORDER: 9,
	BORDER_LEFT: 10,
	BORDER_RIGHT: 11,
	BORDER_TOP: 12,
	BORDER_BOTTOM: 13,
    BORDER_LEFT_SIZE: 14,
    BORDER_RIGHT_SIZE: 15,
    BORDER_TOP_SIZE: 16,
    BORDER_BOTTOM_SIZE: 17,
    BORDER_RADIUS: 18,
	LINE: 19,
    FONT_NAME: 20,
    FONT_SIZE: 21,
    FONT_BOLD: 22,
    FONT_ITALIC: 23,
	TEXT_DECORATION: 24,
    TEXT_DECORATION_COLOR: 25,
    TEXT_SHADOW: 26,
	TEXT_ALIGNMENT: 27,
	LINE_ALIGNMENT: 28,
    TEXT_WRAP: 29,
    TEXT_FORMAT: 30,
	NUMBER_FORMAT: 31,
	DATETIME_FORMAT: 32,
	BOOLEAN_FORMAT: 33,
	PREFIX: 34,
	SUFFIX: 35,
	MARGIN_LEFT: 36,
	MARGIN_RIGHT: 37,
	MARGIN_TOP: 38,
	MARGIN_BOTTOM: 39,
	PADDING_LEFT: 40,
	PADDING_RIGHT: 41,
	PADDING_TOP: 42,
	PADDING_BOTTOM: 43,
	ICON_INDEX: 44,
	ICON_LOCATION: 45,
	ICON_ALIGNMENT: 46,
	ICON_OFFSET: 47,
	ICON_PADDING: 48,
    ICON_ALPHA: 49,
    SHAPE_NAME: 50,
	SHAPE_COLOR: 51,
    SHAPE_COLORS: 52,
    SHAPE_INACTIVE_COLOR: 53,
    SHAPE_SELECTED_COLOR: 54,
    SHAPE_HOVERED_COLOR: 55,
	SHAPE_BORDER: 56,
    SHAPE_INACTIVE_BORDER: 57,
    SHAPE_SELECTED_BORDER: 58,
    SHAPE_HOVERED_BORDER: 59,
    SHAPE_LOCATION: 60,
    SHAPE_ALIGNMENT: 61,
    SHAPE_OFFSET: 62,
    SHAPE_PADDING: 63,
	SHAPE_SIZE: 64,
	SHAPE_ROTATE: 65,
    SHAPE_INNER_NAME: 66,
    SHAPE_INNER_COLOR: 67,
    SHAPE_INNER_SIZE: 68,
    SHAPE_INNER_ROTATE: 69,
    STYLE_LAST: 69,
    equalFonts: function (f1, f2) {
        if (f1 == f1) return true;
        return f1 && f2 && f1.s == f2.s && f1.size == f2.size && f1.deco == f2.deco && f1.line == f2.line;
    },
    getFillText: function (fill) {
        return fill ? fill.toText() : null;
    },
    getStrokeText: function (stroke) {
        return stroke ? stroke.toText() : null;
    },
    getFillPaletteText: function (pal) {
        return pal instanceof FillPalette ? pal.toString() : pal;
    },
	getDimension: function (value) {
		if (value !== null && !(value instanceof Dimension)) {
			value = new Dimension(value);
		} 
		return value;
	},
    getDimensionText: function (dim) {
        return dim ? dim.toString() : null;
    },
	$_extendPropMap: function (props) {
		for (var p in props) {
			$$_STYLE_PROP_MAP[p] = props[p];
		}
	},
    $_extendNameMap: function (names) {
        var map = GridStyles.STYLE_NAMES;
        for (var n in names) {
            map[n] = names[n];
        }
    }
}, function (f) {
	f.Default = new f(null, "defaultStyles");
	initStyles(f.Default);
	function initStyles(s) {
        s._renderer = null;
		s._background = null;
        s._inactiveBackground = SolidBrush.LTGRAY;
		s._selectedBackground = SolidBrush.DIMGRAY;
        s._hoveredBackground = SolidBrush.WHITE;
        s._color = SolidBrush.BLACK;
        s._inactiveColor = SolidBrush.GRAY;
        s._selectedColor = SolidBrush.WHITE;
        s._hoveredColor = SolidBrush.BLACK;
		s._border = null;
		s._borderLeft = null;
		s._borderRight = null;
		s._borderTop = null;
		s._borderBottom = null;
        s._borderLeftSize = null;
        s._borderRightSize = null;
        s._borderTopSize = null;
        s._borderBottomSize = null;
        s._borderRadius = 0;
		s._line = SolidPen.GRAY;
		s._fontName = "Tahoma";
		s._fontSize = 12;
		s._fontBold = false;
		s._fontItalic = false;
		s._textDecoration = null;
		s._textDecorationColor = null;
        s._textShadow = null;
		s._textAlignment = Alignment.CENTER;
		s._lineAlignment = Alignment.CENTER;
        s._textWrap = TextWrap.NONE;
        s._textFormat = null;
		s._numberFormat = null;
		s._datetimeFormat = null;
		s._booleanFormat = null;
		s._prefix = null;
		s._suffix = null;
		s._marginLeft = 0;
		s._marginRight = 0;
		s._marginTop = 0;
		s._marginBottom = 0;
		s._paddingLeft = 0;
		s._paddingRight = 0;
		s._paddingTop = 0;
		s._paddingBottom = 0;
		s._iconIndex = 0;
		s._iconLocation = IconLocation.LEFT_SIDE;
		s._iconAlignment = Alignment.CENTER;
		s._iconOffset = 0;
		s._iconPadding = 2;
        s._iconAlpha = 1.0;
        s._shapeName = null;
		s._shapeColor = new SolidBrush(0xff008800);
        s._shapeColors = null;
        s._shapeInactiveColor = SolidBrush.LTGRAY;
        s._shapeSelectedColor = new SolidBrush(0xff008800);
        s._shapeHoveredColor = new SolidBrush(0xff008800);
		s._shapeBorder = null;
        s._shapeInactiveBorder = null;
        s._shapeSelectedBorder = null;
        s._shapeHoveredBorder = null;
        s._shapeLocation = IconLocation.LEFT_SIDE;
        s._shapeAlignment = Alignment.CENTER;
        s._shapeOffset = 0;
        s._shapePadding = 2;
		s._shapeSize = null;
		s._shapeRotate = 0;
        s._shapeInnerName = null;
        s._shapeInnerColor = SolidBrush.WHITE;
        s._shapeInnerSize = 0.5;
        s._shapeInnerRotate = 0;
    }
	f.STYLE_NAMES = {
        renderer: f.RENDERER,
		background: f.BACKGROUND,
        inactiveBackground: f.INACTIVE_BACKGROUND,
		selectedBackground: f.SELECTED_BACKGROUND,
        hoveredBackground: f.HOVERED_BACKGROUND,
        color: f.COLOR,
        inactiveColor: f.INACTIVE_COLOR,
        selectedColor: f.SELECTED_COLOR,
        hoveredColor: f.HOVERED_COLOR,
        border: f.BORDER,
		borderLeft: f.BORDER_LEFT,
		borderRight: f.BORDER_RIGHT,
		borderTop: f.BORDER_TOP,
		borderBottom: f.BORDER_BOTTOM,
        borderLeftSize: f.BORDER_LEFT_SIZE,
        borderRightSize: f.BORDER_RIGHT_SIZE,
        borderTopSize: f.BORDER_TOP_SIZE,
        borderBottomSize: f.BORDER_BOTTOM_SIZE,
        borderRadius: f.BORDER_RADIUS,
		line: f.LINE,
		fontName: f.FONT_NAME,
		fontSize: f.FONT_SIZE,
		fontBold: f.FONT_BOLD,
		fontItalic: f.FONT_ITALIC,
		textDecoration: f.TEXT_DECORATION,
		textDecorationColor: f.TEXT_DECORATION_COLOR,
        textShadow: f.TEXT_SHADOW,
		textAlignment: f.TEXT_ALIGNMENT,
		lineAlignment: f.LINE_ALIGNMENT,
        textWrap: f.TEXT_WRAP,
        textFormat: f.TEXT_FORMAT,
		numberFormat: f.NUMBER_FORMAT,
		datetimeFormat: f.DATETIME_FORMAT,
		booleanFormat: f.BOOLEAN_FORMAT,
		prefix: f.PREFIX,
		suffix: f.SUFFIX,
		marginLeft: f.MARGIN_LEFT,
		marginRight: f.MARGIN_RIGHT,
		marginTop: f.MARGIN_TOP,
		marginBottom: f.MARGIN_BOTTOM,
		paddingLeft: f.PADDING_LEFT,
		paddingRight: f.PADDING_RIGHT,
		paddingTop: f.PADDING_TOP,
		paddingBottom: f.PADDING_BOTTOM,
		iconIndex: f.ICON_INDEX,
		iconLocation: f.ICON_LOCATION,
		iconAlignment: f.ICON_ALIGNMENT,
		iconOffset: f.ICON_OFFSET,
		iconPadding: f.ICON_PADDING,
        iconAlpha: f.ICON_ALPHA,
        shapeName: f.SHAPE_NAME,
		shapeColor: f.SHAPE_COLOR,
        shapeColors: f.SHAPE_COLORS,
        shapeInactiveColor: f.SHAPE_INACTIVE_COLOR,
        shapeSelectedColor: f.SHAPE_SELECTED_COLOR,
        shapeHoveredColor: f.SHAPE_HOVERED_COLOR,
		shapeBorder: f.SHAPE_BORDER,
        shapeInactiveBorder: f.SHAPE_INACTIVE_BORDER,
        shapeSelectedBorder: f.SHAPE_SELECTED_BORDER,
        shapeHoveredBorder: f.SHAPE_HOVERED_BORDER,
        shapeLocation: f.SHAPE_LOCATION,
        shapeAlignment: f.SHAPE_ALIGNMENT,
        shapeOffset: f.SHAPE_OFFSET,
        shapePadding: f.SHAPE_PADDING,
		shapeSize: f.SHAPE_SIZE,
		shapeRotate: f.SHAPE_ROTATE,
        shapeInnerName: f.SHAPE_INNER_NAME,
        shapeInnerColor: f.SHAPE_INNER_COLOR,
        shapeInnerSize: f.SHAPE_INNER_SIZE,
        shapeInnerRotate: f.SHAPE_INNER_ROTATE
	};
});
GridStylesProto = GridStyles.prototype;
GridStylesProto.$_spd = GridStylesProto.setParentAndDefault;
GridStylesProto.$_ssd = GridStylesProto.setSysDefault;
GridStyles.CHANGED = "onVisualStylesChanged";
var GridStyleSheet = defineClass("GridStyleSheet", null, {
	init : function() {
		this._super();
		this._default = new GridStyles(null, GridStyleSheet.DEFAULT, null, false);
		this._grid = new GridStyles(null, GridStyleSheet.GRID, null, false);
		this._panel = new GridStyles(null, GridStyleSheet.PANEL, null, false);
        this._groupPanel = new GridStyles(null, GridStyleSheet.GROUPPANEL, null, false);
        this._groupPanelItem = new GridStyles(null, GridStyleSheet.GROUPPANEL_ITEM, null, false);
        this._groupPanelItemInner = new GridStyles(null, GridStyleSheet.GROUPPANEL_ITEM_INNER, null, false);
        this._groupPanelHead = new GridStyles(null, GridStyleSheet.GROUPPANEL_HEAD, null, false);
        this._groupPanelHeadInner = new GridStyles(null, GridStyleSheet.GROUPPANEL_HEAD_INNER, null, false);
		this._body = new GridStyles(null, GridStyleSheet.BODY, null, false);
		this._bodyEmpty = new GridStyles(null, GridStyleSheet.BODY_EMPTY, null, false);
        this._bodyEmptyData = new GridStyles(null, GridStyleSheet.BODY_EMPTY_DATA, null, false);
        this._bodyRow = new GridStyles(null, GridStyleSheet.BODY_ROW, null, false);
        this._bodyFixedRow = new GridStyles(null, GridStyleSheet.BODY_FIXED_ROW, null, false);
		this._bodyCell = new GridStyles(null, GridStyleSheet.BODY_CELL, null, false);
		this._bodyFixedCell = new GridStyles(null, GridStyleSheet.BODY_FIXED_CELL, null, false);
        this._bodyMerged = new GridStyles(null, GridStyleSheet.BODY_MERGED, null, false);
        this._bodyFixedMerged = new GridStyles(null, GridStyleSheet.BODY_FIXED_MERGED, null, false);
		this._bodyFixedColumnBar = new GridStyles(null, GridStyleSheet.BODY_FIXED_COLBAR, null, false);
		this._bodyFixedRowBar = new GridStyles(null, GridStyleSheet.BODY_FIXED_ROWBAR, null, false);
        this._bodySelection = new GridStyles(null, GridStyleSheet.BODY_SELECTION, null, false);
        this._bodyMobileSelection = new GridStyles(null, GridStyleSheet.BODY_MOBILE_SELECTION, null, false);
        this._bodyRowHover = new GridStyles(null, GridStyleSheet.BODY_ROW_HOVER, null, false);
		this._header = new GridStyles(null, GridStyleSheet.HEADER, null, false);
		this._headerHead = new GridStyles(null, GridStyleSheet.HEADER_HEAD, null, false);
		this._headerGroup = new GridStyles(null, GridStyleSheet.HEADER_GROUP, null, false);
        this._headerSub = new GridStyles(null, GridStyleSheet.HEADER_SUB, null, false);
        this._headerMenuHandle = new GridStyles(null, GridStyleSheet.HEADER_MENUHANDLE, null, false);
        this._headerFilterHandle = new GridStyles(null, GridStyleSheet.HEADER_FILTERHANDLE, null, false);
        this._headerSortHandle = new GridStyles(null, GridStyleSheet.HEADER_SORTHANDLE, null, false);
		this._headerSortOrder = new GridStyles(null, GridStyleSheet.HEADER_SORTORDER, null, false);
        this._headerSummary = new GridStyles(null, GridStyleSheet.HEADER_SUMMARY, null, false);
        this._headerSummaryHead = new GridStyles(null, GridStyleSheet.HEADER_SUMMARY_HEAD, null, false);
		this._headerSummaryGroup = new GridStyles(null, GridStyleSheet.HEADER_SUMMARY_GROUP, null, false);
		this._footer = new GridStyles(null, GridStyleSheet.FOOTER, null, false);
		this._footerGroup = new GridStyles(null, GridStyleSheet.FOOTER_GROUP, null, false);
        this._footerHead = new GridStyles(null, GridStyleSheet.FOOTER_HEAD, null, false);
		this._rowGroupHead = new GridStyles(null, GridStyleSheet.ROWGROUP_HEAD, null, false);
		this._rowGroupHeader = new GridStyles(null, GridStyleSheet.ROWGROUP_HEADER, null, false);
		this._rowGroupExpander = new GridStyles(null, GridStyleSheet.ROWGROUP_EXPANDER, null, false);
		this._rowGroupFooter = new GridStyles(null, GridStyleSheet.ROWGROUP_FOOTER, null, false);
		this._rowGroupIndent = new GridStyles(null, GridStyleSheet.ROWGROUP_INDENT, null, false);
		this._rowGroupBar = new GridStyles(null, GridStyleSheet.ROWGROUP_BAR, null, false);
		this._rowGroupHeaderBar = new GridStyles(null, GridStyleSheet.ROWGROUP_HEADER_BAR, null, false);
		this._rowGroupFooterBar = new GridStyles(null, GridStyleSheet.ROWGROUP_FOOTER_BAR, null, false);
		this._rowIndicator = new GridStyles(null, GridStyleSheet.ROWINDICATOR, null, false);
		this._rowIndicatorState = new GridStyles(null, GridStyleSheet.ROWINDICATOR_STATE, null, false);
		this._rowIndicatorCreated = new GridStyles(null, GridStyleSheet.ROWINDICATOR_CREATED, null, false);
		this._rowIndicatorUpdated = new GridStyles(null, GridStyleSheet.ROWINDICATOR_UPDATED, null, false);
		this._rowIndicatorDeleted = new GridStyles(null, GridStyleSheet.ROWINDICATOR_DELETED, null, false);
		this._checkBar = new GridStyles(null, GridStyleSheet.CHECKBAR, null, false);
		this._checkBarHead = new GridStyles(null, GridStyleSheet.CHECKBAR_HEAD, null, false);
        this._headerItem = new GridStyles(null, GridStyleSheet.HEADER_ITEM, null, false);
        this._footerItem = new GridStyles(null, GridStyleSheet.FOOTER_ITEM, null, false);
		this._treeFooter = new GridStyles(null, GridStyleSheet.TREE_FOOTER, null, false);
		this._treeExpander = new GridStyles(null, GridStyleSheet.TREE_EXPANDER, null, false);
        this._treeIndent = new GridStyles(null, GridStyleSheet.TREE_INDENT, null, false);
        this._scrollBar = new GridStyles(null, GridStyleSheet.SCROLLBAR, null, false);
        this._scrollBarButton = new GridStyles(null, GridStyleSheet.SCROLLBAR_BUTTON, null, false);
        this._scrollBarThumb = new GridStyles(null, GridStyleSheet.SCROLLBAR_THUMB, null, false);
        this._scrollBarIndent = new GridStyles(null, GridStyleSheet.SCROLLBAR_INDENT, null, false);
		this._scrollEdge = new GridStyles(null, GridStyleSheet.SCROLL_EDGE, null, false);
        this._tooltip = new GridStyles(null, GridStyleSheet.TOOLTIP, null, false);
	},
	default: function () { return this._default; },
	grid: function () { return this._grid; },
	panel: function () { return this._panel; },
    groupPanel: function () { return this._groupPanel; },
    groupPanelItem: function () { return this._groupPanelItem; },
    groupPanelItemInner: function () { return this._groupPanelItemInner; },
    groupPanelHead: function () { return this._groupPanelHead; },
    groupPanelHeadInner: function () { return this._groupPanelHeadInner; },
	body: function () { return this._body; },
	bodyEmpty: function () { return this._bodyEmpty; },
    bodyEmptyData: function () { return this._bodyEmptyData; },
    bodyRow: function () { return this._bodyRow; },
    bodyFixedRow: function () { return this._bodyFixedRow; },
	bodyCell: function () { return this._bodyCell; },
	bodyFixedCell: function () { return this._bodyFixedCell; },
    bodyMerged: function () { return this._bodyMerged; },
    bodyFixedMerged: function () { return this._bodyFixedMerged; },
	bodyFixedColumnBar: function () { return this._bodyFixedColumnBar; },
	bodyFixedRowBar: function () { return this._bodyFixedRowBar; },
    bodySelection: function () { return this._bodySelection; },
    bodyMobileSelection: function () { return this._bodyMobileSelection; },
    bodyRowHover: function () { return this._bodyRowHover; },
	header: function () { return this._header; },
	headerHead: function () { return this._headerHead; },
	headerGroup: function () { return this._headerGroup; },
    headerSub: function () { return this._headerSub; },
    headerMenuHandle: function () { return this._headerMenuHandle; },
    headerFilterHandle: function () { return this._headerFilterHandle; },
    headerSortHandle: function () { return this._headerSortHandle; },
	headerSortOrder: function () { return this._headerSortOrder; },
    headerSummary: function () { return this._headerSummary; },
    headerSummaryHead: function () { return this._headerSummaryHead; },
	headerSummaryGroup: function () { return this._headerSummaryGroup; },
	footer: function () { return this._footer; },
	footerGroup: function () { return this._footerGroup; },
    footerHead: function () { return this._footerHead; },
	rowGroupHead: function () { return this._rowGroupHead; },
	rowGroupHeader: function () { return this._rowGroupHeader; },
	rowGroupExpander: function () { return this._rowGroupExpander; },
	rowGroupFooter: function () { return this._rowGroupFooter; },
	rowGroupIndent: function () { return this._rowGroupIndent; },
	rowGroupBar: function () { return this._rowGroupBar; },
	rowGroupHeaderBar: function () { return this._rowGroupHeaderBar; },
	rowGroupFooterBar: function () { return this._rowGroupFooterBar; },
	rowIndicator: function () { return this._rowIndicator; },
	rowIndicatorState: function () { return this._rowIndicatorState; },
	rowIndicatorCreated: function () { return this._rowIndicatorCreated; },
	rowIndicatorUpdated: function () { return this._rowIndicatorUpdated; },
	rowIndicatorDeleted: function () { return this._rowIndicatorDeleted; },
	checkBar: function () { return this._checkBar; },
	checkBarHead: function () { return this._checkBarHead; },
    headerItem: function () { return this._headerItem; },
    footerItem: function () { return this._footerItem; },
	treeFooter: function () { return this._treeFooter; },
	treeExpander: function () { return this._treeExpander; },
    treeIndent: function () { return this._treeIndent; },
    scrollBar: function () { return this._scrollBar; },
    scrollBarButton: function () { return this._scrollBarButton; },
    scrollBarThumb: function () { return this._scrollBarThumb; },
    scrollBarIndent: function () { return this._scrollBarIndent; },
	scrollEdge: function () { return this._scrollEdge; },
    tooltip: function () { return this._tooltip; }
}, {
	DEFAULT: "default",
    GRID: "grid",
	PANEL: "panel",
    GROUPPANEL: "groupPanel",
    GROUPPANEL_ITEM: "groupPanelItem",
    GROUPPANEL_ITEM_INNER: "groupPanelItemInner",
    GROUPPANEL_HEAD: "groupPanelHead",
    GROUPPANEL_HEAD_INNER: "groupPanelHeadInner",
	BODY: "body",
	BODY_EMPTY: "body.empty",
    BODY_EMPTY_DATA: "body.emptyData",
    BODY_ROW: "body.row",
    BODY_FIXED_ROW: "body.fixedRow",
	BODY_CELL: "body.cell",
	BODY_FIXED_CELL: "body.fixedCell",
    BODY_MERGED: "body.merged",
    BODY_FIXED_MERGED: "body.fixedMerged",
	BODY_FIXED_COLBAR: "body.fixedColBar",
	BODY_FIXED_ROWBAR: "body.fixedRowBar",
    BODY_SELECTION: "body.selection",
    BODY_MOBILE_SELECTION: "body.mobileSelection",
    BODY_ROW_HOVER: "body.rowHover",
	HEADER: "header",
	HEADER_HEAD: "header.head",
	HEADER_GROUP: "header.group",
    HEADER_SUB: "header.sub",
    HEADER_MENUHANDLE: "header.menuHandle",
    HEADER_FILTERHANDLE: "header.filterHandle",
    HEADER_SORTHANDLE: "header.sortHandle",
	HEADER_SORTORDER: "header.sortOrder",
    HEADER_SUMMARY: "header.summary",
    HEADER_SUMMARY_HEAD: "header.summaryHead",
	HEADER_SUMMARY_GROUP: "header.summaryGroup",
	FOOTER: "footer",
	FOOTER_GROUP: "footer.group",
    FOOTER_HEAD: "footer.head",
	ROWGROUP_HEADER: "rowGroup.header",
	ROWGROUP_EXPANDER: "rowGroup.expander",
	ROWGROUP_FOOTER: "rowGroup.footer",
	ROWGROUP_INDENT: "rowGroup.indent",
	ROWGROUP_HEAD: "rowGroup.head",
	ROWGROUP_BAR: "rowGroup.bar",
	ROWGROUP_HEADER_BAR: "rowGroup.headerBar",
	ROWGROUP_FOOTER_BAR: "rowGroup.footerBar",
	ROWGROUP_LEVELS: "rowGroup.levels",
	ROWINDICATOR: "rowIndicator",
	ROWINDICATOR_STATE: "rowIndicator.state",
	ROWINDICATOR_CREATED: "rowIndicator.created",
	ROWINDICATOR_UPDATED: "rowIndicator.updated",
	ROWINDICATOR_DELETED: "rowIndicator.deleted",
	CHECKBAR: "checkBar",
    CHECKBAR_HEAD: "checkBar.head",
    HEADER_ITEM: "headerItem",
    FOOTER_ITEM: "footerItem",
	TREE_FOOTER: "tree.footer",
	TREE_EXPANDER: "tree.expander",
    TREE_INDENT: "tree.indent",
    SCROLLBAR: "scrollBar",
    SCROLLBAR_BUTTON: "scrollBar.Button",
    SCROLLBAR_THUMB: "scrollBar.Thumb",
    SCROLLBAR_INDENT: "scrollBar.Indent",
	SCROLL_EDGE: "scrollEdge",
    TOOLTIP: "tooltip",
	clearStyles: function (grid) {
		grid.beginUpdate();
		try {
            grid.defaultStyles().clearValues();
			grid.styles().clearValues();
			grid.panel().styles().clearValues();
            grid.groupPanel().styles().clearValues();
            grid.groupPanel().itemStyles().clearValues();
            grid.groupPanel().itemInnerStyles().clearValues();
            grid.groupPanelHead().styles().clearValues();
            grid.groupPanelHead().innerStyles().clearValues();
			grid.body().styles()().clearValues();
			grid.body().emptyStyles().clearValues();
            grid.body().emptyDataStyles().clearValues();
            grid.body().rowStyles().clearValues();
            grid.body().fixedRowStyles().clearValues();
			grid.body().cellStyles().clearValues();
			grid.body().fixedCellStyles().clearValues();
			grid.body().fixedColumnBarStyles().clearValues();
			grid.body().fixedRowBarStyles().clearValues();
			grid.body().selectionStyles().clearValues();
            grid.body().mobileSelectionStyles().clearValues();
            grid.body().rowHoverStyles().clearValues();
			grid.header().styles().clearValues();
			grid.header().head().styles.clearValues();
			grid.header().groupStyles().clearValues();
            grid.header().subStyles().clearValues();
            grid.header().menuHandleStyles().clearValues();
            grid.header().filterHandleStyles().clearValues();
            grid.header().sortHandleStyles().clearValues();
			grid.header().sortOrderStyles().clearValues();
            grid.header().summary().styles().clearValues();
            grid.header().summary().headStyles().clearValues();
			grid.header().summary().groupStyles().clearValues();
			grid.footer().styles().clearValues();
			grid.footer().groupStyles().clearValues();
            grid.footer().head().styles.clearValues();
			grid.rowGroup().headStyles().clearValues();
			grid.rowGroup().headerStyles().clearValues();
			grid.rowGroup().expanderStyles().clearValues();
			grid.rowGroup().footerStyles().clearValues();
			grid.rowGroup().indentStyles().clearValues();
			grid.rowGroup().barStyles().clearValues();
			grid.rowGroup().headerBarStyles().clearValues();
			grid.rowGroup().footerBarStyles().clearValues();
			grid.rowIndicator().styles().clearValues();
			grid.rowIndicator().stateStyles().clearValues();
			grid.rowIndicator().createdStyles().clearValues();
			grid.rowIndicator().updatedStyles().clearValues();
			grid.rowIndicator().deletedStyles().clearValues();
			grid.checkBar().styles().clearValues();
			grid.checkBar().headStyles().clearValues();
            grid.headerItem().styles().clearValues();
            grid.footerItem().styles().clearValues();
			grid.scrollEdgeStyles().clearValues();
			if (grid instanceof TreeView) {
				grid.treeOptions().footerStyles().clearValues();
				grid.treeOptions().expanderStyles().clearValues();
                grid.treeOptions().indentStyles().clearValues();
			}
            grid.vscrollBar().styles().clearValues();
            grid.vscrollBar().buttonStyles().clearValues();
            grid.vscrollBar().thumbStyles().clearValues();
            grid.vscrollBar().indentStyles().clearValues();
			grid.hscrollBar().styles().clearValues();
			grid.hscrollBar().buttonStyles().clearValues();
			grid.hscrollBar().thumbStyles().clearValues();
			grid.hscrollBar().indentStyles().clearValues();
            grid.displayOptions().tooltipStyles().clearValues();
		} finally {
			grid.endUpdate();
		}
	}
});
GridStyleSheet.Default = (function () {
	var sheet = new GridStyleSheet();
	var s = sheet._default;
	s.$_setBackground(SolidBrush.WHITE);
	s.setColor(SolidBrush.BLACK);
    s.setSelectedBackground(new SolidBrush(0xff0088dd));
    s.setSelectedColor(SolidBrush.WHITE);
	s.setBorder(null);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(null);
	s.setBorderBottom(null);
    s.setBorderLeftSize(null);
    s.setBorderTopSize(null);
    s.setBorderRightSize(null);
    s.setBorderBottomSize(null);
    s.setBorderRadius(0);
	s.setInactiveBackground(SolidBrush.LTGRAY);
	s.setFontName("Tahoma");
	s.setFontSize(13);
    s.setTextDecoration(null);
    s.setTextDecorationColor(null);
    s.setTextShadow(null);
	s.setMarginTop(0);
	s.setMarginBottom(0);
	s.setMarginLeft(0);
	s.setMarginRight(0);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.NEAR);
	s.setLineAlignment(Alignment.CENTER);
	s.setIconLocation(IconLocation.LEFT_SIDE);
	s.setIconAlignment(Alignment.CENTER);
	s.setIconPadding(2);
    s.setIconAlpha(1.0);
    s.setShapeName(null);
	s.setShapeColor(SolidBrush.BLACK);
    s.setShapeColors(null),
    s.setShapeInactiveColor(SolidBrush.BLACK);
    s.setShapeSelectedColor(SolidBrush.BLACK);
    s.setShapeHoveredColor(SolidBrush.BLACK);
    s.setShapeLocation(IconLocation.LEFT_SIDE);
    s.setShapeAlignment(Alignment.CENTER);
    s.setShapePadding(2);
	s.setShapeSize(Dimension.NULL);
	s.setShapeRotate(0);
    s.setShapeInnerName(null);
    s.setShapeInnerColor(SolidBrush.WHITE);
    s.setShapeInnerSize(0.5);
    s.setShapeInnerRotate(0);
	var s = sheet._grid;
	s.$_setBackground(null);
	s.setBorder(new SolidPen(0xff616569));
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(null);
    s.setBorderBottom(null);
    s.setLine(SolidPen.GRAY); // tree lines에 사용됨
	s = sheet._panel;
	s.setBackground(new SolidBrush(0xffcccccc));
	s.setColor(new SolidBrush(0xff202020));
	s.setBorderRight(new SolidPen(0xff777777));
	s.setBorderBottom(new SolidPen(0xff777777));
	s.setPaddingLeft(8);
	s.setPaddingTop(4);
	s.setPaddingBottom(5);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.NEAR);
	s.setLineAlignment(Alignment.CENTER);
    s = sheet._groupPanel;
    s.setBackground(new SolidBrush(0xffeef0f4));
    s.setColor(new SolidBrush(0xff202020));
    s.setBorderRight(new SolidPen(0xff777777));
    s.setBorderBottom(new SolidPen(0xff777777));
    s.setPaddingLeft(8);
    s.setPaddingTop(4);
    s.setPaddingBottom(5);
    s.setPaddingRight(2);
    s.setTextAlignment(Alignment.NEAR);
    s.setLineAlignment(Alignment.CENTER);
    s = sheet._groupPanelItem;
	s.setBorderTop(null);
	s.setBorderLeft(null);
	s.setBorderBottom(null);
    s.setBorderRight(new SolidPen(0xffa0a0a0));
    s = sheet._groupPanelItemInner;
	s.setBorderTop(null);
	s.setBorderLeft(null);
	s.setBorderBottom(null);
    s.setBorderRight(SolidPen.WHITE);
    s = sheet._groupPanelHead;
    s.setBorderTop(null);
    s.setBorderLeft(null);
    s.setBorderBottom(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
    s.setShapeColor(SolidBrush.DKGRAY);
    s.setShapeSelectedColor(SolidBrush.DIMGRAY);
    s = sheet._groupPanelHeadInner;
    s.setBorderTop(SolidPen.WHITE);
    s.setBorderLeft(null);
    s.setBorderBottom(null);
    s.setBorderRight(SolidPen.WHITE);
	s = sheet._body;
	s.setBackground(null);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(SolidPen.GRAY);
	s.setBorderBottom(SolidPen.GRAY);
    s.setShapeColors(null),
	s = sheet._bodyEmpty;
	s.setBackground(new SolidBrush(0xfff8f8f8));
	s.setColor(SolidBrush.DIMGRAY);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xff999999));
	s.setBorderBottom(s.borderRight());
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setFontSize(13);
	s.setTextAlignment(Alignment.NEAR);
	s.setLineAlignment(Alignment.NEAR);
    s = sheet._bodyEmptyData;
    s.setBackground(null);
    s.setColor(SolidBrush.DIMGRAY);
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(null);
    s.setBorderBottom(null);
    s.setPaddingTop(10);
    s.setPaddingBottom(10);
    s.setPaddingLeft(10);
    s.setPaddingRight(10);
    s.setFontSize(18);
    s.setTextAlignment(Alignment.CENTER);
    s.setLineAlignment(Alignment.CENTER);
    s = sheet._bodyRow;
    s.setBackground(null);
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(null);
    s.setBorderBottom(null);
	s = sheet._bodyFixedRow;
	s.setBackground(new SolidBrush(0xfff0f0f0));
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(null);
	s.setBorderBottom(null);
	s = sheet._bodyCell;
	s.setBackground(null);
	s.setColor(new SolidBrush(0xff000000));
	s.setHoveredBackground(SolidBrush.WHITE);
	s.setHoveredColor(new SolidBrush(0xff202020));
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffdedede));
	s.setBorderBottom(new SolidPen(0xffdedede));
    s.setLine(SolidPen.WHITE);
	s.setPaddingTop(3);
	s.setPaddingBottom(3);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
    s.setFontName("Tahoma");
	s.setFontSize(13);
	s.setTextAlignment(Alignment.NEAR);
	s.setLineAlignment(Alignment.CENTER);
	s.setIconLocation(IconLocation.LEFT_SIDE);
	s.setIconAlignment(Alignment.CENTER);
	s.setIconPadding(2);
    s.setIconAlpha(1.0);
    s.setShapeName(null);
    s.setShapeColor(SolidBrush.DIMGRAY);
    s.setShapeColors(null),
    s.setShapeInactiveColor(SolidBrush.LTGRAY);
    s.setShapeHoveredColor(SolidBrush.DIMGRAY);
    s.setShapeSelectedColor(null);
    s.setShapeSelectedBorder(null);
    s.setShapeLocation(IconLocation.LEFT_SIDE);
    s.setShapeAlignment(Alignment.CENTER);
	s.setShapeSize(Dimension.NULL);
	s.setShapeRotate(0);
    s.setShapeInnerName(null);
    s.setShapeInnerColor(SolidBrush.WHITE);
    s.setShapeInnerSize(0.5);
    s.setShapeInnerRotate(0);
	s = sheet._bodyFixedCell;
	s.setBackground(null);
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xff999999));
	s.setBorderBottom(s.borderRight());
    s.setShapeColors(null);
    s = sheet._bodyMerged;
    s.setBackground(SolidBrush.WHITE);
    s = sheet._bodyFixedMerged;
    s.setBackground(new SolidBrush(0xfff0f0f0));
	s = sheet._bodyFixedColumnBar;
	s.setBackground(new SolidBrush(0xffcccccc));
	s.setBorderRight(new SolidPen(0xff808080));
	s.setBorderBottom(new SolidPen(0xff808080));
	s = sheet._bodyFixedRowBar;
	s.setBackground(new SolidBrush(0xffcccccc));
	s.setBorderRight(new SolidPen(0xff808080));
	s.setBorderBottom(new SolidPen(0xff808080));
    s = sheet._bodySelection;
    s.setBackground(new SolidBrush(0x10000000));
    s.setBorder(new SolidPen(0xb0000000));
    s = sheet._bodyMobileSelection;
    s = sheet._bodyRowHover;
    s.setBackground(new SolidBrush(0x20aaaaaa));
    s.setBorder(null);
	s = sheet._header;
	s.setBackground("linear,#ffffff,#f0f0f0,90");
	s.setColor(new SolidBrush(0xff303030));
	s.setBorderLeft(null);
	s.setBorderTop(SolidPen.WHITE);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingTop(2);
	s.setPaddingBottom(3);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
    s.setFontSize(12);
    s.setFontBold(true);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setTextWrap(TextWrap.NORMAL);
	s.setSelectedBackground(new SolidBrush(0xffe0e0e0));
	s.setSelectedColor(new SolidBrush(0xff101010));
	s.setHoveredBackground(new SolidBrush(0x205292f8));
	s = sheet._headerHead;
	s.setShapeColor(SolidBrush.DKGRAY);
	s.setShapeSelectedColor(SolidBrush.DIMGRAY);
	/*
	s.setBackground(new SolidBrush(0xffe0e0e0));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(SolidPen.GRAY);
	s.setBorderBottom(SolidPen.GRAY);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setTextWrap(TextWrap.NORMAL);
	s.setHoveredBackground(SolidBrush.LTGRAY);
	*/
	s = sheet._headerGroup;
	s.setBackground("linear,#ffffff,#f0f0f0,90");
	s.setColor(new SolidBrush(0xff303060));
	s.setSelectedBackground("linear,#ffbac3ce,#ffaebccc,90");
	s.setSelectedColor(new SolidBrush(0xff101010));
	s.setHoveredBackground(new SolidBrush(0x205292f8));
	s.setBorderLeft(null);
	s.setBorderTop(SolidPen.WHITE);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setTextWrap(TextWrap.NORMAL);
	s.setFontBold(true);
    s = sheet._headerSub;
    s.setTextAlignment(Alignment.CENTER);
    s.setLineAlignment(Alignment.CENTER);
    s = sheet._headerMenuHandle;
    s.setShapeColor(new SolidBrush(0xff808080));
    s.setShapeHoveredColor(SolidBrush.BLACK);
    s.setShapeBorder(new SolidPen(0xff808080));
    s.setShapeInactiveBorder(new SolidPen(0xff808080));
    s.setShapeHoveredBorder(SolidPen.BLACK);
    s = sheet._headerFilterHandle;
    s.setShapeColor(new SolidBrush(0xff808080));
    s.setShapeHoveredColor(SolidBrush.BLACK);
    s.setShapeBorder(new SolidPen(0xff808080));
    s.setShapeInactiveBorder(new SolidPen(0xff808080));
    s.setShapeHoveredBorder(SolidPen.BLACK);
    s = sheet._headerSortHandle;
	s.setShapeName(null);
    s.setShapeColor(new SolidBrush(0xff808080));
    s.setShapeHoveredColor(SolidBrush.BLACK);
    s.setShapeBorder(new SolidPen(0xff808080));
    s.setShapeInactiveBorder(new SolidPen(0xff808080));
    s.setShapeHoveredBorder(SolidPen.BLACK);
	s = sheet._headerSortOrder;
	s.setColor(new SolidBrush(0xff303060));
	s.setFontSize(11);
    s = sheet._headerSummary;
    s.setBackground(new SolidBrush(0xffeef0f4));
    s.setColor(SolidBrush.BLACK);
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(new SolidPen(0xffa0a0a0));
    s.setBorderBottom(new SolidPen(0xffa0a0a0));
    s.setPaddingLeft(2);
    s.setPaddingRight(2);
    s.setPaddingTop(1);
    s.setPaddingBottom(2);
    s.setTextAlignment(Alignment.FAR);
    s.setLineAlignment(Alignment.CENTER);
    s = sheet._headerSummaryHead;
    /*
    s.setBackground(new SolidBrush(0xffeef0f4));
    s.setColor(SolidBrush.BLACK);
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(SolidPen.GRAY);
    s.setBorderBottom(SolidPen.GRAY);
    s.setPaddingLeft(2);
    s.setPaddingRight(2);
    s.setPaddingTop(1);
    s.setPaddingBottom(2);
    s.setTextAlignment(Alignment.FAR);
    s.setLineAlignment(Alignment.CENTER);
    */
    s.setTextAlignment(Alignment.CENTER);
	s = sheet._headerSummaryGroup;
	s.setBackground(new SolidBrush(0xffeef0f4));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(1);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.FAR);
	s.setLineAlignment(Alignment.CENTER);
	s = sheet._footer;
	s.setBackground(new SolidBrush(0xffeef0f4));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(SolidPen.WHITE);
	s.setBorderBottom(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderTop(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(1);
	s.setTextAlignment(Alignment.FAR);
	s.setLineAlignment(Alignment.CENTER);
	s = sheet._footerGroup;
	s.setBackground(new SolidBrush(0xffeef0f4));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(SolidPen.WHITE);
	s.setBorderBottom(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderTop(new SolidPen(0xffa0a0a0));
	s.setPaddingTop(2);
	s.setPaddingBottom(1);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.FAR);
	s.setLineAlignment(Alignment.CENTER);
    s = sheet._footerHead;
	s.setShapeColor(SolidBrush.DKGRAY);
	s.setShapeSelectedColor(SolidBrush.DIMGRAY);
	/*
    s.setBackground(new SolidBrush(0xffeeeeee));
    s.setColor(SolidBrush.BLACK);
    s.setBorderLeft(null);
    s.setBorderBottom(null);
    s.setBorderRight(SolidPen.GRAY);
    s.setBorderTop(SolidPen.GRAY);
    s.setPaddingLeft(2);
    s.setPaddingRight(2);
    s.setPaddingTop(2);
    s.setPaddingBottom(1);
 	s.setLineAlignment(Alignment.CENTER);
 	*/
    s.setTextAlignment(Alignment.CENTER);
	s = sheet._rowGroupHeader;
	s.setBackground(new SolidBrush(0xfff0f4fa));
	s.setColor(new SolidBrush(0xff001f2f));
	s.setBorderLeft(null);
	s.setBorderTop(SolidPen.WHITE);
	s.setBorderRight(new SolidPen(0xff85a8d0));
	s.setBorderBottom(new SolidPen(0xffa0a0c0));
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setTextAlignment(Alignment.NEAR);
	s.setLineAlignment(Alignment.CENTER);
	s.setShapeColor(new SolidBrush(0xff003f4f));
    s = sheet._rowGroupExpander;
    s.setShapeColor(new SolidBrush(0xff535353));
	s.setBorderRight(null);
	s = sheet._rowGroupFooter;
	s.setBackground(new SolidBrush(0xffeef0f4));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(SolidPen.WHITE);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.FAR);
	s.setLineAlignment(Alignment.CENTER);
	s.setShapeColor(SolidBrush.GRAY);
	s = sheet._rowGroupIndent;
	s.setBackground(new SolidBrush(0xffefefef));
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffc0c0c0));
	s.setBorderBottom(new SolidPen(0xffc0c0c0));
	s = sheet._rowGroupBar;
	s.setBorderLeft(null);
	s.setBorderRight(SolidPen.DIMGRAY);
	s.setBorderTop(null);
	s.setBorderBottom(null);
	s = sheet._rowGroupHeaderBar;
	s.setBorderLeft(null);
	s.setBorderRight(null);
	s.setBorderTop(null);
	s.setBorderBottom(null);
	s = sheet._rowGroupFooterBar;
	s.setBorderLeft(null);
	s.setBorderRight(null);
	s.setBorderTop(null);
	s.setBorderBottom(SolidPen.GRAY);
    s = sheet._rowGroupHead;
	s = sheet._rowIndicator;
	s.setBackground(new SolidBrush(0xfff8f8f8));
	s.setColor(new SolidBrush(0xff202030));
	s.setBorderLeft(SolidPen.WHITE);
	s.setBorderTop(SolidPen.WHITE);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setHoveredBackground(new SolidBrush(0x205292f8));
	s.setSelectedBackground(new SolidBrush(0xffe0e0e0));
	s.setSelectedColor(new SolidBrush(0xff101010));
	s.setShapeColor(new SolidBrush(0xff202030));
    s.setShapeHoveredColor(new SolidBrush(0xff327288));
	s = sheet._rowIndicatorState;
	s.setBackground(new SolidBrush(0xfffcfcfc));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffaab1b8));
	s.setBorderBottom(new SolidPen(0xffaab1b8));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setIconIndex(-1);
	s.setShapeName(null);
	s = sheet._rowIndicatorCreated;
	s.setBackground(new SolidBrush(0x600099ff));
	s.setHoveredBackground(new SolidBrush(0x800099ff));
	s = sheet._rowIndicatorUpdated;
	s.setBackground(new SolidBrush(0x20000000));
	s.setHoveredBackground(new SolidBrush(0x40000000));
	s = sheet._rowIndicatorDeleted;
	s.setBackground(new SolidBrush(0x80000000));
	s.setHoveredBackground(new SolidBrush(0xc0000000));
	s = sheet._checkBar;
	s.setBackground(SolidBrush.WHITE);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.CENTER);
	s.setLineAlignment(Alignment.CENTER);
	s.setShapeName(null);
	s.setShapeColor(new SolidBrush(0xff555555));
	s.setShapeInactiveColor(new SolidBrush(0xffc0c0c0));
	s.setShapeSize(new Dimension(12));
	s = sheet._checkBarHead;
	s.setShapeName(null);
	s.setShapeColor(new SolidBrush(0xff555555));
	s.setShapeInactiveColor(new SolidBrush(0xffc0c0c0));
	s.setShapeSize(new Dimension(12));
	s = sheet._treeFooter;
	s.setBackground(new SolidBrush(0xffeef0f4));
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);//SolidPen.WHITE);
	s.setBorderTop(null);
	s.setBorderRight(new SolidPen(0xffa0a0a0));
	s.setBorderBottom(new SolidPen(0xffa0a0a0));
	s.setPaddingLeft(2);
	s.setPaddingRight(2);
	s.setPaddingTop(2);
	s.setPaddingBottom(2);
	s.setTextAlignment(Alignment.FAR);
	s.setLineAlignment(Alignment.CENTER);
	s.setShapeColor(SolidBrush.GRAY);
    s = sheet._headerItem;
    s.setBackground(SolidBrush.WHITE);
    s.setBorderRight(new SolidPen(0xffa0a0a0));
    s.setBorderBottom(new SolidPen(0xffa0a0a0));
    s.setPaddingLeft(4);
    s.setPaddingTop(4);
    s.setPaddingBottom(4);
    s.setPaddingRight(4);
    s = sheet._footerItem;
    s.setBackground(SolidBrush.WHITE);
    s.setBorderRight(new SolidPen(0xffa0a0a0));
    s.setBorderTop(new SolidPen(0xffa0a0a0));
    s.setPaddingLeft(4);
    s.setPaddingTop(4);
    s.setPaddingBottom(4);
    s.setPaddingRight(4);
	s = sheet._treeExpander;
	s.setColor(SolidBrush.BLACK);
	s.setBorderLeft(null);
	s.setBorderTop(null);
	s.setBorderRight(null);
	s.setBorderBottom(new SolidPen(0xffcccccc));
	s.setPaddingTop(0);
	s.setPaddingBottom(0);
	s.setPaddingLeft(0);
	s.setPaddingRight(2);
	s.setShapeColor(SolidBrush.DIMGRAY);
	s.setShapeSize(new Dimension(9));
    s = sheet._treeIndent;
    s.setBackground(null);//new SolidBrush(0xffeef0f4));
    s.setBorderLeft(null);
    s.setBorderTop(null);
    s.setBorderRight(new SolidPen(0xffa0a0a0));
    s.setBorderBottom(new SolidPen(0xffa0a0a0));
    s = sheet._scrollBar;
    s.setBackground(SolidBrush.SCROLL);
    s = sheet._scrollBarButton;
    s.setBackground(new SolidBrush(0xfff0f0f0));
    s.setSelectedBackground(new SolidBrush(0xff808080));
    s.setHoveredBackground(new SolidBrush(0xffd0c0d0));
	s.setInactiveBackground(new SolidBrush(0xfff0f0f0));
	s.setShapeColor(new SolidBrush(0xff333333));
	s.setShapeSelectedColor(new SolidBrush(0xffffffff));
	s.setShapeHoveredColor(new SolidBrush(0xff333333));
	s.setShapeInactiveColor(new SolidBrush(0xffa0a0a0));
	s = sheet._scrollBarThumb;
	s.setBackground(new SolidBrush(0xffc0c0c0));
	s.setHoveredBackground(new SolidBrush(0xffa0a0a0));
	s.setSelectedBackground(new SolidBrush(0xff808080));
    s.setBorderRadius(0);
	s = sheet._scrollBarIndent;
	s.setBackground(SolidBrush.SCROLLINDENT);
	s = sheet._scrollEdge;
	s.setBackground(SolidBrush.SCROLL);
    s = sheet._tooltip;
    s.setBackground('linear,#ffffff,#f8f8f8');
    s.setColor(SolidBrush.BLACK);
    s.setBorder('#646464');
    s.setBorderRadius(3);
    s.setFontName('Helvetica');
    s.setFontSize(13);
    s.setPaddingLeft(7);
    s.setPaddingRight(7);
    s.setPaddingTop(5);
    s.setPaddingBottom(5);
	return sheet;
})();
var DEFAULT_STYLES = "default";
var GRID_STYLES = "grid";
var PANEL_STYLES = "panel";
var GROUPPANEL_STYLES = "groupPanel";
var GROUPPANEL_ITEM_STYLES = "groupPanel.item";
var GROUPPANEL_ITEM_INNER_STYLES = "groupPanel.itemInner";
var GROUPPANEL_HEAD_STYLES = "groupPanel.head";
var GROUPPANEL_HEAD_INNER_STYLES = "groupPanel.headInner";
var BODY_STYLES = "body";
var BODY_EMPTY_STYLES = "body.empty";
var BODY_EMPTY_DATA_STYLES = "body.emptyData";
var BODY_ROW_STYLES = "body.row";
var BODY_FIXED_ROW_STYLES = "body.fixedRow";
var BODY_CELL_STYLES = "body.cell";
var BODY_FIXED_CELL_STYLES = "body.fixedCell";
var BODY_MERGED_STYLES = "body.merged";
var BODY_FIXED_MERGED_STYLES = "body.fixedMerged";
var BODY_CREATED_STYLES = "body.created";
var BODY_UPDATED_STYLES = "body.updated";
var BODY_DELETED_STYLES = "body.deleted";
var BODY_CHECKED_STYLES = "body.checked";
var BODY_FIXED_COLBAR_STYLES = "body.fixedColumnBar";
var BODY_FIXED_ROWBAR_STYLES = "body.fixedRowBar";
var BODY_SELECTION_STYLES = "body.selection";
var BODY_MOBILE_SELECTION_STYLES = "body.mobileSelection";
var BODY_ROW_HOVER_STYLES = "body.rowHover";
var BODY_ROW_RANGE = "body.rowRange";
var BODY_ROW_DYNAMIC = "body.rowDynamic";
var BODY_CELL_DYNAMIC = "body.cellDynamic";
var BODY_FOCUS = "body.focus";
var HEADER_STYLES = "header";
var HEADER_HEAD_STYLES = "header.head";
var HEADER_GROUP_STYLES = "header.group";
var HEADER_SUB_STYLES = "header.sub";
var HEADER_MENUHANDLE_STYLES = "header.menuHandle";
var HEADER_FILTERHANDLE_STYLES = "header.filterHandle";
var HEADER_SORTHANDLE_STYLES = "header.sortHandle";
var HEADER_SORTORDER_STYLES = "header.sortOrder";
var HEADER_SUMMARY_STYLES = "header.summary";
var HEADER_SUMMARY_HEAD_STYLES = "header.summary.head";
var HEADER_SUMMARY_GROUP_STYLES = "header.summary.group";
var FOOTER_STYLES = "footer";
var FOOTER_GROUP_STYLES = "footer.group";
var FOOTER_HEAD_STYLES = "footer.head";
var ROWGROUP_STYLES = "rowGroup";
var ROWGROUP_HEADER_STYLES = "rowGroup.header";
var ROWGROUP_EXPANDER_STYLES = "rowGroup.expander";
var ROWGROUP_FOOTER_STYLES = "rowGroup.footer";
var ROWGROUP_INDENT_STYLES = "rowGroup.indent";
var ROWGROUP_HEAD_STYLES = "rowGroup.head";
var ROWGROUP_BAR_STYLES = "rowGroup.bar";
var ROWGROUP_HEADERBAR_STYLES = "rowGroup.headerBar";
var ROWGROUP_FOOTERBAR_STYLES = "rowGroup.footerBar";
var ROWINDICATOR_STYLES = "rowIndicator";
var ROWINDICATOR_STATE_STYLES = "rowIndicator.state";
var ROWINDICATOR_CREATED_STYLES = "rowIndicator.created";
var ROWINDICATOR_UPDATED_STYLES = "rowIndicator.updated";
var ROWINDICATOR_DELETED_STYLES = "rowIndicator.deleted";
var CHECKBAR_STYLES = "checkBar";
var CHECKBAR_HEAD_STYLES = "checkBar.head";
var HEADER_ITEM_STYLES = "headerItem";
var FOOTER_ITEM_STYLES = "footerItem";
var TREE_STYLES = "tree";
var TREE_FOOTER_STYLES = "tree.footer";
var TREE_EXPANDER_STYLES = "tree.expander";
var TREE_INDENT_STYLES = "tree.indent";
var SCROLLBAR_STYLES = "scrollBar";
var SCROLLBAR_BUTTON_STYLES = "scrollBar.button";
var SCROLLBAR_THUMB_STYLES = "scrollBar.thumb";
var SCROLLBAR_INDENT_STYLES = "scrollBar.indent";
var SCROLL_EDGE_STYLES = "scrollEdge";
var TOOLTIP_STYLES = "tooltip";
var PALETTES = "palettes";
var COLUMNS_STYLES = "columns";
/** @abstract */
var StylesArchiver = defineClass("StylesArchiver", null, {
	init: function() {
		this._super();
	},
	loadGridStyles: function(source, grid) {
		this.loadGrid(source, grid);
	},
	loadGrid: function (source, grid) {
	},
	saveGrid: function (grid) {
	},
	loadStyles: function (source, styles) {
	},
	saveStyles: function (styles) {
	}
}, {
	applyStyles: function (source, styles, fireEvents) {
		fireEvents = arguments.length > 2 ? fireEvents : true;
		if (source && styles) {
			styles.extend(source, fireEvents);
		}
	},
	deserialize: function (source, grid) {
		function setStyles(styleName, styles) {
			if (source.hasOwnProperty(styleName)) {
				var obj = source[styleName];
				if (obj) {
					styles.extend(obj);
					return true;
				}
			}
			return false;
		}
		function setChildStyles(parentStyle, styleName, styles) {
			var obj = source[parentStyle][styleName];
			if (obj) {
				styles.extend(obj);
				return true;
			}
			return false;
		}
        function setChildStyles2(parentStyle, parentStyle2, styleName, styles) {
            var obj = source[parentStyle][parentStyle2][styleName];
            if (obj) {
                styles.extend(obj);
                return true;
            }
            return false;
        }
        if (!source || !grid) return;
		var owner, styles, s, s2, scase, style, obj, i,
            options = grid.displayOptions();
		setStyles(DEFAULT_STYLES, grid.defaultStyles());
		setStyles(GRID_STYLES, grid.styles());
		setStyles(PANEL_STYLES, grid.panel().styles());
        var panel = grid.groupPanel();
        if (setStyles(GROUPPANEL_STYLES, panel.styles())) {
            setChildStyles(GROUPPANEL_STYLES, "item", panel.itemStyles());
            setChildStyles(GROUPPANEL_STYLES, "itemInner", panel.itemInnerStyles());
            setChildStyles(GROUPPANEL_STYLES, "head", panel.head().styles());
            setChildStyles(GROUPPANEL_STYLES, "headInner", panel.head().innerStyles());
        }
        setStyles(GROUPPANEL_ITEM_STYLES, panel.itemStyles());
        setStyles(GROUPPANEL_ITEM_INNER_STYLES, panel.itemInnerStyles());
        setStyles(GROUPPANEL_HEAD_STYLES, panel.head().styles());
        setStyles(GROUPPANEL_HEAD_INNER_STYLES, panel.head().innerStyles());
		var body = grid.body();
		if (setStyles(BODY_STYLES, body.styles()) && (s = source[BODY_STYLES])) {
			setChildStyles(BODY_STYLES, "empty", body.emptyStyles());
            setChildStyles(BODY_STYLES, "emptyData", body.emptyDataStyles());
            setChildStyles(BODY_STYLES, "row", body.rowStyles());
            setChildStyles(BODY_STYLES, "fixedRow", body.fixedRowStyles());
			setChildStyles(BODY_STYLES, "cell", body.cellStyles());
			setChildStyles(BODY_STYLES, "fixedCell", body.fixedCellStyles());
            setChildStyles(BODY_STYLES, "merged", body.mergedStyles());
            setChildStyles(BODY_STYLES, "fixedMerged", body.fixedMergedStyles());
			setChildStyles(BODY_STYLES, "fixedColumnBar", body.fixedColumnBarStyles());
			setChildStyles(BODY_STYLES, "fixedRowBar", body.fixedRowBarStyles());
            setChildStyles(BODY_STYLES, "rowHover", options.rowHoverMask().styles());
			if (s.hasOwnProperty("focus")) {
				s2 = s.focus.border;
				s2 && options.setFocusBorder(s2);
			}
            if (_isMobile()) {
                setChildStyles(BODY_STYLES, "selection", body.mobileSelectionStyles());
            } else {
                setChildStyles(BODY_STYLES, "selection", body.selectionStyles());
            }
			obj = s.created;
            obj && body.setCreatedStyles(obj);
            obj = s.updated;
            obj && body.setUpdatedStyles(obj);
            obj = s.deleted;
            obj && body.setDeletedStyles(obj);
            obj = s.checked;
            obj && body.setCheckedStyles(obj);
            obj = s.rowRange;
            obj && body.setRowRangeStyles(obj);
            obj = s.rowDynamic;
            obj && body.setRowDynamicStyles(obj);
			obj = s.cellDynamic;
            obj && body.setCellDynamicStyles(obj);
		}
		setStyles(BODY_EMPTY_STYLES, body.emptyStyles());
        setStyles(BODY_EMPTY_DATA_STYLES, body.emptyDataStyles());
        setStyles(BODY_ROW_STYLES, body.rowStyles());
        setStyles(BODY_FIXED_ROW_STYLES, body.fixedRowStyles());
		setStyles(BODY_CELL_STYLES, body.cellStyles());
		setStyles(BODY_FIXED_CELL_STYLES, body.fixedCellStyles());
        setStyles(BODY_MERGED_STYLES, body.mergedStyles());
        setStyles(BODY_FIXED_MERGED_STYLES, body.fixedMergedStyles());
		setStyles(BODY_FIXED_COLBAR_STYLES, body.fixedColumnBarStyles());
		setStyles(BODY_FIXED_ROWBAR_STYLES, body.fixedRowBarStyles());
        setStyles(BODY_ROW_HOVER_STYLES, options.rowHoverMask().styles());
		setStyles(BODY_CREATED_STYLES, body.createdStyles());
        setStyles(BODY_UPDATED_STYLES, body.updatedStyles());
        setStyles(BODY_DELETED_STYLES, body.deletedStyles());
        setStyles(BODY_CHECKED_STYLES, body.checkedStyles());
        if (_isMobile()) {
            setStyles(BODY_MOBILE_SELECTION_STYLES, body.mobileSelectionStyles());
        } else {
            setStyles(BODY_SELECTION_STYLES, body.selectionStyles());
        }
        setStyles(BODY_ROW_HOVER_STYLES, options.rowHoverMask().styles());
        if (s) {
            if (source.hasOwnProperty(BODY_ROW_RANGE)) {
                body.setRowRangeStyles(source[BODY_ROW_RANGE]);
            }
            if (source.hasOwnProperty(BODY_ROW_DYNAMIC)) {
                body.setRowDynamicStyles(source[BODY_ROW_DYNAMIC]);
            }
            if (source.hasOwnProperty(BODY_CELL_DYNAMIC)) {
                body.setCellDynamicStyles(source[BODY_CELL_DYNAMIC]);
            }
        }
		if (source.hasOwnProperty(BODY_FOCUS)) {
			s2 = source[BODY_FOCUS].border;
			s2 && grid.options.setFocusBorder(s2);
		}
		var header = grid.header();
		if (setStyles(HEADER_STYLES, header.styles())) {
			setChildStyles(HEADER_STYLES, "head", header.head().styles());
			setChildStyles(HEADER_STYLES, "group", header.groupStyles());
            setChildStyles(HEADER_STYLES, "sub", header.subStyles());
            setChildStyles(HEADER_STYLES, "menuHandle", header.menuHandleStyles());
            setChildStyles(HEADER_STYLES, "filterHandle", header.filterHandleStyles());
            setChildStyles(HEADER_STYLES, "sortHandle", header.sortHandleStyles());
			setChildStyles(HEADER_STYLES, "sortOrder", header.sortOrderStyles());
            if (setChildStyles(HEADER_STYLES, "summary", header.summary().styles())) {
                setChildStyles2(HEADER_STYLES, "summary", "head", header.summary().head().styles());
				setChildStyles2(HEADER_STYLES, "summary", "group", header.summary().groupStyles());
            }
		}
        setStyles(HEADER_HEAD_STYLES, header.head().styles());
        setStyles(HEADER_GROUP_STYLES, header.groupStyles());
        setStyles(HEADER_SUB_STYLES, header.subStyles());
        setStyles(HEADER_MENUHANDLE_STYLES, header.menuHandleStyles());
        setStyles(HEADER_FILTERHANDLE_STYLES, header.filterHandleStyles());
        setStyles(HEADER_SORTHANDLE_STYLES, header.sortHandleStyles());
        setStyles(HEADER_SORTORDER_STYLES, header.sortOrderStyles());
        setStyles(HEADER_SUMMARY_STYLES, header.summary().styles());
        setStyles(HEADER_SUMMARY_HEAD_STYLES, header.summary().head().styles());
		setStyles(HEADER_SUMMARY_HEAD_STYLES, header.summary().groupStyles());
		var footer = grid.footer();
		if (setStyles(FOOTER_STYLES, footer.styles())) {
			setChildStyles(FOOTER_STYLES, "group", footer.groupStyles());
            setChildStyles(FOOTER_STYLES, "head", footer.head().styles());
		}
        setStyles(FOOTER_GROUP_STYLES, footer.groupStyles());
        setStyles(FOOTER_HEAD_STYLES, footer.head().styles());
        var rowGroup = grid.rowGroup();
		if (source && source.hasOwnProperty(ROWGROUP_STYLES)) {
			setChildStyles(ROWGROUP_STYLES, "header", rowGroup.headerStyles());
			setChildStyles(ROWGROUP_STYLES, "expander", rowGroup.expanderStyles());
			setChildStyles(ROWGROUP_STYLES, "footer", rowGroup.footerStyles());
			setChildStyles(ROWGROUP_STYLES, "indent", rowGroup.indentStyles());
			setChildStyles(ROWGROUP_STYLES, "head", rowGroup.headStyles());
            setChildStyles(ROWGROUP_STYLES, "bar", rowGroup.barStyles());
			setChildStyles(ROWGROUP_STYLES, "headerBar", rowGroup.headerBarStyles());
			setChildStyles(ROWGROUP_STYLES, "footerBar", rowGroup.footerBarStyles());
            /*
			var levels = source[ROWGROUP_STYLES].rowGroupLevels;
			if (levels) {
				for (i = 0; i < Math.min(levels.length, rowGroup.levelCount); i++) {
					obj = levels[i];
					var glevel = rowGroup.getLevel(i);
					if (obj.header) {
						glevel.headerStyles().extend(obj.header);
					}
					if (obj.footer) {
						glevel.footerStyles().extend(obj.footer);
					}
					if (obj.headerBar) {
						glevel.headerBarStyles().extend(obj.headerBar);
					}
					if (obj.footerBar) {
						glevel.footerBarStyles().extend(obj.footerBar);
					}
					if (obj.bar) {
						glevel.barStyles().extend(obj.bar);
					}
				}
			}
			*/
		}
        setStyles(ROWGROUP_HEADER_STYLES, rowGroup.headerStyles());
        setStyles(ROWGROUP_EXPANDER_STYLES, rowGroup.expanderStyles());
        setStyles(ROWGROUP_FOOTER_STYLES, rowGroup.footerStyles());
        setStyles(ROWGROUP_INDENT_STYLES, rowGroup.indentStyles());
        setStyles(ROWGROUP_HEAD_STYLES, rowGroup.headStyles());
        setStyles(ROWGROUP_BAR_STYLES, rowGroup.barStyles());
        setStyles(ROWGROUP_HEADERBAR_STYLES, rowGroup.headerBarStyles());
        setStyles(ROWGROUP_FOOTERBAR_STYLES, rowGroup.footerBarStyles());
		var indicator = grid.rowIndicator();
        if (setStyles(ROWINDICATOR_STYLES, indicator.styles())) {
			setChildStyles(ROWINDICATOR_STYLES, "state", indicator.stateStyles());
			setChildStyles(ROWINDICATOR_STYLES, "created", indicator.createdStyles());
			setChildStyles(ROWINDICATOR_STYLES, "updated", indicator.updatedStyles());
			setChildStyles(ROWINDICATOR_STYLES, "deleted", indicator.deletedStyles());
        }
        setStyles(ROWINDICATOR_STATE_STYLES, indicator.stateStyles());
		setStyles(ROWINDICATOR_CREATED_STYLES, indicator.createdStyles());
		setStyles(ROWINDICATOR_UPDATED_STYLES, indicator.updatedStyles());
		setStyles(ROWINDICATOR_DELETED_STYLES, indicator.deletedStyles());
		var checkBar = grid.checkBar();
		if (setStyles(CHECKBAR_STYLES, checkBar.styles())) {
			setChildStyles(CHECKBAR_STYLES, "head", checkBar.headStyles());
		}
        setStyles(CHECKBAR_HEAD_STYLES, checkBar.headStyles());
        setStyles(HEADER_ITEM_STYLES, grid.headerItemStyles());
        setStyles(FOOTER_ITEM_STYLES, grid.footerItemStyles());
        if (TreeView) {
            var tree = _cast(grid, TreeView);
            if (tree) {
                setStyles(TREE_STYLES, grid.styles());
                var treeOptions = tree.treeOptions();
                if (source && source.hasOwnProperty(TREE_STYLES)) {
					setChildStyles(TREE_STYLES, "footer", treeOptions.footerStyles());
                    setChildStyles(TREE_STYLES, "expander", treeOptions.expanderStyles());
                    setChildStyles(TREE_STYLES, "indent", treeOptions.indentStyles());
                }
                setStyles(TREE_FOOTER_STYLES, treeOptions.footerStyles());
				setStyles(TREE_EXPANDER_STYLES, treeOptions.expanderStyles());
                setStyles(TREE_INDENT_STYLES, treeOptions.indentStyles());
            }
        }
		var vscrollBar = grid.vscrollBar();
		var hscrollBar = grid.hscrollBar();
		if (setStyles(SCROLLBAR_STYLES, vscrollBar.styles())) {
			setStyles(SCROLLBAR_STYLES, hscrollBar.styles());
			setChildStyles(SCROLLBAR_STYLES, "button", vscrollBar.buttonStyles());
			setChildStyles(SCROLLBAR_STYLES, "button", hscrollBar.buttonStyles());
			setChildStyles(SCROLLBAR_STYLES, "thumb", vscrollBar.thumbStyles());
			setChildStyles(SCROLLBAR_STYLES, "thumb", hscrollBar.thumbStyles());
			setChildStyles(SCROLLBAR_STYLES, "indent", vscrollBar.indentStyles());
			setChildStyles(SCROLLBAR_STYLES, "indent", hscrollBar.indentStyles());
		}
		setStyles(SCROLLBAR_BUTTON_STYLES, vscrollBar.buttonStyles());
		setStyles(SCROLLBAR_BUTTON_STYLES, hscrollBar.buttonStyles());
		setStyles(SCROLLBAR_THUMB_STYLES, vscrollBar.thumbStyles());
		setStyles(SCROLLBAR_THUMB_STYLES, hscrollBar.thumbStyles());
		setStyles(SCROLLBAR_INDENT_STYLES, vscrollBar.indentStyles());
		setStyles(SCROLLBAR_INDENT_STYLES, hscrollBar.indentStyles());
		setStyles(SCROLL_EDGE_STYLES, grid.scrollEdgeStyles());
        setStyles(TOOLTIP_STYLES, options.tooltipStyles());
        var pals = source[PALETTES];
        pals && grid.loadPalettes(pals);
		var colStyles = source[COLUMNS_STYLES];
        colStyles && grid.registerColumnStyles(colStyles);
        var options = source["options"];
        options && grid.setOptions(options);
	}
});
/** @abstract */
var DynamicStyle = defineClass("DynamicStyle", null, {
	init: function () {
		this._super();
		this._body = true;
		this._fixed = true;
	},
	apply: function (runtime, target/* GridStyles */) {
	},
	_changed: function () {
	}
}); 
var DynamicStyleImpl = defineClass("DynamicStyleImpl", DynamicStyle, {
	init: function( source) {
		this._super();
		this._exprNode = null;
		this._styleMap = {};
		if (source) {
			if (source.hasOwnProperty("expression")) {
				this.setExpression(source.expression);
			}
			if (source.hasOwnProperty("styles")) {
				this.setStyles(source.styles);
			}
		}
	},
	expression: null,
    callback: null,
	styles: null,
	setExpression: function (value) {
		var s = value ? value.toString() : null;
		if (s != this._expression) {
			this._expression = s;
			this.$_buildExpression();
			this._changed();
		}
	},
    setCallback: function (value) {
        if (value !== this._callback) {
            this._callback = (typeof value == "function") ? value : null;
            this._changed();
        }
    },
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles = value;
			this.$_buildStyles();
			this._changed();
		}
	},
	apply: function (runtime, target) {
        var checked = false;
        if (this._callback) {
            checked = this._callback(runtime.scope());
        } else if (this._exprNode && this._exprNode.evaluate(runtime)) {
            checked = true;
        }
        if (checked) {
            for (var style in this._styleMap) {
				var setter = target[$$_STYLE_PROP_MAP[style]];
				if (setter) { 
					setter.call(target, this._styleMap[style]);
				}
			}
		}
	},
    getAppliables: function (runtime, target) {
        var checked = false;
        if (this._callback) {
            checked = this._callback(runtime.scope());
        } else if (this._exprNode && this._exprNode.evaluate(runtime)) {
            checked = true;
        }
        if (checked) {
            for (var style in this._styleMap) {
                var setter = GridStylesProto[$$_STYLE_PROP_MAP[style]];
                if (setter) {
                    target[style] = {
                        setter: setter,
                        value: this._styleMap[style]
                    }
                }
            }
        }
		return target;
    },
	$_buildExpression: function () {
		if (this._expression) {
			this._exprNode = ExpressionParser.Default.parse(this._expression);
			if (this._exprNode == null) {
				this._exprNode = EmptyExpressionNode.Default;
			}
		} else {
			this._exprNode = EmptyExpressionNode.Default;
		}
	},
	$_buildStyles: function () {
		this._styleMap = {};
		if (this._styles) {
			for (var p in this._styles) {
				this._styleMap[p] = this._styles[p];
			}
		}
	}
});
var DynamicStyleCase = defineClass("DynamicStyleCase", DynamicStyle, {
	init : function(config) {
		this._super();
        this._callbacks = [];
		this._exprNodes = [];
		this._stylesMap = [];
		if (config) {
            if (config.hasOwnProperty("callbacks")) {
                this.setCallbacks(config.callbacks);
            }
			if (config.hasOwnProperty("expressions")) {
				this.setExpressions(config.expressions);
			}
			if (config.hasOwnProperty("styles")) {
				this.setStyles(config.styles);
			}
		}
	},
	expressions: null,
    callbacks: null,
	styles: null,
	setExpressions: function (value) {
		if (value != this._expressions) {
			this._expressions = value;
			this.$_buildExpressions();
			this._changed();
		}
	},
    setCallbacks: function (value) {
        if (value !== this._callbacks) {
            this._callbacks = [];
            if (_isArray(value)) {
                for (var i = 0, cnt = value.length; i < cnt; i++) {
                    this._callbacks.push(typeof value[i] == "function" ? value[i] : null);
                }
            } else if (typeof value == "function") {
                this._callbacks.push(value);
            }
            this._changed();
        }
    },
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles = _isArray(value) ? value : [value];
			this.$_buildStyles();
			this._changed();
		}
	},
	apply: function(runtime, target) {
        var i, fnc, expr, styleMap, style, v,
            len = Math.max(this._callbacks ? this._callbacks.length : 0, this._exprNodes ? this._exprNodes.length : 0);
        for (i = 0; i < len; i++) {
            if ((fnc = this._callbacks[i]) && fnc(runtime.scope()) ||
                (expr = this._exprNodes[i]) && expr.evaluate(runtime)) {
                styleMap = this._stylesMap[i];
                for (style in styleMap) {
                    v = styleMap[style];
                    if (v !== undefined) {
                        target[$$_STYLE_PROP_MAP[style]].call(target, v);
                    }
                }
                break;
            }
        }
	},
    getAppliables: function (runtime, target) {
        var i, fnc, expr, styleMap, style, v,
            len = Math.max(this._callbacks ? this._callbacks.length : 0, this._exprNodes ? this._exprNodes.length : 0);
        for (i = 0; i < len; i++) {
            styleMap = undefined;
            if ((fnc = this._callbacks[i]) && fnc(runtime.scope()) ||
                (expr = this._exprNodes[i]) && expr.evaluate(runtime)) {
                styleMap = this._stylesMap[i];
            }
            if (styleMap) {
                for (style in styleMap) {
                    v = styleMap[style];
                    if (v !== undefined) {
                        target[style] = {
                            setter: GridStylesProto[$$_STYLE_PROP_MAP[style]],
                            value: v
                        }
                    }
                }
                break;
            }
        }
		return target;
    },
	$_buildExpressions: function () {
		var cnt, i, s, expr;
		this._exprNodes = [];
		if (_isArray(this._expressions) && (cnt = this._expressions.length) > 0) {
			for (i = 0; i < cnt; i++) {
				s = this._expressions[i];
				if (s) {
					expr = ExpressionParser.Default.parse(s);
					if (expr == null) {
						expr = EmptyExpressionNode.Default;
					}
					this._exprNodes.push(expr);
				} else {
					this._exprNodes.push(EmptyExpressionNode.Default);
				}
			}
		}
		this.$_buildStyles();
	},
	$_buildStyles: function () {
        var i, cnt, style, map, p,
            maps = this._stylesMap = [];
		if (_isArray(this._styles)) {
			cnt = Math.max(this._callbacks ? this._callbacks.length : 0, this._exprNodes ? this._exprNodes.length : 0);
            for (i = 0; i < cnt; i++) {
				styles = this._styles[i];
                if (styles) {
                    map = {};
                    if (styles) {
                        for (var p in styles) {
                            map[p] = styles[p];
                        }
                    }
                    maps.push(map);
                } else if (i > 0) {
                    maps.push(maps[maps.length - 1])
                } else {
                    maps.push(null);
                }
			}
		}
	}
}); 
var DynamicStyleCollection = defineClass("DynamicStyleCollection", null, {
	init: function () {
		this._super();
		this._items = [];
	},
	count: function () {
		return this._items.length;
	},
	getItem: function (index) {
		return this._items[index];
	},
	clear: function () {
		this._items = [];
	},
	add: function (item) {
		var style = this.$_createStyle(item);
		if (style && this._items.indexOf(style) < 0) {
			this._items.push(style);
		}
	},
	getItems: function () {
		return this._items.slice();
	},
	setItems: function (items) {
        var i, cnt, style;
		this._items = [];
		if (items) {
			if (items instanceof DynamicStyleCollection) {
				items = items.getItems();
			} else if (!_isArray(items)) {
				items = [items];
			}
			for (i = 0, cnt = items.length; i < cnt; i++) {
				style = this.$_createStyle(items[i]);
				style && this._items.push(style);
			}
		}
	},
	prepare: function () {
	},
	applyCheck: function (runtime, styles, targets) {
		if (runtime && styles && targets) {
			this.applyInternalNormal(runtime, styles, targets);
		}
	},
	applyInternalNormal: function (runtime, styles, targets) {
        var i, cnt, style;
        for (i = 0, cnt = this._items.length; i < cnt; i++) {
            style = this._items[i];
            style.apply(runtime, styles);
        }
	},
    applyInternalUserMode: function (runtime, styles, targets) {
        var i, cnt, style;
        try {
            for (i = 0, cnt = this._items.length; i < cnt; i++) {
                style = this._items[i];
                style.apply(runtime, styles);
            }
        } catch (err) {
        }
    },
    getAppliables: function (runtime, target) {
        var i, cnt, style;
        for (i = 0, cnt = this._items.length; i < cnt; i++) {
            style = this._items[i];
            style.getAppliables(runtime, target);
        }
		return target;
    },
	toArray: function () {
		return this._items.concat(); 
	},
    proxy: function () {
        var i, items = [];
        for (i = 0; i < this._items.length; i++) {
            items.push(this._items[i].proxy());
        }
        return items;
    },
	$_createStyle: function (source) {
		var s = null;
		if (source instanceof DynamicStyle) {
            s = source;
        } else if (source) {
            if (_isArray(source.callbacks)) {
                s = new DynamicStyleCase();
                s.setCallbacks(source.callbacks);
                s.setStyles(source.styles);
            } else if (source.callback) {
                s = new DynamicStyleImpl();
                s.setCallback(source.callback);
                s.setStyles(source.styles);
            } else if (_isArray(source.expressions)) {
                s = new DynamicStyleCase();
                s.setExpressions(source.expressions);
                s.setStyles(source.styles);
            } else if (source.expression) {
                s = new DynamicStyleImpl();
                s.setExpression(source.expression);
                s.setStyles(source.styles);
            }
        }
		return s;
	}
}); 
var GridRowStyleRange = defineClass("GridRowStyleRange", null, {
    init: function (owner, rangeExpr, styles) {
        this._super();
        if (typeof rangeExpr === 'function') {
            this._callback = rangeExpr;
        } else if (rangeExpr) {
            this._rangeNode = ExpressionParser.Default.parse(rangeExpr);
        } else {
            this._rangeNode = null;
        }
        this._styles = new GridStyles(owner, null, styles, false, owner);
    },
    getRow: function (runtime, row) {
        if (this._callback) {
            if (this._callback(this._styles._owner._owner._grid, row)) {
                return this._styles;
            }
        } else {
            runtime.setRow(row);
            if (this._rangeNode && this._rangeNode.evaluate(runtime)) {
                return this._styles;
            }
        }
        return null;
    }
});
var GridRowStyles = defineClass("GridRowStyles", null, {
    init: function (owner, source) {
        this._super();
        this._owner = owner;
		this._rangeRuntime = new GridRowStyleRangeRuntime();
		this.assign(source);
		this._current = undefined;
		this._palettes = null;
    },
    setDefaultStyles: function (defaultStyles, fixedStyles) {
        this._styles = defaultStyles;
        this._fixedStyles = fixedStyles;
    },
	stylesChanged: function (/*stypeProp*/) {
        this._changed();
	},
    getPaletteScope: function () {
        return this;
    },
	getPalette: function (pal) {
		return this._palettes[pal];
	},
	getPaletteIndex: function (index) {
		return index == "row" ? this._current : index;
	},
	styles: null,
	fixedStyles: null,
    /* @internal */
    owner: function () {
        return this._owner;
    },
    /* @internal */
    getRow: function (row, fixed) {
		if (fixed && this._fixedIgnore) {
			return this._fixedStyles;
		}
        var i, len,
		    def = fixed ? this._fixedStyles : this._styles,
		    st = this._rows[row] || this._rowMap[row];
        if (!st && this._ranges) {
            for (i = 0, len = this._ranges.length; i < len; i++) {
                st = this._ranges[i].getRow(this._rangeRuntime, row);
                if (st) {
                    this._rowMap[row] = st;
                    break;
                }
            }
        }
		if (st) {
			st._parent = def;
		}
        this._current = row;
		return st || def;
    },
    clearRows: function () {
        var r, hasRows = false;
        for (r in this._rows) {
            hasRows = true;
            break;
        }
        if (hasRows) {
            this._rows = {};
            this._rowMap = {};
			this._changed();
        }
        return this;
    },
    setRow: function (row, styles) {
        if (_isInt(row) && styles) {
            this._rows[row] = new GridStyles(null, null, styles, false);
			this._rows[row]._parent = this._styles;
			this._changed();
        } else if (this._rows[row]) {
            delete this._rows[row];
			this._changed();
        }
        return this;
    },
    clearRanges: function () {
        if (this._ranges && this._ranges.length > 0) {
            this._ranges = null;
            this._rangeMap = {};
			this._changed();
        }
        return this;
    },
    setRange: function (name, rangeExpr, styles) {
        var range, r, i;
        if (range && styles) {
            range = new GridRowStyleRange(this, rangeExpr, styles);
			range._styles._parent = this._styles;
            this._ranges = this._ranges || [];
            this._ranges.push(range);
            if (name) {
                this._rangeMap[name] = range;
            }
			this._changed();
        } else if (name && this._ranges) {
            r = this._rangeMap[name];
            delete this._rangeMap[name];
            for (i = this._ranges.length; i--;) {
                if (this._ranges[i] === r) {
                    this._ranges.splice(i, 1);
                    break;
                }
            }
			this._changed();
        }
        return this;
    },
    assign: function (source) {
        var rows, expr, range, i, rng, row;
		this._ranges = null;
        this._rangeMap = {};
		this._rows = {};
		this._rowMap = {};
		if (source) {
			rows = source.rows;
			if (rows) {
				for (i = 0; i < rows.length; i++) {
					rng = rows[i];
                    expr = rng.callback || rng.range;
					if (expr && rng.styles) {
						range = new GridRowStyleRange(this, expr, rng.styles);
						range._styles._parent = this._styles;
                        this._ranges = this._ranges || [];
						this._ranges.push(range);
                        if (rng.name) {
                            this._rangeMap[rng.name] = range;
                        }
					}
				}
			}
			for (row in source) {
				if (row != 'rows') {
					r = Number(row);
					if (!isNaN(r)) {
						this._rows[r] = new GridStyles(null, null, source[row], false);
						this._rows[r]._parent = this._styles;
					} else if (_isObject(source[row])) {
						range = new GridRowStyleRange(this, row, source[row]);
						range._styles._parent = this._styles;
						this._ranges = this._ranges || [];
						this._ranges.push(range);
					}
				}
			}
		}
        return this;
    },
    $_prepareRender: function (palettes, ignoreRangeOnFixed) {
        this._rowMap = {};
		this._palettes = palettes;
		this._fixedIgnore = ignoreRangeOnFixed;
        this._rangeRuntime.setGrid(this._owner.owner());
    },
	_changed: function () {
		this._owner && this._owner.onRowStylesChanged(this);
	}
});
var $$_dc_empty_styles = new GridStyles();
var $$_dc_edit_props = ["readOnly", "editable", "button"/*, "popupMenu"*/];
var CellStyle = defineClass("CellStyle", null, {
    init: function (id, source) {
        this._super();
        this._id = id;
        this._styles = $$_dc_empty_styles;
        this._props = null;
        source && this.assign(source);
    },
    id: function () {
        return this._id;
    },
    editable: function () {
        return this._props ? this._props.editable : undefined;
    },
    isEditable: function () {
        return this.editable();
    },
    readOnly: function () {
        return this._props ? this._props.readOnly : undefined;
    },
    isReadOnly: function () {
        return this.readOnly();
    },
    button: function () {
        return this._props && this._props.button;
    },
    clone: function () {
        var cs = new CellStyle(this._id);
        cs._styles = this._styles === $$_dc_empty_styles ? $$_dc_empty_styles : this._styles.clone();
        cs._props = this._props ? _extend(null, this._props) : null;
    },
    setStyles: function (value) {
        if (value != this._styles) {
            if (value) {
                if (this._styles === $$_dc_empty_styles) {
                    this._styles = new GridStyles(null, null, false);
                }
                this._styles.clearValues();
                this._styles.extend(value, false, false);
            } else {
                this._styles = $$_dc_empty_styles;
            }
        }
    },
    /** @internal */
    assignTo: function (styles) {
        styles && styles.extend(this._styles, false, false);
    },
    assign: function (source) {
        if (source) {
            this.setStyles(source instanceof CellStyle ? source._styles : source);
            this.$_assignProps(source, $$_dc_edit_props);
        }
    },
    $_assignProps: function (source, props) {
        var i, p, v;
        for (i = props.length; i--;) {
            p = props[i];
            if (source.hasOwnProperty(p)) {
                v = source[p];
                if (v === undefined) {
                    if (this._props) {
                        delete this._props[p];
                    }
                } else {
                    this._props = this._props || {};
                    this._props[p] = source[p];
                }
            }
        }
    }
});
var CellStyleCollection = defineClass("CellStyleCollection", EventAware, {
    init: function (owner) {
        this._super();
        this._owner = owner;
        this._styles = {};
        this._dirtyLock = 0;
    },
    getCellStyle: function (id) {
        return this._styles[id];
    },
    /*
     getStyle: function (id) {
     return this._styles[id];
     },
     */
    exists: function (id) {
        return this._styles[id] !== undefined;
    },
    "get": function (id) {
        return this._styles[id];
    },
    clear: function () {
        if (!_isEmptyObject(this._styles)) {
            this._styles = {};
            if (this._dirtyLock <= 0 && this._owner) {
                this._owner.cellStylesCleared(this._dirtyLock <= 0);
            }
            return true;
        }
        return false;
    },
    add: function (id, style) {
        if (id && style && !this._styles[id]) {
            this._styles[id] = new CellStyle(id, style);
            this._owner && this._owner.cellStyleAdded(id, this._dirtyLock <= 0);
            return true;
        }
        return false;
    },
    "set": function (id, style) {
        if (id) {
            var oldStyle = this._styles[id];
            if (style) {
                if (oldStyle) {
                    oldStyle.assign(style);
                    this._owner && this._owner.cellStyleChanged(id, this._dirtyLock <= 0);
                } else {
                    this._styles[id] = new CellStyle(id, style);
                    this._owner && this._owner.cellStyleAdded(id, this._dirtyLock <= 0);
                }
                return true;
            } else if (oldStyle) {
                delete this._styles[id];
                this._owner && this._owner.cellStyleRemoved(id, oldStyle, this._dirtyLock <= 0);
                return true;
            }
        }
        return false;
    },
    beginUpdate: function () {
        this._dirtyLock++;
    },
    endUpdate: function (updateOwner) {
        this._dirtyLock--;
        if (this._dirtyLock == 0 && updateOwner && this._owner) {
            this._owner.cellStyleChanged(null, true);
        }
    },
    load: function (source) {
    }
});
/** @abstract */
var CellStyleMap = defineClass("CellStyleMap", DataTag, {
    init: function () {
        this._super();
        this._ds = null;
        this._initMap();
    },
    isEmpty: function () {
        return this._styleMap.length == 0 && !this._styleMap[-1];
    },
    setCellStyle: function (row, field, style) {
        if (field < 0) {
            this._styleMap[row] = style;
        } else {
            var oldStyle = this._styleMap[row];
            var styles;
            if (oldStyle) {
                if (_isArray(oldStyle)) {
                    oldStyle[field] = style;
                } else {
                    styles = [];
                    for (var i = 0, cnt = this._ds.fieldCount(); i < cnt; i++) {
                        styles[i] = oldStyle;
                    }
                    this._styleMap[row] = styles;
                }
            }
            styles = this._styleMap[row];
            if (!styles) {
                styles = [];
            }
            styles[field] = style;
            this._styleMap[row] = styles;
        }
    },
    loadStyleRows: function (provider, rows, fieldMap, startRow, count) {
        if (!rows || rows.length < 1 || !fieldMap) {
            return false;
        }
        var ds = this._ds;
        startRow = startRow === undefined ? 0 : Math.max(this._minRowIndex(ds), startRow);
        count = count === undefined ? rows.length : Math.max(0, Math.min(rows.length, count));
        if (count <= 0) {
            return false;
        }
        var f, fld, style, r, cnt, row,
            rowCount = this._maxRowIndex(ds),
            fldCount = ds.fieldCount(),
            fields = {},
            cnt = rows.length;
        for (f in fieldMap) {
            fld = ds.getFieldIndexEx(fieldMap[f]);
            if (fld >= 0) {
                fields[f] = fld;
            }
        }
        for (r = startRow, cnt = Math.min(count, cnt), i = 0; i < cnt && r < rowCount; i++, r++) {
            if (row = rows[i]) {
                for (f in fields) {
                    fld = fields[f];
                    style = provider.getCellStyle(row[f]);
                    style && this.setCellStyle(r, fld, style)
                }
            }
        }
        return true;
    },
    removeCellStyle: function (style) {
        var r, cnt, styles;
        for (r = 0, cnt = this._styleMap.length; r < cnt; r++) {
            styles = this._styleMap[r];
            if (_isArray(styles)) {
                for (var i = styles.length - 1; i >= 0; i--) {
                    if (styles[i] === style) {
                        styles[i] = null;
                    }
                }
            } else {
                if (this._styleMap[r] === style) {
                    delete this._styleMap[r];
                }
            }
        }
    },
    clearCellStyles: function () {
        if (!this.isEmpty()) {
            this._initMap();
            return true;
        }
        return false;
    },
    getCellStyle: function (dataRow, field) {
        var style = this._styleMap[dataRow];
        if (_isArray(style)) {
            return style[field];
        } else {
            return style;
        }
    },
    _initMap: function () {
        this._styleMap = [];
    },
    _minRowIndex: function (ds) {
        return 0;
    },
    _maxRowIndex: function (ds) {
        return ds.rowCount();
    }
});
var CellStyleManager = defineClass("CellStyleManager", EventAware, {
    init: function (grid) {
        this._super();
        this._styles = new CellStyleCollection();
        this._styleMap = grid.createCellStyleMap();
        this._updateLock = 0;
    },
    dataSource: null,
    setDataSource: function (value) {
        if (value !== this._dataSource) {
            if (this._dataSource) {
                this._dataSource.removeTag(this._styleMap);
            }
            this._dataSource = value;
            if (value) {
                value.addTag(this._styleMap);
            }
            this._styleChanged();
        }
    },
    isEmpty: function () {
        return this._styleMap.isEmpty();
    },
    beginUpdate: function () {
        this._updateLock++;
    },
    endUpdate: function (refreshViews) {
        refreshViews = arguments.length > 0 ? refreshViews : true;
        this._updateLock--;
        if (this._updateLock == 0 && refreshViews) {
            this._styleChanged();
        }
    },
    registerStyle: function (styleId, style, overwrite) {
        if (styleId && _isObject(style)) {
            var r = false;
            if (overwrite) {
                r = this._styles.set(styleId, style);
            } else {
                r = this._styles.add(styleId, style);
            }
            r && this._styleChanged();
        }
    },
    registerStyles: function (styles, overwrite) {
        if (_isArray(styles)) {
            var r = false;
            for (var i = 0, cnt = styles.length; i < cnt; i++) {
                var s = styles[i];
                if (s && s.id) {
                    if (overwrite) {
                        r = this._styles.set(s.id, s) || r;
                    } else {
                        r = this._styles.add(s.id, s) || r;
                    }
                }
            }
            r && this._styleChanged();
        }
    },
    unregisterStyles: function (styleIds) {
        var r = false;
        if (_isArray(ids)) {
            for (var i = styleIds.length; i--;) {
                r = this._styles.set(styleIds[i], undefined) || r;
            }
        } else if (styleIds) {
            r = this._styles.set(styleIds, undefined);
        }
        r && this._styleChanged();
    },
    unregisterAll: function () {
        if (this._styles.clear()) {
            this._styleChanged();
        }
    },
    getStyle: function (styleId) {
        return this._styles.get(styleId);
    },
    hasStyle: function (styleId) {
        return this._styles.exists(styleId);
    },
    getStyleAt: function (row, field) {
        if (this._dataSource) {
            var fld = this._dataSource.getFieldIndexEx(field);
            return this._styleMap.getCellStyle(row, fld);
        }
        return undefined;
    },
    setStyleAt: function (row, field, styleId, fireEvent) {
        if (this._dataSource) {
            var style = styleId ? this._styles.get(styleId) : null;
            this.$_setStyle(this._dataSource, row, field, style);
            if (fireEvent) {
                this._cellChanged(row, field);
            }
        }
    },
    setStylesAt: function (rows, fields, styleId) {
        var ds = this._dataSource;
        if (ds) {
            var rs = _asArray(rows);
            var flds = _asArray(fields);
            var style = styleId ? this._styles.get(styleId) : null;
            var r, cnt, f, cnt2;
            if (rs && flds) {
                cnt2 = flds.length;
                for (r = 0, cnt = rs.length; r < cnt; r++) {
                    for (f = 0; f < cnt2; f++) {
                        this.$_setStyle(ds, rs[r], flds[f], style);
                    }
                }
            } else if (rs) {
                for (r = 0, cnt = rs.length; r < cnt; r++) {
                    this.$_setStyle(ds, rs[r], fields, style);
                }
            } else if (flds) {
                for (f = 0, cnt = flds.length; f < cnt; f++) {
                    this.$_setStyle(ds, rows, flds[f], style);
                }
            } else {
                this.$_setStyle(ds, rs, fields, style);
            }
            this._cellChanged(rows, fields);
        }
    },
    loadStyleRows: function (rows, fieldMap, startRow, count) {
        if (this._styleMap.loadStyleRows(this._styles, rows, fieldMap, startRow, count)) {
            this._cellChanged(startRow, fieldMap);
        }
    },
    clear: function () {
        if (this._styleMap.clearCellStyles()) {
            this._cellChanged(-1);
        }
    },
    $_getStyleAt: function (row, field) {
        return this._styleMap.getCellStyle(row, field);
    },
    $_setStyle: function (ds, row, field, style) {
        var r = Math.max(-1, row); // TODO: -1이면 추가 중인 행에 적용한다.
        var f = ds.getFieldIndexEx(field);
        this._styleMap.setCellStyle(row, f, style);
    },
    _styleChanged: function () {
        if (this._updateLock == 0) {
            this.fireEvent(CellStyleManager.STYLE_CHANGED);
        }
    },
    _cellChanged: function (row, field) {
        if (this._updateLock == 0) {
            this.fireEvent(CellStyleManager.CELL_CHANGED, row, field);
        }
    }
});
CellStyleManager.STYLE_CHANGED = "onCellStyleManagerStyleChanged";
CellStyleManager.CELL_CHANGED = "onCellStyleManagerCellChanged";
var ColumnFilter = defineClass("ColumnFilter", EventAware, {
	init : function(expression) {
		this._super();
		this.setExpression(expression);
	},
	name: null,
    expression: null,
	text: null,
	description: null,
	active: false,
	visible: true,
	propertyChanged: function (prop, newValue) {
		this._changed();
	},
	toString: function () {
		return this._text || this._name;
	},
	_changed: function () {
		this.fireEvent(ColumnFilter.CHANGED);
	}
}, {
    CHANGED: "onColumnFilterChanged"
});
var ColumnFilterRun = defineClass("ColumnFilterRun", ColumnFilter, {
	init : function(expression) {
		this._super(expression);
	},
	prepare: function (runtime, dataSource) {
		runtime.setDataSource(dataSource);
	},
	select: function (runtime, item, field) {
		if (this._exprNode) {
			runtime.setData(item, field);
			return this._exprNode.evaluate(runtime);
		}
        return true;
	},
	setExpression: function (value) {
		if (value != this._expression) {
			this._expression = value;
            this._exprNode = value ? ExpressionParser.Default.parse(value, null) : null;
		}
	}
});
var ColumnFilterCollection = defineClass("ColumnFilterCollection", EventAware, {
	init : function() {
		this._super();
		this._items = [];
		this._names = {};
		this._updating = false;
	},
	count: function () {
		return this._items.length;
	},
	activeCount: function () {
		var i, cnt = 0;
		for (i = this._items.length; i--;) {
			if (this._items[i].active()) {
				cnt++;
			}
		}
		return cnt;
	},
	items: function () {
		return this._items.slice();
	},
	visible: function () {
		for (var i = this._items.length; i--;) {
			if (this._items[i].visible()) {
				return true;
			}
		}
		return false;
	},
	getItemAt: function (index) {
		if (index < 0 || index >= this._items.length) {
			if ($_debug) debugger;
			throw new Error("Invalid index: " + index);
		}
		return this._items[index];
	},
	getItem: function (filterName) {
		return this._names[filterName] || null;
	},
	getItemIndex: function (filterName) {
		for (var i = this._items.length - 1; i >= 0; i--) {
			if (this._items[i]._name == filterName) {
				return i;
			}
		}
		return -1;
	},
	getActiveItems: function (active) {
		var i, items = [];
		for (i = this._items.length - 1; i >= 0; i--) {
			if (this._items[i].active() == active) {
				items.push(this._items[i]);
			}
		}
		return items;
	},
	clear: function (fireEvent) {
		fireEvent = arguments.length > 0 ? fireEvent : true;
        var i, cnt = this._items.length;
		if (cnt > 0) {
			for (i = 0; i < cnt; i++) {
				this._items[i].removeListener(this);
			}
			this._items.length = 0;
			this._names = {};
			fireEvent && this._changed(null);
			return true;
		}
		return false;
	},
	add: function (filter) {
		var f = _cast(filter, ColumnFilter);
		if (f) {
			if (this._items.indexOf(f) < 0 && f.name()) {
				this.$_checkName(f.name);
                f = f.clone();
			}
		} else if (filter && filter.name) {
			this.$_checkName(filter.name);
			f = new ColumnFilter();
			f.assign(filter);
		}
		this._items.push(f);
		this._names[f.name] = f;
		f.addListener(this);
		this._changed(null);
	},
	addItems: function (filters, overwrite) {
		if (!_isArray(filters) && filters) {
			filters = [filters];
		}
		if (filters && filters.length > 0) {
			var i, filter, idx,
                cnt = 0;
			for (i = 0, len = filters.length; i < len; i++) {
				filter = _cast(filters[i], ColumnFilter);
				if (filter) {
					if (this._items.indexOf(filters[i]) < 0 && filter.name()) {
						if (!overwrite) {
							this.$_checkName(filter.name());
						}
                        filter = filter.clone();
					}
				} else if (filters[i] && filters[i].name) {
					if (!overwrite) {
						this.$_checkName(filters[i].name);
					}
					filter = new ColumnFilter();
					filter.assign(filters[i]);
				}
                if (filter) {
                    idx = this.getItemIndex(filter.name());
                    if (idx >= 0) {
                        if (this._items[idx]) {
                            this._items[idx].removeListener(this);
                        }
                        this._items[idx] = filter;
                    } else {
                        this._items.push(filter);
                    }
                    filter.addListener(this);
                    this._names[filter.name()] = filter;
                    cnt++;
                }
			}
			if (cnt > 0) {
				this._changed(null);
			}
		}
	},
	remove: function (filterName) {
		if (!filterName) {
			return false;
		}
        var i, filter;
		for (i = this._items.length - 1; i >= 0; i--) {
			filter = this._items[i];
			if (filter.name() == filterName) {
				this._items.splice(i, 1);
				delete this._names[filter.name()];
				filter.removeListener(this);
				this._changed(null);
				return true;
			}
		}
		return false;
	},
	removeItems: function (filterNames) {
		if (!_isArray(filterNames) || filterNames.length < 1) {
			return;
		}
		var i, j, filter,
			cnt = 0;
		for (i = filterNames.length - 1; i >= 0; i--) {
			j = this.getItemIndex(filterNames[i]);
			if (j >= 0) {
				filter = this._items[j];
				this._items.splice(j, 1);
				delete this._names[filter.name()];
				filter.removeListener(this);
				cnt++;
			}				
		}
		if (cnt > 0) {
			this._changed(null);
		}
	},
	activateItems: function (filterNames, active) {
		if (!_isArray(filterNames) || filterNames.length < 1) {
			return;
		}
		var i, filter,
			cnt = 0;
		this._updating = true;
		try {
			for (i = filterNames.length - 1; i >= 0; i--) {
				filter = this._names[filterNames[i]];
				if (filter && filter.active() != active) {
					filter.setActive(active);
					cnt++;
				}				
			}
			if (cnt > 0) {
				this._changed(null, true);
			}
		} finally {
			this._updating = false;
		}
	},
	activateAll: function (active) {
		var i, filter,
			cnt = this._items.length,
			dirty = false;
		this._updating = true;
		try {
			for (i = 0; i < cnt; i++) {
				filter = this._items[i];
				if (filter.active() != active) {
					filter.setActive(active);
					dirty = true;
				}
			}
			if (dirty) {
				this._changed(null, true);
			}
		} finally {
			this._updating = false;
		}
	},
	toggleItems: function (filterNames) {
		var i, filter, cnt;
		if (!_isArray(filterNames) || filterNames.length < 1) {
			return;
		}
		this._updating = true;
		try {
			cnt = 0;
			for (i = filterNames.length - 1; i >= 0; i--) {
				filter = this._names[filterNames[i]];
				if (filter) {
					filter.setActive(!filter.active());
					cnt++;
				}
			}
			if (cnt > 0) {
				this._changed(null, true);
			}
		} finally {
			this._updating = false;				
		}
	},
	toggleAll: function () {
		var i, filter,
			cnt = this._items.length,
			dirty = false;
		this._updating = true;
		try {
			for (i = 0; i < cnt; i++) {
				filter = this._items[i];
				filter.setActive(!filter.active());
				dirty = true;
			}
			if (dirty) {
				this._changed(null, true);
			}
		} finally {
			this._updating = false;
		}
	},
	assign: function (source) {
		if (source === this) {
			return;
		}
		var i, cnt, filter,
			src = _asArray(source),
			cleared = this.clear(false);
		if (source) {
			if (!src) {
				src = [source];
			}
			for (i = 0, cnt = src.length; i < cnt; i++) {
				source = src[i];
				filter = null;
				if (source instanceof ColumnFilter) {
					if (this._items.indexOf(source) < 0 && source.name()) {
						this.$_checkName(source.name());
						filter = source.clone();
					}
				} else 	if (source && source.name) {
					this.$_checkName(source.name);
					filter = new ColumnFilter();
					filter.assign(source);
				}
				if (filter) {
					this._items.push(filter);
					this._names[filter.name()] = filter;
					filter.addListener(this);
				}
			}
		}
		if (cleared || this.count() > 0) {
			this._changed(null);
		}
	},
	$_checkName: function (name) {
		if (this._names.hasOwnProperty(name)) {
            throw new Error(GridLocale._default.columnFilterExists + name);
		}
	},
	_changed: function (filter, force) {
		if (!this._updating || force) {
			this.fireEvent(ColumnFilter.CHANGED, filter);
		}
	},
	onColumnFilterChanged: function (filter) {
		this._changed(filter);
	}
});
var ColumnFilterSelector = defineClass("ColumnFilterSelector", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._element) {
					return;
				}
				p = p.parentNode;
			}
			this.hide();
		}.bind(this);
	},
	minWidth: 100,
	closeWhenClick: false,
	column: function () {
		return this._column;
	},
	opened: function () {
		return this._element && this._container.contains(this._element);
	},
	show: function (columnView, options) {
		this.hide();
		if (!columnView) return;
		this._showing = true;
		try {
			options = options || columnView.grid().operateOptions().filterSelector();
			this._closeWhenClick = options.closeWhenClick();
			this.$_show(columnView, options);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (columnView, options) {
		var elt = this._element = this._initControl();
		if (!elt || elt.parentNode) {
			return;
		}
		var p, cr, cr2, cr3, cr4, hasItems, hasAuto, y, nodes, cnt, node,
			css = elt.style,
            eltAll = this._eltAll,
            eltItems = this._eltItems,
            eltAuto = this._eltAuto,
            autoView = this._autoView,
			grid = columnView.grid(),
            col = this._column = columnView.index().column,
			r = columnView.boundsByContainer(),
			w = grid.width() - 10, // minus paddings + border
			h = grid.height() - 10;
		Dom.setStyles(elt, {
			position: "absolute",
			float: "none",
			overflow: "hidden",
			zIndex: 3000,
			background: "rgb(233, 233, 233)",
			border: "1px solid rgb(200, 200, 200)",
			boxShadow: "rgba(0, 0, 0, 0.8) 1px 2px 5px",
			fontFamily: "Tahoma",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			fontSize: "10pt",
			padding: "4px"
		});
		this.$_clearItems();
		hasItems = this.$_buildItems(col);
		hasAuto = this.$_buildAuto(grid, hasItems);
		p = parseFloat(options.getMinWidth(w));
		if (!isNaN(p) && p > 0) {
			css.minWidth = p + "px";
		}
		p = parseFloat(options.getMaxWidth(w));
		if (!isNaN(p) && p > 0) {
			css.maxWidth = Math.min(p, w) + "px";
		} else {
            css.maxWidth = w + "px";
        }
		p = parseFloat(options.getMinHeight(h));
		if (!isNaN(p) && p > 0) {
			css.minHeight = p + "px";
		}
		p = parseFloat(options.getMaxHeight(h));
		if (!isNaN(p) && p > 0) {
			css.maxHeight = Math.min(p, h) + "px";
		} else {
            css.maxHeight = h + "px";
        }
		eltAll.style.visibility = hasItems ? "" : "collapse";
		eltAll.style.height = hasItems ? "" : "0px";
		this._container.appendChild(elt);
		if (hasAuto) {
			nodes = autoView._eltItems.childNodes;
			cnt = Math.max(1, Math.min(this._column.autoFilter().displayCount() + 1, nodes.length))
			node = nodes[cnt - 1];
			autoView._eltItems.style.height = (node.offsetHeight * cnt + 3) + 'px';
		}
		eltAuto.style.display = hasAuto ? "block" : "none";
		cr = elt.getBoundingClientRect();
		y = cr.height - eltAll.offsetHeight - 8/* paddings */;
        if (hasAuto) {
            y -= eltAuto.getBoundingClientRect().height;
        }
		eltItems.style.height = y + "px";
		if (eltItems.offsetWidth > eltItems.clientWidth) {
			css.width = (cr.width + eltItems.offsetWidth - eltItems.clientWidth) + "px"; // for scroll bar
		}
		p = (r.right() - cr.width);
		css.left = (this._x = Math.max(0, p))  + "px";
		y = r.bottom();
		h += 10; // padding + border 추가
		if (y + cr.height >= h) {
			y = Math.max(0, h - cr.height - 3); // TODO 3을 빼주지 않으면 아래로 넘친다. Why?
		}
		css.top = (this._y = y) + "px";
		if (hasAuto) {
			cr2 = eltAll.getBoundingClientRect();
			cr3 = eltItems.getBoundingClientRect();
			cr4 = eltAuto.getBoundingClientRect();
			if (cr2.height + cr3.height + cr4.height > cr.height) {
				h = (cr2.height + cr3.height + cr4.height) - cr.height +
					autoView._eltFinder.getBoundingClientRect().height +
					autoView._hr.getBoundingClientRect().height;
				autoView._eltItems.style.height = Math.max(0, (node.offsetHeight * cnt + 2 - h - 2)) + 'px';
			}
            autoView._findInput.style.minWidth
                = autoView._findInput.style.maxWidth
                = Math.max(0, cr2.width - autoView._findButton.offsetWidth - 4) + 'px';
		}
		if (!hasItems && !hasAuto) {
			this.hide();
		}
		setTimeout(function () {
			_win.addEventListener("mousedown", this._globalMouseHandler);
		}.bind(this), 0);
	},
	hide: function () {
		var elt = this._element;
		if (elt && elt.parentNode) {
			_win.removeEventListener("mousedown", this._globalMouseHandler);
			this._container.removeChild(elt);
		}
	},
	_initControl: function () {
		var div, check, label, hr,
			container = _doc.createElement("div");
		container.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		div = this._eltAll = _doc.createElement("div");
		div.style.float = "none";
		div.style.backgroundColor = "#333";
		div.style.color = "#fff";
		check = _doc.createElement("input");
		check.id = "$columnFilter_all_" + ColumnFilterSelector.$_checkId++;
		check.type = "checkbox";
		check.tabIndex = -1;
		check.onclick = function (e) {
			this._column.activateAllFilters(e.target.checked);
			this.$_refreshItems();
		}.bind(this);
		div.appendChild(check);
		label = _doc.createElement("label");
		label.htmlFor = check.id;
		label.innerHTML = "All";
		div.appendChild(label);
		hr = _doc.createElement("hr");
		hr.style.height = "1px";
		hr.style.border = "0px";
		hr.style.margin = "2px";
		hr.style.color = "#777";
		hr.style.backgroundColor = "#777";
		div.appendChild(hr);
		container.appendChild(div);
		div = this._eltItems = _doc.createElement("div");
		div.style.float = "none";
		div.style.overflow = "auto";
		container.appendChild(div);
		this._autoView = new ColumnAutoFilterView(this._container);
		div = this._eltAuto = this._autoView._element;
		div.style.float = "none";
		div.style.overflow = "hidden";
        div.style.marginTop = '0px';
		container.appendChild(div);
		return container;
	},
	$_clearItems: function () {
		var elt = this._eltItems;
		while (elt.lastChild) {
			elt.removeChild(elt.lastChild);
		}
	},
	$_buildItems: function (column) {
		var i, cnt, filter, div, check, label,
			filters = column.filters(),
			visible = false,
			self = this;
		for (i = 0, cnt = filters.length; i < cnt; i++) {
			filter = filters[i];
			if (filter.visible()) {
				div = _doc.createElement("div");
				div.style.float = "none";
				div.style.whiteSpace = "nowrap";
				Dom.disableSelection(div);
				this._eltItems.appendChild(div);
				div.onmouseover = function (e) {
					var div = this._currDiv = e.currentTarget;
					div.style.textDecoration = "underline";
				};
				div.onmouseout = function (e) {
					var div = this._currDiv = e.currentTarget;
					div.style.textDecoration = "none";
				};
				check = _doc.createElement("input");
				check.id = "$columnFilter_item_" + ColumnFilterSelector.$_checkId++;
				check.type = "checkbox";
				check.tabIndex = -1;
				check.checked = filter.active();
				check.filter = filter;
				check.onclick = function (e) {
					var check = e.target;
					var filter = check.filter;
					filter.setActive(check.checked);
					self._closeWhenClick && self.hide();
				};
				div.check = check;
				div.appendChild(check);
				label = _doc.createElement("label");
				label.htmlFor = check.id;
				label.innerHTML = filter.toString();
                label.title = filter.description() || filter.toString();
				div.appendChild(label);
				visible = true;
			}
		}
		return visible;
	},
	$_buildAuto: function (grid, hasFilter) {
		var filter = this._column.autoFilter(),
			autoView = this._autoView;
		if (filter.active()) {
			autoView.setFilter(filter);
			autoView.measure(grid, 100, 100, hasFilter);
			return true;
		}
	},
	$_refreshItems: function () {
		var i, cnt, child,
			children = this._eltItems.children;
		for (i = 0, cnt = children.length; i < cnt; i++) {
			child = children[i];
			child.check.checked = child.check.filter.active();
		}
	},
	_changed: function () {
		this.fireEvent(ColumnFilter.CHANGED);
	}
}, {
	$_checkId: 0
});
ColumnFilterSelector.CHANGED = "onColumnFilterSelectorChanged";
var RowFilter = defineClass("RowFilter", EventAware, {
	init: function (owner) {
		this._super();
		this._owner = owner;
	},
	active: true,
	expression: null,
	callback: null,
	setActive: function (value) {
		if (value != this._active) {
			this._active = value;
			this._changed();
		}
	},
	setExpression: function (value) {
		if (value != this._expression) {
			this._expression = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value, null) : null;
			this._changed();
		}
	},
	setCallback: function (value) {
		value = _asFunction(value);
		if (value != this._callback) {
			this._callback = value;
			this._changed();
		}
	},
	canFiltering: function () {
		return this._active && (this._callback || this._exprNode);
	},
	prepare: function (runtime) {
		this._runtime = runtime;
	},
	select: function (row) {
		if (this._callback) {
			return this._callback(row);
		} else if (this._exprNode) {
			return this._exprNode.evaluate(this._runtime.setRow(row));
		}
	},
    assignSimple: function (value) {
        if (_isString(value)) {
            this.setExpression(value);
        } else if (_isFunction(value)) {
            this.setCallback(value);
        } else if (value === null || value === undefined) {
            this.setExpression(null);
            this.setCallback(null);
        }
    },
	_changed: function () {
		this._owner && this._owner.rowFilterChanged(this);
	}
});
var ColumnAutoFilter = defineClass("ColumnAutoFilter", EventAware, {
	init: function (column) {
		this._super();
        this._column = column;
		this._valueType = column && column.valueType();
		this.$_clear();
        this._alone = true;
	},
    active: false,
    valueScale: 0,
    menu: null,
	maxCount: IntProp(100),
	ignoreCase: false,
	displayCase: TextCase.NORMAL,
	ascending: true,
	displayCount: IntProp(6),
    editSize: IntProp(18),
    showEllipsis: false,
	setValueScale: function (value) {
		value = _forceInt(value);
		if (value != this._valueScale) {
			this._valueScale = value;
			this.$_clear();
			this._changed();
		}
	},
    column: function () {
        return this._column;
    },
	valueType: function () {
		return this._valueType;
	},
	count: function () {
		return this._values.length;
	},
	checkedCount: function () {
		return this._active ? this._checkCount : 0;
	},
	allChecked: function () {
		var i,
			checks = this._checks,
			vals = this._values,
			cnt = vals.length;
		if (this._checkCount >= cnt) {
			for (i = 0; i < cnt; i++) {
				if (!checks[vals[i]]) return false;
			}
			return true;
		}
	},
    setAlone: function (value) {
        this._alone = value;
    },
    clearChecked: function () {
        if (this._checkCount > 0) {
            this._checks = {};
            this._checkCount = 0;
            this._changed();
        }
    },
	clear: function () {
		if (this._values && this._values.length || this._checkCount > 0) {
			this.$_clear();
			this._changed();
		}
	},
	loadItems: function (force, grid) {
		if (!force && this._values && this._values.length > 0) return;
		grid = grid || this._column.grid();
		if (!grid) {
            this._values = [];
            return;
        }
        var ds = grid.dataSource();
        if (!ds) {
            this._values = [];
            return;
        }
		var len, i, v1, v2, arr, scale,
			maxCount = this._maxCount <= 0 ? MAX_INT : this._maxCount,
			checks = this._checks,
			vt = this._valueType = this._column.valueType(),
			vals = ds.getDistinctValues(this._column.dataIndex());
        this._obj = vt == ValueType.OBJECT;
		if (vals && (len = vals.length) > 0) {
			if (this._ignoreCase && (this._column.valueType() == ValueType.TEXT)) {
				v1 = _toUpper(vals[0]);
				arr = [vals[0]];
				for (i = 1; i < len; i++) {
					v2 = _toUpper(vals[i]);
					if (v2 !== v1) {
						arr.push(vals[i]);
						v1 = v2;
					}
				}
				vals = arr;
			}
		}
        if (vals) {
			scale = this._valueScale =_forceInt(this._valueScale);
			if (scale || this._obj) {
				vals = this.$_scaleValues(vals, scale);
			}
            if (!this._ascending) {
                vals.reverse();
            }
			this._allValues = vals;
			if (this._checkCount > 0) {
				for (i = vals.length; i--;) {
					if (checks[vals[i]]) break;
				}
				maxCount = Math.max(maxCount, i + 1);
			}
            this._remainder = vals.length - maxCount;
            if (this._remainder > 0) {
                vals = vals.slice(0, maxCount);
            }
        } else {
            this._remainder = 0;
        }
		this._values = vals || [];
	},
	$_search: function (key, start, end, nodes) {
        var i, k,
            vals = this._values;
		switch (this._valueType) {
			case ValueType.TEXT:
				for (i = start; i < end; i++) {
					if (vals[i].indexOf(key) == 0) {
						return i;
					}
				}
				k = key.toUpperCase();
                for (i = start; i < end; i++) {
					if (vals[i].toUpperCase().indexOf(k) == 0) {
						return i;
					}
				}
                for (i = start; i < end; i++) {
					if (vals[i].indexOf(key) >= 0) {
						return i;
					}
				}
                for (i = start; i < end; i++) {
					if (vals[i].toUpperCase().indexOf(k) >= 0) {
						return i;
					}
				}
				break;
			case ValueType.NUMBER:
				k = Number(key);
                for (i = start; i < end; i++) {
					if (vals[i] == k) {
						return i;
					}
				}
            default:
				if (nodes) {
					end = Math.min(end, nodes.length);
					for (i = start; i < end; i++) {
						k = nodes[i + 1].childNodes[1].innerHTML;
						if (k && k.indexOf(key) == 0) {
							return i;
						}
					}
				} else {
					for (i = start; i < end; i++) {
						if (vals[i] == key) {
							return i;
						}
					}
				}
				break;
		}
        return -1;
	},
    search: function (key, start, nodes) {
        var i,
            cnt = this._values.length;
		if (cnt > 0) {
			start = start >= cnt ? 0 : start;
			i = this.$_search(key, start, cnt, nodes);
			if (i < 0) {
				i = this.$_search(key, 0, start, nodes);
			}
			return i;
		}
		return -1;
    },
	$_checkValue: function (v, checked) {
		if (checked && !this._checks[v]) {
			this._checks[v] = true;
			this._checkCount++;
			return true;
		} else if (!checked && this._checks[v]) {
			this._checks[v] = false;
			this._checkCount--;
			return true;
		}
	},
	$_check: function (index, checked) {
		if (index < this._values.length) {
			var v = this._values[index];
			return this.$_checkValue(v, checked);
		}
	},
	check: function (index, checked) {
		if (this._values) {
			if (this.$_check(index, checked)) {
				this._column.$_autoFilterChecked(index, this._values[index], checked);
				this.fireEvent(ColumnAutoFilter.CHECKED, index, this._values[index], checked);
			}
		}
	},
	checkList: function (list, checked) {
		var i, idx, arr, vals;
		if (this._values && _isArray(list)) {
			arr = [];
			vals = [];
			for (i = list.length; i--;) {
				idx = list[i];
				if (this.$_check(idx, checked)) {
					arr.push(idx);
					vals.push(this._values[idx]);
				}
			}
			if (arr.length > 0) {
				this._column.$_autoFilterChecked(arr, vals, checked);
				this.fireEvent(ColumnAutoFilter.LIST_CHECKED, arr, vals, checked);
			}
		}
	},
	checkValue: function (value, checked) {
		var v = this._valueScale ? this.$_scale(value) : value;
		if (this.$_checkValue(v, checked)) {
			this._column.$_autoFilterChecked(-1, value, checked);
			this.fireEvent(ColumnAutoFilter.CHECKED, -1, value, checked);
			return v;
		}
	},
	checkValues: function (values, checked) {
		if (_isArray(values)) {
			var i,
				list = [],
				vals = this._valueScale ? this.$_scaleValues(values, this._valueScale) : values;
			for (i = vals.length; i--;) {
				if (this.$_checkValue(vals[i], checked)) {
					list.push(vals[i]);
				}
			}
			if (list.length > 0) {
				this._column.$_autoFilterChecked(null, list, checked);
				this.fireEvent(ColumnAutoFilter.LIST_CHECKED, null, list, checked);
				return list;
			}
		}
	},
	checkAll: function (checked) {
		var i, vals = this._values;
		if (checked && vals) {
			for (i = vals.length; i--;) {
				this._checks[vals[i]] = true;
			}
			this._checkCount = vals.length;
			this._column.$_autoFilterChecked(-1, ColumnAutoFilter.ALL, checked);
			this.fireEvent(ColumnAutoFilter.ALL_CHECKED, true);
		} else if (!checked && this._checkCount > 0) {
			this._checks = {};
			this._checkCount = 0;
			this._column.$_autoFilterChecked(-1, ColumnAutoFilter.ALL, checked);
			this.fireEvent(ColumnAutoFilter.ALL_CHECKED, false);
		}
	},
    getValue: function (index) {
        return this._values[index];
    },
    addValue: function (value) {
        return this._values.push(value);
    },
    isChecked: function (value) {
        return this._all || this._checks[value];
    },
	isCheckedAt: function (index) {
		return this._all || this._checks[this._values[index]];
	},
	select: function (value) {
        if (this._all) {
            return true;
        }
		if (this._checkCount <= 0) {
            return this._alone;
        }
        (this._valueScale || this._obj) && (value = ColumnAutoFilter[this._valueType](this._valueScale, value, this._column));
		return this._checks[value];
	},
	assignSimple: function (value) {
		if (typeof value === 'boolean') {
			this.setActive(value);
		}
	},
    propertyChanged: function () {
        this._changed();
    },
    _changed: function () {
        this._column && this._column.$_autoFilterChanged(this);
    },
	$_clear: function () {
		this._values = [];
		this._checks = {};
		this._checkCount = 0;
		this._remainder = 0;
	},
    $_scaleValues: function (values, scale) {
		var v,
            col = this._column,
			vt = col.valueType(),
			date = vt == ValueType.DATETIME,
			scaler = ColumnAutoFilter[vt];
			prev = scaler(scale, values[0], col),
			vals = [prev],
			cnt = values.length,
			i = 1;
        if (!_defined(prev)) {
            while (i < cnt) {
                v = scaler(scale, values[i++], col);
                if (_defined(v)) {
                    vals.push(v);
                    prev = v;
                    break;
                }
            }
        }
		while (i < cnt) {
			v = scaler(scale, values[i++], col);
			if (date && v.getTime() != prev.getTime() || !date && v != prev) {
				vals.push(v);
				prev = v;
			}
		}
		return vals;
    },
	$_scale: function (value) {
		var scaler = ColumnAutoFilter[this._column.valueType()];
		return scaler(this._valueScale, value, this._column);
	}
}, {
	NULL: {},
	ALL: {},
	text: function (scale, value) {
		if (value) {
			return scale > 0 ? value.substr(0, scale) : value.substr(scale, -scale);
		}
	},
	number: function (scale, value) {
		return _toFixed(value, scale);
	},
	datetime: function (scale, value) {
		if (value instanceof Date) {
			value = new Date(value);
			switch (scale) {
				case DateTimeScale.YEAR:
					value.setMonth(0);
				case DateTimeScale.MONTH:
					value.setDate(1);
				case DateTimeScale.DATE:
					value.setHours(0);
				case DateTimeScale.HOUR:
					value.setMinutes(0);
				case DateTimeScale.MINUTE:
					value.setSeconds(0);
				case DateTimeScale.SECOND:
					value.setMilliseconds(0);
                    break;
                case DateTimeScale.WEEK:
                    value.setMilliseconds(0);
                    value.setSeconds(0);
                    value.setMinutes(0);
                    value.setHours(0);
                    value.setDate(value.getDate() - value.getDay());
                    break;
                case DateTimeScale.QUARTER:
                    value.setMilliseconds(0);
                    value.setSeconds(0);
                    value.setMinutes(0);
                    value.setHours(0);
                    value.setDate(1);
                    value.setMonth(_int(value.getMonth() / 3) * 3);
                    break;
                case DateTimeScale.HALF:
                    value.setMilliseconds(0);
                    value.setSeconds(0);
                    value.setMinutes(0);
                    value.setHours(0);
                    value.setDate(1);
                    value.setMonth(_int(value.getMonth() / 6) * 6);
                    break;
			}
		}
		return value;
	},
	boolean: function (scale, value) {
		return value;
	},
	object: function (scale, obj, col) {
        var v = col._keyFn ? col._keyFn(col.$_field, obj) :
            col._keyPath ? DataPath.extractJson(obj, col._keyPath, true) : obj;
        return v;
	},
    ALL_CHECKED: "onColumnAutoFilterAllChecked",
    LIST_CHECKED: "ononColumnAutoFilterListChecked",
	CHECKED: "ononColumnAutoFilterChecked"
});
var ColumnAutoFilterView = defineClass("ColumnAutoFilterView", EventAware, {
	init: function (container) {
		this._super();
		this._container = container; // grid container
		this._dom = new Dom(this._element = this.$_createElement());
		this._filter = null;
        this._selIndex = -1;
		this._checkHandler = function (ev) {
			var check = ev.target;
			this._filter.check(check.$_index, check.checked);
			this._eltAll.check.checked = this._filter.allChecked();
		}.bind(this);
		this._mouseoverHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			div.style.background = "rgba(0, 0, 0, 0.05)";
			div.style.textDecoration = "underline";
		}.bind(this);
		this.mouseoutHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
            div.style.background = null;
			div.style.textDecoration = "none";
		}.bind(this);
	},
	showAll: true,
	displayCount: 6,
	maxCount: 100,
	setFilter: function (filter) {
		if (filter !== this._filter) {
			this._filter = filter;
		}
	},
	measure: function (grid, hintWidth, hintHeight, hasFilter) {
		var filter = this._filter,
			elt = this._eltItems,
			sz = { width: 0, height: 0 };
		this._hr.style.display = hasFilter ? "" : "none";
		filter.loadItems(true, grid);
        this._findInput.size = Math.max(2, filter.editSize());
		this.$_buildItems(filter);
		sz.width = Math.max(hintWidth, 200);
		sz.height = Math.max(hintWidth, 500);
		return sz;
	},
	layout: function (bounds) {
        debugger;
	},
	$_createElement: function () {
        var elt = document.createElement("div"),
            hr = this.$_createHr();
			finder = this.$_createFinder(),
			items = this._eltItems = document.createElement("div");
        elt.appendChild(hr);
		elt.appendChild(finder);
		finder.style.marginBottom = "4px";
        finder.style.width = "100%";
		elt.appendChild(items);
		items.style.overflow = "auto";
		items.style.background = '#fff';
		items.style.width = "100%";
        items.style.border = '1px solid #aaa';
		items.style.marginBottom = '2px';
		return elt;
	},
    $_createHr: function () {
        var hr = this._hr = document.createElement("hr");
        hr.style.height = "1px";
        hr.style.border = "0px";
		hr.style.marginTop = "1px";
        hr.style.marginBottom = "5px";
        hr.style.color = "#777";
        hr.style.backgroundColor = "#aaa";
        return hr;
    },
    $_search: function () {
        var i, label, sel,
            k = _trim(this._findInput.value);
        if (k) {
            if (sel = this._selected) {
                sel.childNodes[1].style.color = '#222';
            }
            i = this._filter.search(k, this._selIndex + 1, this._eltItems.childNodes);
            if (i >= 0) {
                sel = this._selected = this._eltItems.childNodes[i + 1];
                label = sel.childNodes[1];
                    this._eltItems.scrollTop = sel.offsetTop - this._eltItems.clientHeight;
                label.style.color = '#e00';
            } else {
                this._selected = null;
            }
            this._selIndex = i;
        }
    },
	$_createFinder: function () {
		var filter = this._filter,
			elt = this._eltFinder = document.createElement("div"),
			editor = this._findInput = document.createElement('input'),
			button = this._findButton = document.createElement('img');
		elt.style.textAlign = "right";
		Dom.setStyles(editor, {
			marginRight: '4px',
			outline: '0px solid transparent',
			fontFamily: 'Tahoma',
			fontSize: '10pt'
		}, {
			type: 'search',
			placeholder: 'Search',
			size: 18
		});
        editor.onkeydown = function (ev) {
            ev.stopImmediatePropagation && ev.stopImmediatePropagation();
            if (ev.keyCode == 13) {
                this.$_search();
            }
        }.bind(this);
		elt.appendChild(editor);
        button.src = ColumnAutoFilterView.$_BTNIMG;
        button.alt = 'Search';
        button.title = 'Search';
        button.style.verticalAlign = 'middle';
        button.style.marginBottom = '2px';
        button.onclick = function (ev) {
            this.$_search();
        }.bind(this);
		elt.appendChild(button);
		return elt;
	},
    $_writer: function (f) {
        var writer, s,
			loc = Locale._default,
            vt = f.valueType(),
            scale = f.valueScale();
        if (vt == ValueType.DATETIME) {
            if (scale) {
                writer = DateTimeWriter.Writers[scale]
            }
            if (!writer) {
                s = f._column.styles().datetimeFormat();
                writer = s ? new DateTimeWriter(s) : DateTimeWriter.Default;
            }
            return function (d) {
                if (!_defined(d)) return '';
                var s = writer.getText(d);
                switch (scale) {
                    case DateTimeScale.QUARTER:
                        s += ' (' + loc.quarters[_int(d.getMonth() / 3)] + ')';
                        break;
                    case DateTimeScale.HALF:
                        s += ' (' + loc.halfs[d.getMonth() > 5 ? 1 : 0] + ')';
                        break;
                }
                return s;
            };
        } else if (vt == ValueType.BOOLEAN) {
            s = f._column.styles().booleanFormat();
            if (s) {
                writer = BooleanFormatter.getFormatter(s);
                return function (b) {
                    return writer.formatValue(b);
                };
            }
        }/* else if (vt == ValueType.OBJECT) {
            col = f._column;
            return function (obj) {
                v = col._keyFn ? col._keyFn(col.$_field, obj) :
                    col._keyPath ? DataPath.extractJson(obj, col._keyPath, true) : obj;
                return v;
            };
        }*/
    },
    $_toCase: function (f) {
        var textCase = f.valueType() == ValueType.TEXT && f.displayCase();
        return textCase == TextCase.UPPER ? _toUpper : textCase == TextCase.LOWER ? _toLower : null;
    },
    $_ellipsis: function (f) {
        return (f._showEllipsis && f._valueScale > 0 && f.valueType() == ValueType.TEXT) ? ' ...' : '';
    },
	$_buildItems: function (filter) {
		var i, v, checked, eltItem, eltCheck, eltValue, css,
            writer = this.$_writer(filter),
			toCase = this.$_toCase(filter),
            ellipsis = this.$_ellipsis(filter),
			elt = this._eltItems;
		if (this._showAll) {
			eltItem = this._eltAll = this.$_buildItem(-1, '(Select All)', false, '');
			eltItem.check.onclick = function (ev) {
				var checked = !!ev.target.checked;
				this._filter.checkAll(checked);
				this.$_allChecked(checked);
			}.bind(this);
            css = eltItem.childNodes[1].style;
            css.color = '#000';
            elt.appendChild(eltItem);
		}
		for (i = 0; i < filter.count(); i++) {
			v = filter.getValue(i);
			checked = filter.isChecked(v);
			if (toCase) v = toCase(v);
			eltItem = this.$_buildItem(i, v, checked, ellipsis, writer);
			elt.appendChild(eltItem);
		}
        if (filter._remainder > 0) {
            eltItem = this._eltMore = this.$_buildItem(-1, '(More...)', false, '');
            eltItem.check.style.visibility = "hidden";
            eltItem.check.onclick = undefined;
            eltItem.childNodes[1].onclick = function (ev) {
                this.$_buildMoreItems(filter, elt, eltItem);
            }.bind(this);
            css = eltItem.childNodes[1].style;
            css.color = '#000';
            elt.appendChild(eltItem);
        }
		return elt;
	},
    $_buildMoreItems: function (filter, eltItems, eltMore) {
        var i, v, checked, elt,
            writer = this.$_writer(filter),
            toCase = this.$_toCase(filter),
            ellipsis = this.$_ellipsis(filter),
            allVals = filter._allValues,
            count = filter.count(),
            cnt = Math.min(filter.maxCount(), allVals.length - count);
        for (i = 0; i < cnt; i++) {
			v = allVals[i + count];
			checked = filter.isChecked(v);
			filter.addValue(v);
            if (toCase) v = toCase(v);
            elt = this.$_buildItem(i + count, v, checked, ellipsis, writer);
            eltItems.insertBefore(elt, eltMore);
        }
        if (filter.count() >= allVals.length) {
            eltItems.removeChild(eltMore);
        }
    },
	$_buildItem: function (index, value, checked, ellipsis, writer) {
		var eltItem, eltCheck, eltValue;
		eltItem = document.createElement("div");
		eltItem.style.whiteSpace = "nowrap";
		Dom.disableSelection(eltItem);
		eltItem.onmouseover = this._mouseoverHandler;
		eltItem.onmouseout = this.mouseoutHandler;
		eltCheck = document.createElement("input");
		eltCheck.id = "$autoFilter_item_" + ColumnFilterSelector.$_checkId++;
		eltCheck.setAttribute('type', 'checkbox')
		eltCheck.$_index = index;
		eltCheck.onclick = this._checkHandler;
		eltCheck.checked = checked;
		eltItem.check = eltCheck;
		eltItem.appendChild(eltCheck);
		eltValue = document.createElement("label");
		eltValue.htmlFor = eltCheck.id;
		eltValue.innerHTML = writer ? writer(value) : !_defined(value) ? '' : value + ellipsis;
		eltValue.title = value;
        eltValue.style.color = '#222';
		eltItem.appendChild(eltValue);
		return eltItem;
	},
	$_allChecked: function (checked) {
		var all = this._eltAll;
		Dom.visitChildren(this._eltItems, function (item, child) {
			if (child !== all) {
				child.check.checked = checked;
			}
		});
	}
}, {
    $_BTNIMG: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAABTElEQVR42o2Rv0rDYBTF0wdw9QEU6eSgj5DQFpMWmn9QWihUQgLOztEurukThExFH6BuQuOa3UERF6FZ4qCg2DTWc0A/2mKlF+7w8d0f55x7JQlVrVa3VVX1dF2/a7fbeafT+TQM46ler1/IsrwrrdYPcILhZ9/3iyiKiuFwOBsMBjPP84pms3ldqVT2liBN01wCYRgWWZbNFztJktxxHIJX5XJ5S0C0RIVV4LfH4/EUVidHKAExAy2tg9itVuut0WicCoihmeE/qNvtfsDiuYC4pSAI1iqlaVrYtv2C7McC4lq5JYb+C+r3+7lpmg+KouwIiA9Ij1zXncVxPF1UIACVOdw84iz7S2vnHQBeoicI/YoM77SE4XsC6C/83dZqtUOMlwTIO3Ct3BIsn6F7dEEFAjgNwRuMHEibFBUIWJZVAI6lDatEBQJwMvoGdjwqony8pFcAAAAASUVORK5CYII="
});
var ToastOptions = defineClass("ToastOptions", null, {
	init : function (options) {
		this._super();
		this._styles = {};
		options && this.assign(options);
	},
	visible: true,
	message: null,
    resourceId: null,
	styles: null,
	styleName: null,
	duration: 0,
	setStyles: function (value) {
		if (_isObject(value)) {
			this._styles = _extend(null, value)
		} else {
			this._styles = {};
		}
	},
    getMessage: function () {
        return this._message || GridLocale._default[this.resourceId()];
    },
	assign: function (source) {
		if (_isString(source)) {
			this._message = source;
            this._visible = true;
		} else if (_isBoolean(source)) {
			this._visible = source;
		} else {
			this._super(source);	
		}
	}
});
var ToastView = defineClass("ToastView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._span = null;
		this._element = this._createElement();
		this._showing = false;
		this._timer = undefined;
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	show: function (options) {
		this._showing = true;
		try {
			this.$_show(options);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (options) {
        var s, elt, css, st, p, container, span, cr, w, h, r;
		this.$_stopTimer();
		s = options.getMessage();
		if (!s) {
			return;
		}
		elt = this._element;
		if (!elt) {
			return;
		}
		css = elt.style;
		if (options.styleName()) {
			elt.className = options.styleName();
		} else {
			_fillToCss("rgba(0, 0, 55, 0.8)", css);
			css.borderRadius = "7px";
			css.color = "rgb(255, 255, 255)";
			css.border = "1px solid rgb(200, 200, 200)";
			css.boxShadow = "rgb(0, 0, 0, 0.8) 1px 2px 5px";
			css.fontSize = "16pt";
			css.padding = "8px 16px 8px 16px";
		}
		st = options.styles();
		if (st) {
			for (p in st) {
				css[p] = st[p];
			}
			st.hasOwnProperty('background') && _fillToCss(st['background'], css);
		}
		css.position = "absolute";
		css.overflow = "hidden";
		css.zIndex = 3000;
		container = this._container._container;
		span = this._span;
		span.innerHTML = s;
		container.appendChild(elt);
		cr = elt.getBoundingClientRect2();
		w = cr.width + 10;
		h = cr.height + 10;
		r = new Rectangle();
		r.width = this._container.width();
		r.height = this._container.height();
		css.left = ((r.width - w) / 2) + "px";
		css.top =  ((r.height - h) * 3 / 8) + "px";
		if (options.duration() > 0) {
			this.$_startTimer(options.duration());
		}
		/*
		_win.onmousedown = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._element)
					return;
				p = p.parentNode;
			}
			this.hide();
		}.bind(this);
		*/
	},
	hide: function () {
        var elt, container;
		this.$_stopTimer();
		elt = this._element;
		if (!elt || !elt.parentNode) {
			return;
		}
		container = this._container._container;
		container.removeChild(elt);
	},
	_createElement: function () {
		var element = _doc.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		this._disableSelection(element);
		this._span = _doc.createElement("span");
		element.appendChild(this._span);
		this._disableSelection(this._span);
		return element;
	},
	_disableSelection: function (element) {
        if (typeof element.onselectstart !== 'undefined') {
            element.onselectstart = function() { return false; };
        } else if (typeof element.style.MozUserSelect !== 'undefined') {
            element.style.MozUserSelect = 'none';
        } else {
            element.onmousedown = function() { return false; };
        }
    },
	$_startTimer: function (duration) {
		this.$_stopTimer();
		this._timer = setTimeout(function () {
			this.hide();
		}.bind(this), duration)
	},
	$_stopTimer: function () {
		if (this._timer) {
			clearTimeout(this._timer);
			this._timer = undefined;
		}
	}
}, {
	$_labelId: 0
});
var ToastManager = defineClass("ToastManager", null, {
	init: function (grid) {
		this._super();
		this._container = grid.container();
		this._toast = null;
		this._active = false;
	},
	visible: function () {
		return this._active;
	},
	show: function (options, force, action) {
		if (!this._active || force) {
			this.close();
			options = options instanceof ToastOptions ? options : options ? new ToastOptions(options) : null;
			if (options && options.visible() && options.getMessage()) {
				if (!this._toast) {
					this._toast = new ToastView(this._container);
				}
				this._toast.show(options);
				this._active = true;
				if (action) {
					setTimeout(function () {
						try {
							action();
						} finally {
							this.close();
						}
					}.bind(this), 0);
				}
			} else {
				action && action();
			}
		} else if (action) {
			action();
		}
	},
	close: function () {
		if (this._active) {
			this._toast && this._toast.hide();
			this._active = false;
			return true;
		}
		return false;
	}
});
var ValidationLevel = _enum('ValidationLevel', {
	ERROR: "error",
	WARNING: "warning",
	INFO: "info",
	IGNORE: "ignore",
	$_levels: {
		error: 1,
		warning: 2,
		info: 3,
		ignore: 4
	},
	compare: function (level1, level2) {
		return ValidationLevel.$_levels[level1] - ValidationLevel.$_levels[level2];
	}
});
var ValidationMode = _enum('ValidationMode', {
	ALWAYS: "always", 
	UPDATE: "update",
	INSERT: "insert"
});
var ValidationError = function (level, message, column) {
	this.name = 'DataLudi.ValidationError';
	this.level = level;
	this.message = message;
	this.column = column;
};
ValidationError.prototype = new AbortError();
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.toString = function () {
	return "Validation failed [" + _toUpper(this.level) + "]: " + this.message;
};
var EditValidation = defineClass("EditValidation", null, {
	init: function (name) {
		this._super();
		this._name = name;
		this.validate = this.$_validateExpression;
	},
	name: null,
	active: true,
	mode: EnumProp(ValidationMode, ValidationMode.ALWAYS),
	level: EnumProp(ValidationLevel, ValidationLevel.ERROR),
	expression: null,
	callback: null,
	message: null,
	description: null,
    styles: {},
	setExpression: function (value) {
		if (value != this._expression) {
			this._expression = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value) : null;
		}
	},
	setCallback: function (value) {
		if (value !== this._callback) {
			if (typeof value == "function") {
				this._callback = value;
				this.validate = this.$_validateCallback;
			} else {
				this._callback = null;
				this.validate = this.$_validateExpression;
			}
		}
	},
    setStyles: function (value) {
		this._styles = value ? _extend(null, value) : {};
    },
	$_validateCallback: function (runtime) {
        var ret = this._callback(runtime.scope());
		if (ret === false) {
			this.$_throwError();
		}
	},
	$_validateExpression: function (runtime) {
		if (this._exprNode && !this._exprNode.evaluate(runtime)) {
			this.$_throwError();
		}
	},
	$_throwError: function () {
		var s = this._message || this._description || this._name || this._expression;
		throw new ValidationError(this._level, s, null, this._message);
	}
});
var EditValidationCollection = defineClass("EditValidationCollection", null, {
	init: function() {
		this._super();
		this._items = [];
	},
	items: null,
	count: function () {
		return this._items.length;
	},
	items_: function () {
		return this._items.slice();
	},
	setItems: function (value) {
		this.assign(value);
	},
	getItem: function (index) {
		return this._items[index];
	},
	clear: function () {
		this._items = [];
	},
	addAll: function (items) {
		if (items && items.length > 0) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				this._items.push(items[i]);
			}
		}
	},
	assign: function (source) {
		if (source !== this) {
			this.clear();
			if (source) {
				if (!_isArray(source)) {
					source = [source];
				}
				for (var i = 0, cnt = source.length; i < cnt; i++) {
                    var ev = source[i];
                    if (ev) {
                        ev = new EditValidation().assign(ev);
						this._items.push(ev);
                    }
				}
			}
		}
	},
	validate: function (mode, runtime, checkLevel, commitLevel) {
		for (var i = 0; i < this._items.length; i++) {
			var item = this._items[i];
			if (item.active() && (item.mode() == mode || item.mode() == ValidationMode.ALWAYS)) {
				try {
					item.validate(runtime);
				} catch (err) {
					if (!checkLevel || (ValidationLevel.compare(item.level(), commitLevel) < 0)) {
						if (err instanceof ValidationError) {
							err.level = item.level();
							throw err;
						} else {
							throw new ValidationError(item.level(), err);
						}
					}
				}
			}
		}
	}
});
var DataRowValidationRuntime = defineClass("DataRowValidationRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._item = null;
		this._dataSet = null;
		this._fieldCount = null;
        this._scope = undefined;
	},
	item: null,
	setItem: function (value) {
		this._item = value;
		this._dataSet = this._item.dataSource();
		this._fieldCount = this._dataSet ? this._dataSet.fieldCount() : 0;
	},
    scope: function (value) {
        var s = this._scope;
        if (!s) {
            s = {
                row: this._item,
                dataSet: this._dataSet
            }
        }
        return s;
    },
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataRowValidationRuntime.IDENTS.hasOwnProperty(token)) {
			var v = DataRowValidationRuntime.IDENTS[token];
			return v;
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataRowValidationRuntime.ID_ROW:
				return this._item.index();
			case DataRowValidationRuntime.ID_DATA_ROW:
				return this._item.dataIndex();
			case DataRowValidationRuntime.ID_CHECKED:
				return this._item.checked();
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
		case DataRowValidationRuntime.ID_VALUES:
			return this._item.getValue(index);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index) {
		var idx = this._dataSet.getFieldIndex(index);
		if (idx < 0 || idx >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field is not exists:" + index);
		}
		switch (idKey) {
			case DataRowValidationRuntime.ID_VALUES:
				return this._item.getValue(idx);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUES: 3
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checekd: f.ID_CHECKED,
		values: f.ID_VALUES
	};
});
var DataCellValidationRuntime = defineClass("DataCellValidationRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._index = null;
		this._row = null;
		this._value = null;
        this._scope = undefined;
	},
	setIndex: function (value) {
		this._index = value;
		this._row = value.getRow(value.column.$_grid);
		this._value = this._row.getValue(this._index.column.dataIndex());
	},
    scope: function () {
        var s = this._scope;
        if (!s) {
            s = {
                index: this._index,
                row: this._row,
                value: this._value
            };
        }
        return s;
    },
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellValidationRuntime.IDENTS.hasOwnProperty(token)) {
			var v = DataCellValidationRuntime.IDENTS[token];
			return v;
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataCellValidationRuntime.ID_VALUE:
				return this._value;
			case DataCellValidationRuntime.ID_ROW:
				return this._row.index();
			case DataCellValidationRuntime.ID_DATA_ROW:
				return this._row.dataIndex();
			case DataCellValidationRuntime.ID_CHECKED:
				return this._index.column.$_grid.isChecked(this._row);
			/*
			case DataCellValidationRuntime.ID_TAG:
				return this._index.column.tag();
			*/
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_CHECKED: 3,
	ID_TAG: 4
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checked: f.ID_CHECKED,
		tag: f.ID_TAG
	};
});
var ValidationManager = defineClass("ValidationManager", null, {
	init: function(grid) {
		this._super();
		this._grid = grid;
	},
	owner: function () {
		return this._grid;
	},
	hasRowValidation: function () {
        var validations = this._grid.editOptions().validations();
		return validations && validations.count() > 0;
	},
	validateCell: function (index, inserting) {
		this.$_validateCell(index, inserting, false);// true, this._grid.editOptions().commitLevel());
	},
	validateRow: function (row, inserting, rowOnly) {
		var level = this._grid.editOptions().commitLevel();
		if (!rowOnly) {
			var columns/*[DataColumn]*/ = this._grid.getDataColumns();
			for (var i = 0, cnt = columns.length; i < cnt; i++) {
				var column = columns[i];
				var index = CellIndex.temp(row.index(), column);
				this.$_validateCell(index, inserting, true, level);
			}
		}
		var validations/*EditValidationCollection*/ = this._grid.editOptions().validations();
		if (validations && validations.count() > 0) {
			var runtime/*DataRowValidationRuntime*/ = this._grid.rowValidationRuntime();
			runtime.setItem(row);
			validations.validate(inserting ? ValidationMode.INSERT : ValidationMode.UPDATE, runtime, true, level);
		}
	},
	$_validateCell: function (index, inserting, levelCheck, level) {
		var value, grid, fld, level, msg, validations, runtime,
			column = _cast(index.dataColumn(), DataColumn);
		if (column) {
			value = index.getRow(this._grid).getValue(column.dataIndex());
			if (column.required()) {
				grid = column.grid();
				fld = grid && grid.dataSource() && grid.dataSource().getField(column.dataIndex());
				if (fld && fld.isEmpty(value)) {
					level = column.requiredLevel() || ValidationLevel.ERROR;
					msg = column.requiredMessage() || (Locale._default.valueIsRequired + ": " + column.fieldName());
					throw new ValidationError(level, msg, column, column.requiredMessage());
				}
			}
			validations = column.validations();
			if (validations && validations.count() > 0) {
				runtime = this._grid.columnValidationRuntime();
				runtime.setIndex(index);
				try {
					validations.validate(inserting ? ValidationMode.INSERT : ValidationMode.UPDATE, runtime, levelCheck, level);
				} catch (err) {
					if (err instanceof ValidationError) {
						err.column = column;
					}
					throw err;
				}
			}
		}
	}
});
/** @abstract */
var LookupSource = defineClass("LookupSource", EventAware, {
	init: function (id) {
		this._super();
		this._id = id;
	},
	id: function () {
		return this._id;
	},
	clear: function () {},
	load: function (options) {},
	exists: function (/*keys*/) {	return false;	},
	fill: function (keys, values) {},
	fillRows: function (rows) {},
	add: function (keys, value) {},
	addRow: function (row) {},
	lookup: function () { return UNDEFINED; },
	getDomain: function (/*keys*/) { return null; },
	getTextDomain: function (/*keys*/) { return null; },
	_changed: function () {
		this.fireEvent(LookupSource.CHANGED);
	}
});
LookupSource.CHANGED = "onLookupSourceChanged";
/** @abstract */
var LookupSourceProvider = defineClass("LookupSourceProvider", EventAware, {
	init: function () {
		this._super();
	},
	getSource: function (id) {
		return null;
	},
	_changed: function () {
		this.fireEvent(LookupSourceProvider.CHANGED);
	}
});
LookupSourceProvider.CHANGED = "onLookupSourceProviderChanged";
var LocalLookupSourceProvider = defineClass("LocalLookupSourceProvider", LookupSourceProvider, {
	init: function (config) {
		this._super();
		this._sources = {};
		config && this.load(config);
	},
	load: function (config) {
		if (config !== this) {
			this._sources = {};
			if (_isArray(config)) {
				for (var i = 0, cnt = config.length; i < cnt; i++) {
					this.$_add(config[i]);
				}
			} else if (config) {
				this.$_add(config);
			}
			this._changed();
		}
	},
	add: function (config) {
		var source = this.$_add(config);
		source && this._changed();
		return source;
	},
	remove: function (id) {
		if (this.$_remove(id)) {
			this._changed();
            return true;
		}
        return false;
	},
	getSource: function (id) {
		return this._sources[id];
	},
	$_createSource: function (src) {
		var source = null;
		if (src) {
			var type = src.type;
			type = type ? type.toLowerCase() : null;
				var tree = new LookupTree(src.id, src.levels, src.ordered);
				tree.fill(src.keys, src.values);
				source = tree;
		}
		return source;
	},
	$_add: function (config) {
        var source = null;
        if (config instanceof LookupSource) {
            if (config.id() && this._sources[config.id()] !== config) {
                source = config;
            }
        } else if (config && config.id) {
			if (this._sources[config.id] !== config) {
				source = this.$_createSource(config);
			}
		}
        if (source) {
            this.$_remove(source.id());
            this._sources[source.id()] = source;
            source.addListener(this);
            return source;
        }
		return null;
	},
	$_remove: function (id) {
		if (id) {
			var source = this._sources[id];
			if (source) {
				source.removeListener(this);
				delete this._sources[id];
				return true;
			}
		}
		return false;
	},
	onLookupSourceChanged: function (source) {
		this._changed();
	}
});
var LookupTree = defineClass("LookupTree", LookupSource, {
	init: function (id, levels, ordered) {
		id = arguments.length > 0 ? id : null;
		levels = arguments.length > 1 ? levels : -1;
		ordered = arguments.length > 2 ? ordered : false;
		this._super(id);
		if (levels < 1 ) {
			throw "LookupTable levels must be equals or greater than 1";
		}
		this._levels = levels;
		this._tree = {};
		this._listMap = ordered ? {} : null;
	},
    levels: function () {
        return this._levels;
    },
	clear: function () {
		this._tree = {};
		this._changed();
	},
	load: function (options) {
	},
	exists: function (keys) {
		var len, key, map, i;
        if (this._levels > 1) {
            if (keys && (len = keys.length) > 0 && len <= this._levels) {
                len = Math.min(len, this._levels) - 1;
                if (len > 0) {
                    map = this._tree;
                    for (i = 0; i < len; i++) {
                        key = keys[i];
                        map = map[key];
                        if (!map) {
                            break;
                        }
                    }
                    return map && map.hasOwnProperty(keys[len]);
                } else {
                    return this._tree.hasOwnProperty(keys[0]);
                }
            }
        } else {
            return this._tree.hasOwnProperty(_isArray(keys) ? keys[0] : keys);
        }
		return false;
	},
	fill: function (keys, values) {
		if (keys && keys.length > 0 && values && values.length > 0) {
            var i, k,
			    cnt = Math.min(keys.length, values.length);
			for (i = 0; i < cnt; i++) {
				k = keys[i];
				if (!_isArray(k)) {
					k = [k];
				}
				this.$_add(k, values[i]);
			}
			this._changed();
		}
        return this;
	},
	fillRows: function (rows) {
		var cnt;
		if (rows && (cnt = rows.length) > 0) {
			for (var i = 0; i < cnt; i++) {
				this.$_addRow(rows[i]);
			}
			this._changed();
		}
        return this;
	},
	add: function (keys, value) {
		if (keys) {
			this.$_add(keys, value);
			this._changed();
		}
        return this;
	},
	addRow: function (row) {
		if (row) {
			this.$_addRow(row);
			this._changed();
		}
        return this;
	},
	lookup: function (keys) {
		if (this._levels > 1) {
			var i, key,
			    map = this._tree,
			    len = this._levels - 1;
			for (i = 0; i < len; i++) {
				key = keys[i];
				map = map[key];
				if (!map) {
					break;
				}
			}
			return map ? map[keys[len]] : undefined;
		} else {
			return this._tree[keys];
		}
	},
	getDomain: function (keys) {
		if (!keys || keys.length != this._levels - 1) {
			throw "Keys length must be " + (this._levels - 1);
		}
		var i, cnt, k, list,
		    domain = [],
		    values = [],
		    dic = this._tree;
		if (this._levels > 1) {
			cnt = keys.length;
			for (i = 0; i < cnt; i++) {
				dic = dic[keys[i]];
				if (!dic) {
					return {
						keys: domain,
						values: values
					};
				}
			}
		}
		if (this._listMap) {
			list = this._listMap[dic];
			cnt = list.length;
			for (i = 0; i < cnt; i++) {
				domain.push(list[i]);
				values.push(dic[list[i]]);
			}
		} else {
			for (k in dic) {
				domain.push(k);
				values.push(dic[k]);
			}
		}
		return {
			keys: domain,
			values: values
		}
	},
	getTextDomain: function (keys) {
		var i, cnt,
		    domain = this.getDomain(keys),
		    keys = domain.keys,
		    vals = domain.values;
		for (i = 0, cnt = keys.length; i < cnt; i++) {
			keys[i] = _toStr(keys[i]);
			vals[i] = _toStr(vals[i]);
		}
		return domain;
	},
	$_add: function (keys, value) {
		if (!keys) {
			return;
		}
		var k, i, key, node, map, list,
		    levels = this._levels,
		    len = _isArray(keys) ? keys.length : 1;
		if (len < levels) {
			throw Error("Keys length must be equals or greater than " + levels);
		}
		if (levels > 1) {
			map = this._tree;
			for (i = 0, len = levels - 1; i < len; i++) {
				key = keys[i];
				node = map[key];
				if (!node) {
					node = {};
					map[key] = node;
				}
				map = node;
			}
			map[k = keys[len]] = value;
		} else {
			this._tree[k = keys] = value;
		}
		if (this._listMap) {
			list = this._listMap[map];
			if (!_isArray(list)) {
				list = [];
				this._listMap[map] = list;
			}
			list.push(k);
		}
	},
	$_addRow: function (row) {
		if (row) {
            var v,
			    len = row.length;
			if (len - 1 < this._levels ) {
				throw Error("Keys length must be equals or greater than " + this._levels);
			}
			v = row[this._levels];
			row = row.slice(0, this._levels);
			this.$_add(row, v);
		}
	}
});
/** @abstract */
var GridObject = defineClass("GridObject", EventAware, {
    init: function (grid) {
        this._super();
        this._grid = grid;
        this._dirty = false;
    },
    owner: function () {
        return this._grid;
    },
    dirty: function () {
        return this._dirty;
    },
    /*
     assign: function (source) {
     this._super(source);
     this.$_assignProperties(source);
     if (source instanceof GridObject) {
     if (source._styles) {
     this._styles.extend(source._styles);
     }
     } else if (source) {
     if (source.styles) {
     this._styles.extend(source.styles);
     }
     }
     },
     $_assignProperties: function (source) {
     var prop = null,
     name;
     if (source instanceof GridObject) {
     for (prop in source) {
     if (prop.indexOf("get") == 0) {
     name = "set" + prop.substring(3);
     if (this[name]) {
     this[name].call(this, source[prop].call(source));
     } else {
     trace("Unknown setter: " + name);
     }
     }
     }
     } else if (source) {
     for (prop in source) {
     if (source.hasOwnProperty(prop)) {
     name = "set" + _capitalize(prop);
     if (this[name]) {
     this[name].call(this, source[prop]);
     } else {
     trace("Unknown setter: " + name);
     }
     }
     }
     }
     },
     */
    clean: function () {
        if (this._dirty) {
            this._dirty = false;
        }
    },
    invalidate: function () {
        this._grid && this._grid.invalidate();
    },
    refreshOwner: function () {
        this._grid && this._grid.refreshView();
    },
    propertyChanged: function (prop, newValue) {
        this._changed();
    },
    _changed: function () {
        if (!this._dirty) {
            this._dirty = true;
            this._doChanged();
            this.refreshOwner();
        }
    },
    _doChanged: function () {
    }
});
/** @abstract */
var VisualObject = defineClass("VisualObject", GridObject, {
    init: function (grid, styleName) {
        this._super(grid);
        this._styles = new GridStyles(this, styleName);
    },
    stylesChanged: function (/*stypeProp*/) {
        this._changed();
    },
    getPaletteScope: function () {
    },
    visible: true,
    styles: null,
    setStyles: function (value) {
        if (value !== this._styles) {
            this._styles.extend(value);
        }
        return this;
    },
    clearStyles: function (recursive) {
        this._styles.clearValues();
        if (recursive) {
            this._doClearStyles();
        }
        this.stylesChanged();
    },
    assignSimple: function (value) {
        if (typeof value === 'boolean') {
            this.setVisible(value);
        }
    },
    _doChanged: function () {
        if (this._grid) {
            this._grid._visualObjectChanged(this);
        }
    },
    _doPrepareUpdate: function () {
    },
    $_prepareUpdate: function () {
        this._doPrepareUpdate();
    },
    _doClearStyles: function () {
    }
});
var GridPanel = defineClass("GridPanel", VisualObject, {
    init: function (grid/* GridBase */) {
        this._super(grid, "panelStyles");
        this.setVisible(false);
    },
    minHeight: 20,
    height: 0
});
var RowGroupPanelHead = defineClass("RowGroupPanelHead", VisualObject, {
    init: function (panel) {
        this._super(panel.owner(), "groupPanelHead");
        this._innerStyles = new GridStyles(this, "groupPanelHeadInner");
        this._panel = panel;
        this.setVisible(true);
    },
    innerStyles: null,
    showMenu: true,
    setInnerStyles: function (value) {
        if (value !== this._innerStyles) {
            this._innerStyles.extend(value);
        }
        return this;
    },
    setShowMenu: function (value) {
        if (value != this._showMenu) {
            this._showMenu = value;
            this._panel._changed();
        }
        return this;
    },
    _doClearStyles: function () {
        this._innerStyles.clearValues();
    }
});
var RowGroupPanel = defineClass("RowGroupPanel", VisualObject, {
    init: function (grid) {
        this._super(grid, "groupPanel");
        this._head = new RowGroupPanelHead(this);
        this._itemStyles = new GridStyles(this, "groupPanelItem");
        this._itemInnerStyles = new GridStyles(this, "groupPanelItemInner");
        this.setVisible(false);
    },
    head: null,
    itemStyles: null,
    itemInnerStyles: null,
    minHeight: IntProp(20),
    height: IntProp(0),
    prompt: "Group by",
    setHead: function (value) {
        if (value !== this._head) {
            this._head.assign(value);
        }
    },
    setItemStyles: function (value) {
        if (value !== this._itemStyles) {
            this._itemStyles.extend(value);
        }
        return this;
    },
    setItemInnerStyles: function (value) {
        if (value !== this._itemInnerStyles) {
            this._itemInnerStyles.extend(value);
        }
        return this;
    },
    _doClearStyles: function () {
        this._itemStyles.clearValues();
        this._head.clearStyles(true);
    }
});
/** @interanl */
var MenuVisualObject = defineClass("MenuVisualObject", VisualObject, {
    init: function (owner, name) {
        MenuVisualObject.Base.init.call(this, owner, name);
        this._popupMenuName = null;
    },
    popupMenu: null,
    menuVisible: true,
    setPopupMenu: function (value) {
        if (value != this._popupMenu) {
            this._popupMenu = value;
            if (_isArray(value) || _isObject(value)) {
                this._popupMenuName = '$$_' + this.className() + '_menu';
                this.owner().registerPopupMenu(this._popupMenuName, _isArray(value) ? value : [value]);
            } else if (value) {
                this._popupMenuName = String(value);
            } else {
                this._popupMenuName = null;
            }
        }
    },
    popupMenuName: function () {
        return this._popupMenuName;
    }
});
var HeaderSummaryHead = defineClass("HeaderSummaryHead", MenuVisualObject, {
    init: function (summary) {
        this._super(summary.owner(), "headerSummaryHead");
        this._summary = summary;
    },
    text: null,
    summary: function () {
        return this._summary;
    },
    assignSimple: function (source) {
        this.setText(source);
    }
});
var HeaderSummary = defineClass("HeaderSummary", VisualObject, {
    init: function (header) {
        this._super(header._grid, "headerSummary");
        this._header = header;
        this._head = new HeaderSummaryHead(this);
        this._groupStyles = new GridStyles(this);
        this._cell = new HeaderSummaryCell(this._grid);
        this._headCell = new HeaderSummaryHeadCell(this._grid, this._head);
        this._runtime = new FooterExpressionRuntime();
        this._runStyles = new GridStyles(this, "runFooter", null, false);
        this.setVisible(false);
    },
    head: null,
    groupStyles: null,
    minHeight: IntProp(19),
    height: IntProp_0,
    autoResize: false,
    resizable: false,
    tooltipCallback: null,	// function (column, value):String
    setHead: function (value) {
        if (value !== this._head) {
            this._head.assign(value);
        }
        return this;
    },
    setGroupStyles: function (value) {
        if (value !== this._groupStyles) {
            this._groupStyles.extend(value);
        }
        return this;
    },
    header: function () {
        return this._header;
    },
    getCell: function (index) {
        var summary, d, r,
            cell = this._cell,
            column = index.column;
        cell.setIndex(index);
        cell.calculate();
        if (column instanceof ColumnGroup) {
            cell.setStyles(this._groupStyles);
        } else {
            summary = column.header().summary();
            d = summary.dynamicStyles();
            if (d && d.count() > 0) {
                r = this._runStyles;
                r.clearValues();
                r.setParent(summary.styles());
                this._runtime.setCell(cell);
                d.applyInternal(this._runtime, r);
                cell.setStyles(r);
            } else {
                cell.setStyles(summary.styles())
            }
        }
        return cell;
    },
    getHeadCell: function () {
        var head = this._head,
            cell = this._headCell;
        cell.setMenuVisible(head.menuVisible() && head.popupMenu());
        cell.setStyles(head.styles());
        cell.setText(head.text());
        return cell;
    },
    clean: function () {
        this._super();
        this._head.clean();
    },
    _doClearStyles: function () {
        this._groupStyles.clearValues();
        this._runStyles.clearValues();
        this._head.clearStyles(true);
    }
});
var GridHeaderHead = defineClass("GridHeaderHead", MenuVisualObject, {
    init: function (header) {
        GridHeaderHead.Base.init.call(this, header.owner(), "headerHead");
        this._header = header;
    },
    header: function () {
        return this._header;
    }
});
var GridHeader = defineClass("GridHeader", VisualObject, {
    init: function (grid) {
        this._super(grid, "gridHeader");
        this._head = new GridHeaderHead(this);
        this._summary = new HeaderSummary(this);
        this._groupStyles = new GridStyles(this, "headerGroup");
        this._subStyles = new GridStyles(this, "headerSub");
        this._menuHandleStyles = new GridStyles(this, 'menuHandle');
        this._filterHandleStyles = new GridStyles(this, 'filterHandle');
        this._sortHandleStyles = new GridStyles(this, 'sortHandle');
        this._sortOrderStyles = new GridStyles(this, 'sortOrder');
        this._cell = new HeaderCell(grid);
        this._headCell = new HeaderHeadCell(grid, this._head);
        this._images = null;
        this.setVisible(true);
    },
    head: null,
    summary: null,
    groupStyles: null,
    subStyles: null,
    menuHandleStyles: null,
    filterHandleStyles: null,
    sortHandleStyles: null,
    sortOrderStyles: null,
    minHeight: IntProp(23),
    height: IntProp_0,
    sortOrderVisible: true,
    autoResize: false,
    resizable: false,
    selectable: true,
    checkLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
    imageLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
    subTextLocation: EnumProp(SubTextLocation, SubTextLocation.BOTTOM),
    subTextGap: 1,
    itemOffset: 2,
    itemGap: 2,
    imageList: null,
    imageOffset: 0,
    handleOffset: 2,
    handleGap: 1,
    menuHandleWidth: 7,
    tooltipCallback: null,	// function (column):String
    setHead: function (value) {
        if (value !== this._head) {
            this._head.assign(value);
        }
    },
    setSummary: function (value) {
        if (value !== this._summary) {
            this._summary.assign(value);
        }
        return this;
    },
    setGroupStyles: function (value) {
        if (value !== this._groupStyles) {
            this._groupStyles.extend(value);
        }
        return this;
    },
    setSubStyles: function (value) {
        if (value !== this._subStyles) {
            this._subStyles.extend(value);
        }
        return this;
    },
    setMenuHandleStyles: function (value) {
        if (value !== this._menuHandleStyles) {
            this._menuHandleStyles.extend(value);
        }
        return this;
    },
    setFilterHandleStyles: function (value) {
        if (value !== this._filterHandleStyles) {
            this._filterHandleStyles.extend(value);
        }
        return this;
    },
    setSortHandleStyles: function (value) {
        if (value !== this._sortHandleStyles) {
            this._sortHandleStyles.extend(value);
        }
        return this;
    },
    setSortOrderStyles: function (value) {
        if (value !== this._sortOrderStyles) {
            this._sortOrderStyles.extend(value);
        }
        return this;
    },
    setCheckLocation: function (value) {
        if (!value || value == HeaderItemLocation.DEFAULT) {
            value = HeaderItemLocation.NONE;
        }
        if (value !== this._checkLocation) {
            this._checkLocation = value;
            this._changed();
        }
        return this;
    },
    setImageLocation: function (value) {
        if (!value || value == HeaderItemLocation.DEFAULT) {
            value = HeaderItemLocation.NONE;
        }
        if (value !== this._imageLocation) {
            this._imageLocation = value;
            this._changed();
        }
        return this;
    },
    setSubTextLocation: function (value) {
        if (!value) {
            value = SubTextLocation.BOTTOM;
        }
        if (value != this._subTextLocation) {
            this._subTextLocation = value;
            this._changed();
        }
        return this;
    },
    getCell: function (index) {
        var v,
            cell = this._cell,
            column = index.column,
            m = column.header();
        cell.setIndex(index);
        cell._styles = m.styles();
        cell._subStyles = m.subStyles();
        switch (m.sortOrderVisibility()) {
            case SortOrderVisibility.VISIBLE:
                v = true;
                break;
            case SortOrderVisibility.HIDDEN:
                v = false;
                break;
            default:
                v = this._sortOrderVisible;
                break;
        }
        cell._sortOrderVisible = v;
        cell._text = m.displayText();
        cell._subText = m.subText();
        cell._subTextLocation = (!(v = m.subTextLocation()) || v == SubTextLocation.DEFAULT) ? this._subTextLocation : v;
        cell._subTextGap = (v = m.subTextGap()) === undefined ? this._subTextGap : v;
        cell._itemOffset = (v = m.itemOffset()) === undefined ? this._itemOffset : v;
        cell._itemGap = (v = m.itemGap()) === undefined ? this._itemGap : v;
        cell._imageList = this._imageList;
        cell._imageIndex = m.imageIndex();
        cell._imageUrl = m.imageUrl();
        cell._imageOffset = (v = m.imageOffset()) === undefined ? this._imageOffset : v;
        cell._checkLocation = (v = m.checkLocation()) == HeaderItemLocation.DEFAULT ? this._checkLocation : v;
        cell._imageLocation = (v = m.imageLocation()) == HeaderItemLocation.DEFAULT ? this._imageLocation : v;
        cell._checked = column.checked();
        cell._handleOffset = (v = m.handleOffset()) === undefined ? this._handleOffset : v;
        cell._handleGap = (v = m.handleGap()) === undefined ? this._handleGap : v;
        cell._menuWidth = (v = m.menuHandleWidth()) === undefined ? this._menuHandleWidth : v;
        return cell;
    },
    getHeadCell: function () {
        var cell = this._headCell;
        cell.setMenuVisible(this._head.menuVisible() && this._head.popupMenu());
        cell.setStyles(this._head.styles());
        return cell;
    },
    getGroupingCell: function (column) {
        var v,
            cell = this._cell,
            header = column.header();
        cell.setIndex(new CellIndex(-1, column));
        cell._styles = this._grid.rowGroup().panelStyles();
        cell._subStyles = header.subStyles();
        cell._text = header.displayText();
        cell._subText = header.subText();
        cell._subLocation = !(v = header.subTextLocation()) ? this._subTextLocation : v;
        cell._subTextGap = (v = header.subTextGap()) === undefined ? this._subTextGap : v;
        cell._itemOffset = (v = header.itemOffset()) === undefined ? this._itemOffset : v;
        cell._itemGap = (v = header.itemGap()) === undefined ? this._itemGap : v;
        cell._imageList = this._imageList;
        cell._imageIndex = header.imageIndex();
        cell._imageUrl = header.imageUrl();
        cell._checkLocation = header.checkLocation();
        cell._imageLocation = header.imageLocation();
        cell._checked = column.checked();
        return cell;
    },
    /** @internal */
    getImage: function (imageIndex) {
        return this._images && this._images.getImage(imageIndex);
    },
    clean: function () {
        this._super();
        this._head.clean();
        this._summary.clean();
    },
    _doPrepareUpdate: function () {
        this._images = this._imageList ? this._grid.getImageList(this._imageList) : null;
    },
    _doClearStyles: function () {
        this._groupStyles.clearValues();
        this._subStyles.clearValues();
        this._filterHandleStyles.clearValues();
        this._sortHandleStyles.clearValues();
        this._sortOrderStyles.clearValues();
        this._head.clearStyles(true);
        this._summary.clearStyles(true);
    }
});
/** @internal */
var EditBar = defineClass("EditBar", VisualObject, {
    init: function (grid) {
        this._super(grid, "editBarStyles");
        this._cell = new EditBarCell(grid);
        this.setVisible(false);
    },
    minHeight: 23,
    height: 0,
    getCell: function (index) {
        var cell = this._cell;
        cell.setStyles(this._styles);
        return cell;
    }
});
var GridFooterHead = defineClass("GridFooterHead", MenuVisualObject, {
    init: function (footer) {
        this._super(footer.owner(), "footerHeadStyles");
        this._footer = footer;
    },
    text: null,
    iconUrl: null,
    footer: function () {
        return this._footer;
    },
    assignSimple: function (source) {
        this.setText(source);
    }
});
var GridFooter = defineClass("GridFooter", VisualObject, {
    init: function (grid) {
        this._super(grid, "footerStyles");
        this._groupStyles = new GridStyles(this);
        this._head = new GridFooterHead(this);
        this._cell = new FooterCell(grid);
        this._headCell = new FooterHeadCell(grid, this._head);
        this._runtime = new FooterExpressionRuntime();
        this._runStyles = new GridStyles(this, "runFooterStyles", null, false);
        this.setVisible(true);
    },
    groupStyles: null,
    head: null,
    minHeight: IntProp(23),
    height: IntProp_0,
    autoResize: false,
    resizable: false,
    tooltipCallback: null,	// function (column):String
    setGroupStyles: function (value) {
        if (value !== this._groupStyles) {
            this._groupStyles.extend(value);
        }
        return this;
    },
    setHead: function (value) {
        if (value !== this._head) {
            this._head.assign(value);
        }
        return this;
    },
    getCell: function (index) {
        var d, r,
            cell = this._cell,
            column = index.column,
            footer = column.footer();
        cell.setIndex(index);
        cell.calculate();
        if (column instanceof ColumnGroup) {
            cell.setStyles(footer.styles());//this._groupStyles);
        } else {
            d = footer.dynamicStyles();
            if (d && d.count() > 0) {
                r = this._runStyles;
                r.clearValues();
                r.setParent(footer.styles());
                this._runtime.setCell(cell);
                d.applyInternal(this._runtime, r);
                cell.setStyles(r);
            } else {
                cell.setStyles(footer.styles())
            }
        }
        return cell;
    },
    getHeadCell: function () {
        var cell = this._headCell;
        cell.setMenuVisible(this._head.menuVisible() && this._head.popupMenu());
        cell.setStyles(this._head.styles());
        return cell;
    },
    clean: function () {
        this._super();
        this._head.clean();
    },
    _doClearStyles: function () {
        this._groupStyles.clearValues();
        this._runStyles.clearValues();
        this._head.clearStyles(true);
    }
});
/** @abstract */
var CustomGridItem = defineClass("CustomGridItem", null, {
    init: function (owner, config) {
        this._super();
        this._owner = owner;
        this._styles = new GridStyles(this, "customGridItem", null, false);
        config && this.assign(config);
    },
    visible: true,
    height: 100,
    minHeight: NaN,
    maxHeight: NaN,
    fillHeight: 0, // 0보다 큰 값이면 그리드 행 표시 후 남은 영역을 이 값의 비례만큼 차지한다.
    styles: null,
    setStyles: function (value) {
        if (value != this._styles) {
            this._styles.extend(value);
            this._changed();
        }
    },
    itemType: function () {
        return this._owner._itemType;
    },
    displayText: function () {
        return this.className();
    },
    isHeader: function () {
        return this._owner._itemType == CustomGroupItemType.HEADER;
    },
    /** @abstract */ createItemView: function () { return null; },
    refresh: function () {
        this._changed();
    },
    proxy: function () {
        var p = this._super();
        p.type = this.$_type();
        return p;
    },
    propertyChanged: function () {
        this._changed();
    },
    _changed: function () {
        this._owner && this._owner._itemChanged(this);
    }
});
var CustomGridItemCollection = defineClass("CustomGridItemCollection", null, {
    init: function (grid, itemType) {
        this._super();
        this._grid = grid;
        this._itemType = itemType || CustomGridItemType.FOOTER;
        this._items = [];
        this._itemTypes = {};
    },
    count: function () {
        return this._items.length;
    },
    visible: function () {
        return this._items.length > 0;
    },
    registerType: function (type, clazz/* CustomGridItem class */) {
        if (type && _isFunction(clazz)) {
            this._itemTypes[type] = clazz;
            return clazz;
        }
        return null;
    },
    getItem: function (index) {
        return this._items[index];
    },
    assign: function (source) {
        var st, i, item;
        if (source === this) return;
        this._items = [];
        this._itemMap = {};
        if (_isArray(source)) {
            st = this._itemType == CustomGridItemType.FOOTER ? this._grid.footerItemStyles() : this._grid.headerItemStyles();
            for (i = 0; i < source.length; i++) {
                item = this._createItem(source[i]);
                if (item) {
                    item.styles().setParent(st, false);
                    this._items.push(item);
                }
            }
        }
    },
    proxy: function () {
        return $$_getProxy(this._items);
    },
    _createItem: function (source) {
        var item,
            clazz = this._itemTypes[source.type];
        if (clazz) {
            item = new clazz(this, source);
            return item;
        }
        return null;
    },
    _itemChanged: function (item) {
        this._grid.$_customGridItemChanged(item);
    },
    _changed: function () {
        this._grid && this._grid.invalidate();
    }
});
var RowIndicator = defineClass("RowIndicator", VisualObject, {
    init: function (grid) {
        this._super(grid, "rowIndicatorStyles");
        this._stateStyles = new GridStyles(this);
        this._createdStyles = new GridStyles(this);
        this._createdStyles.setParent(this._stateStyles, false);
        this._updatedStyles = new GridStyles(this);
        this._updatedStyles.setParent(this._stateStyles, false);
        this._deletedStyles = new GridStyles(this);
        this._deletedStyles.setParent(this._stateStyles, false);
        this._cell = new IndicatorCell(grid, this);
        this._stateCell = new StateCell(grid, this);
        this.setVisible(true);
    },
    displayValue: EnumProp(RowIndicatorValue, RowIndicatorValue.ROW_INDEX),
    shapeVisible: true,
    rowIndexBase: IntProp(1),
    dataIndexBase: IntProp(1),
    minWidth: IntProp(24),
    maxWidth: IntProp_0,
    width: IntProp_0,
    selectable: true,
    indicatorVisible: true,
    stateWidth: IntProp(7),
    stateVisible: false,
    stateStyles: null,
    createdStyles: null,
    updatedStyles: null,
    deletedStyles: null,
    createdLabel: null,
    updatedLabel: null,
    deletedLabel: null,
    stateImageList: null,
    setStateStyles: function (value) {
        if (value !== this._stateStyles) {
            this._stateStyles.extend(value);
        }
        return this;
    },
    setCreatedStyles: function (value) {
        if (value !== this._createdStyles) {
            this._createdStyles.extend(value);
        }
        return this;
    },
    setUpdatedStyles: function (value) {
        if (value !== this._updatedStyles) {
            this._updatedStyles.extend(value);
        }
        return this;
    },
    setDeletedStyles: function (value) {
        if (value !== this._updatedStyles) {
            this._deletedStyles.extend(value);
        }
        return this;
    },
    stateImages: function () {
        return this._stateImages;
    },
    getCell: function (index) {
        var row, state,
            cell = this._cell;
        cell.setIndex(index);
        cell.setStyles(this.styles());
        cell.setShapeVisible(this._shapeVisible);
        row = index.getRow(this._grid);
        if (row) {
            state = row.rowState();
            if (state == GridRowState.NORMAL && this._grid.$_focusedIndex().rowIndex === index.rowIndex) {
                state = GridRowState.FOCUSED;
            }
            cell.setRowState(state);
        }
        return cell;
    },
    getStateCell: function (index) {
        var cell = this._stateCell;
        cell.setIndex(index);
        switch (index.getRow(this._grid).dataState()) {
            case DataRowState.CREATED:
                cell.setStyles(this._createdStyles);
                cell.setLabel(this._createdLabel);
                break;
            case DataRowState.UPDATED:
                cell.setStyles(this._updatedStyles);
                cell.setLabel(this._updatedLabel);
                break;
            case DataRowState.DELETED:
            case DataRowState.CREATED_AND_DELETED:
                cell.setStyles(this._deletedStyles);
                cell.setLabel(this._deletedLabel);
                break;
            default:
                cell.setStyles(this._stateStyles);
                cell.setLabel(null);
                break;
        }
        return cell;
    },
    $_indicatorVisible: function () {
        return this._visible && (this._indicatorVisible || !this._stateVisible);
    },
    $_stateVisible: function () {
        return this._visible && this._stateVisible;
    },
    _doClearStyles: function () {
        this._stateStyles.clearValues();
        this._createdStyles.clearValues();
        this._updatedStyles.clearValues();
        this._deletedStyles.clearValues();
    },
    _doPrepareUpdate: function () {
        this._stateImages = this._stateImageList ? this._grid.getImageList(this._stateImageList) : null;
    }
});
var CheckBar = defineClass("CheckBar", VisualObject, {
    init: function (grid) {
        CheckBar.Base.init.call(this, grid, "checkBarStyles");
        this._headStyles = new GridStyles(this);
        this._cell = new CheckBarCell(grid);
        this._headCell = new StyledCell(grid, this);
        this._checkableRuntime = new CheckableExpressionRuntime();
        this.setVisible(true);
    },
    width: IntProp(21),
    headVisible: true,
    exclusive: false,
    exclusiveDisplay: true,
    checkAllExpression: null,
    checkAllCallback: null,     // function (row): Boolean
    showAll: true,
    showGroup: true,
    groupCheck: false,
    headStyles: null,
    visibleOnly: false,
    checkableOnly: true,
    checkableExpression: null,
    checkableCallback: null,    // function (grid, row): Boolean
    draggable: false,
    hideUncheckable: false,
    setHeadStyles: function (value) {
        if (value !== this._headStyles) {
            this._headStyles.extend(value);
        }
        return this;
    },
    setCheckAllExpression: function (value) {
        value = typeof value === 'string' ? value.trim() : null;
        if (value != this._checkAllExpression) {
            this._checkAllExpression = value;
            this._checkAllNode = value ? ExpressionParser.Default.parse(value) : null;
            this._changed();
        }
        return this;
    },
    setCheckAllCallback: function (value) {
        value = _isFunction(value) ? value : null;
        if (value != this._checkAllCallback) {
            this._checkAllCallback = value;
            this._changed();
        }
        return this;
    },
    setCheckableExpression: function (value) {
        value = typeof value === 'string' ? value.trim() : null;
        if (value != this._checkableExpression) {
            this._checkableExpression = value;
            this._checkableNode = value ? ExpressionParser.Default.parse(value) : null;
            this._changed();
        }
        return this;
    },
    setCheckableCallback: function (value) {
        value = _isFunction(value) ? value : null;
        if (value != this._checkableCallback) {
            this._checkableCallback = value;
            this._changed();
        }
        return this;
    },
    getCell: function (index) {
        var cell = this._cell;
        cell.setIndex(index);
        cell.setStyles(this.styles());
        return cell;
    },
    getHeadCell: function () {
        this._headCell.setStyles(this._headStyles);
        return this._headCell;
    },
    $_getCheckAllCallback: function () {
        return function (row) {
            var callback = this._checkAllCallback;
            if (callback) {
                return callback(row);
            }
            if (this._checkAllNode) {
                this._checkableRuntime.setItem(row);
                return this._checkAllNode.evaluate(this._checkableRuntime);
            }
            return true;
        }.bind(this);
    },
    $_isCheckable: function (row) {
        if (this._checkableOnly) {
            if (this._checkableCallback) {
                return this._checkableCallback(this._grid, row);
            }
            if (this._checkableNode) {
                this._checkableRuntime.setItem(row);
                return this._checkableNode.evaluate(this._checkableRuntime);
            }
            return row.$_isCheckable(this._grid);
        }
        return true;
    },
    _doClearStyles: function () {
        this._headStyles.clearValues();
    },
    _doPrepareUpdate: function () {
        (this._checkableNode || this._checkAllNode) && this._checkableRuntime.setDataSource(this._grid.dataSource());
    }
});
var GridBody = defineClass("GridBody", VisualObject, {
    init: function (grid) {
        GridBody.Base.init.call(this, grid, "bodyStyles");
        this._emptyStyles = new GridStyles(this, "empty", null, true);
        this._emptyDataStyles = new GridStyles(this, "emptyData", null, true);
        /*
        var paletteItemScope = (function (owner) {
            var _row = -1;
            return {
                getPalette: function (pal) {
                    return owner._palettes[pal];
                },
                getPaletteIndex: function (index) {
                    return index == 'row' ? _row : index;
                },
                setRow: function (row) {
                    _row = row;
                }
            };
        })(this);
        */
        this._rowRangeStyles = new GridRowStyles(this);
        this._rowStyles = new GridStyles(this._rowRangeStyles, "row");
        this._fixedRowStyles = new GridStyles(this._rowRangeStyles, "fixedRow");
        this._rowRangeStyles.setDefaultStyles(this._rowStyles, this._fixedRowStyles);
        this._cellStyles = new GridStyles(this, "cell");
        this._fixedCellStyles = new GridStyles(this, "fixedCell", {
            color: '#000',
            borderRight: '#999',
            borderBottom: '#999'
        });
        this._mergedStyles = new GridStyles(this, "merged", {
            background: "#fff"
        });
        this._fixedMergedStyles = new GridStyles(this, "fixedMerged", {
            background: "#fff0f0f0"
        });
        this._createdStyles = new GridStyles(this, 'created');
        this._updatedStyles = new GridStyles(this, 'updated');
        this._deletedStyles = new GridStyles(this, "deleted", {
            fontItalic: true,
            color: '#ffa0a0a0',
            background: '#fff8f8f8'
        });
        this._checkedStyles = new GridStyles(this, 'checked');
        this._fixedRowBarStyles = new GridStyles(this, "fixedRowBar");
        this._fixedColumnBarStyles = new GridStyles(this, "fixedColumnBar");
        this._selectionStyles = new GridStyles(this, "selection");
        this._mobileSelectionStyles = new GridStyles(this, "mobileSelection", {
            background: new SolidBrush(0x10000000),
            border: new SolidPen(0xff333333, 2)
        });
        this._rowDynamicStyles = new DynamicStyleCollection(this);
        this._cellDynamicStyles = new DynamicStyleCollection(this);
        this._groupCell = new GroupCell(grid);
        this._dataCell = new DataCell(grid);
        this._labelCell = new LabelCell(grid);
        this._seriesCell = new SeriesCell(grid);
        this._calcedCell = new CalcedCell(grid);
        this._mergedCell = new MergedDataCell(grid);
        this._mergedSeriesCell = new MergedSeriesCell(grid);
        this._chartCell = new ChartCell(grid);
        this._mergedChartCell = new MergedChartCell(grid);
        this._rowRuntime = new DataRowExpressionRuntime(grid);
        this._cellRuntime = new DataCellExpressionRuntime(grid);
        this._mergeValueRuntime = new ColumnMergeValueRuntime(grid);
        this._runCellStyles = new GridStyles(this, null, null, false);
        this._runDynStyles = new GridStyles(this, null, null, false);
        this._runBodyStyles = new GridStyles(this, null, null, false);
        this._dataSource = null;
        this._fixedColIgnore = false;
        this._fixedDynIgnore = false;
        this._items = null;
        this._styleManager = null;
        this._hasCellStyles = false;
        this._styleTargets = {body: true, fixed: false};
        this._runCheckedStyles = null;
        this._runStateStyles = {};
        this._rowDynMap = {};
        this._palettes = null;
    },
    getPaletteScope: function () {
        return this;
    },
    getPalette: function (pal) {
        return this._palettes[pal];
    },
    getPaletteIndex: function (index) {
        return index;
    },
    onRowStylesChanged: function (rowStyles) {
        this._grid && this._grid.refreshView();
    },
    emptyStyles: null,
    emptyDataStyles: null,
    rowStyles: null,
    fixedRowStyles: null,
    rowRangeStyles: null,
    cellStyles: null,
    fixedCellStyles: null,
    mergedStyles: null,
    fixedMergedStyles: null,
    createdStyles: null,
    updatedStyles: null,
    deletedStyles: null,
    checkedStyles: null,
    fixedRowBarStyles: null,
    fixedColumnBarStyles: null,
    rowDynamicStyles: null,
    cellDynamicStyles: null,
    ignoreRowStylesOnFixed: true,
    ignoreColumnStylesOnFixed: false,
    ignoreDynamicStylesOnFixed: false,
    fixedColumnBarWidth: 0,
    fixedRowBarHeight: 0,
    selectionStyles: null,
    mobileSelectionStyles: null,
    styleCallback: null,    // function (index, styles, merged);
    tooltipCallback: null,  // function (index):String
    setEmptyStyles: function (value) {
        if (value !== this._emptyStyles) {
            this._emptyStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setEmptyDataStyles: function (value) {
        if (value !== this._emptyDataStyles) {
            this._emptyDataStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setRowStyles: function (value) {
        if (value !== this._rowStyles) {
            this._rowStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedRowStyles: function (value) {
        if (value !== this._fixedRowStyles) {
            this._fixedRowStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setRowRangeStyles: function (value) {
        if (value !== this._rowRangeStyles) {
            this._rowRangeStyles.assign(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setCellStyles: function (value) {
        if (value !== this._cellStyles) {
            this._cellStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedCellStyles: function (value) {
        if (value !== this._fixedCellStyles) {
            this._fixedCellStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setMergedStyles: function (value) {
        if (value !== this._mergedStyles) {
            this._mergedStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedMergedStyles: function (value) {
        if (value !== this._fixedMergedStyles) {
            this._fixedMergedStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setCreatedStyles: function (value) {
        if (value !== this._createdStyles) {
            this._createdStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setUpdatedStyles: function (value) {
        if (value !== this._updatedStyles) {
            this._updatedStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setDeletedStyles: function (value) {
        if (value !== this._deletedStyles) {
            this._deletedStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setCheckedStyles: function (value) {
        if (value !== this._checkedStyles) {
            this._checkedStyles.assign(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedRowBarStyles: function (value) {
        if (value !== this._fixedRowBarStyles) {
            this._fixedRowBarStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedColumnBarStyles: function (value) {
        if (value !== this._fixedColumnBarStyles) {
            this._fixedColumnBarStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setSelectionStyles: function (value) {
        if (value !== this._selectionStyles) {
            this._selectionStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setMobileSelectionStyles: function (value) {
        if (value !== this._mobileSelectionStyles) {
            this._mobileSelectionStyles.extend(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setRowDynamicStyles: function (value) {
        if (value !== this._rowDynamicStyles) {
            this._rowDynamicStyles.setItems(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setCellDynamicStyles: function (value) {
        if (value !== this._cellDynamicStyles) {
            this._cellDynamicStyles.setItems(value);
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setIgnoreRowStylesOnFixed: function (value) {
        if (value != this._ignoreRowStylesOnFixed) {
            this._ignoreRowStylesOnFixed = value;
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setIgnoreColumnStylesOnFixed: function (value) {
        if (value != this._ignoreColumnStylesOnFixed) {
            this._ignoreColumnStylesOnFixed = value;
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setIgnoreDynamicStylesOnFixed: function (value) {
        if (value != this._ignoreDynamicStylesOnFixed) {
            this._ignoreDynamicStylesOnFixed = value;
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedColumnBarWidth: function (value) {
        value = Math.max(0, value);
        if (value != this._fixedColumnBarWidth) {
            this._fixedColumnBarWidth = value;
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setFixedRowBarHeight: function (value) {
        value = Math.max(0, value);
        if (value != this._fixedRowBarHeight) {
            this._fixedRowBarHeight = value;
            this._grid && this._grid.refreshView();
        }
        return this;
    },
    setStyleCallback: function (value) {
        value = _asFunction(value);
        if (value !== this._styleCallback) {
            this._styleCallback = value;
            this._grid && this._grid.refreshView();
        }
    },
    rowRuntime: function () {
        return this._rowRuntime;
    },
    cellRunTime: function () {
        return this._cellRuntime;
    },
    getCell: function (index, mergeRoom) {
        var cell, colStyles, runBodyStyles, runStyles, dyn, f, cs, callback,
            grid = this._grid,
            item = index.getRow(grid),
            column = index.column,
            dataColumn = column instanceof DataColumn ? column : null,
            fixed = index.isFixed(grid);
        cell = mergeRoom ? this.$_getMergedCell(mergeRoom, column, fixed) : this.$_getCell(column, fixed);
        cell.setIndex(index);
        colStyles = this._runCellStyles;
        colStyles.clearValues();
        if (fixed && this._fixedColIgnore) {
            colStyles.setParent(mergeRoom ? this._fixedMergedStyles : this._fixedCellStyles, false);
            colStyles._sysDefault = undefined;
        } else {
            if (mergeRoom) {
                column._styles.setParent(fixed ? this._fixedMergedStyles : this._mergedStyles, false);
            } else {
                column._styles.setParent(fixed ? this._fixedCellStyles : this._cellStyles, false);
            }
            colStyles.setParent(column._styles, false);
            colStyles._sysDefault = column._runStyles;
        }
        if (this._dataSource && cell !== this._groupCell) {
            this._styleTargets.body = !fixed;
            this._styleTargets.fixed = fixed;
            if (column.$_dynRowCount > 0) {
                runBodyStyles = this._runBodyStyles;
                runBodyStyles.clearValues();
                runBodyStyles.setParent(colStyles, false);
                this._rowRuntime.setItem(item);
                dyn = this._rowDynMap[item.dataIndex()];//index.rowIndex];
                if (!dyn) {
                    this._rowDynMap[item.dataIndex()] = dyn = this._rowDynamicStyles.getAppliables(this._rowRuntime, {});
                }
                for (f in dyn) {
                    dyn[f].setter.call(runBodyStyles, dyn[f].value);
                }
            } else {
                runBodyStyles = colStyles;
            }
            if (column.$_dynCellCount > 0 || column.$_dynColCount > 0) {
                runStyles = this._runDynStyles;
                runStyles.clearValues();
                runStyles.setParent(runBodyStyles, false);
                if (column.$_dynCellCount > 0) {
                    this._cellRuntime.setCell(cell);
                    this._cellDynamicStyles.applyInternal(this._cellRuntime, runStyles, this._styleTargets);
                }
                if (column.$_dynColCount > 0) {
                    this._cellRuntime.setCell(cell);
                    column._dynamicStyles.applyInternal(this._cellRuntime, runStyles, this._styleTargets);
                }
                cell._styles = runStyles;
            } else {
                cell._styles = runBodyStyles;
            }
            if (dataColumn && this._hasCellStyles) {
                cs = this._styleManager.getStyleAt(item.dataIndex(), dataColumn._dataIndex);
                cell.setCellStyles(cs);
            } else {
                cell.setCellStyles(null);
            }
        } else {
            cell.setStyles(colStyles);
        }
        callback = column.$_styleCallback;
        if (callback) {
            callback(index, cell._styles, cell.merged());
        }
        if (dataColumn) {
            if (grid.isRowEditing(item)) {
                cell.setError(dataColumn.error());
                cell.setErrorLevel(dataColumn.errorLevel());
            } else {
                cell.setError(null);
            }
        }
        if (runStyles = this._runStateStyles[item.$_state]) {
            runStyles._parent = cell._styles;
            cell._styles = runStyles;
        }
        if (item.$_checked && this._runCheckedStyles) {
            this._runCheckedStyles._parent = cell._styles;
            cell._styles = this._runCheckedStyles;
        }
        return cell;
    },
    getCellSimple: function (index, merged) {
        var col = index._column,
            cell = merged ? this._mergedCell :
                    col instanceof SeriesColumn ? this._seriesCell :
                    col instanceof LabelCell ? this._labelCell :
                    col instanceof ColumnGroup ? this._groupCell : this._dataCell;
        cell.setIndex(index);
        return cell;
    },
    addDynamicStyle: function (criteria, styles) {
    },
    _doPrepareUpdate: function () {
        var proto,
            grid = this._grid = this.owner(),
            palettes = grid._palettes._palettes;
        this._items = grid.itemSource();
        this._fixedColIgnore = this._ignoreColumnStylesOnFixed;
        this._fixedDynIgnore = this._ignoreDynamicStylesOnFixed;
        this._rowRangeStyles.$_prepareRender(palettes, this._ignoreRowStylesOnFixed);
        this._runStateStyles = {};
        if (!this._createdStyles.isEmpty()) this._runStateStyles[DataRowState.CREATED] = this._createdStyles;
        if (!this._updatedStyles.isEmpty()) this._runStateStyles[DataRowState.UPDATED] = this._updatedStyles;
        if (!this._deletedStyles.isEmpty()) this._runStateStyles[DataRowState.CREATE_AND_DELETED] = this._runStateStyles[DataRowState.DELETED] = this._deletedStyles;
        this._runCheckedStyles = this._checkedStyles.isEmpty() ? null : this._checkedStyles;
        this._styleManager = grid.styleManager();
        this._hasCellStyles = !this._styleManager.isEmpty();
        this._dataSource = grid.dataSource();
        this._rowRuntime.setDataSource(this._dataSource);
        this._cellRuntime.setDataSource(this._dataSource);
        this._mergeValueRuntime.setDataSource(this._dataSource);
        this._rowDynMap = {};
        this._palettes = palettes;
        grid.cellRendererRuntime().setDataSource(this._dataSource);
        proto = DynamicStyleCollection.prototype;
        proto.applyInternal = this._grid._userMode ? proto.applyInternalUserMode : proto.applyInternalNormal;
    },
    _doClearStyles: function () {
        this._emptyStyles.clearValues();
        this._emptyDataStyles.clearValues();
        this._rowStyles.clearValues();
        this._fixedRowStyles.clearValues();
        this._cellStyles.clearValues();
        this._fixedCellStyles.clearValues();
        this._mergedStyles.clearValues();
        this._fixedMergedStyles.clearValues();
        this._createdStyles.clearValues();
        this._updatedStyles.clearValues();
        this._deletedStyles.clearValues();
        this._checkedStyles.clearValues();
        this._fixedRowBarStyles.clearValues();
        this._fixedColumnBarStyles.clearValues();
        this._selectionStyles.clearValues();
        this._mobileSelectionStyles.clearValues();
        this._runCellStyles.clearValues();
        this._runDynStyles.clearValues();
        this._runBodyStyles.clearValues();
        this._rowDynamicStyles.clear();
        this._cellDynamicStyles.clear();
    },
    $_getCell: function (column, fixed) {
        var dc,
            cell = column.$_cell;
        if (!cell) {
            dc = false;
            if (column instanceof SeriesColumn) {
                if (column instanceof ChartColumn) {
                    cell = this._chartCell;
                } else {
                    cell = this._seriesCell;
                }
            } else if (column instanceof LabelColumn) {
                cell = this._labelCell;
            } else if (column instanceof CalculatedColumn) {
                dc = true;
                cell = this._calcedCell;
            } else if (column instanceof ColumnGroup) {
                cell = this._groupCell;
            } else {
                dc = true;
                cell = this._dataCell;
            }
            column.$_cell = cell;
            if (cell !== this._groupCell) {
                if (!fixed || !this._fixedDynIgnore) {
                    column.$_dynRowCount = dc && column._ignoreRowDynamicStyles ? 0 : this._rowDynamicStyles.count();
                    column.$_dynCellCount = column._ignoreDefaultDynamicStyles ? 0 : this._cellDynamicStyles.count();
                    column.$_dynColCount = dc ? column._dynamicStyles.count() : 0;
                }
            }
        }
        return cell;
    },
    $_getMergedCell: function (mergeRoom, column, fixed) {
        if (column instanceof SeriesColumn) {
            if (column instanceof ChartColumn) {
                cell = this._mergedChartCell;
            } else {
                cell = this._mergedSeriesCell;
            }
        } else {
            cell = this._mergedCell.$_setMergeValue(column._mergeValueNode, this._mergeValueRuntime);
        }
        cell._room = mergeRoom;
        if (!fixed || !this._fixedDynIgnore) {
            column.$_dynCellCount = column._ignoreDefaultDynamicStyles ? 0 : this._cellDynamicStyles.count();
            column.$_dynColCount = column._dynamicStyles ? column._dynamicStyles.count() : 0;
        }
        return cell;
    },
    $_hasDynamicStyles: function (item, column) {
        if (this._hasCellStyles && column instanceof DataColumn) {
            if (this._styleManager.getStyleAt(item.dataIndex(), column._dataIndex)) {
                return true;
            }
        }
        return this._runStateStyles[item.$_state] || (item.$_checked && this._runCheckedStyles);
    }
});
var RowHoverMask = defineClass("RowHoverMask", VisualObject, {
    init: function (grid) {
        this._super(grid, 'rowHoverMask');
        this._visible = false;
    },
    extent: EnumProp(RowHoverMaskExtent, RowHoverMaskExtent.DATA)
});
var $_SBAR_MIN_WIDTH = 8;
var ScrollBar = defineClass("ScrollBar", VisualObject, {
    init: function (grid, config) {
        this._super(grid, 'scrollBar');
        this._buttonStyles = new GridStyles(this, 'scrollButton');
        this._thumbStyles = new GridStyles(this, 'scrollThumb');
        this._indentStyles = new GridStyles(this, 'scrollIndent');
        config && this.assign(config);
    },
    buttonStyles: null,
    thumbStyles: null,
    indentStyles: null,
    barWidth: 16,
    barIndent: EnumProp(ScrollBarIndent, ScrollBarIndent.NONE),
    buttonLocation: EnumProp(ScrollButtonLocation, ScrollButtonLocation.NORMAL),
    lineScrollSize: IntProp(1),
    pageScrollSize: IntProp(1),
    minThumbSize: IntProp(20),
    setButtonStyles: function (value) {
        if (value !== this._buttonStyles) {
            this._buttonStyles.extend(value);
        }
        return this;
    },
    setThumbStyles: function (value) {
        if (value !== this._thumbStyles) {
            this._thumbStyles.extend(value);
        }
        return this;
    },
    setIndentStyles: function (value) {
        if (value !== this._indentStyles) {
            this._indentStyles.extend(value);
        }
        return this;
    },
    setBarWidth: function (value) {
        value = parseInt(value);
        if (!isNaN(value)) {
            value = Math.max($_SBAR_MIN_WIDTH, value);
            if (value != this._barWidth) {
                this._barWidth = value;
                this._changed();
            }
        }
    },
    displayWidth: function () {
        return this._visible ? this._barWidth : 0;
    }
});
/** @abstract */
var ColumnSummary = defineClass("ColumnSummary", GridObject, {
	init: function (column) {
		this._super();
		this._column = column;
		this._styles = new GridStyles(this, "columnSummary");
		this._dynamicStyles = new DynamicStyleCollection(this);
		this._exprNode = undefined;
		this._dirty = false;
	},
	stylesChanged: function (styleProp) {
		this._changed();
	},
	styles: null,
	text: null,
	expression: null,
    callback: null,         // function (scope): Number
    summaryCallback: null,  // function (column, group):Number - NaN을 리턴하면 계산하지 않은 것으로 판단.
	dynamicStyles: null,
	spanPrev: 0,
	spanNext: 0,
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
		}
        return this;
	},
    setText: function (value) {
        if (value != this._text) {
            this._text = value;
            this._changed();
        }
        return this;
    },
	$_clearSummary: function () {
		var grid = this._column.grid();
		grid && grid.clearRowSummary();
		this._changed();
	},
	setExpression: function (value) {
		value = trim(value);
		if (value != this._expression) {
			this._expression = value;
			if (value) {
				this._exprNode = ExpressionParser.Default.parse(value);
			} else {
				this._exprNode = undefined;
			}
			this.$_clearSummary();
		}
        return this;
	},
    setCallback: function (value) {
		value = _asFunction(value);
        if (value !== this._callback) {
            this._callback = value;
			this.$_clearSummary();
        }
        return this;
    },
    setSummaryCallback: function (value) {
		value = _asFunction(value);
        if (value !== this._summaryCallback) {
            this._summaryCallback = value;
			this.$_clearSummary();
        }
        return this;
    },
	setDynamicStyles: function (value) {
		this._dynamicStyles.setItems(value);
		this._changed();
        return this;
	},
	setSpanPrev: function (value) {
		value = Math.max(0, parseInt(value));
		if (!isNaN(value) && value !== this._spanPrev) {
			this._spanPrev = value;
			this._column.$_summarySpanChanged(this);
            this._changed();
		}
        return this;
	},
	setSpanNext: function (value) {
		value = Math.max(0, parseInt(value));
		if (!isNaN(value) && value !== this._spanNext) {
			this._spanNext = value;
			this._column.$_summarySpanChanged(this);
            this._changed();
		}
        return this;
	},
    column: function () {
        return this._column;
    },
    isDirty: function () {
        return this._dirty;
    },
    canSummary: function () {
        return this._callback || this._exprNode;
    },
	clean: function () {
		this._dirty = false;
	},
	/** @internal */
    evaluate: function (runtime) {
        if (this._callback) {
            return this._callback(runtime.scope());
        } else if (this._exprNode) {
            return this._exprNode.evaluate(runtime);
        }
        return undefined;
	},
	assign: function (value) {
		typeof value === "string" ? this.setText(value) : this._super(value);
	},
	_changed: function () {
		if (!this._dirty) {
			this.dirty = true;
			if (this._column instanceof ValueColumn) {
				this._column._footerChanged();
			}
		}
	}
});
var ColumnHeaderSummary = defineClass("ColumnHeaderSummary", ColumnSummary, {
	init: function (columnHeader) {
		this._super(columnHeader._column);
	}
});
var ColumnHeader = defineClass("ColumnHeader", GridObject, {
	init: function (column) {
        ColumnHeader.Base.init.call(this);
		this._column = column;
		this._summary = new ColumnHeaderSummary(this);
		this._styles = new GridStyles(this, "columnHeaderStyles");
        this._subStyles = new GridStyles(this, "columnHeaderSubStyles");
        this._popupMenuName = null;
		this._dirty = false;
	},
	stylesChanged: function (/*styleProp*/) {
		this._changed();
	},
    popupMenu: null,
    sortHandleVisibility: undefined,
    filterHandleVisibility: undefined,
    sortOrderVisibility: EnumProp(SortOrderVisibility, SortOrderVisibility.INHERIT),
	summary: null,
	styles: null,
    subStyles: null,
	text: null,
    subText: null,
    subTextGap: undefined,
    itemOffset: undefined,
    itemGap: undefined,
    subTextLocation: EnumProp(SubTextLocation, SubTextLocation.DEFAULT),
    imageIndex: -1,
    imageUrl: null,
	imageOffset: undefined,
	checkLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.DEFAULT),
	imageLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.DEFAULT),
    handleOffset: undefined,
    handleGap: undefined,
    menuHandleWidth: undefined,
    setPopupMenu: function (value) {
        if (value != this._popupMenu) {
            if (_isArray(value) || _isObject(value)) {
                this._popupMenu = value;
                this._popupMenuName = null;
            } else if (value) {
                this._popupMenu = null;
                this._popupMenuName = String(value);
            } else {
                this._popupMenu = null;
                this._popupMenuName = null;
            }
            this._changed();
			this._popupMenuChanged = true;
        }
        return this;
    },
    $_checkPopupMenu: function (grid) {
        var v;
        if ((v = this._popupMenu) && !this._popupMenuName) {
            this._popupMenuName = '$$_column_' + ++$_autoinc + '_menu';
            grid.registerPopupMenu(this._popupMenuName, _isArray(v) ? v : [v]);
        }
    },
    popupMenuName: function () {
        return this._popupMenuName;
    },
    column: {
        get: function () {
            return this._column;
        },
        set: null
    },
	setSummary: function (value) {
		if (value != this._summary) {
			this._summary.assign(value);
			this._changed();
		}
        return this;
	},
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
			this._changed();
		}
        return this;
	},
    setSubStyles: function (value) {
        if (value !== this._subStyles) {
            this._subStyles.extend(value);
			this._changed();
        }
        return this;
    },
	displayText: function () {
        var fld, s = this._text;
		if (s === undefined || s === null) {
			if (!s && this._column instanceof DataColumn) {
				fld = this._column.getDataField();
				if (fld) {
					s = fld.header() || fld.fieldName();
				} else {
					s = this._column.fieldName();
				}
			}
			if (!s) {
				s = this._column.name();
			}
			if (!s && this._column instanceof LabelColumn) {
				s = this._column.text();
			}
		}
		return s;
	},
	clean: function () {
		this._dirty = false;
	},
    hasMenu: function () {
        return this._popupMenuName;
    },
	assign: function (value) {
		typeof value === "string" ? this.setText(value) : this._super(value);
	},
	_changed: function () {
		if (!this._dirty) {
			this.dirty = true;
			if (this._column) {
				this._column._headerChanged();
			}
		}
	}
});
var ColumnFooter = defineClass("ColumnFooter", ColumnSummary, {
	init: function (column) {
		this._super(column);
	}
});
var ColumnGroupSummary = defineClass("ColumnGroupSummary", ColumnSummary, {
	init: function (column) {
		this._super(column);
	}
});
var GridColumn = defineClass("GridColumn", null, {
	init: function (config) {
		this._super();
		this._initColumn();
		config && this.assign(config);
	},
	_initColumn: function () {
		this._header = this._createHeader();
        this._footer = this._createFooter();
        this._groupFooter = this._createGroupFooter();
		this._groupSummary = this._createGroupSummary();
		this._styles = new GridStyles(this, "columnStyles");
		this._index = -1;
		this._layoutRect = new Rectangle();
		this._orgWidth = NaN;
        this._groupWidth = NaN;
        this._displayOffset = NaN;
        this._displayWidth = NaN;
		this._fitOffset = NaN;
		this._fitWidth = NaN;
		this._measuredHeight = -1;
		this._dataRoot = null;
		this._distance = 0;
		this._value = UNDEFINED;
		this._states = {};
		this._parent = null;
        this.$_grid = null;
        this.$_fixed = false;
		this._palettes = null;
		this._dirty = false;
	},
	stylesChanged: function (styles, styleProp) {
        this._changed();
	},
    getPaletteScope: function () {
        return this;
    },
	getPalette: function (pal) {
		return this._palettes[pal];
	},
	getPaletteIndex: function (index) {
		return index;
	},
	header: null,
    footer: null,
    groupFooter: null,
	groupSummary: null,
	styles: null,
	name: null,
	tag: null,
	visible: true,
	width: 100,
	height: 0,
	/* @internal */ saveWidth: NaN,
	fillWidth: 0,
	fillHeight: 0,
	resizable: true,
	movable: true,
	styleName: null,
	displayIndex: -1,
    checked: false,
	userData: null, // dataludi는 손대지 않는다. 그리드 개발자들이 임의로 사용할 수 있도록 한다.
	grid: function () {
		return this._parent ? this._parent.grid() : null;
	},
	parent: function () {
		return this._parent;
	},
	setParent: function (value) {
		var grid = this.grid(),
			old = this._parent;
		if (value != old) {
			if (old) {
				old._removeInternal(this);
			}
			if (value instanceof ColumnGroup) {
				value.$_addInternal(this);
			} else {
				this._parent = null;
			}
			if (grid) {
				grid._columnsReset();
				grid._columnParentChanged(this, old, value);
			}
		}
	},
	group: function () {
		return (this._parent instanceof RootColumn) ? null : this._parent;
	},
	root: function () {
		var g = this.group();
		return g ? g.root() : this;
	},
	isRoot: function () {
		return this === this.root();
	},
	dataRoot: function () {
		return this._dataRoot;
	},
	isDataRoot: function () {
		return this._dataRoot === this;
	},
	isDirty: function () {
		return this._dirty || this._header._isDirty;
	},
	setHeader: function (value) {
		if (value !== this._header) {
			if (typeof value == "string") {
				value = { text: value };
			} else if (typeof value == "boolean") {
                value = { visible: value };
            }
			this._header.assign(value);
		}
        return this;
	},
    setFooter: function (value) {
		if (value !== this._footer) {
			this._footer.assign(value);
		}
        return this;
    },
    setGroupFooter: function (value) {
		if (value !== this._groupFooter) {
			this._groupFooter.assign(value);
		}
        return this;
    },
	setVisible: function (value) {
		if (value != this._visible) {
			this._visible = value;
			this._invalidateSize();
			this._invalidateVisible();
			var grid = this.grid();
			grid && grid._columnVisibleChanged(this);
		}
        return this;
	},
	setWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._width) {
			var wOld = this._width;
			this._width = value;
            if (!this.group() || isNaN(this._groupWidth) || isNaN(this._displayWidth)) {
                this._displayWidth = this._groupWidth = value;
            }
			this._widthChanged(wOld, value);
			this._invalidateSize();
		} else if (!this.group() || isNaN(this._groupWidth) || isNaN(this._displayWidth)) {
			this._displayWidth = this._groupWidth = value;
		}
        return this;
	},
	setHeight: function (value) {
		value = _int(Math.max(0, value));
		if (value != this._height) {
			this._height = value;
			this._changed();
		}
        return this;
	},
	setFillWidth: function (value) {
		value = _int(Math.max(0, value));
		if (value != this._fillWidth) {
			this._fillWidth = value;
			this._changed();
		}
        return this;
	},
	setFillHeight: function (value) {
		value = _int(Math.max(0, value));
		if (value != this._fillHeight) {
			this._fillHeight = value;
			this._changed();
		}
        return this;
	},
    groupWidth: function () {
        return this._groupWidth;
    },
	displayOffset: function () {
        return isNaN(this._fitOffset) ? this._displayOffset : this._fitOffset;
	},
	displayWidth: {
		get: function () {
            return isNaN(this._fitWidth) ? this._displayWidth : _int(this._fitWidth);
		},
		set: function (value) {
			value = Math.max(0, value);
			var w = this.displayWidth();
			isNaN(w) && (w = 0);
			if (!isNaN(value) && value != w) {
				ColumnGroup.changeWidth(this, value - w);
			}
			/*
			 if (isNaN(w)) w = 0;
			 if (value != w) {
			 ColumnGroup.changeWidth(this, value - w);
			 }
			 */
		}
	},
	saveWidth_: function () {
		return isNaN(this._fitWidth) ? this._groupWidth : this._fitWidth;
	},
	setSaveWidth: function (value) {
		this._saveWidth = value;
	},
	measuredHeight: function () {
		return this._measuredHeight;
	},
	index: function () {
		return this._index;
	},
	displayIndex_: function () {
		return (this._visible && this._parent) ? this._displayIndex : -1;
	},
	setDisplayIndex: function (value) {
        if (this._parent) {
            if (value < 0) {
                this.setVisible(false);
            } else {
                value = Math.min(value, this._parent.visibleCount() - 1);
				this.setVisible(true);
                this._parent.setChildDisplayIndex(this, value);
            }
        }
        return this;
	},
	setStyleName: function (value) {
		if (value != this._styleName) {
			var oldName = this._styleName;
			this._styleName = value;
			var grid = this.grid();
			grid && grid.$_columnStyleNameChanged(this);
		}
        return this;
	},
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
			this._changed();
		}
        return this;
	},
    setChecked: function (value) {
        if (value != this._checked) {
            this._checked = value;
            this._changed();
            var grid = this.grid();
            grid && grid._columnChecked(this, value);
        }
        return this;
    },
	distance: function () {
		return this._distance;
	},
	displayText: function () {
		return this._name ? this._name : this.header() ? this.header().text()  : "col:" + this._index;
	},
	/** @deprecated use fixed() instead. */
	isFixed: function () {
		return this.$_fixed;
	},
    fixed: function () {
        return this.$_fixed;
    },
    delegateOwner: function () {
        var owner = this.$_delegateOwner;
        return owner ? (owner.delegateOwner() || owner) : null;
    },
    canEditable: function () {
        return false;
    },
    canEdit: function () {
        return false;
    },
    canMerge: function () {
        return false;
    },
	prepareLayout: function (grid, fixed, fixedCols) {
        this.$_grid = grid;
        this.$_fixed = fixed;
		this.$_cell = undefined;
		this.$_dynRowCount = this.$_dynCellCount = this.$_dynColCount = 0;
		this._palettes = grid._palettes._palettes;
		if (this._header._popupMenuChanged) {
			this._header.$_checkPopupMenu(grid);
			this._header._popupMenuChanged = false;
		}
	},
	clean: function () {
		this._dirty = false;
		this._header.clean();
	},
	$_getOffset: function () {
		var x = 0,
			c = this,
			p = c.group();
		while (p) {
			x += c._displayOffset;
			c = p;
			p = p.group();
		}
		return x;
	},
	stateFor: function (state) {
		return this._states[state];
	},
	setState: function (state, value) {
		this._states[state] = value;
	},
	proxy: function () {
		var p = this._super();
		p.type = this.constructor.$_columnType;
		return p;
	},
	propertyChanged: function (/*prop, oldValue, newValue*/) {
		this._changed();
	},
	_setParent: function (group, grid) {
		if (group != this._parent) {
			var old = group;
			if (group) {
				group._columnRemoved(this);
			}
			this._parent = group;
			if (group) {
				group._columnAdded(this);
			}
			this._parentChanged();
			grid && grid._columnParentChanged(this, old, group);
		}
	},
	_parentChanged: function () {
	},
	_createHeader: function () {
		return new ColumnHeader(this);
	},
    _createFooter: function () {
        return new ColumnFooter(this);
    },
    _createGroupFooter: function () {
        return new ColumnFooter(this);
    },
	_createGroupSummary: function () {
		return new ColumnGroupSummary(this);
	},
	_headerChanged: function () {
		this._changed();
	},
	_widthChanged: function (oldWidth, newWidth) {
		var grid = this.grid();
		if (grid) {
			this._dirty = true;
			grid.$_columnWidthChanged(this, oldWidth, newWidth);
		}
	},
	_invalidateSize: function () {
		var grid = this.grid();
		if (grid) {
			this._dirty = true;
			grid.invalidateColumnWidths();
		}
	},
	_invalidateVisible: function () {
		var grid = this.grid();
		grid && grid._columnDisplayIndexChanged();
	},
	_changed: function () {
		if (!this._dirty) {
			this._dirty = true;
			var grid = this.grid();
			grid &&	grid.invalidateColumns();
		}
	},
	_canSplit: function () {
		return true;
	},
	$_summarySpanChanged: function (summary) {
		if (this._parent) {
			if (summary === this._footer) {
                this._parent.$_childFooterSpanChanged(this);
            } else if (summary === this._groupFooter) {
                this._parent.$_childGroupFooterSpanChanged(this);
			} else if (summary === this._header._summary) {
				this._parent.$_childSummarySpanChanged(this);
			}
		}
	},
    $_hasDynamicStyles: function () {
        return this.$_dynCellCount > 0 || this.$_dynColCount > 0 || this.$_dynRowCount > 0 || _isFunction(this._styleCallback);
    }
}, {
	compareLoc: function (col1, col2) {
		if (col1 == null || col2 == null) {
			return 0;
		}
		if (col1 == null) {
			return -1;
		}
		if (col2 == null) {
			return 1;
		}
		var idx1 = col1.root().displayIndex();
		var idx2 = col2.root().displayIndex();
		if (idx1 == idx2) {
			if (col1.group() == col2.group()) {
				idx1 = col1.displayIndex();
				idx2 = col2.displayIndex();
			} else {
				idx1 = col1.dataRoot().displayIndex();
				idx2 = col2.dataRoot().displayIndex();
			}
		}
		return idx1 - idx2;
	},
    $_ALL: {}
});
var _compCL = GridColumn.compareLoc;
var ColumnGroupHeader = defineClass("ColumnGroupHeader", ColumnHeader, {
	init: function (group) {
		ColumnGroupHeader.Base.init.call(this, group);
	},
	visible: true,
	group: function () {
		return this._column;
	}
});
var ColumnGroup = defineClass("ColumnGroup", GridColumn, {
	init: function (config) {
		this._super(config);
		this._headerLevel = this._dataLevel = this._footerLevel = this._headerSummaryLevel =
            this._groupHeaderLevel = this._groupFooterLevel = 0;
	},
	_initColumn: function() {
		this._super();
		this._columns = new ColumnCollection(this);
		this._sum = UNDEFINED;
		this._childFooterSpansDirty = true;
        this._childGroupFooterSpansDirty = true;
		this._childSummarySpansDirty = true;
	},
	layout: EnumProp(ColumnGroupLayout, ColumnGroupLayout.HORIZONTAL),
	columns: null,
	headerDelegate: null,
	footerDelegate: null,
    groupFooterDelegate: null,
    summaryDelegate: null,
    childHeadersVisible: true,
    childFootersVisible: true,
    childGroupFootersVisible: true,
	childSummariesVisible: true,
	setLayout: function (value) {
		if (_checkEnumValue(ColumnGroupLayout, value) != this._layout) {
			this._layout = value;
			this.resetGroupWidths();
			this._changed();
		}
	},
	columns_: function () {
		return this._columns.items();
	},
	setColumns: function (value, attachKey) {
        var i, cnt, grid, column, col,
			grid = this.grid(),
		    columns = this._columns;
		columns.clear();
		if (value && (cnt = value.length) > 0) {
			for (i = 0; i < cnt; i++) {
				column = value[i];
				if (!(column instanceof GridColumn)) {
					col = GridBase.createColumn(column, attachKey);
					this._columns.add(col);
				} else if (columns.indexOf(column) < 0) {
					this._columns.add(column);
				}
			}
			this.$_attachChildren(grid);
		}
		if (grid) {
			grid._columnsReset(this);
		}
	},
	setHeaderDelegate: function (value) {
		if (value != this._headerDelegate) {
			this._headerDelegate = value;
			this._changed();
		}
	},
	setFooterDelegate: function (value) {
		if (value != this._footerDelegate) {
			this._footerDelegate = value;
			this._changed();
		}
	},
    setGroupFooterDelegate: function (value) {
        if (value != this._groupFooterDelegate) {
            this._groupFooterDelegate = value;
            this._changed();
        }
    },
    setSummaryDelegate: function (value) {
        if (value != this._summaryDelegate) {
            this._summaryDelegate = value;
            this._changed();
        }
    },
    setChildHeadersVisible: function (value) {
        if (value != this._childHeadersVisible) {
            this._childHeadersVisible = value;
            this._changed();
        }
    },
	/** @deprecated */
	hiddenChildHeaders: function (value) {
		return !this.childHeadersVisible(!value);
	},
	/** @deprecated */
	setHiddenChildHeaders: function (value) {
		this.setChildHeadersVisible(!value);
	},
	setChildSummariesVisible: function (value) {
		if (value != this._childSummariesVisible) {
			this._childSummariesVisible = value;
			this._changed();
		}
	},
	/** @deprecated */
	hiddenChildHeaderSummaries: function (value) {
		return !this.childSummariesVisible(!value);
	},
	/** @deprecated */
	setHiddenChildHeaderSummaries: function (value) {
		this.setChildSummariesVisible(!value);
	},
    setChildFootersVisible: function (value) {
        if (value != this._childFootersVisible) {
            this._childFootersVisible = value;
            this._changed();
        }
    },
    setChildGroupFootersVisible: function (value) {
        if (value != this._childGroupFootersVisible) {
            this._childGroupFootersVisible = value;
            this._changed();
        }
    },
	/** @deprecated */
	hiddenChildFooters: function (value) {
		return !this.childFootersVisible(!value);
	},
	/** @deprecated */
	setHiddenChildFooters: function (value) {
		this.setChildFootersVisible(!value);
	},
    visibleItems: function () {
        return this._columns.visibleItems();
    },
    hiddenItems: function () {
        return this._columns.hiddenItems();
    },
	/** @internal */
    headerLevel: function () {
		return this._headerLevel;
	},
    /** @internal */ 
    dataLevel: function () {
        return this._dataLevel;
    },
	/** @internal */ 
    footerLevel: function () {
		return this._footerLevel;
	},
	/** @internal */ 
    headerSummaryLevel: function () {
		return this._headerSummaryLevel;
	},
    /** @internal */ 
    groupHeaderLevel: function () {
        return this._groupHeaderLevel;
    },
    /** @internal */ 
    groupFooterLevel: function () {
        return this._groupFooterLevel;
    },
	count: function () {
		return this._columns.count();
	},
	visibleCount: function () {
		return this._columns.visibleCount();
	},
	/** @deprecated use vertical() instead. */
	isVertical: function () {
		return this._layout == ColumnGroupLayout.VERTICAL;
	},
	/** @deprecated use horizontal() instead. */
	isHorizontal: function () {
		return this._layout != ColumnGroupLayout.VERTICAL;
	},
	vertical: function () {
		return this._layout == ColumnGroupLayout.VERTICAL;
	},
	horizontal: function () {
		return this._layout != ColumnGroupLayout.VERTICAL;
	},
	$_isVeritcalGrouped: function () {
		var n, i, col,
			v = this._layout == ColumnGroupLayout.VERTICAL && (n = this._columns.visibleCount()) > 1;
		if (!v) {
			for (i; i < n; i++) {
				col = this._columns.getVisibleItem(i);
				if (col instanceof ColumnGroup && column.$_verticalGrouped()) {
					return true;
				}
			}
		}
		return v;
	},
	first: function () {
		return $_getFirstColumn(this) || this;
	},
	last: function () {
		return $_getLastColumn(this) || this;
	},
	getVisibleColumns: function () {
		return this._columns.visibleItems();
	},
	getHiddenColumns: function () {
		return this._columns.hiddenItems();
	},
    visitAllChildren: function (callback) {
		if (callback) {
			for (var i = 0, cnt = this._columns.count(); i < cnt; i++) {
				var col = this._columns.getItem(i);
				if (callback(col) === false) {
					return false;
				}
				if (col instanceof ColumnGroup) {
					if (col.visitAllChildren(callback) === false) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
    },
    visitChildren: function (callback) {
        if (callback) {
            for (var i = 0, cnt = this._columns.visibleCount(); i < cnt; i++) {
                var col = this._columns.getVisibleItem(i);
                if (callback(col) === false) {
                    return false;
                }
                if (col instanceof ColumnGroup) {
                    if (col.visitChildren(callback) === false) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    },
	getItem: function (index) {
		return this._columns.getItem(index);
	},
	getVisibleItem: function (index) {
        if (index < 0 || index >= this._columns.visibleCount()) {
            throw "Invalid visible index: " + index;
        }
		return this._columns.getVisibleItem(index);
	},
	isAncestorOf: function (column) {
		if (column && column !== this) {
			var p = column._parent;
			while (p) {
				if (p === this) {
					return true;
				}
				p = p._parent;
			}
		}
		return false;
	},
    setChildrenProperty: function (prop, value, recursive, visibleOnly) {
        this._columns.setChildrenProperty(prop, value, recursive, visibleOnly);
    },
	/** @internal */
	calcHeaderLevels: function () {
		var levels = this.header().visible() ? 1 : 0;
        if (this.$_headerColumn instanceof ColumnGroup) {
            levels += this.$_headerColumn.calcHeaderLevels();
        } else if (this.$_headerColumn) {
            levels++;
        } else if (this._childHeadersVisible) {
			var	cols = this.visibleCount();
			var	cnt = 0;
			var i, group;
			if (cols > 0) {
				if (this.horizontal()) {
					cnt = 1;
					for (i = 0; i < cols; i++) {
						group = this.getVisibleItem(i);
						if (group instanceof ColumnGroup) {
							cnt = Math.max(cnt, group.calcHeaderLevels());
						}
					}
				} else {
					for (i = 0; i < cols; i++) {
						group = this.getVisibleItem(i);
						if (group instanceof ColumnGroup) {
							cnt += group.calcHeaderLevels();
						} else {
							cnt++;
						}
					}
				}
			}
			levels += cnt;
		}
		return this._headerLevel = Math.max(1, levels);
	},
	/** @internal */
	calcDataLevels: function (ignoreSpan) {
        var i, group,
		    columns = this._columns,
		    levels = 0,
		    cols = this.visibleCount(),
		    cnt = 0;
		if (cols > 0) {
			if (this.horizontal()) {
				cnt = 1;
				for (i = 0; i < cols; i++) {
					group = columns.getVisibleItem(i);
					if (group instanceof ColumnGroup) {
						cnt = Math.max(cnt, group.calcDataLevels(ignoreSpan));
					}
				}
			} else {
				for (i = 0; i < cols; i++) {
					group = columns.getVisibleItem(i);
					if (group instanceof ColumnGroup) {
						cnt += group.calcDataLevels(ignoreSpan);
					} else {
						cnt++;
					}
				}
			}
		}
		return this._dataLevel = levels + cnt;
	},
	/** @internal */
	calcFooterLevels: function (ignoreSpan) {
        if (this.$_footerColumn instanceof ColumnGroup) {
            return this.$_footerColumn.calcFooterLevels(ignoreSpan);
        } else if (this.$_footerColumn) {
            return 1;
        } else if (!this._childFootersVisible) {
			return 0;
		}
		var	levels = 0;
		var	cnt = 0;
        var	cols = this.visibleCount();
		if (cols > 0) {
            var columns = this._columns;
            var i, group;
            if (this.horizontal()) {
                cnt = 1;
                for (i = 0; i < cols; i++) {
                    group = columns.getVisibleItem(i);
                    if (group instanceof ColumnGroup) {
                        cnt = Math.max(cnt, group.calcFooterLevels(ignoreSpan));
                    }
                }
            } else {
                var spans = !ignoreSpan && this.$_footerSpanned ? this.$_footerSpans : null;
                var prev;
                if (spans) {
                    prev = spans[0];
                    cnt = 1;
                    for (i = 1; i < spans.length; i++) {
                        group = spans[i];
                        if (group !== prev) {
                            if (group instanceof ColumnGroup) {
                                cnt += group.calcFooterLevels(ignoreSpan);
                            } else {
                                cnt++;
                            }
                            prev = group;
                        }
                    }
                } else {
                    for (i = 0; i < cols; i++) {
                        group = columns.getVisibleItem(i);
                        if (group instanceof ColumnGroup) {
                            cnt += group.calcFooterLevels(ignoreSpan);
                        } else {
                            cnt++;
                        }
                    }
                }
            }
		}
		return this._footerLevel = levels + cnt;
	},
    /** @internal */
	calcHeaderSummaryLevels: function (ignoreSpan) {
        if (this.$_summaryColumn instanceof ColumnGroup) {
            return this.$_summaryColumn.calcHeaderSummaryLevels(ignoreSpan);
        } else if (this.$_summaryColumn) {
            return 1;
        } else if (!this._childSummariesVisible) {
            return 0;
        }
        var	levels = 0;
        var	cnt = 0;
        var	cols = this.visibleCount();
        if (cols > 0) {
            var	columns = this._columns;
            var i, group;
            if (this.horizontal()) {
                cnt = 1;
                for (i = 0; i < cols; i++) {
                    group = columns.getVisibleItem(i);
                    if (group instanceof ColumnGroup) {
                        cnt = Math.max(cnt, group.calcHeaderSummaryLevels(ignoreSpan));
                    }
                }
            } else {
                var spans = !ignoreSpan && this.$_summarySpanned ? this.$_summarySpans : null;
                var prev;
                if (spans) {
                    prev = spans[0];
                    cnt = 1;
                    for (i = 1; i < spans.length; i++) {
                        group = spans[i];
                        if (group !== prev) {
                            if (group instanceof ColumnGroup) {
                                cnt += group.calcHeaderSummaryLevels(ignoreSpan);
                            } else {
                                cnt++;
                            }
                            prev = group;
                        }
                    }
                } else {
                    for (i = 0; i < cols; i++) {
                        group = columns.getVisibleItem(i);
                        if (group instanceof ColumnGroup) {
                            cnt += group.calcHeaderSummaryLevels(ignoreSpan);
                        } else {
                            cnt++;
                        }
                    }
                }
            }
        }
        return this._headerSummaryLevel = levels + cnt;
    },
    /** @internal */
	calcGroupHeaderLevels: function (ignoreSpan) {
        return this._groupHeaderLevel = 1;
    },
    /** @internal */
	calcGroupFooterLevels: function (ignoreSpan) {
        if (this.$_groupFooterColumn instanceof ColumnGroup) {
            return this.$_groupFooterColumn.calcGroupFooterLevels(ignoreSpan);
        } else if (this.$_groupFooterColumn) {
            return 1;
        } else if (!this._childGroupFootersVisible) {
            return 0;
        }
        var	levels = 0;
        var	cols = this.visibleCount();
        var	cnt = 0;
        if (cols > 0) {
            var	columns = this._columns;
            var i, group;
            if (this.horizontal()) {
                cnt = 1;
                for (i = 0; i < cols; i++) {
                    group = columns.getVisibleItem(i);
                    if (group instanceof ColumnGroup) {
                        cnt = Math.max(cnt, group.calcGroupFooterLevels(ignoreSpan));
                    }
                }
            } else {
                var spans = !ignoreSpan && this.$_groupFooterSpanned ? this.$_groupFooterSpans : null;
                var prev;
                if (spans) {
                    prev = spans[0];
                    cnt = 1;
                    for (i = 1; i < spans.length; i++) {
                        group = spans[i];
                        if (group !== prev) {
                            if (group instanceof ColumnGroup) {
                                cnt += group.calcGroupFooterLevels(ignoreSpan);
                            } else {
                                cnt++;
                            }
                            prev = group;
                        }
                    }
                } else {
                    for (i = 0; i < cols; i++) {
                        group = columns.getVisibleItem(i);
                        if (group instanceof ColumnGroup) {
                            cnt += group.calcGroupFooterLevels(ignoreSpan);
                        } else {
                            cnt++;
                        }
                    }
                }
            }
        }
        return this._groupFooterLevel = levels + cnt;
    },
	/** @interal */
    calcHorz: function () {
		var	column;
		var	cnt = this.visibleCount();
		var	result = 1;
        var i;
		if (cnt >= 1) {
			if (this.vertical()) {
				result = 1;
				for (i = 0; i < cnt; i++) {
					column = this.getVisibleItem(i);
					if (column instanceof ColumnGroup) {
						result = Math.max(result, column.calcHorz());
					}
				}
			} else {
				result = 0;
				for (i = 0; i < cnt; i++) {
					column = this.getVisibleItem(i);
					if (column instanceof ColumnGroup) {
						result += Math.max(1, column.calcHorz());
					} else {
						result++;
					}
				}
			}
		}
		return result;
	},
	right: function (column) {
		if (this.horizontal()) {
            try {
                var idx = this._checkVisible(column);
                if (idx < this.visibleCount() - 1) {
                    column = $_getRightColumn(this, idx + 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	left: function (column) {
		if (this.horizontal()) {
            try {
                var idx = this._checkVisible(column);
                if (idx > 0) {
                    column = $_getLeftColumn(this, idx - 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	next: function (column) {
        try {
            var idx = this._checkVisible(column);
            if (idx < this.visibleCount() - 1) {
                column = $_getNextColumn(this, idx + 1);
                return column;
            }
        } catch (err) {
        }
		return null;
	},
	prev: function (column) {
        try {
            var idx = this._checkVisible(column);
            if (idx > 0) {
                column = $_getPrevColumn(this, idx - 1);
                return column;
            }
        } catch (err) {
        }
		return null;
	},
	lower: function (column) {
		if (this.vertical()) {
            try {
                var idx = this._checkVisible(column);
                if (idx < this.count() - 1) {
                    column = $_getLowerColumn(this, idx + 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	upper: function (column) {
		if (this.vertical()) {
            try {
                var idx = this._checkVisible(column);
                if (idx > 0) {
                    column = $_getUpperColumn(this, idx - 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	columnAtPoint: function (x, y) {
		var i, column, group;
		var cnt = this.visibleCount();
		if (this.vertical()) {
			for (i = 0; i < cnt; i++) {
				column = this.getVisibleItem(i);
				if (y < column._layoutRect.bottom()) {
					group = _cast(column, ColumnGroup);
					if (group) {
						y -= column._layoutRect.y;
						return group.columnAtPoint(x, y);
					}
					return column;
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = this.getVisibleItem(i);
				if (x < column._layoutRect.right()) {
					group = _cast(column, ColumnGroup);
					if (group) {
						x -= column._layoutRect.x;
						return group.columnAtPoint(x, y);
					}
					return column;
				}
			}
		}
		return this;
	},
	$_addInternal: function (column, index) {
		if (column && !(column instanceof GridColumn)) {
			column = GridBase.createColumn(column);
		}
		if (column && !(column instanceof ColumnGroup && column.isAncestorOf(this)) && !this._columns.contains(column)) {
			this._columns.add(column, index);
            return column;
		}
		return null;
	},
	add: function (column, index) {
        if (column) {
            var grid;
            column = this.$_addInternal(column, index);
            if (column && (grid = this.grid())) {
                grid._columnsReset(this, column);
				grid._columnParentChanged(column, null, this);
            }
            return column;
        }
        return null;
	},
    addAll: function (columns) {
        var i, cnt, col, grid,
			list = [];
        if (_isArray(columns)) {
            for (i = 0, cnt = columns.length; i < cnt; i++) {
                col = this.$_addInternal(columns[i]);
                col && list.push(col);
            }
            if (list.length > 0 && (grid = this.grid())) {
                grid._columnsReset(this);
				for (i = 0, cnt = list.length; i < cnt; i++) {
					grid._columnParentChanged(list[i], null, this);
				}
            }
        }
        return list.length;
    },
	_removeInternal: function (column) {
		var index = this._columns.indexOf(column);
		if (index >= 0) {
			this._columns.removeAt(index);
			return true;
		}
		return false;
	},
	remove: function (column) {
		if (this._removeInternal(column)) {
			var grid = this.grid();
			if (grid) {
				grid._columnsReset(this);
				grid._columnParentChanged(column, this, null);
			}
			return true;
		}
		return false;
	},
	removeAt: function (index) {
		if (index >= 0 && index < this.count()) {
			this._columns.removeAt(index);
            var grid = this.grid();
			if (grid) {
				grid._columnsReset(this);
				grid._columnParentChanged(column, this, null);
			}
            return true;
		}
        return false;
	},
	clear: function () {
		if (this.count() > 0) {
			var i, cnt,
				grid = this.grid(),
				list = this._columns.items();
			this._columns.clear();
            if (grid) {
                grid._columnsReset(this);
				for (i = 0, cnt = list.length; i < cnt; i++) {
					grid._columnParentChanged(list[i], this, null);
				}
			}
		}
	},
	setChildIndex: function (column, newIndex) {
		var grid = this.grid();
		if (grid && column && column.parent() === this && column.index() != newIndex) {
			if (this._columns.move(column, newIndex)) {
				grid._columnIndexChanged(column);
                return true;
			}
		}
        return false;
	},
	setChildDisplayIndex: function (column, newIndex) {
		var old,
			grid = this.grid();
		if (grid && column && column.parent() === this) {
			old = column.displayIndex();
			if (this._columns.moveVisible(column, newIndex)) {
				grid._columnDisplayIndexChanged(column, old, newIndex);
                return true;
			}
		}
        return false;
	},
	/** @internal */
	initGroupWidths: function () {
		var i, column,
			cnt = this._columns.count();
		if (cnt < 1) {
			return;
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			column._displayWidth = column._groupWidth = NaN;
			if (column instanceof ColumnGroup) {
				column.initGroupWidths();
			}
		}
		/*
		var column, sum, i, w, len;
		var gw = this._groupWidth;
		if (this.vertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				sum += column._width;
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getItem(i);
				w = gw * column._width / sum;
				column._groupWidth = w;
				column._displayOffset = _int(len);
				len += w;
			}
			column = this._columns.getItem(cnt - 1);
			w = gw - len;
			column._groupWidth = w;
			column._displayOffset = _int(len);
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
				column.initGroupWidths();
			}
		}
		*/
	},
	/** @internal */
    restoreGroupWidths: function () {
		var gw, column, sum, i, w, len,
			cnt = this._columns.count();
		if (cnt < 1) {
			return;
		}
		gw = this._groupWidth;
		if (this.vertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				column._displayWidth = column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				sum += column._displayWidth = !isNaN(column._saveWidth) ? column._saveWidth : column.saveWidth();
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getItem(i);
				w = column._displayWidth * gw / sum;
				column._groupWidth = w;
				column._displayOffset = _int(len);
				len += w;
                column._displayWidth = _int(len) - column._displayOffset;
			}
			column = this._columns.getItem(cnt - 1);
			w = gw - len;
			column._groupWidth = w;
			column._displayOffset = _int(len);
            column._displayWidth = _int(len + w) - column._displayOffset;
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
				column.restoreGroupWidths();
			}
		}
	},
	/** @internal */
    resetGroupWidths: function () {
		var gw, i, column, sum, w, len,
			cnt = this._columns.visibleCount();
		if (cnt < 1) {
			return;
		}
		gw = this._groupWidth;
		if (this.vertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				column._displayWidth = column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				sum += column._displayWidth = column._width;// isNaN(column._groupWidth) ? column._width : column._groupWidth;
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getVisibleItem(i);
				w = sum == 0 ? 0 : gw * column._displayWidth / sum;
				column._groupWidth = w;
				column._displayOffset = _int(len);
				len += w;
                column._displayWidth = _int(len) - column._displayOffset;
			}
			column = this._columns.getVisibleItem(cnt - 1);
			w = gw - len;
			column._groupWidth = w;
			column._displayOffset = _int(len);
            column._displayWidth = _int(len + w) - column._displayOffset;
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getVisibleItem(i);
			if (column instanceof ColumnGroup) {
				column.resetGroupWidths();
			}
		}
	},
	collectColumns: function (list, columnsOnly) {
		var i, cnt, column;
		for (i = 0, cnt = this._columns.count(); i < cnt; i++) {
			column = this._columns.getItem(i);
			if ((!columnsOnly || !(column instanceof ColumnGroup))) {
				list.push(column);
			}
			if (column instanceof ColumnGroup) {
				column.collectColumns(list, columnsOnly);
			}
		}
	},
	collectGroups: function (list) {
		var i, cnt, group;
		for (i = 0, cnt = this._columns.count(); i < cnt; i++) {
			group = _cast(this._columns.getItem(i), ColumnGroup);
			if (group) {
				list.push(group);
				group.collectGroups(list);
			}
		}
	},
	collectColumnNames: function (list, columnsOnly) {
		var i, cnt, column, name;
		for (i = 0, cnt = this._columns.count(); i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column && (name = column.name()) && (!columnsOnly || !(column instanceof ColumnGroup))) {
                list.push(name);
			}
			if (column instanceof ColumnGroup) {
				column.collectColumnNames(list, columnsOnly);
			}
		}
		return list;
	},
	collectGroupNames: function (list) {
		var i, cnt, column, name;
		for (i = 0, cnt = this._columns.count(); i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
                name = column.name();
				name && list.push(name);
				column.collectGroupNames(list);
			}
		}
		return list;
	},
	/** @intenral */
	clearMergeGrouped: function () {
		var i, column,
			cnt = this._columns.count();
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof DataColumn) {
				column._setMergeGrouped(false);
			}
			if (column instanceof ColumnGroup) {
				column.clearMergeGrouped();
			}
		}
	},
	columnByName: function (name, ignoreCase) {
		return this._columns.columnByName(name, ignoreCase);
	},
	visibleColumnByName: function (name, ignoreCase) {
		return this._columns.visibleColumnByName(name, ignoreCase);
	},
	valueColumnByName: function (name, ignoreCase) {
		return this._columns.valueColumnByName(name, ignoreCase);
	},
	columnByField: function (fieldIndex, visibleOnly) {
		if (fieldIndex >= 0) {
			var i, column,
				cols = this._columns,
				cnt = visibleOnly ? cols.visibleCount() : cols.count();
			for (i = 0; i < cnt; i++) {
				column = visibleOnly ? cols.getVisibleItem(i) : cols.getItem(i);
				if (column instanceof DataColumn && column.dataIndex() == fieldIndex) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column.columnByField(fieldIndex, visibleOnly);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	collectColumnsByField: function (fieldIndex, list) {
		if (fieldIndex >= 0) {
			var i, cnt, colum;
			for (i = 0, cnt = this._columns.count(); i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column instanceof DataColumn && column.dataIndex() == fieldIndex) {
					list.push(column);
				}
				if (column instanceof ColumnGroup) {
					column.collectColumnsByField(fieldIndex, list);
				}
			}
		}
	},
	columnByTag: function (tag) {
		if (tag) {
			var i, column,
				cnt = this._columns.count();
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column.tag() == tag) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column.columnByTag(tag);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	collectColumnsByTag: function (tag, list) {
		if (tag) {
			var i, column,
				cnt = this._columns.count();
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column.tag() == tag) {
					list.push(column);
				}
				if (column instanceof ColumnGroup) {
					column.collectColumnsByTag(tag, list);
				}
			}
		}
	},
	getLeafColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
		var columns = [];
		$_collectColumns(this, columns, visibleOnly);
		return columns;
	},
    getValueColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        var columns = [];
        $_collectValueColumns(this, columns, visibleOnly);
        return columns;
    },
	getDataColumns: function (visibleOnly) {
		visibleOnly = arguments.length > 0 ? visibleOnly : true;
		var columns = [];
		$_collectDataColumns(this, columns, visibleOnly);
		return columns;
	},
	/** @internal */
	clearFitWidths: function () {
		this._columns.$_clearFitWidths();
	},
	/** @internal */
	resetFitWidths: function () {
		var gw, i, w, len, column, group, sum,
			cnt = this._columns.visibleCount();
		if (cnt < 1) {
			return;
		}
		gw = this._fitWidth;
		if (this.horizontal()) {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				sum += column._groupWidth;
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getVisibleItem(i);
				w = sum == 0 ? 0 : column._groupWidth * gw / sum;
				column._fitOffset = _int(len);
				len += w;
				column._fitWidth = _int(len) - column._fitOffset;
			}
			column = this._columns.getVisibleItem(cnt - 1);
			w = gw - len;
			column._fitOffset = len;
			column._fitWidth = _int(len + w) - column._fitOffset;
		} else {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				column._fitWidth = gw
				column._fitOffset = 0;
			}
		}
		for (i = 0; i < cnt; i++) {
			group = _cast(this._columns.getVisibleItem(i), ColumnGroup);
			if (group) {
				group.resetFitWidths();
			}
		}
	},
	setChildrenVisible: function (columns, visible) {
		var changed, i, col,
			grid = this.grid();
		if (grid) {
			changed = false;
			for (i = 0; i < columns.length; i++) {
				col = columns[i];
				if (col._visible != visible) {
					col._visible = visible;
					col._dirty = true;
					changed = true;
				}
			}
			if (changed) {
				grid.invalidateColumnWidths();
				grid._columnDisplayIndexChanged();
			}
		}
	},
	_createHeader: function () {
		return new ColumnGroupHeader(this);
	},
	clean: function () {
		this._super();
		for (var i = this.count(); i--;) {
			this.getItem(i).clean();
		}
	},
    canMerge: function () {
        return false;
    },
	prepareLayout: function (grid, fixed, fixedCols) {
        function getDelegateColumn(self, col) {
            var d = null;
            if (col instanceof GridColumn) {
                if (self._columns._visibles.indexOf(col) >= 0) {
                    d = col;
                }
            } else if (col) {
                d = self._columns.visibleColumnByName(col);
            }
            if (d) d.$_delegateOwner = self;
            return d;
        }
		this._super(grid, fixed);
		this.$_headerColumn = getDelegateColumn(this, this._headerDelegate);
		this.$_footerColumn = getDelegateColumn(this, this._footerDelegate);
        this.$_groupFooterColumn = getDelegateColumn(this, this._groupFooterDelegate);
        this.$_summaryColumn = getDelegateColumn(this, this._summaryDelegate);
		if (this._childFooterSpansDirty) {
			this.$_refreshChildFooterSpans(fixedCols);
			this._childFooterSpansDirty = false;
		}
        if (this._childGroupFooterSpansDirty && grid.canShowGroupFooters()) {
            this.$_refreshChildGroupFooterSpans(fixedCols);
            this._childGroupFooterSpansDirty = false;
        }
		if (this._childSummarySpansDirty) {
			this.$_refreshChildSummarySpans(fixedCols);
			this._childSummarySpansDirty = false;
		}
	},
	$_attachChildren: function (grid) {
		var i, column;
		for (i = this.count(); i--;) {
			column = this.getItem(i);
			column._setParent(this, grid);
			if (column instanceof ColumnGroup) {
				column.$_attachChildren(grid);
			}
		}
	},
	_columnAdded: function (column) {
	},
	_columnRemoved: function (column) {
	},
	initVisibles: function () {
		this._columns.$_initVisibles();
	},
	resetVisibles: function () {
		this._columns.$_resetVisibles();
		this._childFooterSpansDirty = true;
		this._childGroupFooterSpansDirty = true;
		this._childSummarySpansDirty = true;
	},
	resetStates: function () {
		this._columns.$_resetStates(this.grid());
	},
	resetIndices: function (grid) {
		this._columns.$_resetIndices(grid);
	},
	_checkVisible: function (column) {
		var i;
		if (!column || (i = column._displayIndex) < 0 || column !== this.getVisibleItem(i)) {
			throw new Error("Column is not a visible group member");
		}
		return i;
	},
	_clearSavedWidths: function () {
		var i, cnt, c;
		for (i = 0, cnt = this.count(); i < cnt; i++) {
			c = this.getItem(i);
			c._saveWidth = NaN;
			if (c instanceof ColumnGroup) {
				c._clearSavedWidths();
			}
		}
	},
	_saveOrgWidths: function () {
		var i, cnt, c;
		for (i = 0, cnt = this.count(); i < cnt; i++) {
			c = this.getItem(i);
			c._orgWidth = c.saveWidth();
			if (c instanceof ColumnGroup) {
				c._saveOrgWidths();
			}
		}
	},
	_restoreOrgWidths: function () {
		var i, cnt, c;
		for (i = 0, cnt = this.count(); i < cnt; i++) {
			c = this.getItem(i);
			c._saveWidth = c._orgWidth;
			if (c instanceof ColumnGroup) {
				c._restoreOrgWidths();
			}
		}
	},
    /*
	$_calcSpans: function (row, first, last) {
        if (this._spanned) {
            var cnt = this.visibleCount();
            var rules = this._spanRules;
            var spans = this._spans;
            var i = first;
            while (i <= last) {
                var fn = rules[i];
                if (fn) {
                    var n = parseInt(fn(this.getVisibleItem(i), row));
                    if (n > 1) {
                        spans[i] = 2;
                        for (var j = i + 1; j < cnt && j < i + n; j++) {
                            spans[j] = 0;
                        }
                        i += n;
                    } else {
                        spans[i++] = 1;
                    }
                } else {
                    spans[i++] = 1;
                }
            }
        }
	},
	*/
	$_childFooterSpanChanged: function (column) {
		this._childFooterSpansDirty = true;
	},
    $_childGroupFooterSpanChanged: function (column) {
        this._childGroupFooterSpansDirty = true;
    },
	$_childSummarySpanChanged: function (column) {
		this._childSummarySpansDirty = true;
	},
    $_refreshSpans: function (fixedCols, callback) {
        var col, model, col2, footer, prev, next, j, k,
            spans = [],
            spanned = false,
            cnt = this.visibleCount(),
            i = 0;
        while (i < fixedCols && i < cnt) {
            col = this.getVisibleItem(i);
            model = callback(col);
            prev = model.spanPrev();
            next = model.spanNext();
            if (!(col instanceof ColumnGroup) && (prev > 0 || next > 0)) {
                spans[i] = col;
                for (j = i - 1; prev > 0 && j >= 0; prev--, j--) {
                    k = j;
                    col2 = spans[k];
					if (col2 === this.getVisibleItem(k)) {
						while (k > 0) {
							k--;
							if (spans[k] === col2) {
								spans[k] = col;
							} else {
								break;
							}
						}
					}
                    spans[j] = col;
                }
                for (j = i + 1; next > 0 && j < fixedCols; j++, next--) {
                    spans[j] = col;
                }
                spanned = true;
            } else if (!spans[i]) {
                spans[i] = col;
            }
            i++;
        }
        while (i < cnt) {
            col = this.getVisibleItem(i);
            model = callback(col);
            prev = model.spanPrev();
            next = model.spanNext();
            if (!(col instanceof ColumnGroup) && (prev > 0 || next > 0)) {
                spans[i] = col;
                for (j = i - 1; prev > 0 && j >= fixedCols; prev--, j--) {
                    k = j;
                    col2 = spans[k]
                    if (col2 === this.getVisibleItem(k)) {
                        while (k > fixedCols) {
                            k--;
                            if (spans[k] === col2) {
                                spans[k] = col;
                            } else {
                                break;
                            }
                        }
                    }
                    spans[j] = col;
                }
                for (j = i + 1; next > 0 && j < cnt; j++, next--) {
                    spans[j] = col;
                }
                spanned = true;
            } else if (!spans[i]) {
                spans[i] = col;
            }
            i++;
        }
        return { spans: spans, spanned: spanned }
    },
	$_refreshChildFooterSpans: function (fixedCols) {
        var ret = this.$_refreshSpans(fixedCols, function (col) { return col.footer(); });
        this.$_footerSpanned = ret.spanned;
        this.$_footerSpans = ret.spans;
	},
    $_refreshChildGroupFooterSpans: function (fixedCols) {
        var ret = this.$_refreshSpans(fixedCols, function (col) { return col.groupFooter(); });
        this.$_groupFooterSpanned = ret.spanned;
        this.$_groupFooterSpans = ret.spans;
    },
	$_refreshChildSummarySpans: function (fixedCols) {
        var ret = this.$_refreshSpans(fixedCols, function (col) { return col.header().summary(); });
        this.$_summarySpanned = ret.spanned;
        this.$_summarySpans = ret.spans;
	}
}, {
	$_columnType: "group",
	getRight: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.right(column);
			if (!column) {
				column = ColumnGroup.getRight(group);
			}
			return column;
		}
		return null;
	},
	getLeft: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.left(column);
			if (!column) {
				column = ColumnGroup.getLeft(group);
			}
			return column;
		}
		return null;
	},
	getNext: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.next(column);
			if (!column) {
				column = ColumnGroup.getNext(group);
			}
			return column;
		}
		return null;
	},
	getPrev: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.prev(column);
			if (!column) {
				column = ColumnGroup.getPrev(group);
			}
			return column;
		}
		return null;
	},
	getLower: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.lower(column);
			if (!column) {
				column = ColumnGroup.getLower(group);
			}
			return column;
		}
		return null;
	},
	getUpper: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.upper(column);
			if (!column) {
				column = ColumnGroup.getUpper(group);
			}
			return column;
		}
		return null;
	},
	isTop: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.vertical() && group.visibleCount() > 1 && column._displayIndex > 0) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isBottom: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.vertical() && group.visibleCount() > 1 && column._displayIndex < group.visibleCount() - 1) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isLeft: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.horizontal() && group.visibleCount() > 1 && column._displayIndex > 0) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isRight: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.vertical() && group.visibleCount() > 1 && column._displayIndex < group.visibleCount() - 1) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	getAncestors: function (column, ancestors) {
		if (!ancestors) {
			ancestors = [];
		} else {
			ancestors.length = 0;
		}
		var g = column._parent;
		while (g && !(g instanceof RootColumn)) {
			ancestors.push(g);
			g = g._parent;
		}
		return ancestors;
	},
	getFirstDataRoot: function (group) {
		var cnt = group.visibleCount();
		var c;
		if (cnt < 1) {
			c = group;
		} else if (group.vertical() && cnt > 1) {
			c = group;
		} else {
			c = group.getVisibleItem(0);
            if (c instanceof ColumnGroup) {
                c = ColumnGroup.getFirstDataRoot(c);
            }
		}
		return c;
	},
	getLastDataRoot: function (group) {
		var cnt = group.visibleCount();
		var c;
		if (cnt < 1) {
			c = group;
		} else if (group.vertical() && cnt > 1) {
			c = group;
		} else {
			c = group.getVisibleItem(group.visibleCount() - 1);
            if (c instanceof ColumnGroup) {
                c = ColumnGroup.getLastDataRoot(c);
            }
		}
		return c;
	},
    changeWidth: function (column, delta, fitting, minWidth) {
        if (!column || delta == 0) {
            return;
        }
        if (isNaN(minWidth)) {
            minWidth = 0;
        } else {
            minWidth = Math.max(0, minWidth);
        }
        if (column.displayWidth() + delta < minWidth) {
            return;
        }
        var i, cnt, w, sumFit, groups,
            p = column.parent(),
		    g = column.group(),
            sum = 0,
            dx = delta;
        if (fitting) {
            sumFit = 0;
            sum = 0;
            for (i = 0, cnt = p.visibleCount(); i < cnt; i++) {
                sum += p.getVisibleItem(i)._groupWidth;
                sumFit += p.getVisibleItem(i)._fitWidth;
            }
            dx = delta * (sum / sumFit);
            dx = delta > 0 ? Math.max(1, dx) : Math.min(-1, dx);
        }
		if (g) {
			groups = ColumnGroup.getAncestors(column);
			if (!g.vertical()) {
				w = column._groupWidth > 0 ? column._width * dx / column._groupWidth : dx;
				column.setWidth(Math.max(0, (isNaN(column._width) ? 0 : column._width) + w));
			}
			for (i = 0; i < groups.length - 1; i++) {
				g = groups[i];
				w = g._groupWidth > 0 ? g._width * dx / g._groupWidth : 0;
				g.setWidth(Math.max(0, g._width + w));
			}
			g = groups[groups.length - 1];
			g.setWidth(Math.max(0, _int(g._width + dx)));
			g.resetGroupWidths();
		} else {
			column.setWidth(Math.max(0, _int(column._width + dx)));
			if (column instanceof ColumnGroup) {
				column.resetGroupWidths();
			}
		}
    },
	getColumnMap: function (grid, columns) {
		if (grid && _isArray(columns)) {
			var map = new Dictionary();
			for (var i = columns.length; i--;) {
				var col = _cast(columns[i], GridColumn) || grid.columnByName(columns[i]);
				if (col) {
					var p = col.parent();
					if (p) {
						var list = map.get(p);
						if (!list) {
							map.set(p, list = []);
						}
						list.push(col);
					}
				}
			}
			return map;
		}
		return null;
	},
    createMenuItems: function (sorting, filtering, grouping, other) {
        var menu = [];
        var p;
        if (sorting) {
        }
        if (filtering) {
        }
        if (grouping) {
        }
        if (other) {
            for (p in other) {
                menu[p] = other[p];
            }
        }
        return menu;
    }
});
var $_collectColumns = function (group, list, visibleOnly) {
	var cnt = visibleOnly ? group.visibleCount() : group.count();
	for (var i = 0; i < cnt; i++) {
		var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
		if (column instanceof ColumnGroup) {
			$_collectColumns(column, list, visibleOnly);
		} else {
			list.push(column);
		}
	}
};
var $_collectValueColumns = function (group, columns, visibleOnly) {
    var cnt = visibleOnly ? group.visibleCount() : group.count();
    for (var i = 0; i < cnt; i++) {
        var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
        if (column instanceof ValueColumn) {
            columns.push(column);
        } else if (column instanceof ColumnGroup) {
            $_collectValueColumns(column, columns, visibleOnly);
        }
    }
};
var $_collectDataColumns = function (group, columns, visibleOnly) {
    var cnt = visibleOnly ? group.visibleCount() : group.count();
    for (var i = 0; i < cnt; i++) {
        var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
        if (column instanceof DataColumn) {
            columns.push(column);
        } else if (column instanceof ColumnGroup) {
            $_collectDataColumns(column, columns, visibleOnly);
        }
    }
};
var $_collectDataColumnsOf = function (group, fieldIndex, columns, visibleOnly) {
	var cnt = visibleOnly ? group.visibleCount() : group.count();
	for (var i = 0; i < cnt; i++) {
		var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
		if (column instanceof DataColumn && column.dataIndex() >= 0) {
			columns.push(column);
		} else if (column instanceof ColumnGroup) {
			$_collectDataColumnsOf(column, fieldIndex, columns, visibleOnly);
		}
	}
};
var $_getFirstColumn = function (group) {
	var cnt = group.visibleCount();
	for (var i = 0; i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = $_getFirstColumn(column);
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLastColumn = function (group) {
	for (var i = group.visibleCount() - 1; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = $_getLastColumn(column);
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getRightColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLeftColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getNextColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getPrevColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLowerColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getUpperColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var ColumnCollection = defineClass("ColumnCollection", null, {
	init: function (owner) {
		this._super();
		this._owner = owner; // ColumnGroup
		this._items = [];
		this._visibles = [];
	},
	owner: function () { return this._owner; },
	grid: function () { return this._owner && this._owner.grid(); },
	count: function () { return this._items.length; },
	items: function () { return this._items.slice(); },
	visibleCount: function () {
		return this._visibles.length;
	},
    visibleItems: function () {
        return this._visibles.slice();
    },
	hiddenItems: function () {
		var i, cnt,
			items = this._items,
			len = items.length,
			vitems = this._visibles,
			list = [],
			n = 0;
        if (vitems.length < items.length) {
            for (i = 0, cnt = items.length; i < cnt; i++) {
                if (vitems.indexOf(items[i]) < 0) {
                    list.push(items[i]);
                }
            }
        }
		return list;
	},
	getItem: function (index) { return this._items[index]; },
	getVisibleItem: function (index) {	return this._visibles[index];},
	clear: function (list) {
        this._items.length = this._visibles.length = 0;
    },
    contains: function (column) {
        return this._items.indexOf(column) >= 0;
    },
	indexOf: function (column) {
		return this._items.indexOf(column);
	},
	visibleIndexOf: function (column) {
		return this._visibles.indexOf(column);
	},
	add: function (column, index) {
		if (column == null) {
			if ($_debug) debugger;
			throw new Error("column is null");
		}
		if (this.indexOf(column) >= 0) {
			if ($_debug) debugger;
			throw new Error("column is already contained");
		}
        if (index >= 0 && index < this._items.length) {
            this._items.splice(index, 0, column);
        } else {
            this._items.push(column);
        }
		column._setParent(this._owner);
		return this._items.length;
	},
	removeAt: function (index) {
		if (index < 0 || index >= this._items.length) {
			throw new Error("index is invalid: " + index);
		}
		var column = this._items[index];
		this._items.splice(index, 1);
		column._setParent(null);
        return this._items.length;
	},
	move: function (column, newIndex) {
		if (column == null) {
			throw new Error("column is null");
		}
		if (newIndex < 0 || newIndex >= this._items.length) {
			throw new Error("newIndex is invalid: " + newIndex);
		}
		if (column._parent !== this._owner || column._index == newIndex) {
			return false;
		}
		this._items.splice(column.index(), 1);
		this._items.splice(newIndex, 0, column);
		return true;
	},
	moveVisible: function (column, newIndex) {
		if (column == null) {
			throw new Error("column is null");
		}
		if (newIndex < 0 || newIndex >= this._items.length) {
			return false;
		}
		if (column._parent === this._owner && column._visible) {
			if (!this.$_isVisible(column)) {
				this.$_resetVisibles(false);
				return true;
			}
			var visibles = this._visibles,
				index = column._displayIndex;
			if (index != newIndex) {
				index >= 0 && visibles.splice(index, 1);
				visibles.splice(newIndex, 0, column);
				this.$_resetVisibles(false);
				return true;
			}
		}
		return false;
	},
	columnByName: function (name, ignoreCase) {
		if (name) {
			for (var i = 0, cnt = this._items.length; i < cnt; i++) {
				var column = this._items[i];
				if (_equalTexts(column.name(), name, ignoreCase)) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column._columns.columnByName(name, ignoreCase);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	visibleColumnByName: function (name, ignoreCase) {
		if (name) {
			for (var i = 0, cnt = this._visibles.length; i < cnt; i++) {
				var column = this._visibles[i];
				if (_equalTexts(column.name(), name, ignoreCase)) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column._columns.visibleColumnByName(name, ignoreCase);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	valueColumnByName: function (name, ignoreCase) {
		if (name) {
			var i, cnt, column;
			for (i = 0, cnt = this._items.length; i < cnt; i++) {
				column = this._items[i];
				if (column instanceof ColumnGroup) {
					column = column._columns.valueColumnByName(name, ignoreCase);
					if (column) {
						return column;
					}
				} else if (_equalTexts(column.name(), name, ignoreCase)) {
					return column;
				}
			}
		}
		return null;
	},
    setChildrenProperty: function (prop, value, recursive, visibleOnly) {
        var i, col,
			cols = visibleOnly ? this._visibles : this._items;
        for (i = cols.length; i--;) {
            col = cols[i];
            col.setProperty(prop, value);
            col instanceof ColumnGroup && col.setProperty(prop, value, true);
        }
    },
	$_isVisible: function (column) {
		return this._visibles.indexOf(column) >= 0;
	},
	$_initVisibles: function () {
		var i, cnt,	column,
			items = this._items;
		for (i = 0, cnt = items.length; i < cnt; i++) {
			column = items[i];
			column._displayIndex = i;
			if (column instanceof ColumnGroup) {
				column.initVisibles();
			}
		}
	},
	$_resetVisibles: function (recursive) {
		if (arguments.length < 1) {
			recursive = true;
		}
		var i,	cnt, column,
			items = this._items,
			visibles = this._visibles;
		for (i = visibles.length - 1; i >= 0; i--) {
			column = visibles[i];
			if (!column._visible || items.indexOf(column) < 0) {
				visibles.splice(i, 1);
			}
		}
		for (i = 0, cnt = items.length; i < cnt; i++) {
			column = items[i];
			if (column._visible) {
				if (!this.$_isVisible(column)) {
					if (column._displayIndex >= 0) {
						visibles.splice(Math.min(visibles.length, column._displayIndex), 0, column);
					} else {
						visibles.push(column);
					}
				}
			} else {
			}
		}
        if ((cnt = visibles.length) > 0) {
            for (i = 0; i < cnt; i++) {
                column = visibles[i];
                column._displayIndex = i;
                column.$_last = column._parent.$_last && (i == cnt - 1);
                if (column instanceof ColumnGroup && recursive) {
                    column.resetVisibles();
                }
            }
        }
	},
	$_clearFitWidths: function () {
        for (var i = this._items.length; i--;) {
            var col = this._items[i];
            col._fitWidth = NaN;
            col._fitOffset = NaN;
            if (col instanceof ColumnGroup) {
                col.clearFitWidths();
            }
        }
	},
	$_resetStates: function (grid) {
		var i, c, column, sortFlds,	sortDirs,
			items = this._items,
			cols = items.length,
			itemSource = grid.itemSource();
		for (i = 0; i < cols; i++) {
			column = items[i];
            column._header.$_checkPopupMenu(grid);
			if (column instanceof DataColumn) {
				column._setSortOrder(-1);
			}
		}
		if (itemSource) {
			sortFlds = grid.getSortFields();
			if (sortFlds) {
				sortDirs = grid.getSortDirections();
				for (i = 0; i < sortFlds.length; i++) {
					for (c = 0; c < cols; c++) {
						column = items[c];
						if (column instanceof DataColumn && column.dataIndex() == sortFlds[i]) {
							column._setSortOrder(i);
							column._setSortDirection(sortDirs[i]);
						}
					}
				}
			}
		}
		for (i = 0; i < cols; i++) {
			column = items[i];
			if (column instanceof ColumnGroup) {
				column.resetStates();
			}
		}
	},
	$_resetIndices: function (grid) {
		var i, cnt, column,
			items = grid.itemSource(),
			ds = items && items.dataSource();
		for (i = 0, cnt = this._items.length; i < cnt; i++) {
			column = this._items[i];
			column._index = i;		// 컬렉션 상의 위치
			if (column instanceof DataColumn) {
				column._resetDataIndex(ds);
			} else if (column instanceof SeriesColumn) {
				column.resetIndices(ds);
			} else if (column instanceof CalculatedColumn) {
				grid.$_calculatedColumnChanged(column);
			} else if (column instanceof ColumnGroup) {
				column.resetIndices(grid);
			}
		}
	}
});
var CellIndex = defineClass("CellIndex", null, {
	init: function (rowIndex, column) {
		this._super();
		this.rowIndex = parseInt(rowIndex);
		this.column = (column instanceof GridColumn) ? column : null;
	},
    setColumn: function (value) {
        this.column = value;
        return this;
    },
    setRowIndex: function (value) {
        this.rowIndex = value;
        return this;
    },
    grid: {
        get: function () {
            return this.column && this.column.grid();
        },
        set: null
    },
    dataColumn: {
        get: function () {
            return (this.column instanceof DataColumn) ? this.column : null;
        },
        set: null
    },
    calcedColumn: {
        get: function () {
            return (this.column instanceof CalculatedColumn) ? this.column : null;
        },
        set: null
    },
    valueColumn: {
        get: function () {
            return (this.column instanceof ValueColumn) ? this.column : null;
        },
        set: null
    },
	group: {
        get: function () {
            return (this.column instanceof ColumnGroup) ? this.column : null;
        },
        set: null
    },
	dataField: {
        get: function () {
            return (this.column instanceof DataColumn) ? this.column.dataIndex() : -1;
        },
        set: null
    },
    isDataCell: {
        get: function () {
            if (this.column instanceof DataColumn) {
                var grid = this.column.grid();
                var row = grid.getRow(this.rowIndex);
                return row && row.dataIndex() >= 0;
            }
            return false;
        },
        set: null
    },
	isTopColumn: {
        get: function () {
            var column = this.column;
            if (column) {
                if (column.group()) {
                    return ColumnGroup.isTop(column);
                }
                return true;
            }
            return false;
        },
        set: null
    },
	isBottomColumn: {
        get: function () {
            var column = this.column;
            if (column) {
                if (column.group()) {
                    return ColumnGroup.isBottom(column);
                }
                return true;
            }
            return false;
        },
        set: null
	},
	isLeftColumn: {
        get: function () {
            var column = this.column;
            if (column) {
                var g = column.group();
                if (g) {
                    return g.displayIndex() == 0 && ColumnGroup.isLeft(column);
                } else {
                    return column.displayIndex() == 0;
                }
            }
            return false;
        },
        set: null
	},
	isRightColumn: {
        get: function () {
            var column = this.column;
            if (column) {
                var g = column.group();
                if (g) {
                    return g.displayIndex() == g.grid().visibleColumnCount() - 1 && ColumnGroup.isRight(column);
                } else {
                    return column.displayIndex() == column.grid().visibleColumnCount() - 1;
                }
            }
            return false;
        },
        set: null
	},
    isFirstColumn: {
        get: function () {
            var grid = this.grid();
            if (grid && grid.visibleColumnCount() > 0) {
                var column = grid.getVisibleColumn(0);
                column = column instanceof ValueColumn ? column : column.root().first();
                return column == this.column;
            }
            return false;
        },
        set: null
    },
    isLastColumn: {
        get: function () {
            var grid = this.grid();
            if (grid && grid.visibleColumnCount() > 0) {
                var column = grid.getVisibleColumn(grid.visibleColumnCount() - 1);
                column = column instanceof ValueColumn ? column : column.root().last();
                return column == this.column;
            }
            return false;
        },
        set: null
    },
    equals: function (rowIndex, column) {
        if (rowIndex instanceof  CellIndex) {
            return rowIndex.rowIndex == this.rowIndex && rowIndex.column == this.column;
        } else {
            return rowIndex == this.rowIndex && column == this.column;
        }
    },
	"set": function (rowIndex, column) {
        this.rowIndex = rowIndex;
        this.column = column;
		return this;
	},
    setRow: function (row, force) {
        if (row instanceof GridRow) {
            this.rowIndex = row.index();
        } else if (force) {
            this.rowIndex = -1;
        }
    },
    getRow: function (grid) {
        if (!grid && this.column) {
            grid = this.column.grid();
        }
        if (grid && this.rowIndex >= 0) {
            return grid.getRow(this.rowIndex);
        }
        return null;
    },
    getDataIndex: function (grid) {
        if (!grid && this.column) {
            grid = this.column.grid();
        }
        if (grid && this.rowIndex >= 0) {
            var row = grid.getRow(this.rowIndex);
            return row ? row.dataIndex() : -1;
        }
        return -1;
    },
    getDataId: function (grid) {
        if (!grid && this.column) {
            grid = this.column.grid();
        }
        if (grid && this.rowIndex >= 0) {
            var row = grid.getRow(this.rowIndex);
            return row ? row.dataId() : -1;
        }
        return -1;
    },
    columnIs: function (columnName, ignoreCase) {
        if (columnName === this.column) {
            return true;
        } else if (columnName && this.column) {
            var s = this.column.name();
            return _equalTexts(columnName, s, ignoreCase);
        }
        return false;
    },
	normalize: function (grid) {
		if (grid) {
			if (!this.column) {
				this.column = grid.getFirstColumn();
			}
			this.rowIndex = isNaN(this.rowIndex) ? 0 : Math.max(0, Math.min(grid.rowCount() - 1, this.rowIndex)) >> 0;
		}
		return this;
	},
    isFixed: function (grid) {
        return grid && grid.isFixedCell(this);
    },
    isFixedCol: function (grid) {
        return grid && grid.isFixedColumn(this.column);
    },
    isFixedRow: function (grid) {
        return grid && grid.isFixedRowIndex(this.rowIndex);
    },
	incRow: function (grid, delta) {
        if (grid) {
			this.rowIndex = Math.max(0, Math.min(grid.rowCount() - 1, this.rowIndex + delta));
		}
	},
	firstRow: function (grid) {
        if (grid) {
            this.rowIndex = 0;
		}
	},
	lastRow: function (grid) {
        if (grid) {
			this.rowIndex = grid.rowCount() - 1;
		}
	},
	right: function () {
		var column = $$_cellIndex_getRight(this.grid(), this.column);
		if (column) {
			this.column = column;
		}
	},
	left: function () {
		var column = $$_cellIndex_getLeft(this.grid(), this.column);
		if (column) {
			this.column = column;
		}
	},
	next: function () {
		var column = $$_cellIndex_getNext(this.grid(), this.column);
		if (column) {
			this.column = column;
			return true;
		}
		return false;
	},
	prev: function () {
		var column = $$_cellIndex_getPrev(this.grid(), this.column);
		if (column) {
			this.column = column;
			return true;
		}
		return false;
	},
	home: function () {
		var grid = this.grid();
		if (grid && grid.visibleColumnCount() > 0) {
			var column = grid.getVisibleColumn(0);
			this.column = column instanceof ValueColumn ? column : column.root().first();
		}
	},
	end: function () {
		var grid = this.grid();
		if (grid && grid.visibleColumnCount() > 0) {
			var column = grid.getVisibleColumn(grid.visibleColumnCount() - 1);
			this.column = column instanceof ValueColumn ? column : column.root().last();
		}
	},
	down: function () {
		if (this.isBottomColumn()) {
			this.incRow(this.column.grid(), 1);
		} else {
			this.column = ColumnGroup.getLower(this.column);
		}
	},
	up: function () {
		if (this.isTopColumn()) {
			this.incRow(this.column.grid(), -1);
		} else {
			this.column = ColumnGroup.getUpper(this.column);
		}
	},
    getValue: function () {
        var column = this.column;
        if (column instanceof DataColumn) {
            var fld = column.dataIndex();
            if (fld >= 0) {
                var row = column.grid().getRow(this.rowIndex);
                if (row) {
                    return row.getValue(fld);
                }
            }
        } else if (column instanceof CalculatedColumn) {
            return column.getValue(column.grid().getRow(this.rowIndex));
        }
        return undefined;
    },
    setValue: function (value) {
        var column = this.column;
        if (column instanceof DataColumn) {
            var fld = column.dataIndex();
            if (fld >= 0) {
                var row = column.grid().getRow(this.rowIndex);
                if (row) {
                    return row.setValue(fld, value);
                }
            }
        }
        return undefined;
    },
    clone: function () {
        return new CellIndex(this.rowIndex, this.column);
    },
    copyTo: function (index) {
        index.rowIndex = this.rowIndex;
        index.column = this.column;
        return index;
    },
    assign: function (source) {
        if (source) {
            this.rowIndex = source.rowIndex;
            this.column = source.column;
        } else {
            this.rowIndex = -1;
            this.column = null;
        }
        return this;
    },
	toString: function () {
		var root = this.column ? this.column.root() : null;
		var dataRoot = this.column ? this.column.dataRoot() : null;
		return "(" + (root ? root.displayIndex() : "null") + "," + (dataRoot ? dataRoot.displayIndex() : "null") + "," + this.rowIndex + ")";
	}
}, {
	NULL: null,
	$_temp: null,
	create: function (rowIndex, column) {
        if (rowIndex instanceof CellIndex) {
            return new CellIndex(rowIndex.rowIndex, rowIndex.column);
        } else {
            return new CellIndex(rowIndex, column);
        }
	},
	temp: function (rowIndex, column) {
        if (rowIndex instanceof CellIndex) {
            CellIndex.$_temp.rowIndex = rowIndex.rowIndex;
            CellIndex.$_temp.column = rowIndex.column;
        } else {
            CellIndex.$_temp.rowIndex = rowIndex;
            CellIndex.$_temp.column = column;
        }
		return CellIndex.$_temp;
	},
    /** @deprecated use areEqual instead. */
	areEquals: function (idx1, idx2) {
        return this.areEqual(idx1, idx2);
	},
    areEqual: function (idx1, idx2) {
        if (idx1 === idx2) return true;
        return idx1 && idx2 && idx1.rowIndex == idx2.rowIndex && idx1.column == idx2.column;
    },
    borrow: function (rowIndex, column) {
        var idx = CellIndex.$_buff.pop() || new CellIndex();
        return idx.set(rowIndex, column);
    },
    "return": function (index) {
        index && CellIndex.$_buff.push(index);
    }
}, function (f) {
	f.NULL = new f();
	f.$_temp = new f();
    f.$_buff = [];
});
var _equalIndexes = CellIndex.areEqual;
var $$_cellIndex_getRight = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
    var	column = ColumnGroup.getRight(start);
    if (column) {
        return column;
    }
	var	lm = grid.layoutManager();
    var idx;
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (var i = idx + 1, cnt = lm.columnCount(); i < cnt; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.first();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getLeft = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
    var column = ColumnGroup.getLeft(start);
    if (column) {
        return column;
    }
	var	lm = grid.layoutManager();
    var idx;
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (var i = idx - 1; i >= 0; i--) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.last();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getNext = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
    var column = ColumnGroup.getNext(start);
    if (column) {
        return column;
    }
    var lm = grid.layoutManager();
    var idx;
    if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (var i = idx + 1, cnt = lm.columnCount(); i < cnt; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.first();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getPrev = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
    var column = ColumnGroup.getPrev(start);
    if (column) {
        return column;
    }
	var lm = grid.layoutManager();
    var idx;
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (var i = idx - 1; i >= 0; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.last();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var CellRange = defineClass("CellRange", null, {
	init: function () {
		this._super();
		this._row1 = 0;
		this._col1 = null;
		this._row2 = -1;
		this._col2 = null;
	},
	isEmpty: {
        get: function () {
            return (this._row2 < this._row1) || (this._col1 == null && this._col2 == null);
        },
        set: null
    },
	R1: {
        get: function () {
            return this._row1;
        },
        set: null
    },
	C1: {
        get: function () {
            return this._col1;
        },
        set: null
    },
	R2: {
        get: function () {
            return this._row2;
        },
        set: null
    },
	C2: {
        get: function () {
            return this._col2;
        },
        set: null
    },
	top: {
        get: function () {
            return this._row1 <= this._row2 ? this._row1 : this._row2;
        },
        set: null
    },
	bottom: {
        get: function () {
            return this._row1 <= this._row2 ? this._row2 : this._row1;
        },
        set: null
    },
    rowCount: function () {
        return Math.abs(this._row2 - this._row1) + 1;
    },
	firstCell: {
        get: function () {
            var index = new CellIndex();
            index.rowIndex = this._row1 <= this._row2 ? this._row1 : this._row2;
            if (this._col1.dataRoot().distance() <= this._col2.dataRoot().distance()) {
                index.column = this._col1;
            } else {
                index.column = this._col2;
            }
            return index;
        },
        set: null
	},
	lastCell: {
        get: function () {
            var index = new CellIndex();
            index.rowIndex = this._row1 >= this._row2 ? this._row1 : this._row2;
            if (this._col1.dataRoot().distance() >= this._col2.dataRoot().distance()) {
                index.column = this._col1;
            } else {
                index.column = this._col2;
            }
            return index;
        },
        set: null
	},
	contains: function (rowIndex, column) {
		if (column && (rowIndex >= this._row1) && (rowIndex <= this._row2)) {
            var c,
                c1 = this._col1.dataRoot().distance(),
                c2 = this._col2.dataRoot().distance();
            if (c1 > c2) {
                c = c1;
                c1 = c2;
                c2 = c;
            }
            c = column.dataRoot().distance();
            return (c >= c1) && (c <= c2);
		}
		return false;
	},
	containsIndex: function (index) {
        return index && this.contains(index.rowIndex, index.column);
	},
    intersects: function (index1, index2) {
        var c,
            r1 = Math.min(index1.rowIndex, index2.rowIndex),
            r2 = Math.max(index1.rowIndex, index2.rowIndex),
            row1 = Math.min(this._row1, this._row2),
            row2 = Math.max(this._row1, this._row2),
            c1 = index1.column,
            c2 = index2.column,
            col1 = this._col1,
            col2 = this._col2;
        if (_compCL(c1, c2) > 0) {
            c = c1;
            c1 = c2;
            c2 = c;
        }
        if (_compCL(col1, col2) > 0) {
            c = col1;
            col1 = col2;
            col2 = c;
        }
        return (_compCL(c1, col2) <= 0) && (_compCL(col1, c2) <= 0) && (r1 <= row2) && (row1 <= r2);
    },
    intersectsWith: function (range) {
        return false;
    },
	normalize: function () {
		if (this._row1 > this._row2) {
			var r = this._row1;
			this._row1 = this._row2;
			this._row2 = r;
		}
		if (this._col1.dataRoot().distance() > this._col2.dataRoot().distance()) {
			var c = this._col1;
			this._col1 = this._col2;
			this._col2 = c;
		}
        return this;
	},
	normalizeData: function () {
		this.normalize();
		var g = this._col1;
		if (g instanceof ColumnGroup) {
			this._col1 = ColumnGroup.getFirstDataRoot(g);
		}
		g = this._col2;
		if (g instanceof ColumnGroup) {
			this._col2 = ColumnGroup.getLastDataRoot(g);
		}
        return this;
	},
    bottomIsVisible: function (grid) {
        var lm = grid.layoutManager(),
            fixed = lm.fixedItemCount(),
            t = grid.topIndex(),
            r1 = Math.min(this._row1, this._row2),
            r2 = Math.max(this._row1, this._row2);
        if (fixed > 0) {
            if (r2 >= t + fixed + lm.fullItemCount() || r2 < 0 || r1 >= fixed && r2 < t + fixed) {
                return false;
            }
        } else if (lm.itemCount() > 0) {
            if (r2 >= t + lm.fullItemCount() || r2 < t) {
                return false;
            }
        } else {
            return false;
        }
        return true;
    },
    moveToNext: function (index) {
        var firstCell, lastCell, group, col, firstCol, idx;
        this.normalize();
        firstCell = this.firstCell();
        lastCell = this.lastCell();
        group = lastCell.group();
        col = lastCell.column;
        if (group) {
            col = group.last();
        }
        if (index.column == col) {
            firstCol = firstCell.column;
            if (firstCol instanceof ColumnGroup) {
                firstCol = firstCol.first();
            }
            idx = index.rowIndex + 1;
            if(index.rowIndex == lastCell.rowIndex) {
                idx = firstCell.rowIndex;
            }
            index.set(idx, firstCol);
        } else if (index.column == this.C2()) {
            index.set(index.rowIndex + 1, this.C1());
        } else {
            index.next();
        }
        return index;
    },
    moveToPrev: function (index) {
        var firstCell, lastCell, group, col, lastCol, idx;
        this.normalize();
        firstCell = this.firstCell();
        lastCell = this.lastCell();
        group = firstCell.group();
        col = firstCell.column;
        if (group) {
            col = group.first();
        }
        if (index.column == col) {
            lastCol = lastCell.column;
            if (lastCol instanceof ColumnGroup) {
                lastCol = lastCol.last();
            }
            idx = index.rowIndex - 1;
            if (index.rowIndex == firstCell.rowIndex) {
                idx = lastCell.rowIndex;
            }
            index.set(idx, lastCol);
        } else if (index.column == this.C1()) {
            index.set(index.rowIndex - 1, this.C2());
        } else {
            index.prev();
        }
    return index;
    }
}, {
	$_setRange: function (range, r1, c1, r2, c2) {
		if (r1 < r2) {
			range._row1 = r1;
			range._col1 = c1;
			range._row2 = r2;
			range._col2 = c2;
		} else if (r1 > r2) {
			range._row1 = r2;
			range._col1 = c2;
			range._row2 = r1;
			range._col2 = c1;
		} else {
            range._row1 = r1;
            range._row2 = r2;
        }
		var col1 = c1 instanceof GridColumn ? c1 :null;
        var col2 = c2 instanceof GridColumn ? c2 : null;
        if (col1 && col2) {
            if (col1.dataRoot().distance() <= col2.dataRoot().distance()) {
				range._col1 = c1;
				range._col2 = c2;
			} else {
				range._col1 = c2;
				range._col2 = c1;
			}
		} else {
            range._col1 = c1;
            range._col2 = c2;
        }
		return range;
	},
	create: function (index1, index2) {
		if (!index2 || index1 === index2) {
			var r = new CellRange();
			r._row1 = r._row2 = index1.rowIndex;
			r._col1 = r._col2 = index1.column;
			return r;
		} else {
			return CellRange.$_setRange(new CellRange(), index1.rowIndex, index1.column, index2.rowIndex, index2.column);
		}
	},
	temp: function (index1, index2) {
		var r = CellRange.$_TEMP;
		if (!index2 || index1 === index2) {
			r._row1 = r._row2 = index1.rowIndex;
			r._col1 = r._col2 = index1.column;
			return r;
		} else {
			return CellRange.$_setRange(r, index1.rowIndex, index1.column, index2.rowIndex, index2.column);
		}
	},
	createRange: function (r1, c1, r2, c2) {
		return CellRange.$_setRange(new CellRange(), r1, c1, r2, c2);
	}
});
CellRange.NULL = new CellRange();
CellRange.$_TEMP = new CellRange();
var $_GridCellIndex = defineClass('$_GridCellIndex', CellIndex, {
    init: function (rowIndex, column) {
        this._super(rowIndex, column);
    },
    assign: function (source) {
        if (source) {
            this.rowIndex = source.rowIndex;
            this.column = source.column;
            this.$_row = source.$_row;  // for ExcelIndex
        } else {
            this.rowIndex = -1;
            this.column = null;
            this.$_row = undefined;
        }
        return this;
    },
    getRow: function (grid) {
        return this._super(grid) || this.$_row;
    }
});
/** @abstract */
var GridCell = defineClass("GridCell", null, {
	init: function (grid, name) {
		this._super();
		this._grid = grid;
		this._name = name;
		this._index = new $_GridCellIndex();
	},
	styles: null,
    index: null,
	name: function () {
		return this._name;
	},
    grid: function () {
        return this._grid;
    },
	setIndex: function (value) {
		this._index.assign(value);
        return this;
	},
    column: function () {
        return this._index.column;
    },
    rowIndex: function () {
        return this._index.rowIndex;
    },
	row: function () {
		return this._index.getRow(this._grid);
	},
	displayText: function () {
		return null;
	},
	value: function () {
		return null;
	},
    error: function () {
        return null;
    },
	errorDetail: function () {
		return null;
	},
	errorLevel: function () {
		return ValidationLevel.IGNORE;
	},
    merged: function () {
        return false;
    },
    setCellStyles: function (value) {
    }
}, {
	ERROR: "<<ERROR>>"
});
/** @abstract */
var StyledCell = defineClass("StyledCell", GridCell, {
	init: function (grid, model) {
		this._super(grid, null);
		this._model = model;
	},
	model: null
});
var HeaderCell = defineClass("HeaderCell", GridCell, {
	init: function (grid) {
		this._super(grid, "headerCell");
	},
    sortOrderVisible: true,
    subStyles: null,
    text: null,
    subText: null,
    subTextGap: 1,
    subTextLocation: EnumProp(SubTextLocation, SubTextLocation.BOTTOM),
	itemOffset: 2,
	itemGap: 2,
	imageList: null,
	imageIndex: -1,
	imageUrl: null,
	imageOffset: 0,
	checkLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
	imageLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
	checked: false,
    handleOffset: 2,
    handleGap: 1,
    menuWidth: 7
});
var HeaderHeadCell = defineClass("HeaderHeadCell", GridCell, {
	init: function (grid, headerHead) {
		this._super(grid, "headerHeadCell");
		this._head = headerHead;
    },
    menuVisible: false
});
var HeaderSummaryCell = defineClass("HeaderSummaryCell", GridCell, {
	init: function (grid) {
		this._super(grid, "headerSummaryCell");
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
	},
	displayText: function () {
		if (this._error) {
			return GridCell.ERROR;
		} else {
			var s = isNaN(this._value) ? null : String(this._value);
            if (!s) {
                var column = this.index().column;
                    s = column.header().summary().text();
            }
			return s;
		}
	},
	value: function () {
		return this._value;
	},
	level: function () {
		return 0;
	},
	calculate: function () {
		var column = this.index().valueColumn();
		var grid = column ? column.$_grid : null;
		this._value = NaN;
		this._error = null;
		if (grid && grid.displayOptions().summaryMode() != SummaryMode.NONE) {
			var summary = column.header().summary();
			var callback = summary._summaryCallback || column._summaryCallback;
			if (callback) {
				try {
					this._value = grid.getSummarizer().summarize(summary, function () {
						return callback(column);
					});
				} catch (err) {
					this._error = err;
					this._errorDetail = err;
					_throwDebugError(err);
				}
			} else if (summary.canSummary() && column.dataIndex() >= 0 && grid.dataRowCount() > 0) {
				try {
					var runtime = grid.columnSummaryRuntime();
					runtime.setColumn(column, grid.getSummarizer());
					this._value = summary.evaluate(runtime);
				} catch (err) {
					this._error = err;
					this._errorDetail = err;
					_throwDebugError(err);
				}
			}
		}
	},
	error: function () {
		return this._error;
	},
	errorDetail: function () {
		return this._errorDetail;
	}
});
var HeaderSummaryHeadCell = defineClass("HeaderSummaryHeadCell", GridCell, {
    init: function (grid, head) {
        this._super(grid, "headerSummaryHeadCell");
        this._head = head;
    },
    menuVisible: false,
    text: null
});
var FooterCell = defineClass("FooterCell", GridCell, {
	init: function (grid) {
		this._super(grid, "footerCell");
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
	},
	displayText: function () {
		if (this._error) {
			return GridCell.ERROR;
		} else {
			var v = this._value;
			var s = isNaN(v) ? (typeof v === 'string' ? v : null) : String(v);
			if (!s) {
                var column = this.index().column;
                    s = column.footer().text();
			}
			return s;
		}
	},
	value: function () {
		return this._value;
	},
    level: function () {
        return 0;
    },
	$_setError: function (err) {
		this._error = err;
		this._errorDetail = err;
		_throwDebugError(err);
	},
	calculate: function () {
		var column = this.index().valueColumn();
		var grid = column ? column.$_grid : null;
		this._value = undefined;
		this._error = null;
		if (grid && grid.displayOptions().summaryMode() != SummaryMode.NONE) {
			var footer = column.footer();
            var callback = footer._summaryCallback || column._summaryCallback;
            if (callback) {
                try {
                    this._value = grid.getSummarizer().summarize(footer, function () {
                        return callback(column);
                    });
                } catch (err) {
					this.$_setError(err);
                }
            } else 	if (footer.canSummary() && column.dataIndex() >= 0 && grid.dataRowCount() > 0) {
				try {
					var runtime = grid.columnSummaryRuntime();
					runtime.setColumn(column, grid.getSummarizer());
					this._value = footer.evaluate(runtime);
				} catch (err) {
					this.$_setError(err);
				}
			}
		}
	},
	error: function () {
		return this._error;
	},
	errorDetail: function () {
		return this._errorDetail;
	}
});
var FooterHeadCell = defineClass("FooterHeadCell", GridCell, {
    init: function (grid, footerHead) {
        this._super(grid, "footerHeadCell");
        this._head = footerHead;
    },
    menuVisible: false,
    displayText: function () {
        return this._head.text();
    }
});
/** @internal */
var EditBarCell = defineClass("EditBarCell", GridCell, {
	init: function (grid) {
		this._super(grid, "editBarCell");
	}
});
var IndicatorCell = defineClass("IndicatorCell", GridCell, {
	init: function (grid, indicator) {
		this._super(grid, "indicatorCell");
		this._indicator = indicator;
	},
	indicator: null,
	rowState: EnumProp(GridRowState, GridRowState.NORMAL),
	dataState: EnumProp(DataRowState, DataRowState.NONE),
	stateWidth: 0,
	stateFill: null,
	shapeVisible: true,
	displayText: function () {
		var indicator = this._indicator;
		var index = this.index();
		var item = index.getRow(this._grid);
		var s = "";
		var r;
		if (item) {
			switch (indicator.displayValue()) {
			case RowIndicatorValue.ROW_INDEX:
				r = indicator._grid.getIndicatorIndex(item);
				if (r >= 0) {
					r += indicator.rowIndexBase();
					s = String(r);
				}
				break;
			case RowIndicatorValue.DATA_INDEX:
				r = index.getDataIndex(this._grid);
				if (r >= 0) {
					r += indicator.dataIndexBase();
					s = String(r);
				}
				break;
			}
		}
		return s;
	}
});
var StateCell = defineClass("StateCell", GridCell, {
	init: function (grid) {
		this._super(grid, "stateCell");
	},
	label: null,
	displayText: function () {
		return this._label;
	}
});
var CheckBarCell = defineClass("CheckBarCell", GridCell, {
	init: function (grid) {
		this._super(grid, "checkBarCell");
	},
	displayText: function () {
		return this._index.getDataIndex(this._grid);
	}
});
var GroupCell = defineClass("GroupCell", GridCell, {
    init: function (grid, name) {
        this._super(grid, name);
    }
});
/** @abstract */
var ValueCell = defineClass("ValueCell", GridCell, {
	init: function (grid, name) {
		this._super(grid, name);
	},
    cellStyles: null, // cell element 쪽에서 사용한다.
	displayText: function () {
		return this.value();
	},
    setCellStyles: function (value) {
            this._cellStyles = value;
            value && value.assignTo(this._styles);
    }
});
var DataCell = defineClass("DataCell", ValueCell, {
	init : function(grid, name) {
		this._super(grid, name || "dataCell");
	},
	error: null,
	errorLevel: EnumProp(ValidationLevel, ValidationLevel.IGNORE),
	error_: function () {
		return this._error;
	},
	errorLevel_: function () {
		return this._errorLevel;
	},
    displayText : function() {
		var v, lookup, i, flds, cnt, keys, fld,
        	index = this.index(),
        	col = index.dataColumn(),
        	item = index.getRow(this._grid);
        if (col.lookupDisplay()) {
            lookup = col.lookupSource();
            if (lookup) {
				flds = col.lookupKeyFieldIds();
				cnt = flds.length;
				keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(item.getValue(flds[i]));
                }
                v = lookup.lookup(keys);
                v = (v !== undefined) ? v : this.value();
            } else {
                fld = col.labelFieldIndex();
                v = (fld >= 0) ? item.getValue(fld) : col.getLookupLabel(this.value());
            }
        } else {
            v = this.value();
        }
		return  (v === undefined || v === null) ? "" : String(v);
    },
    value : function() {
        var fld = this._index.column.dataIndex();
        if (fld >= 0) {
            return this._index.getRow(this._grid).getValue(fld);
        }
        return undefined;
    },
    getTextFromItem : function(item) {
        var col = this.index().dataColumn();
        var fldVal = item.getValue(col.dataIndex());
        var v;
        if (col.lookupDisplay()) {
            var lookup = col.lookupSource();
            if (lookup) {
                var i,
                    flds = col.lookupKeyFieldIds(),
                    cnt = flds.length,
                    keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(item.getValue(flds[i]));
                }
                v = lookup.lookup(keys);
                v = (v !== undefined) ? v : this.value();
            } else {
                var fld = col.labelFieldIndex();
                v = (fld >= 0) ? item.getValue(fld) : col.getLookupLabel(fldVal);
            }
        } else {
            v = fldVal;
        }
        return  (v === undefined || v === null) ? "" : String(v);
    }
});
var LabelCell = defineClass("LabelCell", ValueCell, {
	init : function(grid) {
		this._super(grid, "labelCell");
	},
	displayText : function() {
		return this._index.column.text();
	},
	value : function() {
		return this._index.column.text();
	}
});
var SeriesCell = defineClass("SeriesCell", ValueCell, {
	init : function(grid, name) {
		this._super(grid, name || "seriesCell");
	},
    getValue: function (column, row) {
        return (column instanceof SeriesColumn) ? column.getValue(row) : [];
    },
	value: function() {
		var column = this._index.column;
        return (column instanceof SeriesColumn) ? column.getValue(this.row()) : [];
	},
	labels: function () {
		return this._index.column.fieldLabels();
	},
    fieldCount: function () {
        return this._index.column.fieldCount();
    }
}, {
	getText: function (value) {
		return _isArray(value) ? value.join(",") : value;
	}
});
var ChartCell = defineClass("ChartCell", SeriesCell, {
    init : function(grid) {
        this._super(grid, "chartCell");
    },
    chart: function () {
		var config = this._index.column.chart();
		if (config) {
			return new GridChart(this._grid).loadChart(config);
		} else {
			return null;
		}
    },
	getKey: function (index) {
		var fld = this._index.column.getFieldName(index);
	}
});
var CalcedCell = defineClass("CalcedCell", ValueCell, {
    init : function(grid, name) {
        this._super(grid, name || "calcedCell");
    },
    displayText : function() {
        var v = this.value();
        return  (v === undefined || v === null) ? "" : String(v);
    },
    value : function() {
        return this._index.column.getValue(this._index.getRow(this._grid));
    }
});
var RowGroupHeaderCell = defineClass("RowGroupHeaderCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupHeaderCell");
		this._rowGroup = rowGroup;
	},
	displayText: function () {
		var group = this._index.getRow(this._grid);
		if (group instanceof GroupRow) {
			return this._rowGroup.getHeaderText(group);
		}
		return "";
	}
});
var RowGroupExpanderCell = defineClass("RowGroupExpanderCell", GridCell, {
	init: function(grid) {
		this._super(grid, "rowGroupExpanderCell");
	}
});
var RowGroupIndentCell = defineClass("v", GridCell, {
	init: function(grid) {
		this._super(grid, "rowGroupIndentCell");
	}
});
var RowGroupFooterCell = defineClass("RowGroupFooterCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupFooterCell");
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
	},
	calculate: function () {
		this._value = NaN;
		this._error = null;
		try {
			this._value = RowGroupFooterCell.$_getValue(this._index.getRow(this._grid), this._index.column);
		} catch (err) {
			this._error = err;
			this._errorDetail = err;
			_throwDebugError(err);
		}
	},
	displayText: function() {
		if (this._error) {
			return GridCell.ERROR;
		} else {
            var v = this._value;
            var s = isNaN(v) ? (typeof v === 'string' ? v : null) : String(v);
            var column;
			if (!s && (column = this.index().valueColumn())) {
				s = column.groupFooter().text();
			}
			return s;
		}
	},
	value: function() {
		return this._value;
	},
    level: function () {
        return this.index().getRow(this._grid).level();
    },
    error: function () {
        return this._error;
    },
    errorDetail: function () {
        return this._errorDetail;
    }
}, {
	$_getValue: function (item, column) {
		if (column instanceof ValueColumn) {
            var v, runtime,
                footer = column.groupFooter(),
                group = item.parent(),
                callback = footer._summaryCallback;
            if (callback) {
                v = column.$_grid.getSummarizer().summarizeGroup(column, group, function () {
                    return callback(column, group);
                });
            } else if (footer.canSummary() && column.dataIndex() >= 0) {
                runtime = column.$_grid.rowGroupSummaryRuntime();
                runtime.setColumn(column, column.$_grid.getSummarizer());
                runtime.setItem(group);
                v = column.groupFooter().evaluate(runtime);
            }
			return v;
		} else {
			return undefined;
		}
	},
	getValue: function (item, column) {
		try {
			return RowGroupFooterCell.$_getValue(item, column);
		} catch (err) {
			return GridCell.ERROR;
		}
	}
});
var RowGroupBarCell = defineClass("RowGroupBarCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupBarCell");
	},
    level: 0
});
var RowGroupItemBarCell = defineClass("RowGroupItemBarCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupItemBarCell");
	}
});
var RowGroupHeadCell = defineClass("RowGroupHeadCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupHeadCell");
	},
    level: 0,
	index: function () {
		return CellIndex.NULL;
	}
});
var RowGroupFootCell = defineClass("RowGroupFootCell", GridCell, {
	init: function(grid, rowGroup) {
		this._super(grid, "rowGroupFootCell");
	}
});
var HandleRenderer = defineClass("HandleRenderer", EventAware, {
    init: function () {
        this._super();
    },
    draw: function (g, r, handle) {
        this._doDraw(g, r, handle);
    },
    drawHtml: function (r, handle) {
        this._doDrawHtml(r, handle);
    },
    _doDraw: function (g, r, handle) {
    },
    _doDrawHtml: function (r, handle) {
    },
    _changed: function () {
        this.fireEvent(HandleRenderer.CHANGED);
    }
});
HandleRenderer.CHANGED = "onHandleRendererChanged";
var FILTER_ICON_WIDTH = 9;
var FILTER_ICON_HEIGHT = 11;
var FILTER_ICON_BAR = 4;
var DefaultFilterHandleRenderer = defineClass("DefaultFilterHandleRenderer", HandleRenderer, {
    init: function () {
        this._super();
    },
    _doDraw: function (g, r, handle) {
        var fill, border,
            x = r.width / 2,
            y = (r.height - FILTER_ICON_HEIGHT) / 2,
            pts = [
                x - FILTER_ICON_WIDTH / 2, y,
                x + FILTER_ICON_WIDTH / 2, y,
                x, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR + 2,
                x - FILTER_ICON_WIDTH / 2, y
            ],
            filtered = handle.column().filtered();
        if (handle.hovered()) {
            border = handle.hoveredBorder();
            fill = filtered ? handle.hoveredBackground() : null;
        } else {
            border = filtered ? handle.border() : handle.emptyBorder();
            fill = filtered ? handle.background() : null;
        }
        g.drawPolygonArray(fill, border, pts);
        g.drawLineI(border, x - 1, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR - 1, x - 1, y + FILTER_ICON_HEIGHT + 1);
        g.drawLineI(border, x, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR - 1, x, y + FILTER_ICON_HEIGHT + 1);
    },
    _doDrawHtml: function (r, handle) {
        this._doDraw(handle.$_getGraphics(true), r, handle);
    }
});
var SORT_ICON_WIDTH = 7;
var SORT_ICON_HEIGHT = 7;//8;
var DefaultSortHandleRenderer = defineClass("DefaultSortHandleRenderer", HandleRenderer, {
    init: function () {
        this._super();
    },
    _doDraw: function (g, r, handle) {
        var sortOrder = handle.sortOrder();
        var	x = _int(r.width / 2);
        var	y = _int((r.height - SORT_ICON_HEIGHT + 1) / 2) + 1;
        var w = SORT_ICON_WIDTH / 2;
        var py = y + SORT_ICON_HEIGHT - 1;
        var sorted = sortOrder >= 0;
        var	pts, fill, border;
        if (sortOrder < 0 || handle.sortDir() == SortDirection.ASCENDING) {
            pts = [
                x, y,
                x - w, py,
                x + w, py//,
            ];
        } else{
            pts = [
                x - w, y,
                x + w, y,
                x, py//,
            ];
        }
        if (handle.hovered()) {
            border = handle.hoveredBorder();
            fill = sorted ? handle.hoveredBackground() : null;
        } else {
            border = sorted ? handle.border() : handle.emptyBorder();
            fill = sorted ? handle.background() : null;
        }
        g.drawPolygonArray(fill, border, pts);
    },
    _doDrawHtml: function (r, handle) {
        this._doDraw(handle.$_getGraphics(true), r, handle);
    }
});
var GridElement = defineClass("GridElement", UIElement, {
	init: function (dom, name) {
		this._super(dom, name);
        if (this._css) {
            this._css.overflow = 'hidden';
        }
		this._drawRect = new Rectangle();
		this._recycling = false;
	},
	grid: function () {
		var p = this._parent;
		while (p) {
			if (p instanceof GridBase) {
				return p;
			}
			p = p._parent;
		}
		return null;
	},
	measure: function (grid, hintWidth, hintHeight) {
		return this._doMeasure(grid, hintWidth, hintHeight);
	},
	layoutContent: function (lm) {
		return this._doLayoutContent(lm);
	},
	refresh: function () {
		this._doRefresh();
	},
    clip: function (g) {
        this.getClientRect(this._drawRect);
        g.clipRect(this._drawRect);
    },
	_doDraw: function(g, needOpaque) {
		needOpaque && g.drawRectI(SolidBrush.WHITE, null, this._drawRect);
		this._doRender(g, this._drawRect);
	},
	_doClearHtml: function () {
		this._span && (this._span.style.visibility = 'hidden');
		this._svg && (this._svg._svg.style.visibility = 'hidden');
	},
    /*
    _doClearHtml_2: function () {
        this._span && this._span.parentNode === this._dom && this._dom.removeChild(this._span);
        this._svg && this._svg._svg.parentNode === this._dom && this._dom.removeChild(this._svg._svg);
    },
    */
	_doDrawHtml: function () {
		this.getClientRect(this._drawRect);
		this._doRenderHtml(this._drawRect);
	},
	$_prepareSpan: function () {
		if (!this._span) {
			this._span = document.createElement("span");
			this._span.style.position = "absolute";
            this._span.style.display = 'inline-block';
            this._dom.appendChild(this._span);
		}
        this._span.style.visibility = 'visible';
		return this._span;
	},
    /*
    $_prepareSpan_2: function () {
        if (!this._span) {
            this._span = document.createElement("span");
            this._span.style.position = "absolute";
        }
        !this._span.parentNode && this._dom.appendChild(this._span);
        return this._span;
    },
    */
    $_prepareSvg: function () {
        var svg = this._svg;
        if (!svg) {
            svg = this._svg = new SvgSprite(null, this.container());
            this._dom.appendChild(svg._svg);
        }
        svg._svg.style.visibility = 'visible';
        return svg;
    },
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
	},
	_doRefresh: function () {
	},
	_doRender: function (g, r) {
	},
	_doRenderHtml: function (r) {
	},
    _renderText: function (g, font, fill, text, x, y) {
        if (this._dom) {
            var span = this.$_prepareSpan();
            Dom.renderText(span, this._font, fill, text, x, y);
        } else {
            g.drawText(font, fill, text, x, y);
        }
    }
}, {
    drawStyledBorders: function (g, r, styles) {
        var bLeft = styles.borderLeft();
        var bTop = styles.borderTop();
        var bRight = styles.borderRight();
        var bBottom = styles.borderBottom();
        var w;
        if (bLeft && (w = bLeft.width())) {
            w = _floor(w / 2);
            g.drawVertLineI(bLeft, r.y, r.bottom(), r.x + w);
        }
        if (bTop && (w = bTop.width())) {
            w = _floor(w / 2);
            g.drawHorzLineI(bTop, r.x, r.right(), r.y + w);
        }
        if (bRight && (w = bRight.width())) {
            w = _floor((w + 1) / 2);
            g.drawVertLineI(bRight, r.y, r.bottom(), r.right() - w);
        }
        if (bBottom && (w = bBottom.width())) {
            w = _floor((w + 1) / 2);
            g.drawHorzLineI(bBottom, r.x, r.right(), r.bottom() - w);
        }
    },
    drawStyledHtmlBorders: function (css, styles) {
        var bLeft = styles.borderLeft();
        var bTop = styles.borderTop();
        var bRight = styles.borderRight();
        var bBottom = styles.borderBottom();
        css.borderLeft = bLeft ? bLeft.css() : "";
        css.borderTop = bTop ? bTop.css() : "";
        css.borderRight = bRight ? bRight.css() : "";
        css.borderBottom = bBottom ? bBottom.css() : "";
    },
    drawBorders: function (elt, g, r) {
        var wLeft = elt._borderLeft ? elt._borderLeft.width() : 0,
            wTop = elt._borderTop ? elt._borderTop.width() : 0,
            wRight = elt._borderRight ? elt._borderRight.width() : 0,
            wBottom = elt._borderBottom ? elt._borderBottom.width() : 0;
        if (wLeft) {
            wLeft = _floor(wLeft / 2);
            g.drawVertLineI(elt._borderLeft, r.y, r.bottom(), r.x + wLeft);
        }
        if (wTop) {
            wTop = _floor(wTop / 2);
            g.drawHorzLineI(elt._borderTop, r.x, r.right(), r.y + wTop);
        }
        if (wRight) {
            wRight = _floor((wRight + 1) / 2);
            g.drawVertLineI(elt._borderRight, r.y, r.bottom(), r.right() - wRight);
        }
        if (wBottom) {
            wBottom = _floor((wBottom + 1) / 2);
            g.drawHorzLineI(elt._borderBottom, r.x, r.right(), r.bottom() - wBottom);
        }
    },
    drawSizedBorders: function (elt, g, r) {
        var sz, p, p1, p2,
            wLeft = elt._borderLeft ? elt._borderLeft.width() : 0,
            wTop = elt._borderTop ? elt._borderTop.width() : 0,
            wRight = elt._borderRight ? elt._borderRight.width() : 0,
            wBottom = elt._borderBottom ? elt._borderBottom.width() : 0;
        if (wLeft) {
            p1 = r.y;
            p2 = r.bottom();
            sz = elt._borderLeftSize;
            if (sz) {
                p = p2 - p1;
                sz = (p - sz.getDimension(p)) / 2;
                p1 = _int(p1 + sz);
                p2 = _int(p2 - sz);
            }
            wLeft = _floor(wLeft / 2);
            g.drawVertLineI(elt._borderLeft, p1, p2, r.x + wLeft);
        }
        if (wTop) {
            p1 = r.x;
            p2 = r.right();
            sz = elt._borderTopSize;
            if (sz) {
                p = p2 - p1;
                sz = (p - sz.getDimension(p)) / 2;
                p1 = _int(p1 + sz);
                p2 = _int(p2 - sz);
            }
            wTop = _floor(wTop / 2);
            g.drawHorzLineI(elt._borderTop, p1, p2, r.y + wTop);
        }
        if (wRight) {
            p1 = r.y;
            p2 = r.bottom();
            sz = elt._borderRightSize;
            if (sz) {
                p = p2 - p1;
                sz = (p - sz.getDimension(p)) / 2;
                p1 = _int(p1 + sz);
                p2 = _int(p2 - sz);
            }
            wRight = _floor((wRight + 1) / 2);
            g.drawVertLineI(elt._borderRight, p1, p2, r.right() - wRight);
        }
        if (wBottom) {
            p1 = r.x;
            p2 = r.right();
            sz = elt._borderBottomSize;
            if (sz) {
                p = p2 - p1;
                sz = (p - sz.getDimension(p)) / 2;
                p1 = _int(p1 + sz);
                p2 = _int(p2 - sz);
            }
            wBottom = _floor((wBottom + 1) / 2);
            g.drawHorzLineI(elt._borderBottom, p1, p2, r.bottom() - wBottom);
        }
    },
    drawHtmlBorders: function (elt) {
        elt._css.borderLeft = elt._borderLeft ? elt._borderLeft.css() : "";
        elt._css.borderTop = elt._borderTop ? elt._borderTop.css() : "";
        elt._css.borderRight = elt._borderRight ? elt._borderRight.css() : "";
        elt._css.borderBottom = elt._borderBottom ? elt._borderBottom.css() : "";
    }
});
/** @abstract */
var VisualObjectElement = defineClass("VisualObjectElement", GridElement, {
	init : function(dom, name, model) {
        VisualObjectElement.Base.init.call(this, dom, name);
		this._model = model;
		this._clipBounds = null;
		if (this._dom) {
			this._dom.style.pointerEvents = "none";
		}
	},
	model: null,
	setClipBounds: function (x, y, w, h) {
		var r;
		if (x instanceof Rectangle) {
			r = this._clipBounds || new Rectangle();
			r.x = Math.max(x.x, this._x);
			r.setRight(Math.min(x.right(), this.right()));
			r.y = Math.max(x.y, this._y);
			r.setBottom(Math.min(x.bottom(), this.bottom()));
			r.x -= this._x;
			r.y -= this._y;
		} else if (x !== null && !isNaN(x)) {
			r = this._clipBounds || new Rectangle();
			r.x = Math.max(x, this._x);
			r.setRight(Math.min(x + w, this.right()));
			r.y = Math.max(y, this._y);
			r.setBottom(Math.min(y + h, this.bottom()));
			r.x -= this._x;
			r.y -= this._y;
		}
		if (this._dom) {
			this._css.clip = Dom.getClipRect(r);
		} else {
			this._clipBounds = r;
		}
	},
	clip: function (g) {
		this.getClientRect(this._drawRect);
		g.clipRect(this._clipBounds || this._drawRect);
	},
    _doRenderHtml: function (r) {
        this._doRender(this.$_getGraphics(true, r), r);
    },
    _renderHorzBar: function (g, r, noBack) {
        var grid = this.grid();
        var body = grid.body();
        var fill;
        if (!noBack) { // for header/summary element
            if (this._dom) {
                this._dom.style.background = "#fff";
            } else {
                g.drawRectI(SolidBrush.WHITE, null, r);
            }
        } else if (fill = this._fill) { // for body element
            if (this._dom) {
                this._dom.style.background = fill.css();
            } else {
                g.drawRectI(fill, null, r);
            }
        }
        var w, wbar = body.fixedColumnBarWidth();
        if (this._fixed && wbar > 0) {
            r.setLeft(r.right() - wbar);
            r.height = grid.layoutManager().fixedBounds().height;
            var styles = body.fixedColumnBarStyles();
            var fill = styles.background();
            var stroke = styles.borderRight();
            if (fill) {
                g.drawRect(fill, null, r);
            }
            if (stroke && (w = stroke.width()) >= 0) {
                g.drawVLineI(stroke, r.x + _floor(w / 2), r.y, r.bottom());
            }
            stroke = styles.borderRight();
            if (stroke && (w = stroke.width()) >= 0) {
                g.drawVLineI(stroke, r.right() - 1 - _floor(w / 2), r.y, r.bottom());
            }
        }
    },
});
var EmptyGridElement = defineClass("EmptyGridElement", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
        if (dom) {
            this._span1 = Dom.createSimpleSpan(this._dom);
            this._span2 = Dom.createSimpleSpan(this._dom);
        }
	},
	_doRender: function(g, r) {
		var grid = this.grid(),
			s = _pick(grid.displayOptions().emptyGridMessage(), GridLocale._default.emptyGridMessage),
			s2 = grid._productName,
        	styles = grid.body().emptyStyles(),
			fill = styles.background(),
        	textFill = styles.color(),
        	font = styles.font();
		if (fill) {
            if (this._dom) {
                this._dom.style.background = fill.css();
            } else {
                g.drawRectI(fill, null, r);
            }
		}
		if (s || s2) {
			r.inflate(-10, -10);
            if (this._dom) {
                s && Dom.renderTextRect(this._span1, font, textFill, s, r, TextAlign.LEFT, TextLayout.TOP);
                s2 && Dom.renderTextRect(this._span2, font, textFill, s2, r, TextAlign.LEFT, TextLayout.BOTTOM);
            } else {
                s && g.drawTextRect(font, textFill, s, r, TextAlign.LEFT, TextLayout.TOP);
                s2 && g.drawTextRect(font, textFill, s2, r, TextAlign.LEFT, TextLayout.BOTTOM);
            }
		}
	},
	_doRenderHtml: function (r) {
        this._doRender(null, r);
	}
});
var PanelElement = defineClass("PanelElement", VisualObjectElement, {
	init : function(dom, panel) {
		this._super(dom, "panelView", panel);
		this.setElementContext(true);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return Size.create(hintWidth, this.model().minHeight());
	},
	_doRender : function(g, r) {
		var fill,
            panel = this.model(),
		    styles = panel.styles();
		fill = styles.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
        GridElement.drawStyledBorders(g, r, styles);
	},
	_doRenderHtml: function (r) {
		this._dom.style.background = "#ddd";
	}
});
var HeaderElement = defineClass("HeaderElement", VisualObjectElement, {
	init : function(dom, header, fixed) {
		this._super(dom, "headerView", header);
		this._fixed = fixed;
		this._endCol = -1;
		this._cells = {};
		this._focusedColumn = null;
		this.setElementContext(true);
	},
	fixed: function () { return this._fixed; },
	$_getChildAt: function (p, x, y, deep) {
		for (var i = 0, cnt = p.childCount(); i < cnt; i++) {
			var cell = p.getChild(i);
			if (cell.visible()) {
				if (deep && cell instanceof GroupCellElement) {
					var child = this.$_getChildAt(cell, x - cell.x(), y - cell.y(), true);
					if (child) {
						return child;
					}
				}
				if (cell.containsInBounds(x, y)) {
					return cell;
				}
			}
		}
		return null;
	},
	getCellAt: function (x, y, deep) {
		return this.$_getChildAt(this, x, y, deep);
	},
	findCell: function (column, headerOnly) {
		if (column) {
			var root = column.root();
			var view = this._cells[root.$_hash];
			if (view && view.visible()) {
				if (root != column) {
					view = view.findCell(column);
				}
				return (headerOnly && view instanceof HeaderGroupCellElement) ? view.headerCell() : view;
			}
		}
		return null;
	},
    getView: function (column, headerOnly) {
        return this.findCell(column, headerOnly);
    },
    contextOffsetX: function () {
        return this._fixed ? 0 : this.grid().leftPos();
    },
	_doMeasure: function (grid, hintWidth, hintHeight) {
        var h = this.model();
        ColumnMenuHandle.updateStyles(h.menuHandleStyles());
        ColumnFilterHandle.updateStyles(h.filterHandleStyles());
        ColumnSortHandle.updateStyles(h.sortHandleStyles());
		return Size.create(hintWidth, h.minHeight());
	},
	_doRender : function(g, r) {
        this._renderHorzBar(g, r, false);
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	$_checkCell: function (view) {
		var cell = _cast(view, HeaderCellElement);
		if (cell) {
			cell.setFocused(this._focusedColumn == cell.index().column);
		}
		if (view instanceof HeaderGroupCellElement) {
			this.$_refreshCells(view);
		}
	},
	$_refreshCells: function (group) {
		for (var i = 0, cnt = group.childCount(); i < cnt; i++) {
			this.$_checkCell(group.getChild(i));
		}
	},
	_doRefresh: function () {
		this._focusedColumn = this.grid().$_focusedIndex().column;
		for (var key in this._cells) {
			this.$_checkCell(this._cells[key]);
		}
	},
	_prepareCells: function (lm) {
		var fixed, start, end, i, column, view, index, model,
            grid = this.grid(),
            header = grid.header();
		if (grid.columnLayoutChanged()) {
		}
		this.hideAll();
		fixed = lm.fixedColCount();
		start = this._fixed ? 0 : lm.firstCol();
		end = this._fixed ? fixed - 1 : lm.lastCol();
        if (!this._fixed && lm.lastCol() != lm.lastCol2() && grid.vscrollBar().barIndent() != "none") {
            end = lm.lastCol2();
        }
        this._endCol = end;
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
            if (!column) {
                column = lm.getColumn(i);
            }
			view = this._cells[column.$_hash];
			if (!view) {
				if (column instanceof ColumnGroup) {
					view = new HeaderGroupCellElement(this._dom);
				} else {
					view = new HeaderCellElement(this._dom);
				}
				this._cells[column.$_hash] = view;
				this.addElement(view);
			}
			view.setVisible(true);
			index = CellIndex.temp(-1, column);
			model = header.getCell(index);
			view.updateCell(model);
		}
	},
	_layoutCells: function (lm) {
		var i, view, r,
            fixed = lm.fixedColCount(),
		    start = this._fixed ? 0 : lm.firstCol(),
		    end = this._endCol;// this._fixed ? fixed - 1 : lm.lastCol();
		for (i = start; i <= end; i++) {
			view = this._cells[lm.getColumn(i).$_hash];
			r = lm.getColumnBounds(i);
			r.height = this.height();
			view.setRect(r);
			view.layoutContent(lm);
		}
	}
});
/** @abstract */
var SummaryElement = defineClass("SummaryElement", VisualObjectElement, {
    init : function(dom, name, model, fixed) {
        this._super(dom, name, model);
        this._fixed = fixed;
        this._cells = {};
        this.setElementContext(true);
    },
    fixed: function () { return this._fixed; },
    findCell: function (column) {
        if (column) {
            var root = column.root();
            var view = this._cells[root.$_hash];
            if (view && view.visible()) {
                if (root != column) {
                    view = view.findCell(column);
                }
                return view;
            }
        }
        return null;
    },
    getView: function (column) {
        return this.findCell(column);
    },
    contextOffsetX: function () {
        return this._fixed ? 0 : this.grid().leftPos();
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return Size.create(hintWidth, this.model().minHeight());
    },
    _doRender : function(g, r) {
        this._renderHorzBar(g, r, false);
    },
    _doLayoutContent : function(lm) {
        this._prepareCells(lm);
        this._layoutCells(lm);
    },
    _doRefresh : function () {
    },
    _getSummary: function () {
    },
    _createCellView: function (column) {
    },
    _getSpans: function (group) {
    },
    _updateCellView: function (column, summary) {
        var index, model,
            view = this._cells[column.$_hash];
        if (!view) {
            view = this._createCellView(column);
            this._cells[column.$_hash] = view;
            this.addElement(view);
        }
        view.setVisible(true);
        index = CellIndex.temp(-1, column);
        model = summary.getCell(index);
        view.updateCell(model);
        return view;
    },
    _prepareCells: function (lm) {
        var fixed, start, end, i, column, view, index, model,
            grid = this.grid(),
            summary = this._getSummary();
        if (grid.columnLayoutChanged()) {
        }
        this.hideAll();
        fixed = lm.fixedColCount();
        start = this._fixed ? 0 : lm.firstCol();
        end = this._fixed ? fixed - 1 : lm.lastCol();
        if (!this._fixed && lm.lastCol() != lm.lastCol2() && grid.vscrollBar().barIndent() != "none") {
            end = lm.lastCol2();
        }
        this._endCol = end;
        for (i = start; i <= end; i++) {
            column = lm.getColumn(i);
            this._updateCellView(column, summary);
        }
    },
    _layoutCells: function (lm) {
        var i, col, column, view, cv, r,
            summary = this._getSummary(),
            fixedCols = lm.fixedColCount(),
            start = this._fixed ? 0 : lm.firstCol(),
            end = this._endCol, // this._fixed ? fixedCols - 1 : lm.lastCol();
            spans = this._getSpans(lm.getColumn(start)),
            height = this.height(),
            cells = this._cells;
        if (spans) {
            i = start;
            while (i <= end) {
                r = lm.columnBounds(i);
                col = lm.getColumn(i);
                column = spans[i++];
                view = this._updateCellView(column, summary);
                if (col !== column) {
                    cv = cells[col.$_hash];
                    cv && cv.setVisible(false);
                }
                for (; i <= end; i++) {
                    col = spans[i];
                    if (col !== column) break;
                    r.width += lm.columnBounds(i).width;
                    col = lm.getColumn(i);
                    if (col !== column) {
                        cv = cells[col.$_hash];
                        cv && cv.setVisible(false);
                    }
                }
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        } else {
            for (i = start; i <= end; i++) {
                view = cells[lm.getColumn(i).$_hash];
                r = lm.columnBounds(i);
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        }
    }
});
var HeaderSummaryElement = defineClass("HeaderSummaryElement", SummaryElement, {
    init : function(dom, summary, fixed) {
        this._super(dom, "headerSummaryView", summary, fixed);
    },
    _getSummary: function () {
        return this.grid().header().summary();
    },
    _createCellView: function (column) {
        return (column instanceof ColumnGroup) ? new SummaryGroupCellElement(this._dom) : new SummaryCellElement(this._dom);
    },
    _getSpans: function (group) {
        return (group && (group = group.parent()).$_summarySpanned) ? group.$_summarySpans : null;
    }
});
var FooterElement = defineClass("FooterElement", SummaryElement, {
	init : function(dom, footer, fixed) {
		this._super(dom, "footerView", footer, fixed);
	},
    _getSummary: function () {
        return this.grid().footer();
    },
    _createCellView: function (column) {
        return (column instanceof ColumnGroup) ? new FooterGroupCellElement(this._dom) : new FooterCellElement(this._dom);
    },
    _getSpans: function (group) {
        return (group && (group = group.parent()).$_footerSpanned) ? group.$_footerSpans : null;
    }
});
var VisualBarElement = defineClass("VisualBarElement", VisualObjectElement, {
    init: function (dom, name, model) {
        this._super(dom, name, model);
        this._cells = [];
        this._fixedCount = 0;
        this.setElementContext(true);
    },
    findCell: function (rowIndex) {
        for (var i = this.childCount(); i--;) {
            var c = this.getChild(i);
            if (c.index().rowIndex == rowIndex) {
                return c;
            }
        }
        return null;
    },
    _doRefresh : function () {
    },
    _doRender : function(g, r) {
        g.drawRectI(SolidBrush.WHITE, null, r);
    },
    _doRenderHtml: function (r) {
        this._css.background = SolidBrush.WHITE.css();
    },
    _doLayoutContent : function(lm) {
        var view, item, i, cnt, row, index, cell, r,
            model = this.model(),
            width = this.width(),
            topIndex = lm.topIndex(),
            fixedItemCount = lm.fixedItemCount(),
            itemCount = lm.itemCount();
        if (fixedItemCount == this._fixedCount && itemCount == this.childCount() - this._fixedCount && this.childCount() > this._fixedCount + 1) {
            view = this.getChild(this._fixedCount);
            if (view && (item = view.item()) != null) {
                if (item.index() == this._fixedCount + topIndex - 1) {
                    view = this.removeElementAt(this._fixedCount);
                    this.addElement(view);
                } else if (item.index() == this._fixedCount + topIndex + 1) {
                    view = this.removeElementAt(this.childCount() - 1);
                    this.insertElement(this._fixedCount, view);
                }
            }
        }
        this._fixedCount = fixedItemCount;
        while (this.childCount() < fixedItemCount + itemCount) {
            if (this._cells.length > 0) {
                view = this._cells.pop();
            } else {
                view = this._createCellView();
            }
            this.addElement(view);
        }
        while (this.childCount() > fixedItemCount + itemCount) {
            view = this.removeElementAt(this.childCount() - 1);
            view.validate(true);
            this._cells.push(view);
        }
        cnt = this.childCount();
        for (i = 0; i < cnt; i++) {
            row = (i < fixedItemCount) ? i : i + topIndex;
            index = CellIndex.temp(row);
            cell = this._getCell(model, index);
            view = this.getChild(i);
            this._updateCellView(view, cell, index);
            r = lm.getItemBounds(i);
            r.x = 0;
            r.width = width;
            view.setRect(r);
        }
    },
    _createCellView: function () {
    },
    _getCell: function (model, index) {
        return model.getCell(index);
    },
    _updateCellView: function (view, cell, index) {
        view.updateCell(cell);
    }
});
var RowIndicatorElement = defineClass("RowIndicatorElement", VisualBarElement, {
	init : function(dom, indicator) {
		this._super(dom, "rowIndicatorView", indicator);
	},
    findCell: function (row) {
        if (_isNumber(row)) {
            row = this.grid().getRow(row);
        }
        if (row) {
            for (var i = this.childCount(); i--;) {
                var view = this.getChild(i);
                if (view.row() === row) {
                    return  view;
                }
            }
        }
        return null;
    },
	$_calcWidth: function (grid, indicator) {
        var s, c, font, p,
		    st = indicator.styles(),
		    w = st.paddingHorz() + st.borderHorzWidth(),
		    cnt = grid.rowCount();
		if (cnt > 0) {
			s = new Array(String(cnt).length + 1).join('8');
			c = grid.container();
			font = st.font();
			p = st.prefix();
			if (p) s = p + s;
			p = st.suffix();
			if (p) s += p;
			w += c.measureText(font, s) + 2;
		}
		return Math.ceil(w);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		var mw,
			indicator = this.model(),
			w = indicator.width();
		if (isNaN(w) || w <= 0) {
			w = this.$_calcWidth(grid, indicator);
		}
		mw = indicator.maxWidth();
		if (mw > 0 && w > mw) {
			w = mw;
		}
		mw = indicator.minWidth();
		if (mw > 0 && w < mw) {
			w = mw;
		}
		return Size.create(w, hintHeight);
	},
	_doRefresh: function() {
        var i, row, index, cell, view,
		    grid = this.grid(),
		    model = grid.rowIndicator(),
		    lm = grid.layoutManager(),
		    fixed = lm.fixedItemCount(),
		    cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			row = (i < fixed) ? i : i + lm.topIndex();
			index = CellIndex.temp(row);
			cell = model.getCell(index);
			view = this.getChild(i);
			view.updateCell(cell);
		}
	},
	_createCellView: function () {
		return new IndicatorCellElement(this._dom);
	}
});
var StateBarElement = defineClass("StateBarElement", VisualBarElement, {
	init : function(dom, indicator) {
		this._super(dom, "stateBarView", indicator);
	},
    getCellView: function (rowIndex) {
        for (var i = this.childCount(); i--;) {
            var elt = this.getChild(i);
            if (elt instanceof StateCellElement && elt._index.rowIndex === rowIndex) {
                return elt;
            }
        }
        return null;
    },
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return Size.create(this.model().stateWidth(), hintHeight);
	},
    _getCell: function (model, index) {
        return model.getStateCell(index);
    },
	_createCellView: function () {
		return new StateCellElement(this._dom);
	}
});
var CheckBarElement = defineClass("CheckBarElement", VisualBarElement, {
	init : function(dom, checkBar) {
		this._super(dom, "checkBarView", checkBar);
	},
	_doMeasure : function(grid, hintWidth, hintHeight) {
		return Size.create(this.model().width(), hintHeight);
	},
	_doLayoutContent : function(lm) {
        var model = this.model(),
            grid = this.$_grid = this.grid();
        this.$_showGroup = model.showGroup();
        this.$_exclusive = model.exclusive() && model.exclusiveDisplay();
        /*if (this.model().groupCheck() && grid.rowGrouped()) {
            this._layoutGroupContent(lm, model)
        } else*/ {
            this._super(lm);
        }
    },
    /*
    _layoutGroupContent: function (lm, model) {
        var view, item, i, cnt, row, index, cell, r,
		    width = this.width(),
		    showGroup = this.$_showGroup,
		    topIndex = lm.topIndex(),
		    fixedItemCount = lm.fixedItemCount(),
		    itemCount = lm.itemCount(),
            grid = this.$_grid,
            exclusive = this.$_exclusive,
            rows = [];
		if (fixedItemCount == this._fixedCount && itemCount == this.childCount() - this._fixedCount && this.childCount() > this._fixedCount + 1) {
			view = this.getChild(this._fixedCount);
			if (view && (item = view.item()) != null) {
				if (item.index() == this._fixedCount + topIndex - 1) {
					view = this.removeElementAt(this._fixedCount);
					this.addElement(view);
				} else if (item.index() == this._fixedCount + topIndex + 1) {
					view = this.removeElementAt(this.childCount() - 1);
					this.insertElement(this._fixedCount, view);
				}
			}
		}
		this._fixedCount = fixedItemCount;
        for (i = 0; i < fixedItemCount; i++) {
            rows.push(grid.getRow(i));
        }
        i = 0;
        while (i < itemCount) {
            row = grid.getRow(i + topIndex);
            if (row.dataIndex() >= 0 && !row.parent().visible()) {
                rows.push(row);
                while (++i < itemCount) {
                    row = grid.getRow(i + topIndex);
                    if (row.dataIndex() < 0) {
                        break;
                    }
                }
            } else {
                if (row instanceof GroupRow && row.level() === grid.rowGroupLevels()) {
                    rows.push(row);
                }
                i++;
            }
        }
		while (this.childCount() < fixedItemCount + rows.length) {
			if (this._cells.length > 0) {
				view = this._cells.pop();
			} else {
				view = this._createCellView();
			}
			this.addElement(view);
		}
		while (this.childCount() > fixedItemCount + rows.length) {
			view = this.removeElementAt(this.childCount() - 1);
			view.validate(true);
			this._cells.push(view);
		}
		cnt = rows.length;
		for (i = 0; i < cnt; i++) {
			row = rows[i].index();//(i < fixedItemCount) ? i : i + topIndex;
			index = CellIndex.temp(row);
            cell = this._getCell(model, index);
			view = this.getChild(i);
            this._updateCellView(view, cell, index);
			r = lm.getItemBounds(row < fixedItemCount ? row : row - topIndex);
			r.x = 0;
			r.width = width;
            if (rows[i] instanceof GroupRow) {
                if (i < cnt - 1) {
                    r.setBottom(lm.getItemBounds(rows[i + 1].index() - topIndex).y);
                }
            }
			view.setRect(r);
		}
	},
	*/
    _createCellView: function () {
		return new CheckBarCellElement(this._dom);
	},
    _updateCellView: function (view, cell, index) {
        view.setMarkVisible(this.$_showGroup || index.getDataIndex(this.$_grid) >= 0);
        view.setExclusive(this.$_exclusive);
        this._super(view, cell);
    }
});
var GridBodyElement = defineClass("GridBodyElement", VisualObjectElement, {
	init : function (dom, body, fixed) {
		this._super(dom, "gridBodyView", body);
		this._fixed = fixed;
		this._lineScrolled = false;
		this._horzScrolling = false;
		this._fixedCount = 0;
		this._items = [];
		this._rowViews = [];
        this._viewMap = {};
		this._fill = null;
	},
	fixed: function () { return this._fixed; },
	lineScrolled: function () { return this._lineScrolled; },
	checkResourceColumn: function (column, list) {
	},
	checkResourceUse: function (url, list) {
	},
	clearItems: function () {
		this._items = [];
	},
	addItem: function (item) {
		if (this._items.indexOf(item) < 0) {
			this._items.push(item);
		}
	},
	findRowView: function (itemIndex) {
        for (var i = 0, cnt = this.childCount(); i < cnt; i++) {
			var rowView = this.getChild(i);
            var item = rowView.item();
			if (item && (item === itemIndex || item.index() == itemIndex)) {
				return rowView;
			}
		}
		return null;
	},
	findRowViewById: function (rowId) {
		for (var i = 0, cnt = this.childCount(); i < cnt; i++) {
			var rowView = this.getChild(i);
			var item;
			if (rowView instanceof DataRowElement && (item = rowView.item()) && item.dataId() == rowId) {
				return rowView;
			}
		}
		return null;
	},
	findRowViewAt: function (y) {
		for (var i = 0, cnt = this.childCount(); i < cnt; i++) {
			var rowView = this.getChild(i);
			if (y >= rowView.y() && y < rowView.bottom() ) {
				return rowView;
			}
		}
		return null;
	},
    findFirstRow: function () {
        var cnt = this.childCount();
        if (cnt > 0) {
            var first = null;
            for (var i = 1; i < cnt; i++) {
                var rowView = this.getChild(i);
                var item;
                if (rowView instanceof DataRowElement &&  (item = rowView.item())) {
                    if (!first && item.index() < first.itemIndex()) {
                        first = rowView;
                    }
                }
            }
            return first;
        }
        return null;
    },
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return {
			width : hintWidth,
			height : hintHeight
		};
	},
	_doLayoutContent : function(lm) {
		this._lineScrolled = false;
		this._super(lm);
		var i, j, item, view, styles, idx, r, topIndex, rowFixed, wbar, vindex, viewMap, itemViews,
			fixed = this._fixed,
			grid = this.grid(),
        	body = grid.body(),
			rowStyles = body.rowRangeStyles(),
			cnt = this.childCount(),
			items = this._items,
			itemCount = items.length;
        this._fill = body.styles().background();
		while ((cnt = this.childCount()) < itemCount) {
			item = items[cnt];
			view = this.$_borrowView(item);
			this.addElement(view);
		}
		while ((cnt = this.childCount()) > itemCount) {
			this.$_removeView(cnt - 1);
		}
		for (i = this.childCount(); i--;) {
			this.getChild(i)._recycling = false;
		}
		this._fixedCount = lm.fixedItemCount();
		topIndex = grid.topIndex();
		wbar = grid.body().fixedColumnBarWidth();
        vindex = 0;
        viewMap = {};
        itemViews = this.getChildren() || [];
        itemViews.length = Math.min(itemViews.length, itemCount);
        for (i = 0; i < itemCount; i++) {
			item = items[i];
            view = this._viewMap[item.dataIndex()];
            if (view && (j = itemViews.indexOf(view)) >= 0) {
                itemViews.splice(j, 1);
            } else {
                view = itemViews.pop();
            }
            if (view) {
                idx = item.index();
                rowFixed = idx < this._fixedCount;
                styles = rowStyles.getRow(idx, fixed || rowFixed);
                view.updateElement(item, styles);
                idx = rowFixed ? idx : idx - topIndex;
                r = lm.itemBounds(idx, fixed);
                r.width -= wbar;
                view.setRect(r);
                if (!view._recycling) {
                    view._displayIndex = vindex++;
                    view.layoutContent(lm);
                } else if (lm.columnMerged() && this._lineScrolled && (i <= 1 || i >= itemCount - 2)) {
                    view._displayIndex = vindex++;
                    view.layoutContent(lm);
                }
                if (item.dataIndex() >= 0) {
                    viewMap[item.dataIndex()] = view;
                }
            }
		}
        this._viewMap = viewMap;
	},
	_doRender: function(g, r) {
        this._renderHorzBar(g, r, true);
	},
	_doRefresh: function() {
	},
	$_removeView: function (rowIndex) {
		var view = this.removeElementAt(rowIndex);
		view.validate(true);
		this._rowViews.push(view);
	},
	$_borrowView: function (row) {
		var view = this._rowViews.pop();
		if (!view) {
			view = this.grid().delegate().borrowItemView(row, this._fixed);
		}
		_assert(view != null, "view is null");
		return view;
	},
	$_requestFill: function (view, g, r) {
		var fill,
            grid = this.grid();
		grid.$_requestFill(view, g, r);
        fill = this._fill;
		if (fill instanceof SolidBrush) {
			g.drawRectI(fill, null, r);
		} else if (fill) {
			r = this.clientRectByChild(view, this._drawRect);
			g.drawRectI(fill, null, r);
		}
		if ((view instanceof MergedDataCellElement || view instanceof MergedSeriesCellElement) && view._fixed) {
			fill = grid.body().fixedRowStyles().background();
			if (fill instanceof SolidBrush) {
				g.drawRectI(fill, null, r);
			} else if (fill) {
				r = grid.fixedMergeView().clientRectByChild(view, this._drawRect);
				g.drawRectI(fill, null, r);
			}
		}
	},
	$_clearSelections: function () {
		var i, map = this._viewMap;
		for (i in map) {
			map[i].$_clearSelections();
		}
	},
	$_setSelections: function (selItems, single) {
		var i, map = this._viewMap;
		for (i in map) {
			map[i].$_setSelections(selItems, single);
		}
	}
});
var GridBordersElement = defineClass("GridBordersElement", LayerElement, {
    init: function (dom, grid) {
        this._super(dom, "gridBordersView", true);
        this._grid = grid;
    },
    borderLeft: null,
    borderRight: null,
    borderTop: null,
    borderBottom: null,
    updateElement: function () {
        var st = this._grid.styles();
        this.setBorderLeft(st.borderLeft());
        this.setBorderRight(st.borderRight());
        this.setBorderTop(st.borderTop());
        this.setBorderBottom(st.borderBottom());
    },
    deflate: function (r) {
        this._borderLeft && r.leftBy(this._borderLeft.width());
        this._borderRight && r.rightBy(-this._borderRight.width());
        this._borderTop && r.topBy(this._borderTop.width());
        this._borderBottom && r.bottomBy(-this._borderBottom.width());
    },
    _doDraw: function (g) {
        GridElement.drawBorders(this, g, this._drawRect);
    },
    _doDrawHtml: function () {
        GridElement.drawHtmlBorders(this);
    }
});
var GridLinesElement = defineClass("GridLinesElement", LayerElement, {
	init: function(dom, grid) {
		this._super(dom, "gridLinesView");
		this._grid = grid;
	},
    $_renderRowBar: function (g, lm, body, fy, r) {
        var x, y, styles, fill, stroke, h;
        if (lm.fixedHeight() > 0 && body.fixedRowBarHeight() > 0) {
            x = Math.min(lm.gridBounds().right(), r.right());
            y  = r.y + lm.fixedHeight();
            if (y < fy) {
                styles = body.fixedRowBarStyles();
                fill = styles.background();
                stroke = styles.borderTop();
                if (fill) {
                    h = Math.min(body.fixedRowBarHeight(), fy - y);
                    g.drawBoundsI(fill, null, 0, y, x, h);
                }
                if (y < fy && stroke && (w = stroke.width()) > 0) {
                    g.drawHLineI(stroke, y + _floor(w / 2), 0, x);
                }
                stroke = styles.borderBottom();
                y += body.fixedRowBarHeight() - 1;
                if (y < fy && stroke && (w = stroke.width()) > 0) {
                    g.drawHLineI(stroke, y - _floor(w / 2), 0, x);
                }
            }
        }
    },
	_doDraw: function (g) {
		var styles, x, y, fill, stroke, styles, w,
			grid = this._grid,
			body = grid.body(),
			lm = grid.layoutManager(),
			r = lm.bodyBounds(),
			fy = lm.footerBounds().y,
			x2 = Math.min(r.right(), lm.gridBounds().right());
        this.$_renderRowBar(g, lm, body, fy, r);
		styles = body.styles();
        x = r.x + r.width;
        y = r.y + r.height;
        if (!grid.$_hideBorders) {
            stroke = styles.borderRight();
            if (stroke && stroke.width() > 0) {
                if ((/*lm._needVscrollIndent ||*/ x <= x2) && lm.columnCount() + lm.fixedColCount() > 0) {
                    g.drawVLineI(SolidPen.WHITE, x - 1, 0, y);
                    g.drawVLineI(stroke, x - 1, 0, y);
                }
            }
        }
        stroke = styles.borderBottom();
        if (stroke && stroke.width() > 0) {
            if (grid.rowCount() > 0 && lm.itemCount() == lm.fullItemCount() && y < fy) {
                g.drawHLineI(SolidPen.WHITE, y - 1, 0, x2);
                g.drawHLineI(stroke, y - 1, 0, x2);
            }
        }
		/*
		r = lm.bodyBounds();
		r.height--;
		r.width--;
		g.drawRect(null, SolidPen.RED, r);
		console.log('##### BODY: ' + r.x);
		*/
	},
	_doDrawHtml: function () {
        var h, sRight, sBottom,
            grid = this._grid,
            lm = grid.layoutManager(),
            body = grid.body(),
            styles = body.styles(),
            r = lm.bodyBounds(),
            x = r.x + r.width,
            y = r.y + r.height,
            x2 = Math.min(r.right(), lm.gridBounds().right()),
            fy = lm.footerBounds().y;
        if (lm.fixedHeight() > 0 && (h = body.fixedRowBarHeight()) > 0) {
            this.$_renderRowBar(this.$_getGraphics(true, new Rectangle(0, 0, this.container().width(), fy + h)), lm, body, fy, r);
        }
        this._css.borderRight = null;
        stroke = styles.borderRight();
        if (stroke && stroke.width() > 0) {
            if ((/*lm._needVscrollIndent ||*/ x <= x2) && lm.columnCount() + lm.fixedColCount() > 0) {
                sRight = stroke;
            }
        }
        this._css.borderBottom = null;
        stroke = styles.borderBottom();
        if (stroke && stroke.width() > 0) {
            if (grid.rowCount() > 0 && lm.itemCount() == lm.fullItemCount() && y < fy) {
                sBottom = stroke;
            }
        }
        if (sRight || sBottom) {
            this._css.left = 0;
            this._css.top = 0;
            this._css.width = (x/* - lm.leftPos()*/) + 'px';
            this._css.height = y + 'px';
            this._css.borderRight = sRight ? sRight.css() : null;
            this._css.borderBottom = sBottom ? sBottom.css() : null;
        } else {
            this._css.borderRight = null;
            this._css.borderBottom = null;
        }
	}
});
var CustomGridItemHeadElement = defineClass("CustomGridItemHeadElement", GridElement, {
    init: function (dom) {
        this._super(dom, "gridItemHead");
    },
    _doRender: function (g, rc) {
    },
    _doRenderHtml: function (r) {
    }
});
var CustomGridItemElement = defineClass("CustomGridItemElement", VisualObjectElement, {
	init: function (dom, name,  item) {
		this._super(dom, name || "gridItemView", item);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return Size.create(hintWidth, this.model().height());
	},
    _doLayoutContent: function (lm) {
        var r = this.getClientRect(this._drawRect);
        this._doLayoutItem(lm, r);
    },
	/*,
	_doRender : function(g, r) {
	},
	_doRenderHtml: function (r) {
		this._dom.style.background = "#fff";
	}
	*/
    _doLayoutItem: function (lm, r) {
    }
});
var CustomGridItemsLayer = defineClass("CustomGridItemsLayer", LayerElement, {
	init: function (dom, items) {
		this._super(dom, "customGridItemsLayer");
		this._items = items;
        this._viewMap = {};
        this._fillHeights = 0;
	},
	measure: function (grid, hintWidth, hintHeight) {
        var height = 0;
        for (var i = this._items.count(); i--;) {
            var item = this._items.getItem(i);
            var min = item.minHeight();
            var max = item.maxHeight();
            var h = item.height();
            if (isNaN(h)) h = 0;
            if (!isNaN(min)) h = Math.max(min, h);
            if (!isNaN(max)) h = Math.min(max, h);
            height += item.$_measuredHeight = Math.max(0, h);
        }
		return new Size(hintWidth, height);
	},
	layoutContent: function (lm) {
        var i, cnt, item, view, h, f,
            grid = lm.grid(),
            viewMap = {},
            height = this.height(),
            y = 0;
        this.clear();
        for (i = 0, cnt = this._items.count(); i < cnt; i++) {
            item = this._items.getItem(i);
            h = item.$_measuredHeight;
            view = viewMap[item.$_hash];
            if (!view) {
                view = item.createItemView(this._dom);
                viewMap[item.$_hash] = view;
            }
            this.addChild(view);
            if (i < cnt - 1 && this._fillHeights > 0 && item.$_fillHeight > 0) {
                h += _int(this._measuredFillHeights * item.$_fillHeight / this._fillHeights);
            }
            view.setModel(item);
            view.setBoundsI(0, y, this.width(), i < cnt - 1 ? h : height);
            view.layoutContent(lm);
            y += h;
            height -= h;
        }
        this._viewMap = viewMap;
	},
    getFillHeights: function () {
        var i, item,
            height = 0;
        for (i = this._items.count(); i--;) {
            item = this._items.getItem(i);
            h = parseFloat(item.fillHeight());
            height += item.$_fillHeight = isNaN(h) ? 0 : h;
        }
        return this._fillHeights = height;
    },
    setFillHeights: function (value) {
        this._measuredFillHeights = value;
    },
    clip: function (g) {
        this.getClientRect(this._drawRect || (this._drawRect = new Rectangle()));
        g.clipRect(this._drawRect);
    },
	_doDraw: function (g) {
        /*
        var r = this._drawRect;
        var st = this._items.styles();
        g.drawRectI(st.background(), null, r);
        GridElement.drawStyledBorders(g, r, st);
        */
	},
	_doDrawHtml: function () {
        /*
        var css = this._css;
        var r = this._drawRect;
        this.getClientRect(r);
        css.background = st.background().css();
        GridElement.drawStyledHtmlBorders(css, st);
        */
	}
});
/** @abstract */
var HandleElement = defineClass("HandleElement", UIElement, {
	init: function (dom, owner, name) {
		this._super(dom, name);
		this._owner = owner;
	},
	owner: function () { return this._owner; },
	$_getGraphics: function (clear) {
		var svg = this._svg;
		if (!svg) {
			svg = this._svg = new SvgSprite(null, this.container());
		}
		!svg._svg.parentNode && this._dom.appendChild(svg._svg);
		return svg.getGraphics(clear);
	},
	propertyChanged: function () {
		this.invalidate();
	},
	_doClearHtml: function () {
		this._svg && this._svg._svg.parentNode === this._dom && this._dom.removeChild(this._svg._svg);
	}
});
/** @abstract */
var CellHandle = defineClass("CellHandle", HandleElement, {
	init: function (dom, cellView, name) {
		this._super(dom, cellView, name);
	},
	cellView: function () {
		return this._owner;
	},
	_hoveredChanged: function () {
		this.invalidate();
        if (this._owner.$_handleHoveredChanged) {
            this._owner.$_handleHoveredChanged(this, this.hovered());
        } else {
            this._owner.canHovering() && this._owner.invalidate();
        }
	}
});
var ColumnSortHandle = defineClass("ColumnSortHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "sortHandle");
		this.setClickable(false);
	},
	sortOrder: -1,
	sortDir: EnumProp(SortDirection, SortDirection.ASCENDING),
    renderer: null,
    background: function () { return ColumnSortHandle.background; },
    hoveredBackground: function () { return ColumnSortHandle.hoveredBackground; },
    border: function () { return ColumnSortHandle.border; },
    emptyBorder: function () { return ColumnSortHandle.emptyBorder; },
    hoveredBorder: function () { return ColumnSortHandle.hoveredBorder; },
	_doDraw: function (g) {
        this._renderer && this._renderer.draw(g, this.clientRect(), this);
	},
	_doDrawHtml: function () {
		this._renderer && this._renderer.drawHtml(this.clientRect(), this);
	}
}, {
    updateStyles: function (styles) {
        this.background = styles.shapeColor();
        this.hoveredBackground = styles.shapeHoveredColor();
        this.border = styles.shapeBorder();
        this.emptyBorder = styles.shapeInactiveBorder();
        this.hoveredBorder = styles.shapeHoveredBorder();
    },
    background: null,
    hoveredBackground: null,
    border: null,
    emptyBorder: null,
    hoveredBorder: null
});
var ColumnFilterHandle = defineClass("ColumnFilterHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "filterHandle");
		this.setClickable(true);
	},
    renderer: null,
    column: null,
    background: function () { return ColumnFilterHandle.background; },
    hoveredBackground: function () { return ColumnFilterHandle.hoveredBackground; },
    border: function () { return ColumnFilterHandle.border; },
    emptyBorder: function () { return ColumnFilterHandle.emptyBorder; },
    hoveredBorder: function () { return ColumnFilterHandle.hoveredBorder; },
	_doDraw: function(g) {
        this._column && this._renderer && this._renderer.draw(g, this.clientRect(), this);
	},
    _doDrawHtml: function () {
        this._renderer && this._renderer.drawHtml(this.clientRect(), this);
    }
}, {
    updateStyles: function (styles) {
        this.background = styles.shapeColor();
        this.hoveredBackground = styles.shapeHoveredColor();
        this.border = styles.shapeBorder();
        this.emptyBorder = styles.shapeInactiveBorder();
        this.hoveredBorder = styles.shapeHoveredBorder();
    },
    background: null,
    hoveredBackground: null,
    border: null,
    emptyBorder: null,
    hoveredBorder: null
});
var ColumnMenuHandle = defineClass("ColumnMenuHandle", CellHandle, {
    init: function(dom, cellView) {
        this._super(dom, cellView, "menuHandle");
        this.setClickable(true);
    },
    renderer: null,
    column: null,
    background: function () { return ColumnFilterHandle.background; },
    hoveredBackground: function () { return ColumnFilterHandle.hoveredBackground; },
    _doMeasure: function (grid/*, hintWidth, hintHeight*/) {
        return { width: 7, height: 13 };
    },
    _doDraw: function(g) {
        if (this._column) {
            var r = this.clientRect();
            var x = r.x + r.width / 2;
            var y = r.y + (r.height - 13 + 3) / 2;
            var fill = this.hovered() ? this.hoveredBackground() : this.background();
            g.drawCircle(fill, null, x, y, 1.5);
            y += 3 + 2;
            g.drawCircle(fill, null, x, y, 1.5);
            y += 3 + 2;
            g.drawCircle(fill, null, x, y, 1.5);
        }
    },
    _doDrawHtml: function () {
        this._doDraw(this.$_getGraphics(true, this.clientRect()));
    }
}, {
    updateStyles: function (styles) {
        this.background = styles.shapeColor();
        this.hoveredBackground = styles.shapeHoveredColor();
    },
    background: null,
    hoveredBackground: null
});
var HEADER_CHECKBOX_SIZE = 11;
var HEADER_CHECKBOX_BORDER = new SolidPen("rgba(170, 170, 170, 0.7)");
var HeaderCheckHandle = defineClass("HeaderCheckHandle", CellHandle, {
    init: function(dom, cellView) {
        this._super(dom, cellView, "checkHandle");
        this.setClickable(true);
    },
    checked: false,
    _doDraw: function (g) {
        var r = this.getClientRect();
        var fill = SolidBrush.WHITE;
        if (fill) {
            g.drawRectI(fill, HEADER_CHECKBOX_BORDER, r);
        }
        this.$_drawCheck(g, r);
    },
    _doDrawHtml: function () {
        this._doDraw(this.$_getGraphics());
    },
    $_drawCheck: function (g, r) {
        var sz = HEADER_CHECKBOX_SIZE;
        g.drawBoundsI(null, CHECK_CELL_BORDER, r.x, r.y, sz, sz);
        if (this.checked()) {
            r.x++;
            var fill = SolidBrush.DIMGRAY;// this.figureBackground();
            $$_drawCheckMark(g, fill, r, sz - 1);
        }
    }
});
var HeaderImageHandle = defineClass("HeaderImageHandle", CellHandle, {
    init: function(dom, cellView) {
        this._super(dom, cellView, "imageHandle");
        this.setMouseEnabled(false);
        this.setClickable(false);
    },
    image: null,
    _doDraw: function (g) {
        var img = this._image;
        if (img && img.width > 0 && img.height > 0) {
            g.drawImage(img, 0, 0, img.width, img.height);
        }
    },
    _doDrawHtml: function () {
        this._doDraw(this.$_getGraphics(true));
    }
});
var DataCellExpandHandle = defineClass("DataCellExpandHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "dataCellExpandHandle");
        this.setClickable(true);
	},
	expanded: false,
	color: null,
    fill: null,
	group: function () {
		var view = _cast(this.cellView(), MergedDataCellElement);
		return view ? view.mergeRoom().group() : null;
	},
	_doDraw: function (g) {
		var r = this.clientRect();
		var color = this._color;
        var fill = this._fill;
        fill && g.drawRectI(fill, null, r);
		if (this.expanded()) {
			$$_drawMinusBox(g, r, 9, color);
		} else {
			$$_drawPlusBox(g, r, 9, color);
		}
	},
    _doDrawHtml: function () {
        this._doDraw(this.$_getGraphics(true));
    }
});
/** @abstract */
var CellRenderer = defineClass("CellRenderer", GridObject, {
    init: function () {
        this._super();
    }
});
var CellElementIndex = defineClass('CellElementIndex', CellIndex, {
    init: function (grid, rowIndex, column) {
        this._super(rowIndex, column);
        this._grid = grid;
    },
    grid: function () {
        return this._grid;
    },
    getValue: function () {
        var column = this.column;
        if (column instanceof DataColumn) {
            var fld = column.dataIndex();
            if (fld >= 0) {
                var row = this._grid.getRow(this.rowIndex);
                if (row) {
                    return row.getValue(fld);
                }
            }
        }
        return undefined;
    }
});
/** @abtract */
var CellElement = defineClass("CellElement", GridElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._grid = null;
        this._fixed = false;
        this._colspan = 1;
        this._recycling = false;
        this._index = new CellElementIndex(null);
        this._renderRect = new Rectangle();
        this._textAlign = "left";
        this._lineAlign = "middle";
    },
    background: SolidBrush.WHITE,
    color: SolidBrush.BLACK,
    font: null,
    border: null,
    borderLeft: null,
    borderTop: null,
    borderRight: null,
    borderBottom: null,
    paddingLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    shapeColor: SolidBrush.DIMGRAY,
    shapeColors: null,
    shapeInactiveColor: SolidBrush.LTGRAY,
    shapeHoveredColor: SolidBrush.DIMGRAY,
    shapeBorder: null,
    shapeSize: null,
    shapeRotate: 0,
    shapeName: null,
    textAlignment: EnumProp(Alignment, Alignment.NEAR),
    lineAlignment: EnumProp(Alignment, Alignment.CENTER),
    textWrap: EnumProp(TextWrap, TextWrap.NONE),
    pushed: false,
    mouseEntered: false,
    pressed: false,
    index: null,
    isFixed: function () {
        return this._fixed;
    },
    setIndex: function (value) {
        if (!CellIndex.areEqual(this._index, value)) {
            this._index.assign(value);
            this.invalidate();
        }
    },
    /** @deprecated use row instead. */
    item: function () {
        return this._index.getRow(this._grid);
    },
    row: function () {
        return this._index.getRow(this._grid);
    },
    setTextAlignment: function (value) {
        if (value != this._textAlignment) {
            this._textAlign = _alignmentToText(this._textAlignment = value);
            this.invalidate();
        }
    },
    setLineAlignment: function (value) {
        if (value != this._lineAlignment) {
            this._lineAlign = _alignmentToLine(this._lineAlignment = value);
            this.invalidate();
        }
    },
    setFont: function (v) {
        var f = this._font;
        if (v == f) return;
        if (!v || !f || v.font != f.font || v.size != f.size || v.deco != f.deco || v.line !== f.line) {
            this._font = v;
            this.invalidate();
        }
    },
    borderWidth: function () {
        return this._border ? this._border.width() : 0;
    },
    borderLeftWidth: function () {
        return this._borderLeft ? this._borderLeft.width() : 0;
    },
    borderRightWidth: function () {
        return this._borderRight ? this._borderRight.width() : 0;
    },
    borderHorzWidth: function () {
        return (this._borderLeft ? this._borderLeft.width() : 0) + (this._borderRight ? this._borderRight.width() : 0);
    },
    borderTopWidth: function () {
        return this._borderTop ? this._borderTop.width() : 0;
    },
    borderBottomWidth: function () {
        return this._borderBottom ? this._borderBottom.width() : 0;
    },
    borderVertWidth: function () {
        return (this._borderTop ? this._borderTop.width() : 0) + (this._borderBottom ? this._borderBottom.width() : 0);
    },
    paddingHorz: function () {
        return this._paddingLeft + this._paddingRight;
    },
    paddingVert: function () {
        return this._paddingTop + this._paddingBottom;
    },
    textAlign: function () {
        return this._textAlign;
    },
    lineAlign: function () {
        return this._lineAlign;
    },
    canHovering: function (hovered) {
        return true;
    },
    setMouseEntered: function (value) {
        if (value != this._mouseEntered) {
            this._mouseEntered = value;
            if (this.canHovering(value)) {
                this._doLayoutHandles();
                this.invalidate(false, true);
            }
        }
    },
    setPressed: function (value) {
        if (value != this._pressed) {
            this._pressed = value;
            this.invalidate(false, true);
        }
    },
    $_handleHoveredChanged: function (handle, hovered) {
        if (this.canHovering(hovered)) {
            this._doLayoutHandles();
            this.invalidate(false, true);
        }
    },
    $_setHoverIndex: function (x, y) {
    },
    isDataCell: function () {
        return false;
    },
    canEditable: function () {
        return false;
    },
    canEditableAt: function (p) {
        return this.canEditable();
    },
    updateCell: function (model) {
        this._index._grid = this._grid = this.grid();
        this.setIndex(model.index());
        this.$_clickRect = undefined;
        this._doPrepareElement(model);
        this._doPrepareValue(model);
        this._doUpdateContent(model);
    },
    inflatePadding: function (r) {
        r.x += this._paddingLeft;
        r.width -= this._paddingLeft + this._paddingRight;
        r.y += this._paddingTop;
        r.height -= this._paddingTop + this._paddingBottom;
        return r;
    },
    deflatePadding: function (r) {
        r.x -= this._paddingLeft;
        r.width += this._paddingLeft + this._paddingRight;
        r.y -= this._paddingTop;
        r.height += this._paddingTop + this._paddingBottom;
        return r;
    },
    deflatePadding2: function (r) {
        r.x += this._paddingLeft;
        r.width -= this._paddingLeft + this._paddingRight;
        r.y += this._paddingTop;
        r.height -= this._paddingTop + this._paddingBottom;
        return r;
    },
    inflatePadding2: function (r) {
        r.x -= this._paddingLeft;
        r.width += this._paddingLeft + this._paddingRight;
        r.y -= this._paddingTop;
        r.height += this._paddingTop + this._paddingBottom;
        return r;
    },
    getButtonWidth: function () {
        return 0;
    },
    getDelegateParent: function () {
        var cell = this,
            column = this._index.column;
        while (column && (column = column.$_delegateOwner)) {
            cell = cell.parent();
            column = cell._index.column;
        }
        return cell;
    },
    measureWidth: function (grid, defWidth, maxInt, height) {
        return this._doMeasureWidth(grid, defWidth, maxInt, height);
    },
    measureHeight: function (grid, width) {
        return this._doMeasureHeight(grid, width);
    },
    ptInHovered: function (x, y) {
        return true;
    },
    propertyChanged: function (prop, value) {
        this.invalidate();
    },
    _doLayoutContent: function (lm) {
        this._doLayoutHandles();
    },
    _doRender: function (g, r) {
        g.drawTextRect(null, SolidBrush.BLACK, "Cell:" + this._index.toString(), r, TextAlign.CENTER);
    },
    _doPrepareElement: function (model) {
        var s = model.styles();
        this.setBackground(s.background());
        this.setColor(s.color());
        this.setFont(s.font());
        this.setBorder(s.border());
        this.setBorderLeft(s.borderLeft());
        this.setBorderTop(s.borderTop());
        this.setBorderRight(s.borderRight());
        this.setBorderBottom(s.borderBottom());
        this.setPaddingLeft(s.paddingLeft());
        this.setPaddingTop(s.paddingTop());
        this.setPaddingRight(s.paddingRight());
        this.setPaddingBottom(s.paddingBottom());
        this.setShapeColor(s.shapeColor());
        this.setShapeColors(s.shapeColors());
        this.setShapeInactiveColor(s.shapeInactiveColor());
        this.setShapeHoveredColor(s.shapeHoveredColor());
        this.setShapeBorder(s.shapeBorder());
        this.setShapeSize(s.shapeSize());
        this.setShapeRotate(s.shapeRotate());
        this.setShapeName(s.shapeName());
        this.setTextAlignment(s.textAlignment());
        this.setLineAlignment(s.lineAlignment());
        this.setTextWrap(s.textWrap());
        this._textDeco = s.textDecoration();
    },
    _doPrepareValue: function (model) {
    },
    _doUpdateContent: function (model) {
    },
    _doLayoutHandles: function () {
    },
    _drawBorders: function (g, r) {
        GridElement.drawBorders(this, g, r);
    },
    _drawHtmlBorders: function () {
        GridElement.drawHtmlBorders(this);
    },
    _getRenderRect: function (source) {
        var r = this._renderRect,
            wLeft = this._borderLeft ? _int((this._borderLeft.width() + 1) / 2) : 0,
            wTop = this._borderTop ? _int((this._borderTop.width() + 1) / 2) : 0;
        if (source) {
            r.set(source.x + wLeft, source.y + wTop,
                source.width - wLeft - (this._borderRight ? _int((this._borderRight.width() + 1) / 2) : 0),
                source.height - wTop - (this._borderBottom ? _int((this._borderBottom.width() + 1) / 2) : 0));
        } else {
            r.set(wLeft, wTop,
                this.width() - wLeft - (this._borderRight ? _int((this._borderRight.width() + 1) / 2) : 0),
                this.height() - wTop - (this._borderBottom ? _int((this._borderBottom.width() + 1) / 2) : 0));
        }
        return r;
    },
    _renderText: function (g, text, fill, r) {
        this._renderTextBounds(g, text, fill, r.x, r.y, r.width, r.height);
    },
    _renderTextBounds: function (g, text, fill, x, y, width, height) {
        if (this._dom) {
            var span = this.$_prepareSpan();
            Dom.renderTextBounds(span, this._font, fill, text, x, y, width, height,
                this._textAlign, this._lineAlign, this._textWrap);
        } else {
            switch (this._textWrap) {
                case TextWrap.EXPLICIT:
                    g.drawTextBoundsExplicit(this._font, fill, text, x, y, width, height, this._textAlign, this._lineAlign);
                    break;
                case TextWrap.NORMAL:
                    g.drawTextBoundsWrap(this._font, fill, text, x, y, width, height, this._textAlign, this._lineAlign);
                    break;
                default:
                    g.drawTextBounds(this._font, fill, text, x, y, width, height, this._textAlign, this._lineAlign);
                    break;
            }
        }
    },
    _renderText2: function (g, text, font, fill, r, align, valign, wrap) {
        this._renderTextBounds2(g, text, font, fill, r.x, r.y, r.width, r.height, align, valign, wrap);
    },
    _renderTextBounds2: function (g, text, font, fill, x, y, width, height, align, valign, wrap) {
        if (this._dom) {
            var span = this.$_prepareSpan();
            Dom.renderTextBounds(span, font, fill, text, x, y, width, height, align, valign, wrap);
        } else {
            switch (wrap) {
                case TextWrap.EXPLICIT:
                    g.drawTextBoundsExplicit(font, fill, text, x, y, width, height, align, valign);
                    break;
                case TextWrap.NORMAL:
                    g.drawTextBoundsWrap(font, fill, text, x, y, width, height, align, valign);
                    break;
                default:
                    g.drawTextBounds(font, fill, text, x, y, width, height, align, valign);
                    break;
            }
        }
    },
    _renderTextEx: function (g/* span */, text, font, fill, r, align, valign, wrap) {
        this._renderTextBoundsEx(g, text, font, fill, r.x, r.y, r.width, r.height, align, valign, wrap);
    },
    _renderTextBoundsEx: function (g/* span */, text, font, fill, x, y, width, height, align, valign, wrap) {
        if (this._dom) {
            g = g;
            Dom.renderTextBounds(g, font, fill, text, x, y, width, height, align, valign, wrap);
        } else {
            switch (wrap) {
                case TextWrap.EXPLICIT:
                    g.drawTextBoundsExplicit(font, fill, text, x, y, width, height, align, valign);
                    break;
                case TextWrap.NORMAL:
                    g.drawTextBoundsWrap(font, fill, text, x, y, width, height, align, valign);
                    break;
                default:
                    g.drawTextBounds(font, fill, text, x, y, width, height, align, valign);
                    break;
            }
        }
    },
    _calcTextRect: function (g, font, text, x, y, w, h) {
        if (this._dom) {
            var span = this.container().$_textMeasurer;
            return Dom.calcTextBounds(span, this._font, text, x, y, w, h,
                this._textAlign, this._lineAlign, this._textWrap);
        } else {
            switch (this._textWrap) {
                case TextWrap.EXPLICIT:
                    return g.getExplicitTextRect(font, text, x, y, w, h, this._textAlign, this._lineAlign);
                case TextWrap.NORMAL:
                    return g.getWrapTextRect(font, text, x, y, w, h, this._textAlign, this._lineAlign);
                default:
                    return g.getTextRect(font, text, x, y, w, h, this._textAlign, this._lineAlign);
            }
        }
    },
    _calcTextRectEx: function (g, font, text, x, y, w, h, align, valign, wrap) {
        if (this._dom) {
            var span = this.container().$_textMeasurer;
            return Dom.calcTextBounds(span, font, text, x, y, w, h, align, valign, wrap);
        } else {
            switch (wrap) {
                case TextWrap.EXPLICIT:
                    return g.getExplicitTextRect(font, text, x, y, w, h, align, valign);
                case TextWrap.NORMAL:
                    return g.getWrapTextRect(font, text, x, y, w, h, align, valign);
                default:
                    return g.getTextRect(font, text, x, y, w, h, align, valign);
            }
        }
    },
    _doMeasureWidth: function (grid, defWidth, maxInt, height) {
        return this._doMeasure(grid, maxInt, height).width;
    },
    _doMeasureHeight: function (grid, defWidth, maxInt, height) {
    },
    _measureText: function (text, w, h) {
        var r = this.container().measureTextRect(this._font, text, 0, 0, w, h, this._textAlign, this._lineAlign, this._textWrap);
        return { width: r.width, height: r.height };
    },
    $_setSelected: function (value, ranges) {
        if (this._selected != value || !_equalsArray(ranges, this._selRanges)) {
            this._selected = value;
            this._selRanges = ranges;
            this.invalidate(false, true);
        }
    }
});
var CellMenuElement = defineClass("CellMenuElement", GridElement, {
    init: function (dom, owner) {
        this._super(dom);
        this._owner = owner;
        this._grid = null;
    },
    background: null,
    color: null,
    hoveredColor: null,
    owner: function () {
        return this._owner;
    },
    setColor: function (value) {
        if (value != this._color) {
            this._color = value;
            this._stroke = value ? new SolidPen(value.color(), 2) : null;
        }
    },
    setHoveredColor: function (value) {
        if (value != this._hoveredColor) {
            this._hoveredColor = value;
            this._hoveredStroke = value ? new SolidPen(value.color(), 2) : null;
        }
    },
    _doMeasure: function (grid/*, hintWidth, hintHeight*/) {
        return {width: 11, height: 11};
    },
    _doRender: function (g, r) {
        var y, dy, w, x,
            fill = this._background,
            pen = this._hovered ? this._hoveredStroke : this._stroke;
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        if (pen) {
            y = r.y + (r.height - 10) / 2;
            dy = 3 / 2;
            w = Math.min(9, r.width);
            x = r.x + (r.width - w) / 2;
            y += 1;
            g.drawHLine(pen, y, x, x + w);
            y += 3.5;
            g.drawHLine(pen, y, x, x + w);
            y += 3.5;
            g.drawHLine(pen, y, x, x + w);
        }
    },
    _doRenderHtml: function (r) {
        this._doDraw(this.$_getGraphics(true, r), r);
    },
    _hoveredChanged: function () {
        this.invalidate();
    },
    propertyChanged: function () {
        this.invalidate();
    }
});
/** @abstract */
var GroupCellElement = defineClass("GroupCellElement", CellElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._cells = {};
    },
    focused: false,
    group: function () {
        var col = this._index.column;
        return col instanceof ColumnGroup ? col : null;
    },
    findCell: function (column) {
        var i, cnt, view;
        for (i = 0, cnt = this.childCount(); i < cnt; i++) {
            view = this.getChild(i);
            if (view.visible()) {
                if (view.index().column === column) {
                    return view;
                }
                if (view instanceof GroupCellElement) {
                    view = view.findCell(column);
                    if (view) {
                        return view;
                    }
                }
            }
        }
        return null;
    },
    getDisplayIndex: function (cell) {
        var group,
            children = this.getVisibleChildren();
        if (children && children.length > 0) {
            group = this.group();
            if (group.vertical()) {
                children.sort(function (v1, v2) {
                    return v1.y() - v2.y();
                })
            } else {
                children.sort(function (v1, v2) {
                    return v1.x() - v2.x();
                })
            }
            return children.indexOf(cell);
        }
        return -1;
    },
    getVisibleChild: function (index) {
        var group,
            children = this.getVisibleChildren();
        if (children && index >= 0 && index < children.length) {
            group = this.group();
            if (group.vertical()) {
                children.sort(function (v1, v2) {
                    return v1.y() - v2.y();
                })
            } else {
                children.sort(function (v1, v2) {
                    return v1.x() - v2.x();
                })
            }
            return children[index];
        }
        return null;
    },
    getCellBounds: function (cellView, bounds) {
        var column = this.index().column,
            group = cellView.index().column.group(),
            view = cellView;
        if (!bounds) {
            bounds = cellView.bounds();
        } else {
            bounds.copy(cellView.bounds());
        }
        while (group && group != column) {
            view = view.parent();
            bounds.x += view.x();
            bounds.y += view.y();
            group = group.group();
        }
        return bounds;
    },
    $_getChild: function (p, x, y, recursive) {
        var i, cnt, cell, child;
        for (i = 0, cnt = p.childCount(); i < cnt; i++) {
            cell = p.getChild(i);
            if (recursive && cell instanceof GroupCellElement) {
                child = this.$_getChild(cell, x - cell.x(), y - cell.y(), recursive);
                if (child) {
                    return child;
                }
            }
            if (cell.containsInBounds(x, y)) {
                return cell;
            }
        }
        return null;
    },
    getCellAt: function (x, y, recursive) {
        return this.$_getChild(this, x, y, recursive);
    },
    updateCell: function (model) {
        this._super(model);
        this._doUpdateGroup(model.index().column);
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return new Size(hintWidth, grid.header().minHeight());
    },
    _doRender: function (g, r) {
        if (this._needRender()) {
            g.drawRect(this._background, null, r);
            this._renderCell(g, r);
            GridElement.drawBorders(this, g, r);
        }
    },
    _doRenderHtml: function (r) {
        if (this._needRender()) {
            var fill = this._background;
            _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
            this._renderCell(null, r);
            GridElement.drawHtmlBorders(this);
        }
    },
    _doLayoutContent: function (lm) {
        var grid = lm.grid();
        if (grid.columnLayoutChanged()) {
            this.clear();
            this._cells = {};
        }
        this._prepareCells(lm, grid);
        this._layoutCells(lm, grid);
    },
    $_clearSelections: function () {
        var i, cnt, view, selected;
        for (i = 0, cnt = this.childCount(); i < cnt; i++) {
            view = this.getChild(i);
            if (view.visible()) {
                view.$_setSelected(false);
                if (view instanceof GroupCellElement) {
                    view.$_clearSelections();
                }
            }
        }
    },
    $_setSelections: function (selItems, single) {
        var i, j, cnt, view, selected,
            len = selItems.length;
        for (i = 0, cnt = this.childCount(); i < cnt; i++) {
            view = this.getChild(i);
            if (view.visible()) {
                if (single) {
                    view.$_setSelected(CellIndex.areEqual(selItems[0]._startIndex, view._index));
                } else {
                    selected = false;
                    for (j = len; j--;) {
                        if (selItems[j].contains(view._index)) {
                            selected = true;
                            break;
                        }
                    }
                    view.$_setSelected(selected);
                }
                if (view instanceof GroupCellElement) {
                    view.$_setSelections(selItems, single);
                }
            }
        }
    },
    _needRender: function () {
        return this.childCount() <= 0;
    },
    _renderCell: function (g, r) {
    },
    _doUpdateGroup: function (group) {
    },
    _getCell: function (column) {
        return this._cells[column.$_hash];
    },
    $_setCell: function (column, view) {
        this._cells[column.$_hash] = view;
    },
    _prepareCells: function (lm) {
    },
    _layoutCells: function (lm) {
    }
}, {
    getRootOf: function (cell) {
        var p,
            group = _cast(cell.parent(), GroupCellElement);
        if (!group) {
            return null;
        }
        while (group) {
            p = _cast(group.parent(), GroupCellElement);
            if (!p) {
                return group;
            }
            group = p;
        }
        return null;
    }
});
/** @abstract */
var ValueCellElement = defineClass("ValueCellElement", CellElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._numberFormatter = null;
        this._datetimeWriter = null;
        this._booleanFormatter = null;
        this._textFormatter = null;
    },
    focused: false,
    deleted: false,
    text: null,
    prefix: null,
    suffix: null,
    line: null,
    hoveredBackground: null,
    hoveredColor: null,
    selectedBackground: SolidBrush.WHITE,
    selectedColor: SolidBrush.BLACK,
    shapeSelectedColor: null,
    shapeSelectedBorder: null,
    numberFormat: null,
    datetimeFormat: null,
    booleanFormat: null,
    textFormat: null,
    setFocused: function (value) {
        if (value != this._focused) {
            this._focused = value;
            this.invalidate(false, true);
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
            this._numberFormatter = value ? new DecimalFormatter(value) : null;
            this.invalidate();
        }
    },
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            this._datetimeWriter = value ? new DateTimeWriter(value) : null;
            this.invalidate();
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            this._boolFormatter = value ? new BooleanFormatter(value) : null;
            this.invalidate();
        }
    },
    setTextFormat: function (value) {
        if (value != this._textFormat) {
            this._textFormat = value;
            this._textFormatter = value ? new TextFormatter(value) : null;
            this.invalidate();
        }
    },
    numberFormatter: function () {
        return this._numberFormatter;
    },
    booleanFormatter: function () {
        return this._boolFormatter;
    },
    datetimeWriter: function () {
        return this._datetimeWriter || DateTimeWriter.Default;
    },
    textFormatter: function () {
        return this._textFormatter;
    },
    selected: function () {
        return this._selected;
    },
    animate: function (run) {
    },
    setBorderRight: function (value) {
        if (this._grid.$_hideBorders && this._index.column.$_last) {
            value = null;
        }
        this._super(value);
    },
    _doPrepareElement: function (model) {
        this._super(model);
        var s = model.styles();
        this.setHoveredBackground(s.hoveredBackground());
        this.setHoveredColor(s.hoveredColor());
        this.setSelectedBackground(s.selectedBackground());
        this.setLine(s.line());
        this.setSelectedColor(s.selectedColor());
        this.setShapeSelectedColor(s.shapeSelectedColor());
        this.setShapeSelectedBorder(s.shapeSelectedBorder());
        this.setNumberFormat(s.numberFormat());
        this.setDatetimeFormat(s.datetimeFormat());
        this.setBooleanFormat(s.booleanFormat());
        this.setTextFormat(s.textFormat());
        this.setPrefix(s.prefix());
        this.setSuffix(s.suffix());
    },
    $_prepareSummary: function (model) {
        this._value = model.value();
        var s = '',
            f = null,
            v = this._value;
        if (v instanceof Date) {
            if (this._datetimeWriter) {
                s = this._datetimeWriter.getText(v);
            } else {
                s = String(v);
            }
        } else {
            v = Number(v);
            if (isNaN(v)) {
                s = model.displayText();
                if (this._textFormatter && s) {
                    s = this._textFormatter.format(s);
                }
            } else {
                if (this._numberFormatter) {
                    s = this._numberFormatter.format(v);
                } else {
                    s = String(v);
                }
            }
        }
        if (f = this.prefix()) {
            s = f + s;
        }
        if (f = this.suffix()) {
            s = s + f;
        }
        this.setText(s);
        this._error = model.error();
        this._errorDetail = model.errorDetail();
    }
});
var SelectableCellElement = defineClass("SelectableCellElement", CellElement, {
    init: function (dom, name) {
        this._super(dom, name);
    },
    hoveredBackground: SolidBrush.WHITE,
    hoveredColor: SolidBrush.BLACK,
    selectedBackground: SolidBrush.WHITE,
    selectedColor: SolidBrush.BLACK,
    selected: false,
    _doPrepareElement: function (model) {
        this._super(model);
        var s = model.styles();
        this.setHoveredBackground(s.hoveredBackground());
        this.setHoveredColor(s.hoveredColor());
        this.setSelectedBackground(s.selectedBackground());
        this.setSelectedColor(s.selectedColor());
    }
});
var $$_HCE_RECT = new Rectangle();
var HeaderCellElement = defineClass("HeaderCellElement", SelectableCellElement, {
    init: function (dom) {
        this._super(dom, "headerCellView");
        this._menuHandle = new ColumnMenuHandle(dom, this);
        this._menuHandle.setVisible(false);
        this.addElement(this._menuHandle);
        this._sortHandle = new ColumnSortHandle(dom, this);
        this._sortHandle.setVisible(false);
        this.addElement(this._sortHandle);
        this._filterHandle = new ColumnFilterHandle(dom, this);
        this._filterHandle.setVisible(false);
        this.addElement(this._filterHandle);
        this._checkHandle = null;
        this._imageHandle = null;
        this._column = null;
        this._handleWidth = 0;
        this._sortOrderWidth = 0;
        this._sortOrder = 0;
        this._sortOrderLeft = 0;
        this.setClickable(true);
    },
    borderLeftSize: null,
    borderTopSize: null,
    borderRightSize: null,
    borderBottomSize: null,
    subFont: null,
    subColor: null,
    subHoveredColor: null,
    subSelectedColor: null,
    subTextWrap: null,
    subTextAlignment: null,
    subLineAlignment: null,
    focused: false,
    text: null,
    subText: null,
    subTextGap: 1,
    showHandles: true,
    sortOrderVisible: true,
    checkLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
    imageLocation: EnumProp(HeaderItemLocation, HeaderItemLocation.NONE),
    subTextLocation: EnumProp(SubTextLocation, SubTextLocation.BOTTOM),
    imageList: null,
    imageIndex: -1,
    imageUrl: null,
    imageOffset: 0,
    itemOffset: 2,
    itemGap: 2,
    handleOffset: 2,
    handleGap: 1,
    menuWidth: 7,
    checked: false,
    setSubFont: function (value) {
        var f = this._subFont;
        if (value == f) return;
        if (!value || !f || value.font != f.font || value.size != f.size || value.deco != f.deco || value.line !== f.line) {
            this._subFont = value;
            this.invalidate();
        }
    },
    setSubTextAlignment: function (value) {
        if (value != this._subTextAlignment) {
            this._subTextAlign = _alignmentToText(this._subTextAlignment = value);
            this.invalidate();
        }
    },
    setSubLineAlignment: function (value) {
        if (value != this._subLineAlignment) {
            this._subLineAlign = _alignmentToLine(this._subLineAlignment = value);
            this.invalidate();
        }
    },
    setSortOrderVisible: function (value) {
        if (value != this._sortOrderVisible) {
            this._sortOrderVisible = value;
            this._doLayoutHandles();
            this.invalidate();
        }
    },
    setFocused: function (value) {
        if (value != this._focused) {
            this._focused = value;
            this._doLayoutHandles();
            this.invalidate();
        }
    },
    column: function () {
        return this.index().column;
    },
    hovered: function () {
        return this._mouseEntered || this._filterHandle.hovered() || this._sortHandle.hovered();
    },
    setBorderRight: function (value) {
        if (this._grid.$_hideBorders && this._index.column.$_last) {
            value = null;
        }
        this._super(value);
    },
    _doClearHtml: function () {
        this._super();
        this._span2 && this._span2.parentNode === this._dom && this._dom.removeChild(this._span2);
        this._span3 && this._span3.parentNode === this._dom && this._dom.removeChild(this._span3);
    },
    $_prepareSpan2: function () {
        if (!this._span2) {
            this._span2 = document.createElement("span");
            this._span2.style.position = "absolute";
        }
        !this._span2.parentNode && this._dom.appendChild(this._span2);
        return this._span2;
    },
    $_prepareSpan3: function () {
        if (!this._span3) {
            this._span3 = document.createElement("span");
            this._span3.style.position = "absolute";
        }
        !this._span3.parentNode && this._dom.appendChild(this._span3);
        return this._span3;
    },
    _doPrepareElement: function (model) {
        this._super(model);
        var s = model.styles();
        var substyles = model.subStyles();
        this.setBorderLeftSize(s.borderLeftSize());
        this.setBorderTopSize(s.borderTopSize());
        this.setBorderRightSize(s.borderRightSize());
        this.setBorderBottomSize(s.borderBottomSize());
        this.setSubFont(substyles.font());
        this.setSubColor(substyles.color());
        this.setSubHoveredColor(substyles.hoveredColor());
        this.setSubSelectedColor(substyles.selectedColor());
        this.setSubTextAlignment(substyles.textAlignment());
        this.setSubLineAlignment(substyles.lineAlignment());
        this.setSubTextWrap(substyles.textWrap());
        this.setSubText(model.subText());
        this.setSubTextGap(model.subTextGap());
        this.setSubTextLocation(model.subTextLocation());
        this.setItemOffset(model.itemOffset());
        this.setItemGap(model.itemGap());
        this.setImageList(model.imageList());
        this.setImageIndex(model.imageIndex());
        this.setImageUrl(model.imageUrl());
        this.setImageOffset(model.imageOffset());
        this.setCheckLocation(model.checkLocation());
        this.setImageLocation(model.imageLocation());
        this.setChecked(model.checked());
        this.setHandleOffset(model.handleOffset());
        this.setHandleGap(model.handleGap());
        this.setMenuWidth(model.menuWidth());
        this._column = this.index().column;
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.setText(model.text());
        this.setSortOrderVisible(model.sortOrderVisible());
    },
    _doLayoutHandles: function () {
        var options, bMenu, bFilter, bSort, r, x, y, h, w, w2,
            grid = this.grid(),
            column = this._column;
        if (grid) {
            options = grid.operateOptions();
            bMenu = column.header().hasMenu();
            bFilter = this.$_canFilterHandleVisible(grid, column);
            bSort = this.$_canSortHandleVisible(options, column);
            this._handleWidth = 0;
            this._sortOrderWidth = 0;
            if (bMenu || bFilter || bSort) {
                r = this._getRenderRect(null);
                x = r.right() - this._handleOffset;
                y = r.y;
                h = r.height;
            }
            this._menuHandle.setVisible(bMenu);
            if (bMenu) {
                w = this._menuWidth;
                this._menuHandle.setColumn(column);
                this._menuHandle.setBounds(x - w, y, w, h);
                this._menuHandle.invalidate();
                w += this._handleGap;
                x -= w;
                this._handleWidth += w;
            }
            this._filterHandle.setVisible(bFilter);
            if (bFilter) {
                w = 12;
                this._filterHandle.setRenderer(options.$_filterHandleRenderer());
                this._filterHandle.setColumn(column);
                this._filterHandle.setBounds(x - w, y, w, h);
                this._filterHandle.invalidate();
                w += this._handleGap;
                x -= w;
                this._handleWidth += w;
            }
            this._sortHandle.setVisible(bSort);
            if (bSort) {
                this._sortHandle.setSortOrder(column.sortOrder());
                this._sortHandle.setSortDir(column.sortDirection());
                this._sortHandle.setRenderer(options.$_sortHandleRenderer());
                w2 = w = 9;
                if (this._sortOrderVisible && options.sortStyle() === SortStyle.INCLUSIVE
                    && grid.$_sortFieldCount > 1 && column.sortOrder() >= 0) {
                    this._sortOrder = column.sortOrder() + 1;
                    this._sortOrderWidth = this.container().measureText(grid.$_sortOrderFont, this._sortOrder);
                    w2 += this._sortOrderWidth + 1;
                }
                this._sortHandle.setBounds(x - w2, y, w, h);
                this._sortOrderLeft = x - w2 + w + 1;
                this._sortHandle.invalidate();
                this._handleWidth += w2 + this._handleGap;
            }
            this._handleWidth += this._handleWidth > 0 ? 6 : 0;
        }
    },
    $_renderEdgedItems: function (g, tr) {
        var img, w, h, grid, imaged, off,
            checkLoc = this._checkLocation,
            imageLoc = this._imageLocation,
            checkHandle = this._checkHandle,
            imageHandle = this._imageHandle,
            checked = 0,
            sz = HEADER_CHECKBOX_SIZE;
        switch (checkLoc) {
            case HeaderItemLocation.LEFT_SIDE:
                checked = 1;
                break;
            case HeaderItemLocation.RIGHT_SIDE:
                checked = 2;
                break;
            case HeaderItemLocation.TOP_SIDE:
                checked = 3;
                break;
            case HeaderItemLocation.BOTTOM_SIDE:
                checked = 4;
                break;
        }
        if (checked) {
            if (!checkHandle) {
                checkHandle = this._checkHandle = new HeaderCheckHandle(this._dom, this);
                this.addElement(checkHandle);
            }
            switch (checked) {
                case 1: // left
                    tr.leftBy(this._itemOffset);
                    checkHandle.setBoundsI(tr.x, tr.y + (tr.height - sz) / 2, sz, sz);
                    tr.leftBy(sz);
                    break;
                case 2: // right
                    tr.rightBy(-this._itemOffset);
                    checkHandle.setBoundsI(tr.right() - sz, tr.y + (tr.height - sz) / 2, sz, sz);
                    tr.rightBy(-sz);
                    break;
                case 3: // top
                    tr.topBy(this._itemOffset);
                    checkHandle.setBoundsI(tr.x + (tr.width - sz) / 2, tr.y, sz, sz);
                    tr.topBy(sz);
                    break;
                case 4: // bottom
                    tr.bottomBy(-this._itemOffset);
                    checkHandle.setBoundsI(tr.x + (tr.width - sz) / 2, tr.bottom() - sz, sz, sz);
                    tr.bottomBy(-sz);
                    break;
            }
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
        }
        if (imageLoc != HeaderItemLocation.NONE) {
            if (!imageHandle) {
                imageHandle = this._imageHandle = new HeaderImageHandle(this._dom, this);
                this.addElement(imageHandle);
            }
            grid = this.grid();
            img = this._imageUrl ? grid.getImage(this._imageUrl) : grid.header().getImage(this._imageIndex);
            if (img && (w = img.width) > 0 && (h = img.height) > 0) {
                imaged = false;
                off = this._imageOffset;
                switch (imageLoc) {
                    case HeaderItemLocation.LEFT_SIDE:
                        if (checked == 1) {
                            tr.leftBy(this._itemGap);
                        } else {
                            tr.leftBy(this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x, tr.y + (tr.height - h) / 2 + 0.5 + off, w, h);
                        tr.leftBy(w);
                        imaged = true;
                        break;
                    case HeaderItemLocation.RIGHT_SIDE:
                        if (checked == 2) {
                            tr.rightBy(-this._itemGap);
                        } else {
                            tr.rightBy(-this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.right() - w, tr.y + (tr.height - h) / 2 + 0.5 + off, w, h);
                        tr.rightBy(-w);
                        imaged = true;
                        break;
                    case HeaderItemLocation.TOP_SIDE:
                        if (checked == 3) {
                            tr.topBy(this._itemGap);
                        } else {
                            tr.topBy(this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x + (tr.width - w) / 2 + off, tr.y, w, h);
                        tr.topBy(h);
                        imaged = true;
                        break;
                    case HeaderItemLocation.BOTTOM_SIDE:
                        if (checked == 4) {
                            tr.bottomBy(-this._itemGap);
                        } else {
                            tr.bottomBy(-this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x + (tr.width - w) / 2 + off, tr.bottom() - h, w, h);
                        tr.bottomBy(-h);
                        imaged = true;
                        break;
                }
                imageHandle.setImage(img);
                imageHandle.setVisible(imaged);
            } else {
                img = null;
            }
        }
        return img;
    },
    $_renderCenteredItems: function (g, tr, img) {
        var x, y, w, h, r,
            checkLoc = this._checkLocation,
            imageLoc = this._imageLocation,
            checkHandle = this._checkHandle,
            imageHandle = this._imageHandle,
            sz = HEADER_CHECKBOX_SIZE;
        if (img) {
            w = img.width;
            h = img.height;
        } else {
            imageLoc = HeaderItemLocation.NONE;
        }
        if (checkLoc == HeaderItemLocation.CENTER) {
            if (!checkHandle) {
                checkHandle = this._checkHandle = new HeaderCheckHandle(this._dom, this);
                this.addElement(checkHandle);
            }
            if (imageLoc == HeaderItemLocation.NONE || imageHandle.visible()) {
                tr.x += (tr.width - sz) / 2;
                tr.y += (tr.height - sz) / 2;
            } else {
                if (!imageHandle) {
                    imageHandle = this._imageHandle = new HeaderImageHandle(this._dom, this);
                    this.addElement(imageHandle);
                }
                r = tr.clone();
                switch (imageLoc) {
                    case HeaderItemLocation.RIGHT:
                    case HeaderItemLocation.CENTER:
                        tr.x += (tr.width - sz - w - this._itemGap) / 2;
                        tr.y += (tr.height - sz) / 2;
                        x = tr.x + sz + this._itemGap;
                        y = r.y + (r.height - h) / 2 + 0.5;
                        break;
                    case HeaderItemLocation.LEFT:
                        tr.x += (tr.width - sz - w - this._itemGap) / 2 + w + this._itemGap;
                        tr.y += (tr.height - sz) / 2;
                        x = tr.x - this._itemGap - w;
                        y = r.y + (r.height - h) / 2 + 0.5;
                        break;
                    case HeaderItemLocation.TOP:
                        tr.x += (tr.width - sz) / 2;
                        tr.y += (tr.height - sz - h - this._itemGap) / 2 + h + this._itemGap;
                        x = r.x + (r.width - w) / 2;
                        y = tr.y - this._itemGap - h;
                        break;
                    case HeaderItemLocation.BOTTOM:
                        tr.x += (tr.width - sz) / 2;
                        tr.y += (tr.height - sz - h - this._itemGap) / 2;
                        x = r.x + (r.width - w) / 2;
                        y = tr.y + sz + this._itemGap;
                        break;
                }
                imageHandle.setBoundsI(x, y, w, h);
                imageHandle.setVisible(true);
            }
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
            checkHandle.setBoundsI(tr.x, tr.y, sz, sz);
            return true;
        } else if (imageLoc == HeaderItemLocation.CENTER) {
            if (checkLoc == HeaderItemLocation.NONE || (checkHandle && checkHandle.visible())) {
                tr.x += (tr.width - w) / 2;
                tr.y += (tr.height - h) / 2;
            } else {
                if (!checkHandle) {
                    checkHandle = this._checkHandle = new HeaderCheckHandle(this._dom, this);
                    this.addElement(checkHandle);
                }
                r = tr.clone();
                switch (checkLoc) {
                    case HeaderItemLocation.LEFT:
                    case HeaderItemLocation.CENTER:
                        tr.x += (tr.width - w - sz - this._itemGap) / 2 + w + this._itemGap;
                        tr.y += (tr.height - h) / 2;
                        x = tr.x - this._itemGap - sz;
                        y = r.y + (r.height - sz) / 2;
                        break;
                    case HeaderItemLocation.RIGHT:
                        tr.x += (tr.width - w - sz - this._itemGap) / 2;
                        tr.y += (tr.height - h) / 2;
                        x = tr.x + w + this._itemGap;
                        y = r.y + (r.height - sz) / 2;
                        break;
                    case HeaderItemLocation.TOP:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h - sz - this._itemGap) / 2 + sz + this._itemGap;
                        x = r.x + (r.width - sz) / 2;
                        y = tr.y - this._itemGap - sz;
                        break;
                    case HeaderItemLocation.BOTTOM:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h - sz - this._itemGap) / 2;
                        x = r.x + (r.width - sz) / 2;
                        y = tr.y + sz + this._itemGap;
                        break;
                    case HeaderItemLocation.NONE:
                    default:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h) / 2;
                        break;
                }
                checkHandle.setChecked(this._checked);
                checkHandle.setVisible(true);
                checkHandle.setBoundsI(x, y, sz, sz);
            }
            imageHandle.setBoundsI(tr.x, tr.y + 0.5, w, h);
            imageHandle.setVisible(true);
            return true;
        }
        return false;
    },
    $_calcTextRect: function (g, r, info) {
        return this._calcTextRectEx(g, info.font, info.text, r.x, r.y, r.width, r.height, info.align, info.valign, info.wrap);
    },
    $_renderText: function (g, r, info) {
        this._renderTextEx(g || this.$_prepareSpan(), info.text, info.font, info.fill, r, info.align, info.valign, info.wrap);
    },
    $_renderSubText: function (g, r, info) {
        this._renderTextEx(g || this.$_prepareSpan2(), info.text, info.font, info.fill, r, info.align, info.valign, info.wrap);
    },
    $_renderOrderText: function (g, font, fill, s, x, y, w, h, align, valign) {
        this._renderTextBoundsEx(g || this.$_prepareSpan3(), s, font, fill, x, y, w, h, align, valign);
    },
    $_renderTexts: function (g, r, img, hovered, selected) {
        var textInfo, subInfo, fill,
            itemGap, gap, wimg, himg, sz, cleft, cright, ctop, cbottom, ileft, iright, itop, ibottom,
            tr, sr, x, y, r2, w, h,
            cx, cy, ix, iy, ioff,
            checkHandle = this._checkHandle,
            imageHandle = this._imageHandle,
            checkLoc = (!checkHandle || !checkHandle.visible()) ? this._checkLocation : HeaderItemLocation.NONE,
            imageLoc = (img && !imageHandle.visible()) ? this._imageLocation : HeaderItemLocation.NONE,
            text = this._text,
            stext = this._subText;
        if (text) {
            hovered && (fill = this._hoveredColor);
            (!fill && selected) && (fill = this._selectedColor);
            !fill && (fill = this._color);
            textInfo = {
                text: text,
                font: this._font,
                fill: fill,
                wrap: this._textWrap,
                align: this._textAlign,
                valign: this._lineAlign
            };
        }
        if (stext) {
            fill = null;
            hovered && (fill = this._subHoveredColor);
            (!fill && selected) && (fill = this._subSelectedColor);
            !fill && (fill = this._subColor);
            subInfo = {
                text: stext,
                font: this._subFont,
                fill: fill,
                wrap: this._subTextWrap,
                align: this._textAlign, // this._subTextAlign,
                valign: this._lineAlign // this._subLineAlign
            };
        }
        itemGap = this._itemGap;
        gap = this._subTextGap;
        wimg = img ? img.width : 0;
        himg = img ? img.height : 0;
        sz = HEADER_CHECKBOX_SIZE;
        cleft = cright = ctop = cbottom = ileft = iright = itop = ibottom = 0;
        switch (checkLoc) {
            case HeaderItemLocation.LEFT:
                cleft = sz + itemGap;
                break;
            case HeaderItemLocation.RIGHT:
                cright = sz + itemGap;
                break;
            case HeaderItemLocation.TOP:
                ctop = sz + itemGap;
                break;
            case HeaderItemLocation.BOTTOM:
                cbottom = sz + itemGap;
                break;
        }
        switch (imageLoc) {
            case HeaderItemLocation.LEFT:
                ileft = wimg + itemGap;
                break;
            case HeaderItemLocation.RIGHT:
                iright = wimg + itemGap;
                break;
            case HeaderItemLocation.TOP:
                itop = himg + itemGap;
                break;
            case HeaderItemLocation.BOTTOM:
                ibottom = himg + itemGap;
                break;
        }
        ioff = this._imageOffset;
        if (text || stext) {
            r.leftBy(cleft + ileft);
            r.rightBy(-cright - iright);
            r.topBy(ctop + itop);
            r.bottomBy(-cbottom - ibottom);
            tr = text && this.$_calcTextRect(g, r, textInfo);
            sr = stext && this.$_calcTextRect(g, r, subInfo);
        }
        if (text && stext) {
            switch (this._subTextLocation) {
                case SubTextLocation.BOTTOM:
                    if ((y = tr.height + gap + sr.height) <= r.height) {
                        switch (textInfo.valign) {
                            case "middle":
                                y = r.y + (r.height - y) / 2;
                                break;
                            case "bottom":
                                y = r.bottom() - sr.height - gap - tr.height;
                                break;
                            default:
                                y = r.y;
                                break;
                        }
                        tr.y = y;
                        this.$_renderText(g, tr, textInfo);
                        sr.y = tr.bottom() + gap;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = tr;
                        h = tr.height + sr.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else if (tr.height <= r.height) {
                        tr.y = r.y;
                        this.$_renderText(g, tr, textInfo);
                        sr.y = tr.bottom() + gap;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = r;
                        h = r.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else {
                        this.$_renderText(g, r, textInfo);
                        sr = null;
                        r2 = r;
                        h = r.height;
                        x = tr.x;
                        w = tr.width;
                    }
                    (cleft || cright) && (cy = r2.y + (h - sz) / 2);
                    (ileft || iright) && (iy = r2.y + (h - himg) / 2 + 0.5 + ioff);
                    (ctop || cbottom) && (cx = x + (w - sz) / 2);
                    (itop || ibottom) && (ix = x + (w - wimg) / 2 + ioff);
                    break;
                case SubTextLocation.TOP:
                    if ((y = tr.height + gap + sr.height) <= r.height) {
                        switch (textInfo.valign) {
                            case "middle":
                                y = r.y + (r.height - y) / 2;
                                break;
                            case "bottom":
                                y = r.bottom() - sr.height - gap - tr.height;
                                break;
                            default:
                                y = r.y;
                                break;
                        }
                        sr.y = y;
                        this.$_renderText(g, sr, subInfo);
                        tr.y = sr.bottom() + gap;
                        this.$_renderSubText(g, tr, textInfo);
                        r2 = r;
                        h = tr.height + sr.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else if (tr.height <= r.height) {
                        tr.y = r.bottom() - tr.height;
                        this.$_renderText(g, tr, textInfo);
                        sr.y = tr.y - gap - sr.height;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = tr;
                        h = r.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else {
                        this.$_renderText(g, tr, textInfo);
                        sr = null;
                        r2 = r;
                        h = r.height;
                        x = tr.x;
                        w = tr.width;
                    }
                    (cleft || cright) && (cy = r2.y + (h - sz) / 2);
                    (ileft || iright) && (iy = r2.y + (h - himg) / 2 + 0.5 + ioff);
                    (ctop || cbottom) && (cx = x + (w - sz) / 2);
                    (itop || ibottom) && (ix = x + (w - wimg) / 2 + ioff);
                    break;
                case SubTextLocation.RIGHT:
                    if ((x = tr.width + gap + sr.width) <= r.width) {
                        switch (textInfo.align) {
                            case "center":
                                x = r.x + (r.width - x) / 2;
                                break;
                            case "right":
                                x = r.right() - sr.width - gap - tr.width;
                                break;
                            default:
                                x = r.x;
                        }
                        tr.x = x;
                        this.$_renderText(g, tr, textInfo);
                        sr.x = tr.right() + gap;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = tr;
                        w = tr.width + sr.width;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
                    } else if (tr.width <= r.width) {
                        tr.x = r.x;
                        this.$_renderText(g, tr, textInfo);
                        sr.x = tr.right() + gap;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = r;
                        w = r.width;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
                    } else {
                        this.$_renderText(g, r, textInfo);
                        r2 = r;
                        w = r.width;
                        y = tr.y;
                        h = tr.height;
                        sr = null;
                    }
                    (cleft || cright) && (cy = y + (h - sz) / 2);
                    (ileft || iright) && (iy = y + (h - himg) / 2 + 0.5 + ioff);
                    (ctop || cbottom) && (cx = r2.x + (w - sz) / 2);
                    (itop || ibottom) && (ix = r2.x + (w - wimg) / 2 + ioff);
                    break;
                case SubTextLocation.LEFT:
                    if ((x = tr.width + gap + sr.width) <= r.width) {
                        switch (textInfo.align) {
                            case "center":
                                x = r.x + (r.width - x) / 2;
                                break;
                            case "right":
                                x = r.right() - sr.width - gap - tr.width;
                                break;
                            default:
                                x = r.x;
                        }
                        sr.x = x;
                        this.$_renderSubText(g, sr, subInfo);
                        tr.x = sr.right() + gap;
                        this.$_renderText(g, tr, textInfo);
                        r2 = sr;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
                        w = tr.width + sr.width;
                    } else if (tr.width <= r.width) {
                        tr.x = r.right() - tr.width;
                        this.$_renderText(g, tr, textInfo);
                        sr.x = tr.x - gap - sr.width;
                        this.$_renderSubText(g, sr, subInfo);
                        r2 = r;
                        w = r.width;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
                    } else {
                        this.$_renderText(g, tr, textInfo);
                        r2 = r;
                        w = r.width;
                        y = tr.y;
                        h = tr.height;
                        sr = null;
                    }
                    (cleft || cright) && (cy = y + (h - sz) / 2);
                    (ileft || iright) && (iy = y + (h - himg) / 2 + 0.5 + ioff);
                    (ctop || cbottom) && (cx = r2.x + (w - sz) / 2);
                    (itop || ibottom) && (ix = r2.x + (w - wimg) / 2 + ioff);
                    break;
                default:
                    this.$_renderText(g, r, textInfo);
                    break;
            }
        } else if (text || stext) {
            if (text) {
                this.$_renderText(g, r, textInfo);
                r = tr;
            } else {
                this.$_renderSubText(g, r, subInfo);
                r = sr;
            }
            (cleft || cright) && (cy = r.y + (r.height - sz) / 2);
            (ileft || iright) && (iy = r.y + (r.height - himg) / 2 + 0.5 + ioff);
            (ctop || cbottom) && (cx = r.x + (r.width - sz) / 2);
            (itop || ibottom) && (ix = r.x + (r.width - wimg) / 2 + ioff);
        }
        if (cleft || ileft) {
            x = tr && sr ? Math.min(tr.x, sr.x) : tr ? tr.x : sr ? sr.x : r.x;
            if (cleft && ileft) {
                ix = x - itemGap - wimg;
                cx = ix - itemGap - sz;
            } else if (cleft) {
                cx = x - itemGap - sz;
            } else if (ileft) {
                ix = x - itemGap - wimg;
            }
        }
        if (cright + iright) {
            x = tr && sr ? Math.max(tr.right(), sr.right()) : tr ? tr.right() : sr ? sr.right() : r.right();
            if (cright && iright) {
                cx = x + itemGap;
                ix = cx + sz + itemGap;
            } else if (cright) {
                cx = x + itemGap;
            } else if (iright) {
                ix = x + itemGap;
            }
        }
        if (ctop || itop) {
            y = tr && sr ? Math.min(tr.y, sr.y) : tr ? tr.y : sr ? sr.y : r.y;
            if (ctop && itop) {
                iy = y - itemGap - himg;
                cy = iy - itemGap - sz;
            } else if (ctop) {
                cy = y - itemGap - sz;
            } else if (itop) {
                iy = y - itemGap - himg;
            }
        }
        if (cbottom || ibottom) {
            y = tr && sr ? Math.max(tr.bottom(), sr.bottom()) : tr ? tr.bottom() : sr ? sr.bottom() : r.bottom();
            if (cbottom && ibottom) {
                cy = y + itemGap;
                iy = cy + sz + itemGap;
            } else if (cbottom) {
                cy = y + itemGap;
            } else if (ibottom) {
                iy = y + itemGap;
            }
        }
        if (cleft + cright + ctop + cbottom > 0) {
            if (!checkHandle) {
                checkHandle = this._checkHandle = new HeaderCheckHandle(this._dom, this);
                this.addElement(checkHandle);
            }
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
            checkHandle.setBoundsI(cx, cy, sz, sz);
        }
        if (ileft + iright + itop + ibottom > 0) {
            if (!imageHandle) {
                imageHandle = this._imageHandle = new HeaderImageHandle(this._dom, this);
                this.addElement(imageHandle);
            }
            imageHandle.setImage(img);
            imageHandle.setVisible(true);
            imageHandle.setBoundsI(ix, iy, wimg, himg);
        }
    },
    $_renderContents: function (g, r, hovered, selected) {
        var tr, img, col,
            s = this.text(),
            s2 = this.subText(),
            checkLoc = this._checkLocation,
            imageLoc = this._imageLocation,
            checkHandle = this._checkHandle,
            imageHandle = this._imageHandle;
        checkHandle && checkHandle.setVisible(false);
        imageHandle && imageHandle.setVisible(false);
        r.width -= this._handleWidth;
        this.deflatePadding2(r);
        if (r.width > 0) {
            tr = r.clone();
            img = this.$_renderEdgedItems(g, tr);
            if (!this.$_renderCenteredItems(g, tr, img)) {
                this.$_renderTexts(g, tr, img, hovered, selected);
            }
        }
        if (this._sortOrderWidth) {
            col = this._column;
            this.$_renderOrderText(g, col.$_grid.$_sortOrderFont, col.$_grid.$_sortOrderColor, this._sortOrder,
                this._sortOrderLeft, r.y, 1000, r.height, "left", "middle");
        }
        this.inflatePadding2(r);
        r.width += this._handleWidth;
    },
    _doRender: function (g, rc) {
        var selected, r,
            fill = null,
            textFill = null,
            itemCount = this.grid().rowCount(),
            hovered = this.hovered();
        if (hovered) {
            fill = this.hoveredBackground();
        }
        if (!fill && (selected = itemCount > 0 && (this.focused() || this.selected()))) {
            fill = this.selectedBackground();
        }
        if (!fill) {
            fill = this.background();
        }
        if (fill) {
            g.drawRect(fill, null, rc);
        }
        r = this._getRenderRect(rc);
        this.$_renderContents(g, r, hovered, selected);
        GridElement.drawSizedBorders(this, g, rc);
        return;
    },
    _doRenderHtml: function (r) {
        var selected,
            fill = null,
            itemCount = this.grid().rowCount(),
            hovered = this.hovered();
        if (hovered) {
            fill = this.hoveredBackground();
        }
        if (!fill && (selected = itemCount > 0 && (this.focused() || this.selected()))) {
            fill = this.selectedBackground();
        }
        if (!fill) {
            fill = this.background();
        }
        this._css.clip = Dom.getClipRect(r);
        _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        /*
         var s = this.text();
         if (s) {
         var textFill = null;
         if (hovered) {
         textFill = this.hoveredColor();
         }
         if (!textFill) {
         if (selected === undefined) {
         selected = itemCount > 0 && (this.focused() || this.selected());
         }
         if (selected) {
         textFill = this.selectedColor();
         }
         }
         if (!textFill) {
         textFill = this.color();
         }
         this.inflatePadding(r);
         var span = this.$_prepareSpan();
         Dom.renderTextBounds(span, this.font(), textFill, s, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign, this._textWrap);
         this.deflatePadding(r);
         }
         */
        r = this._getRenderRect(r);
        this.$_renderContents(null, r, hovered, selected);
        GridElement.drawHtmlBorders(this);
    },
    getShowHandles: function () {
        return this._showHandles;
    },
    _doMeasureWidth: function (grid, wDef, wMax, hMax) {
        var s, loc, w2,
            wImage = this._imageHandle && this._imageHandle.visible() ? this._imageHandle.width() : 0,
            wCheck = this._checkHandle && this._checkHandle.visible() ? this._checkHandle.width() : 0,
            pImage = this._imageLocation,
            pCheck = this._checkLocation,
            HL = HeaderItemLocation,
            center = HL.CENTER,
            w = this._handleWidth + this._sortOrderWidth + this.paddingHorz() + this.borderHorzWidth();
        if (wImage && pImage == center || wCheck && pCheck == center) {
            if (wImage && pImage == center && wCheck && pCheck == center) {
                w += wImage + this._itemGap + wCheck;
            } else if (wImage && pImage == center) {
                w += wImage;
                if (HL.isHorz(pCheck)) {
                    w += wCheck;
                    if (HL.isHorzSide(pCheck)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                } else if (wCheck > wImage) {
                    w += wCheck - wImage;
                }
            } else {
                w += wCheck;
                if (HL.isHorz(pImage)) {
                    w += wImage;
                    if (HL.isHorzSide(pImage)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                } else if (wImage > wCheck) {
                    w += wImage - wCheck;
                }
            }
        } else {
            w += this._measureText(this.text(), wMax, hMax).width;
            s = this.subText();
            if (s && (loc = this._subTextLocation) != SubTextLocation.NONE) {
                w2 = this._measureText(s, wMax, hMax).width;
                if (SubTextLocation.isHorz(loc)) {
                    w += w2 + this._subTextGap;
                } else if (w2 > w) {
                    w += w2 = w;
                }
            }
            if (wCheck && wImage) {
                if (HL.isHorz(pCheck) && HL.isHorz(pImage)) {
                    w += wCheck + wImage;
                    if (HL.isHorzSide(pCheck) && HL.isHorzSide(pImage)) {
                        if (pCheck == pImage) {
                            w += this._itemOffset + this._itemGap;
                        } else {
                            w += this._itemGap + this._itemGap;
                        }
                    } else if (HL.isHorzSide(pCheck) || HL.isHorzSide(pImage)) {
                        w += this._itemOffset + this._itemGap;
                    } else {
                        w += this._itemGap + this._itemGap;
                    }
                } else if (HL.isHorz(pCheck)) {
                    w += wCheck;
                    if (HL.isHorzSide(pCheck)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                } else if (HL.isHorz(pImage)) {
                    w += wImage;
                    if (HL.isHorzSide(pImage)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                }
            } else if (wCheck) {
                if (HL.isHorz(pCheck)) {
                    w += wCheck;
                    if (HL.isHorzSide(pCheck)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                } else if (wCheck > w) {
                    w += wCheck - w;
                }
            } else if (wImage) {
                if (HL.isHorz(pImage)) {
                    w += wImage;
                    if (HL.isHorzSide(pImage)) {
                        w += this._itemOffset;
                    } else {
                        w += this._itemGap;
                    }
                } else if (wImage > w) {
                    w += wImage - w;
                }
            }
        }
        return w;
    },
    $_canFilterHandleVisible: function (grid, column) {
        var v,
            visible = column instanceof DataColumn && this.showHandles() && column.hasFilters();
        if (visible) {
            v = column.header().filterHandleVisibility() || grid.operateOptions().filterHandleVisibility();
            switch (v) {
                case HandleVisibility.HIDDEN:
                    visible = false;
                    break;
                case HandleVisibility.HOVERED:
                    visible = this.hovered() || grid.isFilterSelecting(column);
                    break;
            }
        }
        return visible;
    },
    $_canSortHandleVisible: function (options, column) {
        var v,
            visible = column instanceof DataColumn && this.showHandles();
        if (visible) {
            v = column.header().sortHandleVisibility() || options.sortHandleVisibility();
            switch (v) {
                case HandleVisibility.VISIBLE:
                    visible = column.sortOrder() >= 0;
                    break;
                case HandleVisibility.HOVERED:
                    visible = this.hovered() && column.sortOrder() >= 0;
                    break;
                case HandleVisibility.HIDDEN:
                    visible = false;
                    break;
                case HandleVisibility.ALWAYS:
                default:
                    break;
            }
        }
        return visible;
    }
});
var HeaderGroupCellElement = defineClass("HeaderGroupCellElement", GroupCellElement, {
    init: function (dom) {
        this._super(dom, "headerGroupCellView");
    },
    focused: false,
    headerCell: function () {
        var view = this._getCell(this.group());
        return view && view.visible() ? view : null;
        /*
        var group = this.group();
        if (group.header().visible()) {
            return this._getCell(group);
        }
        return null;
        */
    },
    _needRender: function () {
        return this.$_needRender;
    },
    _prepareCells: function (lm, grid) {
        this.$_createCells(this.group(), grid);
    },
    _layoutCells: function (lm, grid) {
        var view, level, y, h, i, column, dy, x, w,
            r = new Rectangle(),
            group = this.group(),
            width = this.width(),
            height = this.height(),
            cnt = group.visibleCount(),
            delegate = group.$_headerColumn,
            vis = !delegate && group.childHeadersVisible() && cnt > 0;
        r.set(0, 0, width, height);
        if (group.header().visible()) {
            view = this._getCell(group);
            r.height = _round(r.height / (vis ? group.headerLevel() : delegate ? grid._rootColumn._headerLevel : 1));
            view.setRect(r);
            view.layoutContent(lm);
            if (delegate) {
                r.y = r.bottom();
                r.height = height - r.height;
            }
        }
        if (delegate) {
            view = this._getCell(delegate);
            view.setRect(r);
            view.layoutContent(lm);
        }
        this.$_needRender = !view && !vis;
        if (vis) {
            y = r.height < height ? r.bottom() : 0;
            if (group.vertical()) {
                h = _int(height / group.headerLevel());
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        dy = 0;
                        if (i == cnt - 1) {
                            dy = height - y;
                        } else if (view instanceof HeaderGroupCellElement) {
                            dy = h * view.group().headerLevel();
                        } else {
                            dy += h;
                        }
                        view.setBounds(0, y, width, dy);
                        view.layoutContent(lm);
                        y += dy;
                    }
                }
            } else {
                x = 0;
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        if (i == cnt - 1) {
                            w = width - x;
                        } else {
                            w = column.displayWidth();
                        }
                        view.setBounds(x, y, w, height - y);
                        view.layoutContent(lm);
                        x += w;
                    }
                }
            }
        }
    },
    $_createView: function (header, column, grid) {
        var model, 
            view = this._getCell(column);
        if (!view) {
            if (column instanceof ColumnGroup) {
                view = new HeaderGroupCellElement(this._dom);
            } else {
                view = new HeaderCellElement(this._dom);
            }
            this.$_setCell(column, view);
            this.addElement(view);
        }
        view.setVisible(true);
        model = header.getCell(CellIndex.temp(-1, column));
        view.updateCell(model);
        if (view instanceof HeaderCellElement) {
        } else {
        }
        if (column instanceof ColumnGroup) {
            view.$_createCells(column, grid);
        }
        return view;
    },
    $_createCells: function (group, grid) {
        var i, column, view, model,
            header = grid.header(),
            cnt = group.visibleCount(),
            delegate = group.$_headerColumn,
            vis = !delegate && group.childHeadersVisible() && cnt > 0;
        this.hideAll();
        if (group.header().visible()) {
            view = this._getCell(group);
            if (!view) {
                this.$_setCell(group, view = new HeaderCellElement(this._dom));
                this.addElement(view);
            }
            view.setVisible(true);
            model = header.getCell(CellIndex.temp(-1, group));
            view.updateCell(model);
        }
        if (delegate) {
            this.$_createView(header, delegate, grid);
        } else if (vis) {
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                this.$_createView(header, column, grid);
            }
        }
    }
});
var SummaryCellElement = defineClass("SummaryCellElement", ValueCellElement, {
    init: function (dom) {
        this._super(dom, "summaryCellView");
        this._value = NaN;
        this._error = null;
        this._errorDetail = null;
    },
    text: null,
    column: function () {
        return this.index().column;
    },
    value: function () {
        return this._value;
    },
    error: function () {
        return this._error;
    },
    errorDetail: function () {
        return this._errorDetail;
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.$_prepareSummary(model);
    },
    _doLayoutHandles: function () {
    },
    _doRender: function (g, r) {
        var s,
            fill = this.background();
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        s = this.text();
        if (s) {
            this.inflatePadding(r);
            g.drawTextRect(this._font, this._color, s, r, this._textAlign);
            this.deflatePadding(r);
        }
        GridElement.drawBorders(this, g, r);
    },
    _doRenderHtml: function (r) {
        var s, textFill, span,
            fill = this.background();
        _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        s = this.text();
        if (s) {
            textFill = this.color();
            this.inflatePadding(r);
            span = this.$_prepareSpan();
            Dom.renderTextBounds(span, this.font(), textFill, s, r.x, r.y, r.width, r.height, this.textAlign());
            this.deflatePadding(r);
            /*
            this.$_prepareSpan();
            var textFill = this.color();
            */
            /*
             this.inflatePadding(r);
             g.drawTextRect(this._font, this._color, s, r, this._textAlign);
             this.deflatePadding(r);
             */
            /*
            this._css.font = this._font.font;
            this._css.color = textFill.css();
            this._css.textAlign = "center";
            this._css.lineHeight = (this._height - 2) + "px";
            this._span.style.verticalAlign = "middle";
            this._span.textContent = s;
            */
        }
        GridElement.drawHtmlBorders(this);
    },
    canHovering: function () {
        return false;
    }
});
var SummaryGroupCellElement = defineClass("SummaryGroupCellElement", GroupCellElement, {
    init: function (dom) {
        this._super(dom, "summaryGroupCellView");
    },
    canHovering: function () {
        return false;
    },
    _doUpdateGroup: function (group) {
        this._text = group.header().summary().text();
    },
    _prepareCells: function (lm) {
        this.$_createCells(this.group());
    },
    _layoutCells: function (lm, grid) {
        var column, view, model, i, dy, x, y, h, w, span, j, col, cv, spans,
            summary = grid.header().summary(),
            group = this.group(),
            cnt = group.visibleCount(),
            width = this.width(),
            height = this.height(),
            r = new Rectangle();
        this.$_needRender = false;
        if (column = group.$_summaryColumn) {
            view = this._getCell(column);
            view.setVisible(true);
            model = summary.getCell(CellIndex.temp(-1, column));
            view.updateCell(model);
            r.set(0, 0, width, height);
            view.setRect(r);
            view.layoutContent(lm);
            return;
        } else if (!group.childSummariesVisible() || cnt < 1) {
            this.$_needRender = true;
            return;
        }
        spans = group.$_summarySpanned ? group.$_summarySpans : null;
        if (group.vertical()) {
            y = r.bottom();
            h = _int(height / group.headerSummaryLevel());// cnt // this.childCount());
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        dy = height - y;
                    } else {
                        span = 0;
                        if (view instanceof SummaryGroupCellElement) {
                            dy = h * column.headerSummaryLevel();
                        } else {
                            dy = h;
                        }
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                dy = height - y;
                            } else if (view instanceof SummaryGroupCellElement) {
                            } else {
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = summary.getCell(CellIndex.temp(-1, column));
                    view.updateCell(model);
                    view.setBounds(0, y, width, dy);
                    view.layoutContent(lm);
                    y += dy;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        dy = 0;
                        if (i == cnt - 1) {
                            dy = height - y;
                        } else if (view instanceof SummaryGroupCellElement) {
                            dy = h * column.headerSummaryLevel();
                        } else {
                            dy += h;
                        }
                        view.setVisible(true);
                        model = summary.getCell(CellIndex.temp(-1, column));
                        view.updateCell(model);
                        view.setBounds(0, y, width, dy);
                        view.layoutContent(lm);
                        y += dy;
                    }
                }
            }
        } else {
            x = 0;
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        w = width - x;
                    } else {
                        span = 0;
                        w = col.displayWidth();
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                w = width - x;
                            } else {
                                w += col.displayWidth();
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = summary.getCell(CellIndex.temp(-1, column));
                    view.updateCell(model);
                    view.setBounds(x, 0, w, height);
                    view.layoutContent(lm);
                    x += w;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        if (i == cnt - 1) {
                            w = width - x;
                        } else {
                            w = column.displayWidth();
                        }
                        view.setVisible(true);
                        model = summary.getCell(CellIndex.temp(-1, column));
                        view.updateCell(model);
                        view.setBounds(x, 0, w, height);
                        view.layoutContent(lm);
                        x += w;
                    }
                }
            }
        }
    },
    _needRender: function () {
        return this.$_needRender;
    },
    _renderCell: function (g, r) {
        if (this._text) {
            this.deflatePadding2(r);
            this._renderText(g, this._text, this._color, r);
            this.inflatePadding2(r);
        }
    },
    $_createCell: function (column) {
        var view;
        if (column instanceof ColumnGroup) {
            view = new SummaryGroupCellElement(this._dom);
        } else {
            view = new SummaryCellElement(this._dom);
        }
        this.$_setCell(column, view);
        this.addElement(view);
        if (column instanceof ColumnGroup) {
            view.$_createCells(column);
        }
        return view;
    },
    $_createCells: function (group) {
        var column, view, i, cnt, spans, prev, 
            count = group.visibleCount();
        this.hideAll();
        if (column = group.$_summaryColumn) {
            view = this._getCell(column) || this.$_createCell(column);
        } else if (group.childSummariesVisible() && count > 0) {
            spans = group.$_summarySpanned ? group.$_summarySpans : null;
            if (spans) {
                prev = null;
                for (i = 0, cnt = spans.length; i < cnt; i++) {
                    column = spans[i];
                    if (column != prev) {
                        prev = column;
                        view = this._getCell(column) || this.$_createCell(column);
                    }
                }
            } else {
                for (i = 0; i < count; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column) || this.$_createCell(column);
                }
            }
        }
    }
});
var FooterCellElement = defineClass("FooterCellElement", ValueCellElement, {
    init: function (dom) {
        this._super(dom, "footerCellView");
        this._value = NaN;
        this._error = null;
        this._errorDetail = null;
    },
    text: null,
    column: function () {
        return this.index().column;
    },
    value: function () {
        return this._value;
    },
    error: function () {
        return this._error;
    },
    errorDetail: function () {
        return this._errorDetail;
    },
    setBorderRight: function (value) {
        if (this._grid.$_hideBorders && this._index.column.$_last) {
            value = null;
        }
        this._super(value);
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.$_prepareSummary(model);
    },
    _doLayoutHandles: function () {
    },
    _doRender: function (g, rc) {
        var s, r, 
            fill = this.background();
        if (fill) {
            g.drawRectI(fill, null, rc);
        }
        s = this.text();
        if (s) {
            r = this._getRenderRect(rc)
            this.inflatePadding(r);
            g.drawTextRect(this._font, this._color, s, r, this._textAlign);
            this.deflatePadding(r);
        }
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (r) {
        var s, textFill, span,
            fill = this._background;
        _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        s = this.text();
        if (s) {
            textFill = this.color();
            this.inflatePadding(r);
            span = this.$_prepareSpan();
            Dom.renderTextBounds(span, this.font(), textFill, s, r.x, r.y, r.width, r.height, this.textAlign());
            this.deflatePadding(r);
        }
        GridElement.drawHtmlBorders(this);
    },
    canHovering: function () {
        return false;
    }
});
var FooterGroupCellElement = defineClass("FooterGroupCellElement", GroupCellElement, {
    init: function (dom) {
        this._super(dom, "fooerGroupCellView");
    },
    canHovering: function () {
        return false;
    },
    _doUpdateGroup: function (group) {
        this._text = group.footer().text();
    },
    _prepareCells: function (lm) {
        this.$_createCells(this.group());
    },
    _layoutCells: function (lm, grid) {
        var column, view, model, i, dy, x, y, h, w, span, j, col, cv, spans,
            footer = grid.footer(),
            group = this.group(),
            cnt = group.visibleCount(),
            width = this.width(),
            height = this.height(),
            r = new Rectangle();
        this.$_needRender = false;
        if (column = group.$_footerColumn) {
            view = this._getCell(column);
            view.setVisible(true);
            model = footer.getCell(CellIndex.temp(-1, column));
            view.updateCell(model);
            r.set(0, 0, width, height);
            view.setRect(r);
            view.layoutContent(lm);
            return;
        } else if (!group.childFootersVisible() || cnt < 1) {
            this.$_needRender = true;
            return;
        }
        spans = group.$_footerSpanned ? group.$_footerSpans : null;
        if (group.vertical()) {
            y = r.bottom();
            h = _int(height / group.footerLevel());// cnt // this.childCount());
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        dy = height - y;
                    } else {
                        span = 0;
                        if (view instanceof FooterGroupCellElement) {
                            dy = h * column.footerLevel();
                        } else {
                            dy = h;
                        }
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                dy = height - y;
                            } else if (view instanceof FooterGroupCellElement) {
                            } else {
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = footer.getCell(CellIndex.temp(-1, column));
                    view.updateCell(model);
                    view.setBounds(0, y, width, dy);
                    view.layoutContent(lm);
                    y += dy;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        dy = 0;
                        if (i == cnt - 1) {
                            dy = height - y;
                        } else if (view instanceof FooterGroupCellElement) {
                            dy = h * column.footerLevel();
                        } else {
                            dy += h;
                        }
                        view.setVisible(true);
                        model = footer.getCell(CellIndex.temp(-1, column));
                        view.updateCell(model);
                        view.setBounds(0, y, width, dy);
                        view.layoutContent(lm);
                        y += dy;
                    }
                }
            }
        } else {
            x = 0;
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        w = width - x;
                    } else {
                        span = 0;
                        w = col.displayWidth();
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                w = width - x;
                            } else {
                                w += col.displayWidth();
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = footer.getCell(CellIndex.temp(-1, column));
                    view.updateCell(model);
                    view.setBounds(x, 0, w, height);
                    view.layoutContent(lm);
                    x += w;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        if (i == cnt - 1) {
                            w = width - x;
                        } else {
                            w = column.displayWidth();
                        }
                        view.setVisible(true);
                        model = footer.getCell(CellIndex.temp(-1, column));
                        view.updateCell(model);
                        view.setBounds(x, 0, w, height);
                        view.layoutContent(lm);
                        x += w;
                    }
                }
            }
        }
    },
    _needRender: function () {
        return this.$_needRender;
    },
    _renderCell: function (g, r) {
        if (this._text) {
            this.deflatePadding2(r);
            this._renderText(g, this._text, this._color, r);
            this.inflatePadding2(r);
        }
    },
    $_createCell: function (column) {
        var view;
        if (column instanceof ColumnGroup) {
            view = new FooterGroupCellElement(this._dom);
        } else {
            view = new FooterCellElement(this._dom);
        }
        this.$_setCell(column, view);
        this.addElement(view);
        if (column instanceof ColumnGroup) {
            view.$_createCells(column);
        }
        return view;
    },
    $_createCells: function (group) {
        var column, view, spans, i, cnt, prev,
            count = group.visibleCount();
        this.hideAll();
        if (column = group.$_footerColumn) {
            view = this._getCell(column) || this.$_createCell(column);
        } else if (group.childFootersVisible() && count > 0) {
            spans = group.$_footerSpanned ? group.$_footerSpans : null;
            if (spans) {
                prev = null;
                for (i = 0, cnt = spans.length; i < cnt; i++) {
                    column = spans[i];
                    if (column != prev) {
                        prev = column;
                        view = this._getCell(column) || this.$_createCell(column);
                    }
                }
            } else {
                for (i = 0; i < count; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column) || this.$_createCell(column);
                }
            }
        }
    }
});
var GroupFooterCellElement = defineClass("GroupFooterCellElement", ValueCellElement, {
    init: function (dom) {
        this._super(dom, "groupFooterCellElement");
        this._value = undefined;
        this._error = null;
        this._errorDetail = null;
    },
    text: null,
    value: function () {
        return this._value;
    },
    error: function () {
        return this._error;
    },
    errorDetail: function () {
        return this._errorDetail;
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.$_prepareSummary(model);
    },
    _doLayoutHandles: function () {
    },
    _doDraw: function(g, needOpaque) {
        var r = this._drawRect;
        /*
        r.height -= this._rowBottom;
        needOpaque && this._rowView.$_requestFill(this, g, r);
        */
        if (needOpaque) {
            g.drawRectI(SolidBrush.WHITE, null, r);
        }
        this._doRender(g, r);
    },
    _doRender: function (g, r) {
        var s, 
            fill = this.background();
        if (fill) {
            g.drawRect(fill, null, r);
        }
        s = this.text();
        if (s) {
            this.inflatePadding(r);
            g.drawTextRect(this._font, this._color, s, r, this._textAlign);
            this.deflatePadding(r);
        }
        GridElement.drawBorders(this, g, r);
    },
    _doRenderHtml: function (r) {
        var s,
            fill = this.background();
        this._css.clip = Dom.getClipRect(r);
        _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        s = this.text();
        if (s) {
            this.inflatePadding(r);
            var span = this.$_prepareSpan();
            Dom.renderTextBounds(span, this._font, this._color, s, r.x, r.y, r.width, r.height, this._textAlign);
            this.deflatePadding(r);
        }
        GridElement.drawHtmlBorders(this);
    }
});
var GroupFooterGroupCellElement = defineClass("GroupFooterGroupCellElement", GroupCellElement, {
    init: function (dom, name) {
        this._super(dom, name || "groupFooterGroupCellView");
    },
    layoutTreeContent: function (lm) {
        this._layoutTreeCells(lm);
    },
    _needRender: function () {
        return this.$_needRender;
    },
    _prepareCells: function (lm, grid) {
        this.$_createCells(this.group(), grid);
    },
    _layoutCells: function (lm, grid) {
        var column, view, model,
            i, dy, x, y, h, w, span, j, col, cv, spans,
            rowIndex = this.index().rowIndex,
            group = this.group(),
            cnt = group.visibleCount(),
            width = this.width(),
            height = this.height(),
            r = new Rectangle();
        this.$_needRender = false;
        if (column = group.$_groupFooterColumn) {
            view = this._getCell(column);
            view.setVisible(true);
            model = this._getModel(grid, CellIndex.temp(rowIndex, column));
            view.updateCell(model);
            r.set(0, 0, width, height);
            view.setRect(r);
            view.layoutContent(lm);
            return;
        } else if (!group.childGroupFootersVisible() || cnt < 1) {
            this.$_needRender = true;
            return;
        }
        spans = group.$_groupFooterSpanned ? group.$_groupFooterSpans : null;
        if (group.vertical()) {
            y = r.bottom();
            h = _int(height / group.groupFooterLevel());// cnt // this.childCount());
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        dy = height - y;
                    } else {
                        span = 0;
                        if (view instanceof GroupFooterGroupCellElement) {
                            dy = h * column.groupFooterLevel();
                        } else {
                            dy = h;
                        }
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                dy = height - y;
                            } else if (view instanceof GroupFooterGroupCellElement) {
                            } else {
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                    view.updateCell(model);
                    view.setBounds(0, y, width, dy);
                    view.layoutContent(lm);
                    y += dy;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        dy = 0;
                        if (i == cnt - 1) {
                            dy = height - y;
                        } else if (view instanceof GroupFooterGroupCellElement) {
                            dy = h * column.groupFooterLevel();
                        } else {
                            dy += h;
                        }
                        view.setVisible(true);
                        model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                        view.updateCell(model);
                        view.setBounds(0, y, width, dy);
                        view.layoutContent(lm);
                        y += dy;
                    }
                }
            }
        } else {
            x = 0;
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        w = width - x;
                    } else {
                        span = 0;
                        w = col.displayWidth();
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                w = width - x;
                            } else {
                                w += col.displayWidth();
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                    view.updateCell(model);
                    view.setBounds(x, 0, w, height);
                    view.layoutContent(lm);
                    x += w;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        if (i == cnt - 1) {
                            w = width - x;
                        } else {
                            w = column.displayWidth();
                        }
                        view.setVisible(true);
                        model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                        view.updateCell(model);
                        view.setBounds(x, 0, w, height);
                        view.layoutContent(lm);
                        x += w;
                    }
                }
            }
        }
    },
    _layoutTreeCells: function (lm) {
        var column, view, model,
            i, dy, x, y, h, w, span, j, col, cv, spans,
            grid = lm.grid(),
            rowIndex = this.index().rowIndex,
            group = this.group(),
            cnt = group.visibleCount(),
            width = this.width(),
            height = this.height(),
            r = new Rectangle();
        this.$_needRender = false;
        if (column = group.$_groupFooterColumn) {
            view = this._getCell(column);
            view.setVisible(true);
            model = this._getModel(grid, CellIndex.temp(rowIndex, column));
            view.updateCell(model);
            r.set(0, 0, width, height);
            view.setRect(r);
            if (view instanceof GroupFooterGroupCellElement) {
                view._layoutTreeCells(lm);
            }
            return;
        } else if (!group.childGroupFootersVisible() || cnt < 1) {
            this.$_needRender = true;
            return;
        }
        spans = group.$_groupFooterSpanned ? group.$_groupFooterSpans : null;
        if (group.vertical()) {
            y = r.bottom();
            h = _int(height / group.groupFooterLevel());// cnt // this.childCount());
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    view = this._getCell(column);
                    if (i == cnt) {
                        dy = height - y;
                    } else {
                        span = 0;
                        if (view instanceof GroupFooterGroupCellElement) {
                            dy = h * column.groupFooterLevel();
                        } else {
                            dy = h;
                        }
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                dy = height - y;
                            } else if (view instanceof GroupFooterGroupCellElement) {
                            } else {
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                    view.updateCell(model);
                    view.setBounds(0, y, width, dy);
                    if (view instanceof GroupFooterGroupCellElement) {
                        view._layoutTreeCells(lm);
                    }
                    y += dy;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        dy = 0;
                        if (i == cnt - 1) {
                            dy = height - y;
                        } else if (view instanceof GroupFooterGroupCellElement) {
                            dy = h * column.groupFooterLevel();
                        } else {
                            dy += h;
                        }
                        view.setVisible(true);
                        model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                        view.updateCell(model);
                        view.setBounds(0, y, width, dy);
                        if (view instanceof GroupFooterGroupCellElement) {
                            view._layoutTreeCells(lm);
                        }
                        y += dy;
                    }
                }
            }
        } else {
            x = 0;
            if (spans) {
                i = cnt - 1;
                while (i >= 0) {
                    col = group.getVisibleItem(i);
                    column = spans[i--];
                    view = this._getCell(column);
                    if (i < 0) {
                        w = Math.max(0, width - x);
                    } else {
                        span = 0;
                        w = Math.min(width, col.displayWidth());
                        for (; i >= 0; i--) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == 0) {
                                w = Math.max(0, width - x);
                            } else {
                                w += Math.min(width, col.displayWidth());
                            }
                            span++;
                        }
                    }
                    view.setVisible(true);
                    model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                    view.updateCell(model);
                    x += w;
                    view.setBounds(width - x, 0, w, height);
                    if (view instanceof GroupFooterGroupCellElement) {
                        view._layoutTreeCells(lm);
                    }
                }
            } else {
                for (i = cnt - 1; i >= 0; i--) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column);
                    if (view) {
                        if (i == 0) {
                            w = Math.max(0, width - x);
                        } else {
                            w = Math.min(width, column.displayWidth());
                        }
                        view.setVisible(true);
                        model = this._getModel(grid, CellIndex.temp(rowIndex, column));
                        view.updateCell(model);
                        x += w;
                        view.setBounds(width - x, 0, w, height);
                        if (view instanceof GroupFooterGroupCellElement) {
                            view._layoutTreeCells(lm);
                        }
                    }
                }
            }
        }
    },
    _doDraw: function (g, needOpaque) {
        if (this.childCount() <= 0) {
            var r = this._drawRect;
            /*
            r.height -= this._rowBottom;
            needOpaque && this._rowView.$_requestFill(this, g, r);
            */
            if (needOpaque) {
            }
            this._background && g.drawRect(this._background, null, r);
            GridElement.drawBorders(this, g, r);
        }
    },
    /** @overridable */
    _getModel: function (grid, index) {
        return grid.rowGroup().getFooterCell(index);
    },
    /** @overridable */
    _createGroupCellView: function () {
        return new GroupFooterGroupCellElement(this._dom);
    },
    $_createCell: function (column) {
        var view;
        if (column instanceof ColumnGroup) {
            view = this._createGroupCellView();
        } else {
            view = new GroupFooterCellElement(this._dom);
        }
        this.$_setCell(column, view);
        this.addElement(view);
        if (column instanceof ColumnGroup) {
            view.$_createCells(column);
        }
        return view;
    },
    $_createCells: function (group, grid) {
        this.hideAll();
        var column, view, rowIndex, spans, i, cnt, prev,
            count = group.visibleCount();
        if (column = group.$_groupFooterColumn) {
            view = this._getCell(column) || this.$_createCell(column);
        } else if (group.childGroupFootersVisible() && count > 0) {
            rowIndex = this.index().rowIndex;
            spans = group.$_groupFooterSpanned ? group.$_groupFooterSpans : null;
            if (spans) {
                prev = null;
                for (i = 0, cnt = spans.length; i < cnt; i++) {
                    column = spans[i];
                    if (column != prev) {
                        prev = column;
                        view = this._getCell(column) || this.$_createCell(column);
                    }
                }
            } else {
                for (i = 0; i < count; i++) {
                    column = group.getVisibleItem(i);
                    view = this._getCell(column) || this.$_createCell(column);
                }
            }
        }
    }
});
var HeaderSummaryHeadElement = defineClass("HeaderSummaryHeadElement", CellElement, {
    init: function (dom) {
        this._super(dom, "headerSummaryHeadView");
        if (dom) {
            this.addElement(this._backView = new GraphicElement().setVisible(false));
        }
        this.addElement(this._menuView = new CellMenuElement(dom, this));
        this._menuView.setVisible(false);
    },
    text: null,
    menuVisible: false,
    _doUpdateContent: function (model) {
        this._super(model);
        this.setMenuVisible(model.menuVisible());
        this.setText(model.text());
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
    },
    _doLayoutHandles: function () {
    },
    $_renderMenuText: function (g, r) {
        var sz, fill,
            s = this.text(),
            w = s ? g.getTextWidth(this._font, s) : 0,
            tr = r.clone();
        this.inflatePadding(tr);
        if (this._menuVisible) {
            this._menuView.setVisible(true);
            sz = this._menuView.measure(this._grid);
            w = Math.max(tr.x, (tr.width - sz.width - w) / 2);
            this._menuView.setBoundsI(w, (this.height() - sz.height + 1) / 2, sz.width, sz.height);
            this._menuView.setBackground(this._background);
        } else {
            this._menuView.setVisible(false);
        }
        if (s) {
            fill = this.color();
            if (fill) {
                if (this._menuView.visible()) {
                    tr.leftBy(this._menuView.right());
                }
                this._renderText(g, s, fill, tr);
            }
        }
    },
    _doRender: function (g, r) {
        var fill;
        if (this._renderer) {
            this._renderer.render(this, g, r);
        } else {
            fill = this.background();
            fill && g.drawRect(fill, null, r);
        }
        this.$_renderMenuText(g, r);
        GridElement.drawBorders(this, g, r);
    },
    _doRenderHtml: function (r) {
        var fill;
        if (this._renderer) {
            this._backView.setVisible(true);
            this._renderer.renderHtml(this._backView, r);
        } else {
            fill = this.background();
            this._css.background = fill ? fill.css() : "";
        }
        this.$_renderMenuText(null, r);
        GridElement.drawHtmlBorders(this);
    }
});
var HeaderHeadElement = defineClass("HeaderHeadElement", CellElement, {
    init: function (dom) {
        this._super(dom, "headerHeadView");
        this.addElement(this._menuView = new CellMenuElement(dom, this));
        this._menuView.setVisible(false);
    },
    menuVisible: false,
    _doUpdateContent: function (model) {
        this._super(model);
        this.setMenuVisible(model.menuVisible());
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
    },
    _doLayoutHandles: function () {
        var sz,
            mv = this._menuView;
        if (this._menuVisible) {
            mv.setVisible(true);
            sz = mv.measure(this._grid);
            mv.setBoundsI((this.width() - sz.width) / 2, (this.height() - sz.height + 1) / 2, sz.width, sz.height);
            mv.setBackground(this._background);
            mv.setColor(this._shapeColor);
            mv.setHoveredColor(this._shapeHoveredColor);
        } else {
            mv.setVisible(false);
        }
    },
    _doRender: function (g, r) {
        var fill = this.background();
        fill && g.drawRect(fill, null, r);
        GridElement.drawBorders(this, g, r);
    },
    _doRenderHtml: function (r) {
        var fill = this.background();
        this._css.background = fill ? fill.css() : '';
        GridElement.drawHtmlBorders(this);
    }
});
var CheckBarHeadElement = defineClass("CheckBarHeadElement", CellElement, {
    init: function (dom) {
        this._super(dom, "checkBarHeadView");
    },
    showCheck: true,
    checked: false,
    checkableAt: function (x, y) {
        return (x >= this._boxX) && (x <= this._boxX + this._boxW) && (y >= this._boxY) && (y <= this._boxY + this._boxW);
    },
    _doUpdateContent: function (model) {
        var grid = this.grid(),
            checkBar = grid.checkBar();
        this._super(model);
        this.setShowCheck(checkBar.showAll() && !checkBar.exclusive() && grid.rowCount() > 0);
        if (grid.rowCount() <= 0) {
            this.setChecked(false);
        }
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
    },
    _doRender: function (g, rc) {
        var r, fill = this.background();
        if (fill) {
            g.drawRect(fill, null, rc);
        }
        if (this.showCheck()) {
            r = this._getRenderRect(rc);
            this.$_drawCheck(g, r);
        }
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (r) {
        var check, cr,
            fill = this.background();
        this._css.background = fill ? fill.css() : '';
        if (this.showCheck()) {
            check = this._checkElement;
            if (!check) {
                check = this._checkElement = document.createElement("input");
                check.type = "checkbox";
                check.style.position = "absolute";
                check.style.padding = "0px";
                check.style.margin = "0px";
                check.style.pointEvents = "none";
                this._dom.appendChild(check);
            }
            cr = _getCheckSize(check);
            this._boxW = Math.max(cr.width, cr.height);
            check.checked = this.checked();
            check.style.left = (this._boxX = (r.x + this.paddingLeft() + (r.width - this.paddingHorz() - cr.width) / 2)) + "px";
            check.style.top = (this._boxY = (r.y + this.paddingTop() + (r.height - this.paddingVert() - cr.height) / 2)) + "px";
        }
        GridElement.drawHtmlBorders(this);
    },
    $_drawCheck: function (g, r) {
        var checkSize, sz, x, y,
            fill = this.checked() ? this.shapeColor() : this.shapeInactiveColor();
        if (fill) {
            r = this._getRenderRect(r);
            checkSize = this._shapeSize ? this._shapeSize.getDimension(r.height) : 13;
            sz = _floor(this._boxW = checkSize - 2);
            this._boxX = r.x + (r.width - sz) / 2;
            this._boxY = r.y + (r.height - sz) / 2;
            if (this.shapeName() == 'rectangle') {
                x = _floor(this._boxX);
                y = _floor(this._boxY);
                g.drawBoundsI(null, /*this.isHovered() ? SolidPen.RED : */CHECK_CELL_BORDER, x, y, sz + 1, sz);
                sz++;
                this.checked() && g.drawBounds(fill, null, x + (sz + 1) / 2 - sz / 4, y + sz / 2 - sz / 4, sz / 2, sz / 2);
            } else {
                $$_drawCheckMark(g, fill, r, sz + 2);
            }
        }
    }
});
var IndicatorCellElement = defineClass("IndicatorCellElement", SelectableCellElement, {
    init: function (dom) {
        this._super(dom, "indicatorCellView");
    },
    prefix: null,
    suffix: null,
    text: null,
    shapeVisible: true,
    rowState: EnumProp(GridRowState, GridRowState.NORMAL),
    dataState: EnumProp(DataRowState, DataRowState.NONE),
    setRowState: function (value) {
        if (value != this._rowState) {
            this._rowState = value;
            this.invalidate();
        }
    },
    _doPrepareValue: function (model) {
        this._super(model);
        var styles = model.styles();
        this.setPrefix(styles.prefix());
        this.setSuffix(styles.suffix());
    },
    _doUpdateContent: function (model) {
        this._super(model);
        this.setShapeVisible(model.shapeVisible());
        this.setRowState(model.rowState());
        this.setDataState(model.dataState());
        var s = model.displayText();
        if (this._prefix) s = this._prefix + s;
        if (this._suffix) s += this._suffix;
        this.setText(s);
    },
    _doRender: function (g, rc) {
        var fill = this.$_getBackground();
        fill && g.drawRectI(fill, null, rc);
        this.$_renderCell(g, this._getRenderRect(rc));
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (rc) {
        var r = this._getRenderRect(rc),
            fill = this.$_getBackground();
        _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        this.$_renderCell(this.$_getGraphics(true, r), r);
        GridElement.drawHtmlBorders(this);
    },
    _hoveredChanged: function () {
        this.invalidate();
    },
    $_getBackground: function () {
        var fill = null;
        if (this.hovered()) {
            fill = this._hoveredBackground;
        }
        if (!fill && (this._selected || this._rowState != GridRowState.NORMAL)) {
            fill = this._selectedBackground;
        }
        if (!fill) {
            fill = this._background;
        }
        return fill;
    },
    $_renderCell: function (g, r) {
        var s,
            rowState = this._rowState,
            fill = this._shapeVisible &&
            (this.hovered() ? this._shapeHoveredColor : this._selected ? this._shapeSelectedColor : this._shapeColor);
        if (fill && rowState != GridRowState.NORMAL) {
            if (rowState == GridRowState.INSERTING || rowState == GridRowState.APPENDING) {
                this.$_drawInsert(g, fill, r);
            } else if (rowState == GridRowState.UPDATING) {
                this.$_drawEdit(g, fill, r);
            }
            else if (rowState == GridRowState.FOCUSED) {
                this.$_drawArrow(g, fill, r);
            }
        } else {
            s = this.text();
            if (s) {
                fill = null;
                if (this._selected || this._rowState != GridRowState.NORMAL) {
                    fill = this._selectedColor;
                }
                if (!fill && this.hovered()) {
                    fill = this._hoveredColor;
                }
                if (!fill) {
                    fill = this._color;
                }
                if (fill) {
                    this.inflatePadding(r);
                    this._renderText(g, s, fill, r);
                    this.deflatePadding(r);
                }
            }
        }
    },
    $_drawArrow: function (g, fill, r) {
        var W = 11,
            H = 11,
            x = r.x + (r.width - W) / 2,
            y = r.y + (r.height - H) / 2;
        g.drawPolygonArray(fill, null, [
            x + 4, y + 2.5,
            x + 7.5, y + 5.5,
            x + 4, y + 9,
            x + 5, y + 10.5,
            x + 9.5, y + 5.5,
            x + 5, y + 1
        ]);
    },
    $_drawEdit: function (g, fill, r) {
        var W = 12,
            H = 12,
            x = r.x + (r.width - W) / 2,
            y = r.y + (r.height - H) / 2;
        g.drawPolygonArray(fill, null, [
            x + 1, y + 2,
            x + 7, y + 8,
            x + 9, y + 8,
            x + 9, y + 6,
            x + 3, y + 0
        ]);
        g.drawPolygonArray(fill, null, [
            x + 0, y + 9.5,
            x + 0, y + 11,
            x + 3, y + 11,
            x + 3, y + 9.5
        ]);
        g.drawPolygonArray(fill, null, [
            x + 4, y + 9.5,
            x + 4, y + 11,
            x + 7, y + 11,
            x + 7, y + 9.5
        ]);
        g.drawPolygonArray(fill, null, [
            x + 8, y + 9.5,
            x + 8, y + 11,
            x + 11, y + 11,
            x + 11, y + 9.5
        ]);
    },
    $_drawInsert: function (g, fill, r) {
        var W = 12,
            H = 12,
            x = r.x + (r.width - W) / 2,
            y = r.y + (r.height - H) / 2;
        g.drawPolygonArray(fill, null, [
            x + 4.5, y + 0,
            x + 4.5, y + 7.5,
            x + 6.5, y + 7.5,
            x + 6.5, y + 0
        ]);
        g.drawPolygonArray(fill, null, [
            x + 1, y + 2.5,
            x + 10, y + 2.5,
            x + 10, y + 4,
            x + 1, y + 4
        ]);
        g.drawPolygonArray(fill, null, [
            x + 0, y + 9.5,
            x + 0, y + 11,
            x + 3, y + 11,
            x + 3, y + 9.5
        ]);
        g.drawPolygonArray(fill, null, [
            x + 4, y + 9.5,
            x + 4, y + 11,
            x + 7, y + 11,
            x + 7, y + 9.5
        ]);
        g.drawPolygonArray(fill, null, [
            x + 8, y + 9.5,
            x + 8, y + 11,
            x + 11, y + 11,
            x + 11, y + 9.5
        ]);
    }
});
var StateCellElement = defineClass("StateCellElement", SelectableCellElement, {
    init: function (dom) {
        this._super(dom, "stateCellView");
    },
    iconIndex: -1,
    iconAlpha: 1.0,
    rowState: DataRowState.NONE,
    label: null,
    _doUpdateContent: function (model) {
        this._super(model);
        var styles = model.styles();
        this.setIconIndex(styles.iconIndex());
        this.setIconAlpha(styles.iconAlpha());
        this.setRowState(model.index().getRow(this._grid).dataState());
        this.setLabel(model.label());
        this._images = this._grid.rowIndicator().stateImages();
        if (!this._dirty && this._grid._imageLoaded === this._images) {
            this.invalidate();
        }
    },
    _renderCell: function (g, r, hovered) {
        var fill, w, h, icon, fs;
        if (this._rowState && this._rowState !== DataRowState.NONE) {
            if (this._label && (fill = hovered ? (this.hoveredColor() || this.color()) : this.color())) {
                this.deflatePadding2(r);
                this._renderText(g, this._label, fill, r);
                this.inflatePadding2(r);
            }
            else if (this._images && (icon = this._images.getImage(this._iconIndex)) && (w = icon.width)) {
                h = icon.height;
                g.drawImageAlphaI(icon, this._iconAlpha, r.x + (r.width - w) / 2, r.y + (r.height - h) / 2, w, h);
            }
            else if (this._shapeName) {
                icon = ShapeDrawing.getShape(this, this._shapeName);
                if (icon) {
                    this.deflatePadding2(r);
                    w = Math.min(r.width, r.height);
                    fs = this.shapeSize();
                    if (fs) {
                        w = fs.getDimension(w);
                    }
                    r.x += (r.width - w) / 2;
                    r.y += (r.height - w) / 2;
                    r.width = r.height = w;
                    icon.draw(g, r, this._shapeColor, this._shapeBorder, this._shapeRotate);
                }
            }
        }
    },
    _doRender: function (g, rc) {
        var fill,
            hovered = this.hovered();
        if (hovered) {
            fill = this.hoveredBackground();
        }
        if (!fill) {
            fill = this.background();
        }
        fill && g.drawRect(fill, null, rc);
        this._renderCell(g, this._getRenderRect(rc), hovered);
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (rc) {
        var fill, r,
            hovered = this.hovered();
        if (hovered) {
            fill = this.hoveredBackground();
        }
        if (!fill) {
            fill = this.background();
        }
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        r = this._getRenderRect(rc);
        this._renderCell(this.$_getGraphics(true, r), r, hovered);
        GridElement.drawHtmlBorders(this);
    }
});
var CHECK_CELL_BORDER = new SolidPen("rgba(170, 170, 170, 1)");
var CHECK_CELL_GRAY_FILL = new SolidBrush(0xffeeeeee);
var CHECK_CELL_GRAY_BORDER = new SolidPen("rgba(170, 170, 170, 0.35)");
var CheckBarCellElement = defineClass("CheckBarCellElement", SelectableCellElement, {
    init: function (dom) {
        this._super(dom, "checkBarCellView");
    },
    markVisible: true,
    exclusive: false,
    checked: false,
    checkable: true,
    checkableAt: function (x, y) {
        return (x >= this._boxX) && (x <= this._boxX + this._boxW) && (y >= this._boxY) && (y <= this._boxY + this._boxW);
    },
    _doUpdateContent: function (model) {
        this._super(model);
        var grid = this._grid,
            row = model.index().getRow(grid);
        this.setCheckable(grid.isCheckable(row));
        this.setChecked(row.$_isChecked(grid));
    },
    _doRender: function (g, rc) {
        var fill = null;
        if (this.hovered()) {
            fill = this.hoveredBackground();
        }
        if (!fill) {
            fill = this.background();
        }
        if (fill) {
            g.drawRect(fill, null, rc);
        }
        if (this._markVisible && this.$_showCheckbox()) {
            var r = this._getRenderRect(rc);
            this._exclusive ? this.$_drawRadio(g, r) : this.$_drawCheck(g, r);
        }
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (r) {
        var check, cr,
            fill = null;
        if (this.hovered()) {
            fill = this._hoveredBackground;
        }
        if (!fill) {
            fill = this._background;
        }
        this._css.background = fill ? fill.css() : '';
        check = this._checkElement;
        if (!check) {
            check = this._checkElement = document.createElement("input");
            check.style.position = "absolute";
            check.style.padding = "0px";
            check.style.margin = "0px";
            check.style.pointEvents = "none";
            this._dom.appendChild(check);
        }
        cr = _getCheckSize(check);
        this._boxW = Math.max(cr.width, cr.height);
        check.type = this._exclusive ? "radio" : "checkbox";
        check.disabled = !this._checkable;
        check.checked = this._checked;
        check.style.left = (this._boxX = (r.x + (r.width - cr.width) / 2)) + "px";
        check.style.top = (this._boxY = (r.y + (r.height - cr.height) / 2)) + "px";
        check.style.visibility = this.$_showCheckbox() ? "visible" : "hidden";
        GridElement.drawHtmlBorders(this);
    },
    $_showCheckbox: function () {
        return  this._checkable || !this._grid.checkBar().hideUncheckable();
    },
    $_drawCheck: function (g, r) {
        r = this._getRenderRect(r);
        var fill,
            checkSize = this._shapeSize ? this._shapeSize.getDimension(r.height) : 13,
            sz = _floor(this._boxW = checkSize - 2),
            x = _floor(this._boxX = r.x + (r.width - sz) / 2),
            y = _floor(this._boxY = r.y + (r.height - sz) / 2);
        if (this._checkable) {
            g.drawBoundsI(null, /*this.isHovered() ? SolidPen.RED : */CHECK_CELL_BORDER, x, y, sz + 1, sz);
        } else {
            g.drawBoundsI(CHECK_CELL_GRAY_FILL, CHECK_CELL_GRAY_BORDER, x, y, sz + 1, sz);
        }
        if (this._checked) {
            fill = this._shapeColor;
            if (fill) {
                if (this.shapeName() == "rectangle") {
                    sz++;
                    g.drawBounds(fill, null, x + (sz + 1) / 2 - sz / 4, y + sz / 2 - sz / 4, sz / 2, sz / 2);
                } else {
                     r.leftBy(2);
                     $$_drawCheckMark(g, fill, r, checkSize);
                }
            }
        }
    },
    $_drawRadio: function (g, rc) {
        var fill,
            r = this._getRenderRect(rc),
            checkSize = this._shapeSize ? this._shapeSize.getDimension(r.height) : 12,
            sz = this._boxW = checkSize - 3,
            rd = sz / 2,
            cx = r.x + r.width / 2,
            cy = r.y + r.height / 2;
        this._boxX = r.x + (r.width - sz) / 2;
        this._boxY = r.y + (r.height - sz) / 2;
        if (this._checkable) {
            g.drawCircle(null, CHECK_CELL_BORDER, cx, cy, rd);
        } else {
            g.drawCircle(CHECK_CELL_GRAY_FILL, CHECK_CELL_GRAY_BORDER, cx, cy, rd);
        }
        if (this._checked) {
            fill = this._shapeColor;
            if (fill) {
                rd -= 2;
                g.drawCircle(fill, null, cx, cy, rd);
            }
        }
    }
});
var RenderableValueCellElement = defineClass("RenderableValueCellElement", ValueCellElement, {
    init: function (dom, name) {
        this._super(dom, name);
    },
    iconIndex: 0,
    iconLocation: EnumProp(IconLocation, IconLocation.NONE),
    iconAlignment: EnumProp(Alignment, Alignment.NEAR),
    iconOffset: 0,
    iconPadding: 0,
    iconAlpha: 1.0,
    shapeLocation: EnumProp(IconLocation, IconLocation.NONE),
    shapeAlignment: EnumProp(Alignment, Alignment.NEAR),
    shapeOffset: 0,
    shapePadding: 0,
    renderer: null,
    text: null,
    value: undefined,
    setValue: function (v) {
        if (v !== this._value) {
            this._value = v;
            this.invalidate();
        }
    },
    getAnimations: function () {
        return this._grid._animations.getRuns(this._index.column, this._index.getDataId(this._grid));
    },
    getIcon: function () {
        var images,
            idx = this._iconIndex;
        if (idx >= 0 || typeof idx === "string") { // idx 가 url일 수 있다.
            images = this._index.column.$_images();
            return images ? images.getImage(idx) : null;
        }
        return null;
    },
    _doPrepareElement: function (model) {
        this._super(model);
        var s = model.styles(),
            renderer = null,
            rendererId = s.renderer();
        this.setIconIndex(s.iconIndex());
        this.setIconLocation(s.iconLocation());
        this.setIconAlignment(s.iconAlignment());
        this.setIconOffset(s.iconOffset());
        this.setIconPadding(s.iconPadding());
        this.setIconAlpha(s.iconAlpha());
        this.setShapeLocation(s.shapeLocation());
        this.setShapeAlignment(s.shapeAlignment());
        this.setShapeOffset(s.shapeOffset());
        this.setShapePadding(s.shapePadding());
        if (rendererId) {
            renderer = this.grid().dataCellRenderers().getRenderer(rendererId);
        }
        if (!renderer) {
            renderer = this._index.column.rendererObj();
        }
        this.setRenderer(renderer);
    },
    _doPrepareValue: function (model) {
        this._super(model);
        var func, v, w,
            s = null,
            col = this._index.column,
            vt = col.valueType();
        this.setValue(model.value());
        if (!vt) return;
        func = col._displayCallback;
        if (func) {
            s = func(model._index, this._value);
            if (typeof s !== "string" && s !== undefined && s !== null) {
                s = String(s);
            }
        } else {
            switch (vt) {
                case ValueType.TEXT:
                    s = model.displayText();
                    if (this._textFormatter && s) {
                        s = this._textFormatter.format(s);
                    }
                    break;
                case ValueType.NUMBER:
                    v = Number(this._value);
                    if (isNaN(v)) {
                        s = _pickStr(col._nanText, this._grid.$_nanText);
                    } else if (this._numberFormatter) {
                        s = this._numberFormatter.format(v);
                    } else {
                        s = model.displayText();
                    }
                    break;
                case ValueType.DATETIME:
                    /*if (this._value instanceof Date && this._datetimeFormatter) {
                     s = this._datetimeFormatter.format(this._value);
                     } else*/
                    if (this._value/* instanceof Date*/ && (w = this.datetimeWriter())) {
                        s = w.getText(this._value);
                    } else {
                        s = model.displayText();
                    }
                    break;
                case ValueType.BOOLEAN:
                    if (this._boolFormatter) {
                        s = this._boolFormatter.formatValue(this._value);
                    } else {
                        s = model.displayText();
                    }
                    break;
                case ValueType.OBJECT:
                    if (this._value) {
                        v = col._keyFn ? col._keyFn(col.$_field, this._value) :
                            col._keyPath ? DataPath.extractJson(this._value, col._keyPath, true) : model.displayText();
                        switch (typeof v) {
                            case "string":
                                s = (this._textFormatter && v) ? this._textFormatter.format(v) : v;
                                break;
                            case "number":
                                s = this._numberFormatter ? this._numberFormatter.format(v) : v;
                                break;
                            case "boolean":
                                s = this._boolFormatter ? this._boolFormatter.formatValue(v) : v;
                                break;
                            default:
                                s = (_isDate(v) && (w = this.datetimeWriter())) ? w.getText(v) : v;
                                break;
                        }
                    } else {
                        s = '';
                    }
                    break;
                default:
                    s = model.displayText();
                    break;
            }
        }
        this.setText(s);
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var sz = this.renderer().measure(grid, this, hintWidth, hintHeight);
        this._dirty = this._dirty || grid._imageLoaded;
        sz.width += this._borderLeft ? this._borderLeft.width() : 0;
        sz.width += this._borderRight ? this._borderRight.width() : 0;
        return sz;
    },
    $_setSelStyles: function (styles) {
        this._selFill = styles.background();
    },
    _doDraw: function (g, needOpaque) {
        var r, fill, i, y1, y2,
            rc = this._drawRect,
            ranges = this._selected && this._selRanges,
            selected = !this._selRanges && this._selected;
        rc.height -= this._rowBottom;
        needOpaque && this._rowView.$_requestFill(this, g, rc);
        r = this._getRenderRect(rc);
        fill = selected ? this._selectedBackground : this._background;
        fill && g.drawRectI(fill, null, r);
        this._textColor = selected ? (this._selectedColor || this._color) : this._color;
        this._doRenderCell(g, r);
        GridElement.drawBorders(this, g, rc);
        if (ranges) {
            for (i = 0; i < ranges.length / 2; i++) {
                y1 = ranges[i * 2];
                y2 = ranges[i * 2 + 1];
                (y2 > y1) && g.drawBoundsI(this._selFill, null, rc.x, y1, rc.width, (y2 - y1));
            }
        }
    },
    _doRenderHtml: function (rc) {
        var fill, r, g, i, y1, y2,
            ranges = this._selected && this._selRanges,
            selected = !this._selRanges && this._selected;
        fill = selected ? this._selectedBackground : this._background;
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        r = this._getRenderRect(rc);
        this._textColor = selected ? (this._selectedColor || this._color) : this._color;
        this._doRenderCell(null, r);
        GridElement.drawHtmlBorders(this);
        if (ranges) {
            g = this.$_getSelGraphics(true, rc);
            for (i = 0; i < ranges.length / 2; i++) {
                y1 = ranges[i * 2];
                y2 = ranges[i * 2 + 1];
                (y2 > y1) && g.drawBoundsI(this._selFill, null, rc.x, y1, rc.width, (y2 - y1));
            }
        }
    },
    _doClearHtml: function () {
        this._super();
        this._selSvg && (this._selSvg._svg.style.visibility = 'hidden');
    },
    $_getSelGraphics: function (clear, r) {
        var svg = this._selSvg;
        if (!svg) {
            svg = this._selSvg = new SvgSprite(null, this.container());
            this._dom.appendChild(svg._svg);
        }
        svg._svg.style.visibility = 'visible';
        return svg.getGraphics(clear, r);
    },
    _doRenderCell: function (g, r) {
    }
});
var DataCellElement = defineClass("DataCellElement", RenderableValueCellElement, {
    init: function (dom, name) {
        this._super(dom, name || "dataCellView");
        this._dataColumn = null;
        this._cellStyles = null;
        this._error = null;
        this._errorLevel = ValidationLevel.IGNORE;
        this._lButtonsWidth = 0;
        this._rButtonsWidth = 0;
        this._buttonWidth = 0;
        this._buttonPoints = []; // custom buttons' poses.
        this._editWidth = 0;
        this._errorWidth = 0;
        this._buttonHovered = -1;   // 0이면 기본 버튼, 1 이상은 custom button
        this._buttonPressed = -1;
        this._editorButtonHovered = false;
        this._editorButtonPressed = false;
        this._expandHandle = null;
    },
    button: EnumProp(CellButton, CellButton.NONE),
    buttonVisibility: EnumProp(ButtonVisibility, ButtonVisibility.DEFAULT),
    buttons: null,
    editorButtonVisibility: EnumProp(ButtonVisibility, ButtonVisibility.DEFAULT),
    expanderVisible: false,
    innerIndex: -1,
    setInnerIndex: function (value) {
        if (value != this._innerIndex) {
            this._innerIndex = value;
            this.$_resetButtonsVisible();
            this.invalidate(false, true);
        }
    },
    mergeRoom: function () {
        return null;
    },
    expanderVisible_: function () {
        return this._expandHandle != null;
    },
    setExpanderVisible: function (value) {
        if (value != this.expanderVisible()) {
            if (this._expandHandle) {
                if (this.contains(this._expandHandle)) {
                    this.removeChild(this._expandHandle);
                }
                this._expandHandle = null;
            } else {
                this._expandHandle = new DataCellExpandHandle(this._dom, this);
            }
            this.invalidate(false, true);
        }
    },
    setButtons: function (value) {
        if (value != this._buttons) {
            this._buttons = value;
            this.invalidate(false, true);
        }
    },
    group: function () {
        var room = this.mergeRoom();
        return room ? room.group() : this.index().getRow(this._grid).parent();
    },
    innerCellIndex: function () {
        if (this._innerIndex >= 0) {
            var idx = this._index.clone();
            idx.rowIndex = this._index.rowIndex + this._innerIndex;
            return idx;
        } else {
            return this._index;
        }
    },
    layoutTreeContent: function (lm) {
        this._doLayoutHandles();
    },
    ptInCell: function (x, y) {
        return (x > this._lButtonsWidth) && (x < this.width() - this._buttonWidth - this._rButtonsWidth - this._editWidth - this._errorWidth);
    },
    ptInClick: function (x, y) {
        if (this.$_clickRect) {
            return this.$_clickRect.contains(x, y);
        } else {
            return this.ptInCell(x, y);
        }
    },
    ptInButton: function (x, y) {
        var w = this._buttonWidth,
            w2 = this._rButtonsWidth,
            bx = this.width() - w - w2;
        if (w > 0 && x >= bx && x < this.width() - w2 && y >= 0 && y <= this.height()) {
            return this.grid().$_buttonRenderer.hitTest(w, this.height(), x - bx, y);
        }
        return false;
    },
    ptInCustomButton: function (x, y) {
        var h, renderer, pts, btns, bx, i, b,
            w = this._rButtonsWidth;
        if (w > 0 && y >= 0 && y <= (h = this.height())) {
            renderer = this.grid().$_customButtonRenderer;
            if (renderer) {
                btns = this._buttons;
                pts = this._buttonPoints;
                bx = this.width() - w;
                for (i = 0; i < btns.length; i++) {
                    b = btns[i];
                    if (x >= bx + pts[i] && x < bx + pts[i + 1]) {
                        return i;
                    }
                }
            }
        }
        return -1;
    },
    ptInEditorButton: function (x, y) {
        var w = this._editWidth,
            w2 = this._buttonWidth + this._rButtonsWidth,
            bx = this.width() - w - w2;
        if (w > 0 && x >= bx && x < this.width() - w2 && y >= 0 && y <= this.height()) {
            return this.grid().delegate().getCellEditorButtonRenderer(this.index()).hitTest(w, this.height(), x - bx, y);
        }
        return false;
    },
    ptInDataButton: function (x, y) {
        var renderer = this._renderer;
        if (renderer && renderer.isButton()) {
            return renderer.ptInButton(this, x, y);
        }
        return false;
    },
    ptInHovered: function (x, y) {
        var renderer = this._renderer;
        if (renderer && renderer.isButton()) {
            return renderer.ptInButton(this, x, y);
        }
        return true;
    },
    setButtonState: function (hovered, pressed) {
        if (this._buttonHovered != hovered || this._buttonPressed != pressed) {
            this._buttonHovered = hovered;
            this._buttonPressed = pressed;
            this.invalidate();
        }
    },
    setEditorButtonState: function (hovered, pressed) {
        if (this._editorButtonHovered != hovered || this._editorButtonPressed != pressed) {
            this._editorButtonHovered = hovered;
            this._editorButtonPressed = pressed;
            this.invalidate();
        }
    },
    getButtonsWidth: function () {
        return this._buttonWidth + this._rButtonsWidth + this._editWidth + this._errorWidth - 1;
    },
    getValueOf: function (fieldName) {
        var idx = this.index(),
            row = idx.getRow(this._grid),
            ds = row.dataSource(),
            fld = ds.getFieldIndex(fieldName);
        if (fld >= 0) {
            return row.getValue(fld);
        }
        return undefined;
    },
    isDataCell: function () {
        return true;
    },
    /*
     invalidate: function (force, invalidteChildren) {
     DataCellElement.Base.invalidate.call(this, force, invalidteChildren);
     if (this._expandHandle && !invalidteChildren) debugger;
     this._expandHandle && this._expandHandle.invalidate(force, invalidteChildren);
     },
     */
    canEditable: function () {
        return true;
    },
    canEditableAt: function (p) {
        return !this.ptInButton(p.x, p.y) && !this.ptInCustomButton(p.x, p.y) >= 0 && !this.ptInEditorButton(p.x, p.y);
    },
    setFocused: function (value) {
        this._super(value);
        this.invalidate(false, true);
    },
    canHovering: function (hovered) {
        if (hovered) {
            if (this.button() != CellButton.NONE || this.$_rightButtonsWidth() > 0 || this.$_editorButtonWidth() > 0 || this._expandHandle || this._error) {
                return true;
            }
        } else {
            if (this._lButtonsWidth + this._buttonWidth + this._rButtonsWidth + this._editWidth + this._errorWidth != 0) {
                return true;
            }
        }
        return false;
    },
    _hoveredChanged: function () {
        var renderer = this.renderer();
        if (renderer && (renderer.isClickable(this) || (renderer.alwaysRedraw && renderer.alwaysRedraw()))) {
                this._font.deco = this._hovered ? "underline" : this._textDeco;
                this.invalidate();
        }
    },
    setMouseEntered: function (value) {
        this._super(value);
        if (!value) {
            this.setButtonState(-1, -1);
            this.setEditorButtonState(false, false);
        }
    },
    _doClearHtml: function () {
        this._super();
        var i, span,
            spans = this._spans;
        if (spans) {
            for (i = spans.length; i--;) {
                span = spans[i];
                span && span.parentNode === this._dom && this._dom.removeChild(span);
            }
        }
    },
    $_prepareItemSpan: function (index) {
        if (!this._spans) {
            this._spans = [];
        }
        var span = this._spans[index];
        if (!span) {
            this._spans[index] = span = document.createElement("span");
            span.style.position = "absolute";
        }
        !span.parentNode && this._dom.appendChild(span);
        return span;
    },
    _doLayoutHandles: function () {
        this._super();
        if (this._expandHandle) {
            var cell,
                h = this._expandHandle;
            h.setBounds(2, 2, 12, 12);
            h.setExpanded(this.group().expanded());
            cell = this._grid.rowGroup().getExpanderCell(this._index.rowIndex);
            h.setColor(cell.styles().shapeColor());
            h.setFill(null);
            if (!this.contains(h)) {
                this.addElement(h);
            }
            h.invalidate();
        }
    },
    _doPrepareValue: function (model) {
        this._super(model);
        var col = this._index.column;
        this._dataColumn = col instanceof DataColumn ? col : null;
        this._error = model.error();
        this._errorLevel = model.errorLevel();
    },
    _doUpdateContent: function (model) {
        this._super(model);
        this.setInnerIndex(-1);
        this.$_resetButtonsVisible();
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var sz = this.renderer().measure(grid, this, hintWidth, hintHeight);
        this._dirty = this._dirty || grid._imageLoaded;
        sz.width += this._borderLeft ? this._borderLeft.width() : 0;
        sz.width += this._borderRight ? this._borderRight.width() : 0;
        return sz;
    },
    measureHeight: function (grid, width, maxHeight) {
        var h = this.renderer().measureHeight(grid, this, width, maxHeight);
        h += this._borderTop ? this._borderTop.width() : 0;
        h += this._borderBottom ? this._borderBottom.width() : 0;
        return h;
    },
    _doRenderCell: function (g, r) {
        var br, grid, cr, idx, hasButton,
            wButton, wRight, wEdit, wError,
            wLeft = 0;
        if (this._mergeRoom) {
            if (!this._buttonIdx) this._buttonIdx = new CellIndex();
            this._buttonIdx.column = this._index.column;
            this._buttonIdx.rowIndex = this._index.rowIndex + Math.max(0, (this._mouseEntered && this._hoverIndex >= 0) ? this._hoverIndex : this._innerIndex);
        } else {
            this._buttonIdx = this._index;
        }
        hasButton = (wButton = this._buttonWidth = this.$_buttonWidth())
            + (wRight = this._rButtonsWidth = this.$_rightButtonsWidth())
            + (wEdit = this._editWidth = this.$_editorButtonWidth())
            + (wError = this._errorWidth = this.$_errorWidth()) > 0;
        if (this._renderer) {
            if (hasButton || (wLeft = this._lButtonsWidth = this.$_leftButtonsWidth()) > 0) {
                r.leftBy(wLeft);
                r.rightBy(-wButton - wRight - wEdit - wError);
                if (g) {
                    g.save();
                    g.clipRect(r);
                    this._renderer.render(this, g, r);
                    g.restore();
                } else {
                    this._renderer.renderHtml(this, r);
                }
                r.rightBy(wButton + wRight + wEdit + wError);
                r.leftBy(-wLeft);
            } else {
                if (g) {
                    this._renderer.render(this, g, r);
                } else {
                    this._renderer.renderHtml(this, r);
                }
            }
        }
        if (hasButton) {
            g = g || this.$_getGraphics(true, r);
            br = r.clone();
            if (this._mergeRoom) {
                grid = this._grid;
                cr = grid.lm().getItemRect(this._buttonIdx.rowIndex - grid.topIndex());
                br.y = cr.y - this.topBy(grid, 0);
                br.height = cr.height;
            }
            if (wRight > 0) {
                br.setLeft(br.right() - wRight);
                this.$_drawRightButtons(g, br);
            }
            if (wButton > 0) {
                br.set(r.x, br.y, r.width, br.height);
                br.rightBy(-wRight);
                br.setLeft(br.right() - wButton);
                this.$_drawButton(g, br);
            }
            if (wEdit > 0) {
                br.set(r.x, br.y, r.width, br.height);
                br.rightBy(-wButton - wRight);
                br.setLeft(br.right() - wEdit);
                this.$_drawEditorButton(g, br);
            }
            if (wError > 0) {
                br.set(r.x, br.y, r.width, br.height);
                br.rightBy(-wButton - wRight - wEdit);
                br.setLeft(br.right() - wError);
                this.$_drawError(g, br);
            }
        }
    },
    $_leftButtonsWidth: function () {
        return this._expandHandle ? 16 : 0;
    },
    $_rightButtonsWidth: function () {
        var i, btn, renderer, h, pts,
            btns = this._buttons,
            index = this._buttonIdx;
        if (btns) {
            renderer = this._grid.$_customButtonRenderer;
            if (renderer) {
                pts = this._buttonPoints;
                pts[0] = 0;
                h = this.height();
                for (i = 0; i < btns.length; i++) {
                    btn = btns[i];
                    if (this._getButtonVisible(btn._visibility, true)) {
                        if (!btn._displayCallback || btn._displayCallback(index)) {
                            pts[i + 1] = pts[i] + renderer.measure(index, 0, h).width;
                        } else {
                            pts[i + 1] = pts[i];
                        }
                    } else {
                        pts[i + 1] = pts[i];
                    }
                }
                return pts[btns.length];
            }
        }
        return 0;
    },
    $_getButton: function (column) {
        var b = this._cellStyles && this._cellStyles.button() || column.button();
        return b;
    },
    _getButtonVisible: function (visibility, force) {
        var vis,
            focused = this._focused;// && CellIndex.areEqual(this._grid.$_focusedIndex(), this._index);
        switch (visibility) {
            case ButtonVisibility.ALWAYS:
                return true;
            case ButtonVisibility.HIDDEN:
                return false;
            case ButtonVisibility.CURRENT:
                vis = focused && this._mouseEntered;
                break;
            case ButtonVisibility.VISIBLE:
                vis = focused;
                break;
            case ButtonVisibility.DEFAULT:
            default:
                vis = focused || this._mouseEntered;
                break;
        }
        vis = vis && (force && this._grid.editOptions().forceButtonVisible() || this._grid.editController().getEditable(this._buttonIdx));
        if (vis && this._mergeRoom) {
            vis = this._grid.getRow(this._buttonIdx.rowIndex).canEdit();
        }
        return vis;
    },
    $_resetButtonsVisible: function () {
        var col = this._dataColumn;
        if (col) {
            this.setButton(this.$_getButton(col));
            this.setButtonVisibility(col.buttonVisibility());
            this.setEditorButtonVisibility(col.editorButtonVisibility());
            this.setButtons(col.customButtons());
        }
    },
    $_editorButtonWidth: function () {
        var renderer,
            index = this._buttonIdx,
            w = 0,
            column = this._dataColumn;
        if (column) {
            if (this._grid._delegate.hasEditorButton(index)) {
                if (this._getButtonVisible(this._editorButtonVisibility)) {
                    renderer = this._grid._delegate.getCellEditorButtonRenderer(index);
                    if (renderer) {
                        w = renderer.measure(index, 0, this.height()).width;
                    }
                }
            }
        }
        return w;
    },
    $_drawEditorButton: function (g, r) {
        var renderer = this._grid._delegate.getCellEditorButtonRenderer(this._index);
        renderer.render(this._index, g, r, this._editorButtonHovered, this._editorButtonPressed, this._focused);
    },
    $_buttonWidth: function () {
        var renderer,
            index = this._buttonIdx,
            w = 0;
        if (this._button != CellButton.NONE) {
            if (this._getButtonVisible(this._buttonVisibility, true)) {
                if (!index.column._buttonDisplayCallback || index.column._buttonDisplayCallback(index)) {
                    renderer = this._grid.$_buttonRenderer;
                    if (renderer) {
                        w = renderer.measure(index, 0, this.height()).width;
                    }
                }
            }
        }
        return w;
    },
    getButtonWidth: function () {
        var w = this._buttonWidth + this._rButtonsWidth + this._editWidth + this._errorWidth;
        return isNaN(w) ? 0 : Math.max(w, 0);
    },
    $_drawButton: function (g, r) {
        var idx = this._buttonIdx,
            renderer = this._grid.$_buttonRenderer;
        if (renderer) {
            renderer.render(idx, g, r, this._buttonHovered == 0, this._buttonPressed == 0, this._focused);
        }
    },
    $_drawRightButtons: function (g, r) {
        var idx, i, br, pts, w, btns;
        if (this._rButtonsWidth > 0) {
            renderer = this._grid.$_customButtonRenderer;
            if (renderer) {
                btns = this._buttons;
                idx = this._buttonIdx;
                pts = this._buttonPoints;
                br = r.clone();
                for (i = 0; i < btns.length; i++) {
                    w = pts[i + 1] - pts[i];
                    if (w > 0) {
                        br.x = r.x + pts[i];
                        br.width = w;
                        renderer.setButton(btns[i]);
                        renderer.render(idx, g, br, this._buttonHovered == i + 1, this._buttonPressed == i + 1, this._focused);
                    }
                }
            }
        }
    },
    $_errorWidth: function () {
        if (this._error) {
            var icon = DataCellElement.getErrorIcon(this._grid, this._errorLevel);
            return icon ? icon.width + 4 : 0;
        }
        return 0;
    },
    $_drawError: function (g, r) {
        var w, h, x, y,
            img = DataCellElement.getErrorIcon(this._grid, this._errorLevel);
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            x = _int(r.x + (r.width - w) / 2);
            y = _int(r.y + (r.height - h) / 2);
            g.drawImageI(img, x, y, w, h);
        }
    }
}, null, function (f) {
    var icons = {};
    f.getErrorIcon = function (grid, level) {
        var icon = icons[level];
        if (!icon) {
            icon = grid.getAssetImage("error_" + level);
            if (icon) {
                icons[level] = icon;
            }
        }
        return icon;
    };
});
var CalcedCellElement = defineClass("CalcedCellElement", RenderableValueCellElement, {
    init: function (dom, name) {
        this._super(dom, "calcedCellView");
    },
    text: null,
    isDataCell: function () {
        return true;
    },
    canEditable: function () {
        return true;
    },
    _doPrepareValue: function (model) {
        this._super(model);
    },
    _doRenderCell: function (g, r) {
        if (this._renderer) {
            if (g) {
                this._renderer.render(this, g, r);
            } else {
                this._renderer.renderHtml(this, r);
            }
        }
    }
});
var DataGroupCellElement = defineClass("DataGroupCellElement", GroupCellElement, {
    init: function (dom) {
        this._super(dom, "dataGroupCellView");
    },
    selectedBackground: SolidBrush.WHITE,
    deleted: false,
    layoutTreeContent: function (lm) {
        this._layoutTreeCells(lm);
    },
    clearAnimations: function () {
        var i, column, view,
            group = this.group(),
            cnt = group.visibleCount();
        for (i = 0; i < cnt; i++) {
            column = group.getVisibleItem(i);
            view = this._getCell(column);
            if (view instanceof DataGroupCellElement) {
                view.clearAnimations();
            } else if (view instanceof DataCellElement) {
                view.clearAnimation();
            }
        }
    },
    _needRender: function () {
        return this.$_needRender;
    },
    _prepareCells: function () {
        this.$_createCells(this.group(), true);
    },
    _doPrepareElement: function (model) {
        this._super(model);
        var s = model.styles();
        this.setSelectedBackground(s.selectedBackground());
    },
    layoutColumnRects: function (lm) {
        var i, w, h, column, view, x, y,
            group = this.group(),
            width = group._layoutRect.width,// this._width,
            height = this._height,// - (this._rowView ? this._rowView.$_wBottom : 0),
            cnt = group.visibleCount();
        if (group.vertical()) {
            y = 0;
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                view = this._getCell(column);
                h = column.measuredHeight(); // int 이어야 한다.
                column._layoutRect.set(0, y, width, h);
                y += h;
                if (view instanceof DataGroupCellElement) {
                    view.layoutColumnRects(lm);
                }
            }
        } else {
            x = 0;
            h = height;
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                view = this._getCell(column);
                if (i == cnt - 1) {
                    w = width - x;
                } else {
                    w = column.displayWidth(); // int 이어야 한다.
                }
                column._layoutRect.set(x, 0, w, h);
                x += w;
                if (view instanceof DataGroupCellElement) {
                    view.layoutColumnRects(lm);
                }
            }
        }
    },
    _layoutCells: function (lm) {
        var i, j, w, h, column, span, view, x, y, n, col, cv,
            width = this._width,
            height = this._height,// - (this._rowView ? this._rowView.$_wBottom : 0),
            group = this.group(),
            cnt = group.visibleCount();
        this.$_needRender = cnt == 0;
        if (group.vertical()) {
            y = 0;
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                span = 1;//view._cellSpan;
                if (span > 1) {
                    n = 0;
                    h = column.measuredHeight();
                    for (j = i + 1; j < i + span && j < cnt; j++) {
                        col = group.getVisibleItem(j);
                        cv = this._getCell(col);
                        cv.setVisible(false);
                        h += col.measuredHeight();
                        n++;
                    }
                    i += n;
                    span = n + 1;
                } else {
                    h = column.measuredHeight(); // int 이어야 한다.
                    span = 1;
                }
                view = this._getCell(column);
                if (view) {
                    view._colspan = span;
                    view._fixed = this._fixed;
                    view._rowView = this._rowView;
                    if (i == cnt - 1) {
                        view._rowBottom = this._rowBottom;
                        h = Math.max(0, height - y);
                    } else {
                        view._rowBottom = 0;
                    }
                    view.setBounds(0, y, width, h);
                    if (view instanceof DataGroupCellElement) {
                        view._layoutCells(lm);
                    } else {
                        view.layoutContent(lm);
                    }
                }
                y += h;
            }
        } else {
            x = 0;
            h = height;
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                span = 1;//view._cellSpan;
                if (span > 1) {
                    n = 0;
                    var x2 = x;
                    if (i == cnt - 1) {
                        w = width - x;
                    } else {
                        w = column.displayWidth();
                    }
                    x2 += w;
                    for (j = i + 1; j < i + span && j < cnt; j++) {
                        col = group.getVisibleItem(j);
                        cv = this._getCell(col);
                        cv.setVisible(false);
                        if (j == cnt - 1) {
                            w += width - x2;
                        } else {
                            w += col.displayWidth();
                        }
                        x2 += w;
                        n++;
                    }
                    i += n;
                    span = n + 1;
                } else {
                    if (i == cnt - 1) {
                        w = Math.max(0, width - x);
                    } else {
                        w = column.displayWidth(); // int 이어야 한다.
                    }
                    span = 1;
                }
                view = this._getCell(column);
                if (view) {
                    view._colspan = span;
                    view._fixed = this._fixed;
                    view._rowView = this._rowView;
                    view._rowBottom = this._rowBottom;
                    view.setBounds(x, 0, w, h);
                    if (view instanceof DataGroupCellElement) {
                        view._layoutCells(lm);
                    } else {
                        view.layoutContent(lm);
                    }
                }
                x += w;
            }
        }
    },
    _layoutTreeCells: function (lm) {
        var i, w, h, column, view, x, y,
            width = this._width,
            height = this._height,
            group = this.group(),
            cnt = group.visibleCount();
        if (group.vertical()) {
            y = 0;
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                h = column.measuredHeight();
                view = this._getCell(column);
                if (view) {
                    view._colspan = 1;
                    view._fixed = this._fixed;
                    view._rowView = this._rowView;
                    if (i == cnt - 1) {
                        view._rowBottom = this._rowBottom;
                        h = Math.max(0, height - y);
                    } else {
                        view._rowBottom = 0;
                    }
                    view.setBounds(0, y, width, h);
                    if (view instanceof DataGroupCellElement) {
                        view._layoutTreeCells(lm);
                    } else {
                        view.layoutTreeContent(lm);
                    }
                }
                y += h;
            }
        } else {
            x = 0;
            h = height;
            for (i = cnt - 1; i >= 0; i--) {
                column = group.getVisibleItem(i);
                if (i == 0) {
                    w = Math.max(0, width - x);
                } else {
                    w = Math.min(width, column.displayWidth());
                }
                x += w;
                view = this._getCell(column);
                if (view) {
                    view._colspan = 1;
                    view._fixed = this._fixed;
                    view._rowView = this._rowView;
                    view._rowBottom = this._rowBottom;
                    view.setBounds(width - x, 0, w, h);
                    if (view instanceof DataGroupCellElement) {
                        view._layoutTreeCells(lm);
                    } else {
                        view.layoutTreeContent(lm);
                    }
                }
            }
        }
    },
    _doDraw: function (g, needOpaque) {
        var r, fill;
        if (this._needRender()) {
            r = this._drawRect;
            r.height -= this._rowBottom;
            needOpaque && this._rowView.$_requestFill(this, g, r);
            fill = this._selected ? this._selectedBackground : this._background;
            fill && g.drawRect(fill, null, r);
            GridElement.drawBorders(this, g, r);
        }
    },
    _doRenderHtml: function (rc) {
        if (this._needRender()) {
            var fill = this._selected ? this._selectedBackground : this._background;
            _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
            GridElement.drawHtmlBorders(this);
        }
    },
    $_createCells: function (group, checkMerge) {
        var i, cnt, column, view, model, idx, room, r,
            grid = this.grid(),
            body = grid.body(),
            rowIndex = this.index().rowIndex;
        this.hideAll();
        for (i = 0, cnt = group.visibleCount(); i < cnt; i++) {
            column = group.getVisibleItem(i);
            if (this.$_needScr) {
                r = column._layoutRect;
                if (r.x + this.$_scrX > this.$_scrRight) {
                    break;
                }
                if (r.right() + this.$_scrX < this.$_scrLeft) {
                    continue;
                }
            }
            if (checkMerge && column.canMerge()) {
                room = grid.lm().getMergedCell(idx = CellIndex.borrow(rowIndex, column));
                CellIndex.return(idx);
                if (room) {
                    continue;
                }
            }
            view = this._getCell(column);
            if (!view) {
                if (column instanceof DataColumn) {
                    view = new DataCellElement(this._dom);
                } else if (column instanceof SeriesColumn) {
                    if (column instanceof ChartColumn) {
                        view = new ChartCellElement(this._dom);
                    } else {
                        view = new SeriesCellElement(this._dom);
                    }
                } else if (column instanceof LabelColumn) {
                    view = new LabelCellElement(this._dom);
                } else if (column instanceof CalculatedColumn) {
                    view = new CalcedCellElement(this._dom);
                } else { //if (column is ColumnGroup)
                    view = new DataGroupCellElement(this._dom);
                }
                this.$_setCell(column, view);
                this.addElement(view);
            }
            view.setVisible(true);
            model = body.getCell(CellIndex.temp(rowIndex, column));
            view.setDeleted(this._deleted);
            view.updateCell(model);
            view.setMouseEntered(false);
            if (view instanceof DataCellElement) {
                view.setFocused(false);
            }
            if (column instanceof ValueColumn) {
            } else if (column instanceof ColumnGroup) {
            }
            if (column instanceof ColumnGroup) {
                if (view.$_needScr = this.$_needScr) {
                    view.$_scrLeft = this.$_scrLeft;
                    view.$_scrRight = this.$_scrRight;
                    view.$_scrX = this.$_scrX + r.x;
                }
                view.$_createCells(column);
            }
        }
    },
});
var LabelCellElement = defineClass("LabelCellElement", ValueCellElement, {
    init: function (dom, name) {
        this._super(dom, "labelCellView");
    },
    text: null,
    isDataCell: function () {
        return true;
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.setText(model.displayText());
    },
    _doDraw: function (g, needOpaque) {
        var r, fill,
            rc = this._drawRect,
            selected = this._selected;
        rc.height -= this._rowBottom;
        needOpaque && this._rowView.$_requestFill(this, g, rc);
        r = this._getRenderRect(rc);
        fill = selected ? this._selectedBackground : this._background;
        fill && g.drawRectI(fill, null, r);
        this._textColor = selected ? (this._selectedColor || this._color) : this._color;
        this._doRenderCell(g, r);
        GridElement.drawBorders(this, g, rc);
    },
    _doRenderHtml: function (rc) {
        var fill, r,
            selected = this._selected;
        fill = selected ? this._selectedBackground : this._background;
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        r = this._getRenderRect(rc);
        this._textColor = selected ? (this._selectedColor || this._color) : this._color;
        this._doRenderCell(null, r);
        GridElement.drawHtmlBorders(this);
    },
    _doRenderCell: function (g, r) {
        var s = this._text;
        if (s) {
            this.deflatePadding2(r);
            this._renderText(g, s, this._textColor, r);
        }
    }
});
var SeriesCellElement = defineClass("SeriesCellElement", DataCellElement, {
    init: function (dom, name) {
        this._super(dom, name || "seriesCellView");
        this._values = null;
    },
    labels: null,
    setLabels: function (value) {
        if (value != this._labels) {
            this._labels = value;
            this.invalidate();
        }
    },
    fieldCount: function () {
        return this._fieldCount;
    },
    isDataCell: function () {
        return true;
    },
    _doPrepareValue: function (model) {
        this._super(model);
        this.setLabels(model.labels());
        this._fieldCount = this._labels.length;
    },
    value: function () {
        return this._values;
    },
    setValue: function (value) {
        if (!equalArrays(value, this._values)) {
            this._values = value;
            this.invalidate();
        }
    }
});
var ChartCellElement = defineClass("ChartCellElement", SeriesCellElement, {
    init: function (dom, name) {
        this._super(dom, name);
    },
    _doUpdateContent: function (model) {
        this._super(model);
        var chart = model.chart();
        if (chart) {
            if (!this._chartView) {
                this._chartView = new GridChartView(this._dom, this.container());
                this.addChild(this._chartView);
            }
            chart.setItemSource(model);
            this._chartView.setModel(chart);
        } else if (this._chartView) {
            this.removeChild(this._chartView);
            this._chartView = null;
        }
    },
    _doLayoutContent: function (lm) {
        this._super(lm);
        if (this._chartView) {
            var r = this._getRenderRect();
            this.deflatePadding2(r);
            this._chartView.setRectI(r);
            this._chartView.layoutContent(lm);
        }
    },
    _doRenderCell: function (g, r) {
    },
    /*,
    invalidate: function (force, invalidateChildren) {
        this._super(force, true);
    }*/
});
var FooterHeadElement = defineClass("FooterHeadElement", CellElement, {
    init: function (dom) {
        this._super(dom, "footerHeadView");
        if (dom) {
            this.addElement(this._backView = new GraphicElement().setVisible(false));
        }
        this.addElement(this._menuView = new CellMenuElement(dom, this));
        this._menuView.setVisible(false);
    },
    renderer: null,
    text: null,
    menuVisible: false,
    _doUpdateContent: function (model) {
        this._super(model);
        this.setMenuVisible(model.menuVisible());
        this.setText(model.displayText());
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
    },
    _doLayoutHandles: function () {
    },
    $_renderMenuText: function (g, r) {
        var sz,
            mv = this._menuView,
            s = this.text(),
            w = s ? (g ? g.getTextWidth(this._font, s) : this.container().measureText(this._font, s)) : 0,
            tr = r.clone();
        this.inflatePadding(tr);
        if (this._menuVisible) {
            mv.setVisible(true);
            sz = mv.measure(this._grid);
            w = Math.max(tr.x, (tr.width - sz.width - w) / 2);
            mv.setBoundsI(w, tr.y + (this.height() - sz.height + 1) / 2, sz.width, sz.height);
            mv.setBackground(this._background);
            mv.setColor(this._shapeColor);
            mv.setHoveredColor(this._shapeHoveredColor);
        } else {
            mv.setVisible(false);
        }
        if (s) {
            fill = this.color();
            if (fill) {
                if (mv.visible()) {
                    tr.leftBy(mv.right());
                }
                this._renderText(g, s, fill, tr);
            }
        }
    },
    _doRender: function (g, r) {
        if (this._renderer) {
            this._renderer.render(this, g, r);
        } else {
            var fill = this.background();
            fill && g.drawRect(fill, null, r);
        }
        this.$_renderMenuText(g, r);
        GridElement.drawBorders(this, g, r);
    },
    _doRenderHtml: function (r) {
        if (this._renderer) {
            this._backView.setVisible(true);
            this._renderer.renderHtml(this._backView, r);
        } else {
            var fill = this.background();
            this._css.background = fill ? fill.css() : "";
        }
        this.$_renderMenuText(null, r);
        GridElement.drawHtmlBorders(this);
    }
});
/** @abstract */
var RowElement = defineClass("RowElement", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._item = null;
	},
	item: function () { return this._item; },
	row: function () { return this._item; },
    rowIndex: function () { return this._item.index(); },
	updateElement: function (item, styles) {
		this._item = item;
		this._doUpdateElement(styles);
	},
	propertyChanged: function (prop, value) {
		this.invalidate();
	},
	_doLayoutContent: function (lm) {
		this._doLayoutHandles();
	},
	_doRender: function (g, r) {
	},
    _doRenderHtml: function (r) {
    },
	_doUpdateElement: function (styles) {
	},
    _doLayoutHandles: function () {
    },
	$_clearSelections: function () {
	},
	$_setSelections: function (selItems) {
	}
}, {
});
var DataRowElement = defineClass("DataRowElement", RowElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._cells = {};
        this._displayIndex = -1;
	},
	fixed: false,
    background: null,
    borderBottom: null,
	/** @deprecated use getCell instead */
	findCell: function (column) {
		return this.getCell(column);
	},
	getCell: function (column) {
		if (column) {
			var root = column.root();
			var view = this._cells[root.$_hash];
			if (view && view.visible()) {
				if (root != column) {
					view = view.findCell(column);
				}
				return view;
			}
		}
		return null;
	},
    getLeftCell: function (column) {
    },
	_doUpdateElement: function (styles) {
		this.setBackground(styles.background());
		this.setBorderBottom(styles.borderBottom());
		this.$_wBottom = this._borderBottom ? this._borderBottom.width() : 0;
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return { width: hintWidth, height: hintHeight };
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
        if (this._displayIndex == 0) {
            this._layoutColumnRects(lm);
        }
		this._layoutCells(lm);
	},
	_doRender: function (g, r) {
		this._background && g.drawRectI(this._background, null, r);
		var stroke = this._borderBottom;
		if (stroke) {
			g.drawHLineI(this._borderBottom, r.bottom() - _floor((stroke.width() + 1) / 2), r.x, r.right());
		}
	},
	_doRenderHtml: function (r) {
        var fill = this._background;
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        var stroke = this._borderBottom;
        this._css.borderBottom = stroke ? stroke.css() : "";
	},
	_getCellView: function (column) {
		return this._cells[column.$_hash];
	},
	_getFirstCell: function (lm) {
		var start = this.fixed() ? 0 : lm.firstCol();
		return this._cells[lm.getColumn(start).$_hash];
	},
	_clearChildren: function () {
		this.clear();
		this._cells = {};
	},
    _createCell: function (column) {
        if (column instanceof ColumnGroup) {
            return new DataGroupCellElement(this._dom);
        } else if (column instanceof SeriesColumn) {
            if (column instanceof ChartColumn) {
                return new ChartCellElement(this._dom)
            } else {
                return new SeriesCellElement(this._dom);
            }
        } else if (column instanceof LabelColumn) {
            return new LabelCellElement(this._dom);
        } else if (column instanceof CalculatedColumn) {
            return new CalcedCellElement(this._dom);
        } else {
            return new DataCellElement(this._dom);
        }
    },
	_prepareCells: function (lm) {
		var i, cnt, column, index, cellView, room, start, end, cell, expander, group,
			grid = this.grid(),
			body = grid.body(),
			rowGroup = grid.rowGroup(),
			fixedCols = lm.fixedColCount(),
			horzScrolling = grid.isHorzScrolling(),
			merged = lm.columnMerged(),
			mergeExpander = rowGroup.expanderVisible(),
			adorned = rowGroup.expandedAdornments() == RowGroupAdornments.BOTH,
			deleted = DataRowState.isDeleted(this._item.dataState());
		if (grid.columnLayoutChanged()) {
			this._clearChildren();
			this._cells = {};
		}
		if (horzScrolling) {
			for (var c in  this._cells) {
				this._cells[c]._recycling = false;
			}
			start = this._fixed ? 0 : lm.prevFirst();
			end = this._fixed ? fixedCols - 1 : lm.prevLast();
			for (i = start; i < end; i++) {
				column = lm.getColumn(i);
				cellView = this._cells[column.$_hash];
				if (cellView) {
					cellView._recycling = true;
				}
			}
		}
		this.hideAll();
		start = this._fixed ? 0 : lm.firstCol();
		end = this._fixed ? fixedCols - 1 : lm.lastCol();
		if (!this._fixed && lm.lastCol() != lm.lastCol2() && grid.vscrollBar().barIndent() != "none") {
			end = lm.lastCol2();
		}
		this._endCol = end;
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
			index = CellIndex.temp(this._item.index(), column);
			room = lm.getMergedCell(index);
			if (room) {
				continue;
			}
			cell = body.getCell(index);
			cellView = this._cells[column.$_hash];
			if (!cellView) {
				this._cells[column.$_hash] = cellView = this._createCell(column);
				this.addElement(cellView);
			}
			cellView.setVisible(true);
			cellView._rowView = this;
			cellView._rowBottom = this.$_wBottom;
			if (cellView instanceof DataCellElement) {
				expander = false;
				if (merged && mergeExpander) {
					if (column instanceof DataColumn && column.mergeGrouped()) {
						group = this._item.parent();
						cnt = group.count() - (adorned ? 0 : 1);
						expander = cnt > 1 && group.firstLeaf() == this._item;
					}
				}
				cellView.setExpanderVisible(expander);
			}
			if (!horzScrolling || cellView._recycling) {
				cellView.setDeleted(deleted);
				cellView.updateCell(cell);
			}
			cellView.setMouseEntered(false);
			if (cellView instanceof ValueCellElement) {
				cellView.setFocused(false);
			} else {
			}
		}
	},
    _layoutColumnRects: function (lm) {
        var i, cellView, r,
            grid = this.grid(),
            root = grid._rootColumn,
            horzScrolling = grid.isHorzScrolling(),
            fixedCols = lm.fixedColCount(),
            start = this._fixed ? 0 : lm.firstCol(),
            end = this._endCol;// this._fixed ? fixedCols - 1 : lm.lastCol();
        for (i = start; i <= end; i++) {
            cellView = this._cells[lm.getColumn(i).$_hash];
            if (cellView && cellView.visible()) {
                r = lm.getColumnBounds(i);
                r.height = this.height();
                cellView.index().column._layoutRect.copy(r);
                if (cellView instanceof GroupCellElement && (!horzScrolling || !cellView._recycling)) {
                    cellView.layoutColumnRects(lm);
                }
            }
        }
    },
	_layoutCells: function (lm) {
        var r, cellView, span, n, j, cv, r2,
		    grid = this.grid(),
		    root = grid._rootColumn,
		    horzScrolling = grid.isHorzScrolling(),
		    fixedCols = lm.fixedColCount(),
		    start = this._fixed ? 0 : lm.firstCol(),
		    end = this._endCol,//this._fixed ? fixedCols - 1 : lm.lastCol(),
            i = start;
        while (i <= end) {
            cellView = this._cells[lm.getColumn(i).$_hash];
            if (cellView && cellView.visible()) {
                span = 1;//cellView._cellSpan;
                if (span > 1) {
                    n = 1;
                    for (j = i + 1; j < i + span && j <= end; j++) {
                        cv = this._cells[lm.getColumn(j).$_hash];
                        cv && cv.setVisible(false);
                        n++;
                    }
                    span = n;
                    r = lm.getColumnBounds(i);
                    r2 = lm.getColumnBounds(i + span - 1);
                    r.setRight(r2.right());
                } else {
                    r = lm.getColumnBounds(i);
                    span = 1;
                }
                r.height = this.height();
                cellView._colspan = span;
                cellView._fixed = this._fixed;
                cellView.$_anirate = 1;
                cellView.setRect(r);
                if (!horzScrolling || !cellView._recycling) {
                    if (cellView instanceof DataGroupCellElement) {
                        if (!this._fixed && (i == start || i == end)) {
                            cellView.$_needScr = true;
                            cellView.$_scrLeft = lm._leftPos;
                            cellView.$_scrRight = cellView.$_scrLeft + lm._nonfixedBounds.width;
                            cellView.$_scrX = r.x;
                        } else {
                            cellView.$_needScr = false;
                        }
                    }
                    cellView.layoutContent(lm);
                }
                i += span;
            } else {
                i++;
            }
        }
	},
	$_requestFill: function (cell, g, r) {
		this._parent.$_requestFill(cell, g, r);
		var fill = this._background;
		var stroke = this._borderBottom;
		if (fill || stroke) {
			r = this.clientRectByChild(cell, this._drawRect);
			fill && g.drawRectI(fill, null, r);
			stroke && g.drawHLineI(this._borderBottom, r.bottom() - _floor((stroke.width() + 1) / 2), r.x, r.right());
		}
	},
	$_clearSelections: function () {
		var h, view,
			cells = this._cells;
		for (h in cells) {
			view = cells[h];
			view.$_setSelected(false);
            if (view instanceof GroupCellElement) {
                view.$_clearSelections();
            }
		}
	},
	$_setSelections: function (selItems, single) {
		var h, view, selected, i,
			len = selItems.length,
			cells = this._cells;
		for (h in cells) {
			view = cells[h];
			selected = false;
			for (i = len; i--;) {
				if (selItems[i].contains(view._index)) {
					selected = true;
					break;
				}
			}
            view.$_setSelected(selected);
            if (view instanceof GroupCellElement) {
                view.$_setSelections(selItems, single);
            }
		}
	}
});
var RowGroupLevel = defineClass("RowGroupLevel", null, {
    init : function(owner, config) {
        this._super();
        this._headerStyles = new GridStyles(this, "rowGroupLevelHeaderStyles");
        this._expanderStyles = new GridStyles(this, "rowGroupLevelExpanderStyles");
        this._footerStyles = new GridStyles(this, "rowGroupLevelFooterStyles");
        config && this.assign(config);
        this._owner = owner;
        if (owner) {
            this._headerStyles.setParent(owner.headerStyles(), false);
            this._expanderStyles.setParent(owner.expanderStyles(), false);
            this._footerStyles.setParent(owner.footerStyles(), false);
        }
    },
    stylesChanged: function (/*stypeProp*/) {
        this._changed();
    },
    /*
     minHeight: 0,
     setMinHeight: function (value) {
     if (value != this._minHeight) {
     this._minHeight = value;
     }
     },
     level: function () {
     return this._level;
     },
     column: function () {
     return this._column;
     },
     */
    expanderVisible: undefined,
    headerHeight: undefined,
    footerHeight: undefined,
    headerStatement: undefined,
    headerStyles: null,
    expanderStyles: null,
    footerStyles: null,
    setExpanderVisible: function (value) {
        if (value !== this._expanderVisible) {
            this._expanderVisible = value;
            this._changed();
        }
        return this;
    },
    setHeaderHeight: function (value) {
        if (value !== this._headerHeight) {
            this._headerHeight = value;
            this._changed();
        }
        return this;
    },
    setFooterHeight: function (value) {
        if (value !== this._footerHeight) {
            this._footerHeight = value;
            this._changed();
        }
        return this;
    },
    setHeaderStatement: function (value) {
        if (value !== this._headerStatement) {
            this._headerStatement = value;
            if (value && !this._headerExp) {
                this._headerExpr = new ExpressionStatement();
            }
            this._headerExpr.setSource(value);
            this._changed();
        }
        return this;
    },
    setHeaderStyles: function (value) {
        if (value !== this._headerStyles) {
            this._headerStyles.extend(value);
            this._changed();
        }
        return this;
    },
    setExpanderStyles: function (value) {
        if (value !== this._expanderStyles) {
            this._expanderStyles.extend(value);
            this._changed();
        }
        return this;
    },
    setFooterStyles: function (value) {
        if (value !== this._footerStyles) {
            this._footerStyles.extend(value);
            this._changed();
        }
        return this;
    },
    getExpanderVisible: function () {
        return (this._expanderVisible === undefined && this._owner) ? this._owner._expanderVisible : this._expanderVisible;
    },
    getHeaderHeight: function () {
        return (this._headerHeight === undefined && this._owner) ? this._owner._headerHeight : this._headerHeight;
    },
    getFooterHeight: function () {
        return (this._footerHeight === undefined && this._owner) ? this._owner._footerHeight : this._footerHeight;
    },
    getHeaderText: function (group) {
        var owner = this._owner;
        if (owner) {
            if (this._headerExpr) {
                owner._headerRuntime.setGrid(owner._grid);
                owner._headerRuntime.setGroup(group);
                return this._headerExpr.evaluate(owner._headerRuntime);
            }
        }
    },
    _changed: function () {
        this._owner && this._owner.levelChanged(this);
    }
});
var RowGroup = defineClass("RowGroup", GridObject, {
    init : function(grid) {
        this._super(grid);
        this._levels = [];	// RowGroupLevel
        this._headerItems = new CustomGroupItemCollection(grid, CustomGroupItemType.HEADER);
        this._footerItems = new CustomGroupItemCollection(grid, CustomGroupItemType.FOOTER);
        this._headStyles = new GridStyles(this, "rowGroupHead");
        this._headerStyles = new GridStyles(this, "rowGroupHeader");
        this._expanderStyles = new GridStyles(this, "rowGroupExpander");
        this._footerStyles = new GridStyles(this, "rowGroupFooter");
        this._indentStyles = new GridStyles(this, "rowGroupIndent");
        this._panelStyles = new GridStyles(this, "rowGroupPanel");
        this._barStyles = new GridStyles(this, "rowGroupBar");
        this._headerBarStyles = new GridStyles(this, "rowGroupHeaderBar");
        this._footerBarStyles = new GridStyles(this, "rowGroupFooterBar");
        this._headerCell = new RowGroupHeaderCell(grid, this);
        this._expanderCell = new RowGroupExpanderCell(grid);
        this._footerCell = new RowGroupFooterCell(grid);
        this._indentCell = new RowGroupIndentCell(grid);
        this._barCell = new RowGroupBarCell(grid);
        this._itemBarCell = new RowGroupItemBarCell(grid);
        this._headCell = new RowGroupHeadCell(grid);
        this._footerRuntime = new FooterExpressionRuntime();
        this._runStyles = new GridStyles(this, "rowGroupRuntimeStyles", null, false);
        this._headerExpr = new ExpressionStatement(this._headerStatement);
        this._headerRuntime = new RowGroupStatementRuntime();
    },
    stylesChanged: function (/*stypeProp*/) {
        this._changed();
    },
    levelChanged: function (level) {
        this._changed();
    },
    levels: null,
    headerItems: null,
    footerItems: null,
    headerStyles: null,
    expanderStyles: null,
    footerStyles: null,
    indentStyles: null,
    panelStyles: null,
    barStyles: null,
    headerBarStyles: null,
    footerBarStyles: null,
    headStyles: null,
    headerStatement: "${groupField}: ${groupValue} - ${rowCount} rows",
    headerTextCallback: null, // function (group:GroupRow):String;
    levelIndent: 20,
    minHeaderIndent: 8,
    headerHeight: 0,
    minHeaderHeight: 10,
    footerHeight: 0,
    minFooterHeight: 10,
    displayMode: EnumProp(RowGroupDisplayMode, RowGroupDisplayMode.BANDED),
    expanderVisible: true,
    createFooterCallback: null, // function (group:GroupRow):Boolean;
    expandedAdornments: EnumProp(RowGroupAdornments, RowGroupAdornments.BOTH),
    collapsedAdornments: EnumProp(RowGroupAdornments, RowGroupAdornments.HEADER),
    summaryHeader: false,
    inheritsLevel: true,
    /** @deprecated Use EditOptions.mergedWhenUpdating instead. */
    mergedWhenUpdating: false,
    summaryMode: EnumProp(SummaryMode, SummaryMode.AGGREGATE),
    setMinHeaderIndent: function (value) {
        value = parseInt(value);
        if (!isNaN(value)) {
            value = Math.max(0, value);
            if (value != this._minHeaderIndent) {
                this._minHeaderIndent = value;
                this._changed();
            }
        }
        return this;
    },
    setLevelIndent: function (value) {
        value = parseInt(value);
        if (!isNaN(value)) {
            value = Math.max(0, value);
            if (value != this._levelIndent) {
                this._levelIndent = value;
                this._changed();
            }
        }
        return this;
    },
    levelCount: function () {
        return this._levels.length;
    },
    levels_: function () {
        return this._levels.concat();
    },
    setLevels: function (value) {
        if (value !== this._levels) {
            var i, v;
            this._levels = [];
            if (value && value.length > 0) {
                for (i = 0; i < value.length; i++) {
                    v = value[i];
                    if (v instanceof RowGroupLevel) {
                        this._levels.push(v);
                    } else if (_isObject(v)) {
                        v = new RowGroupLevel(this, v);
                        this._levels.push(v);
                    } else {
                        this._levels.push(null);
                    }
                }
            }
            this._changed();
        }
        return this;
    },
    setHeaderItems: function (value) {
        if (value !== this._headerItems) {
            this._headerItems.assign(value);
            this._changed();
        }
        return this;
    },
    setFooterItems: function (value) {
        if (value !== this._footerItems) {
            this._footerItems.assign(value);
            this._changed();
        }
        return this;
    },
    setHeaderStyles: function (value) {
        if (value !== this._headerStyles) {
            this._headerStyles.extend(value);
        }
        return this;
    },
    setExpanderStyles: function (value) {
        if (value != this._expanderStyles) {
            this._expanderStyles.extend(value);
        }
        return this;
    },
    setFooterStyles: function (value) {
        if (value != this._footerStyles) {
            this._footerStyles.extend(value);
        }
        return this;
    },
    setIndentStyles: function (value) {
        if (value != this._indentStyles) {
            this._indentStyles.extend(value);
        }
        return this;
    },
    setHeadStyles: function (value) {
        if (value !== this._headStyles) {
            this._headStyles.extend(value);
        }
        return this;
    },
    setHeaderStatement: function (value) {
        if (value != this._headerStatement) {
            this._headerStatement = value;
            this._headerExpr.setSource(value);
            this._changed();
        }
        return this;
    },
    setHeaderTextCallback: function (value) {
        if (!_isFunction(value)) value = null;
        if (value != this._headerTextCallback) {
            this._headerTextCallback = value;
            this._changed();
        }
        return this;
    },
    setDisplayMode: function (value) {
        if (value != this._displayMode) {
            this._displayMode = value;
            if (this.owner()) {
                this.owner().$_rowGroupDisplayModeChanged();
            }
        }
        return this;
    },
    setExpanderVisible: function (value) {
        if (value != this._expanderVisible) {
            this._expanderVisible = value;
            this._changed();
        }
        return this;
    },
    setCreateFooterCallback: function (value) {
        if (!_isFunction(value)) value = null;
        if (value != this._createFooterCallback) {
            this._createFooterCallback = value;
            var grid = this.owner();
            grid && grid.$_rowGroupAdornmentsChanged();
        }
        return this;
    },
    setExpandedAdornments: function (value) {
        if (value != this._expandedAdornments) {
            this._expandedAdornments = value;
            var grid = this.owner();
            grid && grid.$_rowGroupAdornmentsChanged();
        }
        return this;
    },
    setCollapsedAdornments: function (value) {
        if (value != this._collapsedAdornments) {
            this._collapsedAdornments = value;
            var grid = this.owner();
            grid && grid.$_rowGroupAdornmentsChanged();
        }
        return this;
    },
    setSummaryHeader: function (value) {
        if (value != this._summaryHeader) {
            this._summaryHeader = value;
            var grid = this.owner();
            grid && grid.$_rowGroupAdornmentsChanged();
        }
        return this;
    },
    setSummaryMode: function (value) {
        if (value != this._summaryMode) {
            this._summaryMode = value;
            var grid = this.owner();
            grid && grid.$_groupSummaryModeChanged();
        }
        return this;
    },
    mergedWhenUpdating_: function () {
        var grid = this.owner();
        return grid && grid._editOptions.mergedWhenUpdating();
    },
    setMergedWhenUpdating: function (value) {
        var grid = this.owner();
        grid && grid._editOptions.setMergedWhenUpdating(value);
    },
    /** @deprecated use mergeMode() instead. */
    isMergeMode: function () {
        return this._displayMode == RowGroupDisplayMode.MERGED;
    },
    mergeMode: function () {
        return this._displayMode == RowGroupDisplayMode.MERGED;
    },
    getLevel: function (level)/* RowGroupLevel */ {
        var lev = this._levels[level];
        if (!lev && this._inheritsLevel) {
            for (; level--;) {
                lev = this._levels[level];
                if (lev) break;
            }
        }
        return lev;
    },
    registerGroupHeaderType: function (type, clazz/* CustomGroupItem class */) {
        this._headerItems.registerType(type, clazz);
    },
    registerGroupFooterType: function (type, clazz) {
        this._footerItems.registerType(type, clazz);
    },
    getHeaderCell: function (index) {
        var row = this.owner().getRow(index),
            level = this.getLevel(row.level() - 1);
        this._runStyles.clearValues();
        if (level) {
            this._runStyles.setParent(level._headerStyles, false);
        } else {
            this._runStyles.setParent(this._headerStyles, false);
        }
        this._headerCell.setStyles(this._runStyles);
        this._headerCell.setIndex(CellIndex.temp(index));
        return this._headerCell;
    },
    getExpanderCell: function (index) {
        var row = this.owner().getRow(index),
            level = this.getLevel(row.level() - 1);
        this._runStyles.clearValues();
        if (level) {
            this._runStyles.setParent(level._expanderStyles, false);
        } else {
            this._runStyles.setParent(this._expanderStyles, false);
        }
        this._expanderCell.setStyles(this._runStyles);
        this._expanderCell.setIndex(CellIndex.temp(index));
        return this._expanderCell;
    },
    getFooterCell: function (index) {
        var d,
            row = this.owner().getRow(index.rowIndex),
            group = row.parent(),
            level = this.getLevel(group.level() - 1),
            column = _cast(index.column, ValueColumn);
        this._runStyles.clearValues();
        if (column) {
            this._runStyles.extend(column.groupFooter().styles());
        }
        if (level) {
            this._runStyles.setParent(level.footerStyles(), false);
        } else {
            this._runStyles.setParent(this._footerStyles, false);
        }
        this._footerCell.setIndex(index);
        this._footerCell.calculate();
        if (column) {
            d = column.groupFooter().dynamicStyles();
            if (d && d.count() > 0) {
                this._footerRuntime.setCell(this._footerCell);
                d.applyInternal(this._footerRuntime, this._runStyles);
            }
        }
        this._footerCell.setStyles(this._runStyles);
        return this._footerCell;
    },
    getIndentCell: function () {
        this._runStyles.clearValues();
        this._runStyles.setParent(this._indentStyles, false);
        this._indentCell.setStyles(this._runStyles);
        return this._indentCell;
    },
    getBarCell: function (level) {
        this._barCell.setLevel(level);
        var glevel = this.getLevel(level - 1);
        if (glevel) {
            this._barCell.setStyles(glevel.barStyles());
        } else {
            this._barCell.setStyles(this._barStyles);
        }
        return this._barCell;
    },
    getHeaderBarCell: function (index) {
        this._itemBarCell.setIndex(index);
        var level = this.getLevel(index.getRow(this._grid).level() - 1);
        if (level) {
            this._itemBarCell.setStyles(level.headerBarStyles());
        } else {
            this._itemBarCell.setStyles(this._headerBarStyles);
        }
        return this._itemBarCell;
    },
    getFooterBarCell: function (index) {
        this._itemBarCell.setIndex(index);
        var group = index.getRow(this._grid).parent();
        var level = this.getLevel(group.level() - 1);
        if (level) {
            this._itemBarCell.setStyles(level.footerBarStyles());
        } else {
            this._itemBarCell.setStyles(this._footerBarStyles);
        }
        return this._itemBarCell;
    },
    getHeadCell: function (level) {
        this._headCell._level = level;
        this._headCell.setStyles(this._headStyles);
        return this._headCell;
    },
    getHeaderText: function (group) {
        var lev = this.getLevel(group.level() - 1);
        if (lev) {
            var s = lev.getHeaderText(group);
            if (s !== undefined) return s;
        }
        if (this._headerTextCallback) {
            return this._headerTextCallback(group);
        } else {
            this._headerRuntime.setGrid(this.owner());
            this._headerRuntime.setGroup(group);
            return this._headerExpr.evaluate(this._headerRuntime);
        }
    },
    clearStyles: function (recursive) {
        if (recursive) {
            this._headStyles.clearValues();
            this._headerStyles.clearValues();
            this._expanderStyles.clearValues();
            this._footerStyles.clearValues();
            this._indentStyles.clearValues();
            this._panelStyles.clearValues();
            this._barStyles.clearValues();
            this._headerBarStyles.clearValues();
            this._footerBarStyles.clearValues();
        }
    },
    getPopupMenu: function () {
        var i, j, col, menus,
            grid = this.owner(),
            cols = this.mergeMode() ? grid.getDataRootColumns() : grid.getDataColumns();
        if (cols && cols.length > 0) {
            for (i = cols.length; i--;) {
                for (j = 0; j < i; j++) {
                    if (cols[i].dataIndex() == cols[j].dataIndex()) {
                        cols.splice(i, 1);
                        break;
                    }
                }
            }
            menus = [];
            for (i = 0, cnt = cols.length; i < cnt; i++) {
                col = cols[i];
                menus.push({
                    label: col.header().displayText(),
                    checked: grid.getGroupLevel(col.dataIndex()) > 0,
                    tag: col.dataIndex(),
                    callback: function (data) {
                        if (!data.checked) {
                            grid.addGroupBy(100000, data.tag);
                        } else {
                            grid.removeGroupBy(data.tag);
                        }
                    }
                });
            }
            return new PopupMenu("rowGroup", grid.popupMenuManager(), menus);
        }
        return null;
    }
});
var RowGroupExpandHandle = defineClass("RowGroupExpandHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "rowGroupExpandHandle");
        this.setClickable(true);
	},
	expanded: false,
    color: null,
	fill: null,
	_doDraw: function (g) {
		var r = this.clientRect(),
		    fill = this.fill();
        fill && g.drawRectI(fill, null, r);
        if (this.expanded()) {
			$$_drawDownArrow(g, r, 9, this.color());
		} else {
			$$_drawRightArrow(g, r, 9, this.color());
		}
	},
	_doDrawHtml: function () {
        this._doDraw(this.$_getGraphics(true));
	}
});
var RowGroupExpanderElement = defineClass("RowGroupExpanderElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name || "rowGroupExpanderView");
		this._handle = new RowGroupExpandHandle(dom, this);
		this.addElement(this._handle);
	},
    setIndent: function (value) {
        this._indent = value;
    },
	setHandleVisible: function(visible) {
		this._handle.setVisible(visible);
	},
    getHandleWidth: function () {
        return 15;
    },
	_doUpdateContent: function (cell) {
		this._super(cell);
        if (this._handle.visible()) {
            var row = cell.index().getRow(this._grid),
                styles = cell.styles();
            this._handle.setColor(styles.shapeColor());
            this._handle.setFill(null);
            this._handle.setExpanded(row instanceof GroupRow && row.expanded());
        }
	},
	_doLayoutContent: function (lm) {
        if (this._handle.visible()) {
            this._handle.setBounds(0 + this._indent, 1, this.width() - this._indent, this.height() - 2);
        }
	},
	_doRender: function (g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	},
	_doRenderHtml: function (r) {
		var fill = this.background();
		_norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
		this._drawHtmlBorders();
	}
});
var GroupRowElement = defineClass("GroupRowElement", RowElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
    background: null,
    borderBottom: null,
    _doUpdateElement: function (styles) {
        this.setBackground(styles.background());
        this.setBorderBottom(styles.borderBottom());
        this.$_wBottom = this._borderBottom ? this._borderBottom.width() : 0;
    },
    _doMesasure: function (grid, hintWidth, hintHeight) {
        return { width: hintWidth, height: hintHeight };
    },
    _doLayoutContent: function (lm) {
    },
    _doRender: function (g, r) {
        this._background && g.drawRectI(this._background, null, r);
        var stroke = this._borderBottom;
        if (stroke) {
            g.drawHLineI(this._borderBottom, r.bottom() - _floor((stroke.width() + 1) / 2), r.x, r.right());
        }
    },
    _doRenderHtml: function (r) {
        var fill = this._background;
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        var stroke = this._borderBottom;
        this._css.borderBottom = stroke ? stroke.css() : "";
    }
});
var RowGroupFooterElement = defineClass("RowGroupFooterElement", GroupRowElement, {
    init: function(dom/*, rowGroup*/) {
        this._super(dom, "rowGroupFooterView");
        this._fixed = false;
        this._cells = {};
    },
    fixed: function() {
        return this._fixed;
    },
    setFixed: function (value) {
        this._fixed = value;
    },
    findCell: function (column) {
        if (column) {
            var root = column.root(),
                view = this._cells[root.$_hash];
            if (view && view.visible()) {
                if (root != column) {
                    view = view.findCell(column);
                }
                return view;
            }
        }
        return null;
    },
    _doUpdateElement: function(styles) {
        this._super(styles);
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doLayoutContent: function(lm) {
        var grid = lm.grid();
        if (grid.columnLayoutChanged()) {
            this.clear();
            this._cells = {};
        }
        this._prepareCells(lm, grid);
        this._layoutCells(lm, grid);
    },
    _doRender: function(g, r) {
        if (this._fixed) {
            var x, y,
                grid = this.grid(),
                options = grid.displayOptions(),
                fill = options.fixedColumnBarStyles().background(),
                stroke = options.fixedColumnBarStyles().borderRight();
            r.setLeft(r.right() - grid.body().fixedColBarWidth());
            if (fill) {
                g.drawRectI(fill, null, r);
            }
            if (stroke) {
                x = r.right() - 1;
                y = r.bottom();
                g.drawLineI(stroke, x, r.y(), x, y);
            }
        }
    },
    _doDraw: function (g) {
    },
    _doDrawHtml: function (g) {
    },
    _createCellView: function (rowGroup, rowIndex, column) {
        var index = CellIndex.temp(rowIndex, column),
            model = rowGroup.getFooterCell(index),
            view = this._cells[column.$_hash];
        if (!(view instanceof CellElement)) {
            if (column instanceof ColumnGroup) {
                view = new GroupFooterGroupCellElement(this._dom);
            } else {
                view = new GroupFooterCellElement(this._dom);
            }
            this._cells[column.$_hash] = view;
            this.addElement(view);
        }
        view.setVisible(true);
        view.updateCell(model);
        return view;
    },
    _prepareCells: function (lm, grid) {
        var i, column,
            rowGroup = grid.rowGroup(),
            rowIndex = this._item.index(),
            fixed = lm.fixedColCount(),
            start = this._fixed ? 0 : lm.firstCol(),
            end = this._fixed ? fixed - 1 : lm.lastCol();
        this.hideAll();
        for (i = start; i <= end; i++) {
            column = lm.getColumn(i);
            this._createCellView(rowGroup, rowIndex, column);
        }
    },
    _layoutCells: function (lm, grid) {
        var i, col, column, view, cv, r,
            rowGroup = grid.rowGroup(),
            rowIndex = this._item.index(),
            leftPos = grid.leftPos(),
            height = this.height(),
            cells = this._cells,
            fixed = this._fixed,
            fixedCols = lm.fixedColCount(),
            start = fixed ? 0 : lm.firstCol(),
            end = fixed ? fixedCols - 1 : lm.lastCol(),
            group = lm.getColumn(start),
            spans = (group && (group = group.parent()).$_groupFooterSpanned) ? group.$_groupFooterSpans : null;
        if (spans) {
            i = start;
            while (i <= end) {
                r = lm.columnBounds(i);
                col = lm.getColumn(i);
                column = spans[i++];
                view = this._createCellView(rowGroup, rowIndex, column);
                if (col !== column) {
                    cv = cells[col.$_hash];
                    cv && cv.setVisible(false);
                }
                for (; i <= end; i++) {
                    col = spans[i];
                    if (col !== column) break;
                    r.width += lm.getColumnBounds(i).width;
                    col = lm.getColumn(i);
                    if (col !== column) {
                        cv = cells[col.$_hash];
                        cv && cv.setVisible(false);
                    }
                }
                if (!fixed) {
                    r.x -= leftPos;
                }
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        } else {
            for (i = start; i <= end; i++) {
                view = cells[lm.getColumn(i).$_hash];
                r = lm.columnBounds(i);
                if (!fixed) {
                    r.x -= leftPos;
                }
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        }
    }
});
var RowGroupElement = defineClass("RowGroupElement", VisualObjectElement, {
    init: function (dom, name, rowGroup) {
        this._super(dom, name, rowGroup);
    }
});
var RowGroupHeadCellElement = defineClass("RowGroupHeadCellElement", CellElement, {
    init: function(dom, name) {
        this._super(dom, name || "rowGroupHeadCellView");
    },
    level: 0,
    _doUpdateContent: function(cell) {
        this._super(cell);
        this._level = cell._level;
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        return new Size(hintWidth, grid.header().minHeight());
    },
    _doRender: function(g, r) {
        var fill = this.background();
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        this._drawBorders(g, r);
    },
    _doRenderHtml: function (r) {
        var fill = this.background();
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        this._drawHtmlBorders();
    }
});
var RowGroupHeadElement = defineClass("RowGroupHeadElement", LayerElement, {
    init: function (dom) {
        this._super(dom, "rowGroupHeadView");
        this._cells = [];
    },
    layoutContent: function (lm) {
        var i, cnt, cell, model,
            grid = lm.grid(),
            rowGroup = grid.rowGroup(),
            x = 0,
            w = rowGroup.levelIndent(),
            h = lm.headerBounds().height;
        this.$_prepareCells(grid.getGroupLevels());
        for (i = 0, cnt = this.childCount(); i < cnt; i++) {
            cell = this._cells[i];
            cell.setBounds(x, 0, w, h);
            x += w;
            model = rowGroup.getHeadCell(i + 1);
            cell.updateCell(model);
            cell.layoutContent(lm);
        }
    },
    $_prepareCells: function (cnt) {
        while (this._cells.length < cnt) {
            var cell = new RowGroupHeadCellElement(this._dom);
            this._cells.push(cell);
        }
        while (this.childCount() < cnt) {
            this.addElement(this._cells[this.childCount()]);
        }
        while (this.childCount() > cnt) {
            this.removeChildAt(this.childCount() - 1);
        }
    }
});
var RowGroupHeaderCellElement = defineClass("RowGroupHeaderCellElement", CellElement, {
    init: function(dom) {
        this._super(dom, "rowGroupHeaderCellView");
    },
    text: null,
    borderLeft: function () {
        return null;
    },
    _doPrepareValue: function (cell) {
        this._super(cell);
        this.setText(cell.displayText());
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doRender: function(g, r) {
        var fill, rc;
        fill = this.background();
        if (fill) {
            g.drawRect(fill, null, r);
        }
        rc = this._getRenderRect(r);
        rc = this.inflatePadding(rc);
        g.drawTextRect(this.font(), this.color(), this.text(), rc, this.textAlign());
        this._drawBorders(g, r);
    },
    _doRenderHtml: function (r) {
        var fill, span, s, rc;
        fill = this.background();
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        span = this.$_prepareSpan();
        s = this.text();
        rc = this._getRenderRect(r);
        rc = this.inflatePadding(rc);
        Dom.renderTextBounds(span, this.font(), this.color(), s, r.x, r.y, r.width, r.height, this.textAlign());
        this._drawHtmlBorders();
    }
});
var BandedRowGroupHeaderCellElement = defineClass("BandedRowGroupHeaderCellElement", CellElement, {
    init: function(dom) {
        this._super(dom, "bandedRowGroupHeaderCellView");
    },
    text: null,
    _doPrepareValue: function (cell) {
        this._super(cell);
        this.setText(cell.displayText());
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doRender: function(g, r) {
        var fill, rc;
        fill = this.background();
        if (fill) {
            g.drawRect(fill, null, r);
        }
        rc = this._getRenderRect(r);
        rc = this.inflatePadding(rc);
        g.drawTextRect(this.font(), this.color(), this.text(), rc, this.textAlign());
        this._drawBorders(g, r);
    },
    _doRenderHtml: function (r) {
        var fill, span, s, rc;
        fill = this.background();
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        span = this.$_prepareSpan();
        s = this.text();
        rc = this._getRenderRect(r);
        rc = this.inflatePadding(rc);
        Dom.renderTextBounds(span, this.font(), this.color(), s, rc.x, rc.y, rc.width, rc.height, this.textAlign());
        this._drawHtmlBorders();
    }
});
var BandedRowGroupHeaderElement = defineClass("BandedRowGroupHeaderElement", GroupRowElement, {
    init: function(dom/*, rowGroup*/) {
        this._super(dom, "bandedRowGroupHeaderView");
        this._expander = new RowGroupExpanderElement(dom);
        this.addElement(this._expander);
        this._cellView = new BandedRowGroupHeaderCellElement(dom);
        this.addElement(this._cellView);
    },
    cellView: function() {
        return this._cellView;
    },
    _doUpdateElement: function (styles) {
        this._super(styles);
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doLayoutContent: function (lm) {
        var rowGroup = this.grid().rowGroup();
        var row = this._item;
        var level = rowGroup.getLevel(row.level() - 1);
        var wHandle = (level ? level.getExpanderVisible() : rowGroup.expanderVisible()) ? this._expander.getHandleWidth() : 0;
        var w = (row.level() - 1) * Math.max(rowGroup.levelIndent(), rowGroup.minHeaderIndent()) + wHandle;
        var view = this._expander;
        view.setHandleVisible(wHandle > 0);
        view.setIndent(w - wHandle);//rowGroup.levelIndent());
        view.updateCell(rowGroup.getExpanderCell(row.index()));
        view.setBounds(0, 0, w, this.height());
        view.layoutContent(lm);
        view = this._cellView;
        view._header = row;
        view.updateCell(rowGroup.getHeaderCell(row.index()));
        view.setBounds(w, 0, this.width() - w, this.height());
    },
    _doRender: function (g, r) {
    },
    _doRenderHtml: function (r) {
    }
});
var BandedRowGroupIndentCellElement = defineClass("BandedRowGroupIndentCellElement", CellElement, {
    init: function(dom) {
        this._super(dom, "bandedRowGroupIndentCellView");
    },
    text: null,
    _doPrepareValue: function (cell) {
    },
    _doUpdateContent: function(cell) {
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        return undefined;
    },
    _doRender: function(g, r) {
        var fill = this.background();
        if (fill) {
            g.drawRect(fill, null, r);
        }
        this._drawBorders(g, r);
    },
    _doRenderHtml: function (r) {
        var fill = this.background();
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        this._drawHtmlBorders();
    }
});
var BandedRowGroupElement = defineClass("BandedRowGroupElement", RowGroupElement, {
    init: function(dom, rowGroup) {
        this._super(dom, "bandedRowGroupLayer", rowGroup);
        this._headers = [];
        this._headerBuff = [];
        this._headerViews = [];
        this._footers = [];
        this._footerBuff = [];
        this._fixedFooterBuff = [];	// RowGroupFooterElement
        this._footerViews = [];
        this._fixedFooterViews = [];
        this._customHeaders = [];
        this._customHeaderBuff = [];
        this._customHeaderViews = [];
        this._customFooters = [];
        this._customFooterBuff = [];
        this._customFooterViews = [];
        this._fixedIndentView = null;
        this._indentViews = [];
        this._indentCount = 0;
        this.setWidth(101);
        this.setHeight(101);
        this.setClickable(false);
    },
    model: function () {
        return this._model;
    },
    levelCount: function() {
        return this.grid().layoutManager().rowGroupLevels();
    },
    indentCount: function () {
        return this._indentCount;
    },
    clearBody: function () {
        this._headers = [];
        this._footers = [];
        this._customHeaders = [];
        this._customFooters = [];
    },
    addHeader: function (header) {
        this._headers.push(header);
    },
    addFooter: function (model) {
        this._footers.push(model);
    },
    addCustomHeader: function (model) {
        this._customHeaders.push(model);
    },
    addCustomFooter: function (model) {
        this._customFooters.push(model);
    },
    findRowView: function (rowIndex) {
        var i;
        for (i = this._headerViews.length; i--;) {
            if (this._headerViews[i].rowIndex() == rowIndex) return this._headerViews[i];
        }
        for (i = this._footerViews.length; i--;) {
            if (this._footerViews[i].rowIndex() == rowIndex) return this._footerViews[i];
        }
    },
    isLayer: function () {
        return true;
    },
    getCellView: function (index, fixed) {
        var row = index.getRow(this.grid());
        if (row instanceof GroupRow || row instanceof GroupFooter || row instanceof CustomGroupItemRow) {
            for (var i = 0, cnt = this.childCount(); i < cnt; i++) {
                var view = this.getChild(i);
                if (view instanceof BandedRowGroupHeaderElement && view.visible() && view.rowIndex() == index.rowIndex) {
                    return view.cellView();
                }
                if (view instanceof RowGroupFooterElement && view._fixed == fixed && view.visible() && view.rowIndex() == index.rowIndex) {
                    return view;
                }
                if (row instanceof CustomGroupItemRow && view instanceof GroupRowElement && view.rowIndex() == index.rowIndex) {
                    return view;
                }
            }
        }
        return null;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return new Size(this.levelCount() * grid.rowGroup().levelIndent(), hintHeight);
    },
    _doLayoutContent: function (lm) {
        /*
        this._bodyElement.setBounds(0, lm.headerBounds().height, this.width(),
            this.height() - lm.headerBounds().height - lm.footerBounds().height);
        */
        var grid = this.grid();
        this.$_layoutIndents(grid, lm);
        this.$_layoutHeaders(grid, lm);
        this.$_layoutCustomHeaders(grid, lm);
        this.$_layoutFooters(grid, lm);
        this.$_layoutCustomFooters(grid, lm);
    },
    _doDraw: function (g) {
    },
    _doDrawHtml: function (r) {
    },
    $_layoutIndents: function (grid, lm) {
        var i, cnt, row, fixedCount, fixedView, itemCount, top, view, model, w, y, h,
            rows = grid.itemSource();
        for (i = 0, cnt = this._indentViews.length; i < cnt; i++) {
            this._indentViews[i].recycling = false;
        }
        fixedCount = lm.fixedItemCount();
        fixedView = this._fixedIndentView;
        if (fixedCount > 0) {
            if (!fixedView) {
                fixedView = this._fixedIndentView = new BandedRowGroupIndentCellElement(this._dom);
                this.addElement(fixedView);
            }
            fixedView.setVisible(true);
        } else if (fixedView) {
            fixedView.setVisible(false);
            fixedView = null;
        }
        itemCount = lm.itemCount();
        top = lm.topIndex();
        view = null;
        for (i = 0, cnt = 0; i < itemCount; i++) {
            row = rows.getItem(top + i + fixedCount);
            if (row instanceof GroupRow) {
                if (view) {
                    view.$_tail = fixedCount + i - 1;
                    view = null;
                }
            } else {
                if (!view) {
                    if (this._indentViews.length > cnt) {
                        view = this._indentViews[cnt];
                    } else {
                        this._indentViews.push(view = new BandedRowGroupIndentCellElement(this._dom));
                        this.addElement(view);
                    }
                    view.$_head = fixedCount + i;
                    cnt++;
                } else {
                    view.$_tail = fixedCount + i;
                }
            }
        }
        for (i = 0; i < cnt; i++) {
            this._indentViews[i].setVisible(true);
        }
        for (i = cnt; i < this._indentViews.length; i++) {
            this._indentViews[i].setVisible(false);
        }
        this._indentCount = cnt;
        model = grid.rowGroup().getIndentCell();
        w = lm.rowGroupLevels() * grid.rowGroup().levelIndent();
        if (fixedView) {
            y = lm.itemBounds(0).y;
            h = lm.itemBounds(fixedCount - 1).bottom() - y;
            fixedView.updateCell(model);
            fixedView.setBounds(0, y, w, h);
        }
        for (i = 0; i < cnt; i++) {
            view = this._indentViews[i];
            y = lm.itemBounds(view.$_head).y;
            h = lm.itemBounds(view.$_tail).bottom() - y;
            view.updateCell(model);
            view.setBounds(0, y, w, h);
        }
    },
    $_layoutHeaders: function (grid, lm) {
        var i, view, header, dirty, r, w,
            rowGroup = this.model(),
            levelIndent = rowGroup.levelIndent(),
            cnt = this._headerViews.length;
        for (i = 0; i < cnt; i++) {
            this._headerViews[i].recycling = false;
        }
        while (cnt < this._headers.length) {
            view = this.$_borrowHeaderView(this._headers[cnt++]);
            this.addElement(view);
            this._headerViews.push(view);
        }
        while (cnt > this._headers.length) {
            this.$_removeHeaderView(this._headerViews[--cnt]);
            this._headerViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            header = this._headers[i];
            view = this._headerViews[i];
            dirty = (view.item() !== header);
            view.updateElement(header, rowGroup.headerStyles());
            r = lm.itemBounds(header.index() - grid.topIndex());
            w = 0;//(header.level() - 1) * levelIndent;
            r.setLeft(w);
            r.width = this.width() - w - grid.leftPos();
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
    },
    $_removeHeaderView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._headerBuff.push(view);
        }
    },
    $_borrowHeaderView: function (header) {
        var view;
        if (this._headerBuff.length > 0) {
            view = this._headerBuff.pop();
        } else {
            view = this.grid().delegate().borrowItemView(header, false);
        }
        view.recycling = false;
        return view;
    },
    $_layoutCustomHeaders: function (grid, lm) {
        var i, view, header, dirty, r, w,
            rowGroup = this.model(),
            levelIndent = rowGroup.levelIndent(),
            cnt = this._customHeaderViews.length;
        for (i = 0; i < cnt; i++) {
            this._customHeaderViews[i].recycling = false;
        }
        while (cnt < this._customHeaders.length) {
            view = this.$_borrowCustomHeaderView(this._customHeaders[cnt++]);
            this.addElement(view);
            this._customHeaderViews.push(view);
        }
        while (cnt > this._customHeaders.length) {
            this.$_removeCustomHeaderView(this._customHeaderViews[--cnt]);
            this._customHeaderViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            header = this._customHeaders[i];
            view = this._customHeaderViews[i];
            dirty = (view.item() !== header);
            view.updateElement(header, header.model().styles());
            r = lm.itemBounds(header.index() - grid.topIndex());
            w = (header.level() - 1) * levelIndent;
            r.setLeft(w);
            r.width = this.width() - w - grid.leftPos();
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
    },
    $_borrowCustomHeaderView: function (header) {
        var view;
        if (this._customHeaderBuff.length > 0) {
            view = this._customHeaderBuff.pop();
        } else {
            view = header.model().createRowView(this._dom);
        }
        view.recycling = false;
        return view;
    },
    $_removeCustomHeaderView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._customHeaderBuff.push(view);
        }
    },
    $_layoutFooters: function (grid, lm) {
        var cnt, i, view, footer, dirty, r, w, wBar,
            width = this.width(),
            rowGroup = this.model(),
            styles = rowGroup.footerStyles(),
            levels = lm.rowGroupLevels(),
            levelIndent = rowGroup.levelIndent(),
            hasFixed = lm.fixedColCount() > 0,
            wFixed = lm.fixedWidth(),
            top = grid.topIndex(),
            leftPos = grid.leftPos();
        cnt = this._footerViews.length;
        for (i = 0; i < cnt; i++) {
            this._footerViews[i].recycling = false;
        }
        while (cnt < this._footers.length) {
            view = this.$_borrowFooterView(this._footers[cnt]);
            this.addElement(view);
            this._footerViews.push(view);
            cnt++;
        }
        while (cnt > this._footers.length) {
            cnt--;
            this.$_removeFooterView(this._footerViews[cnt]);
            this._footerViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            footer = this._footers[i];
            view = this._footerViews[i];
            view._fixed = false;
            dirty = (view.item() !== footer);
            view.updateElement(footer, styles);
            r = lm.itemBounds(footer.index() - top);
            w = levels * levelIndent + wFixed;
            r.setLeft(w);
            r.width = width - w - leftPos;
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
        if (hasFixed) {
            cnt = this._fixedFooterViews.length;
            for (i = 0; i < cnt; i++) {
                this._fixedFooterViews[i].recycling = false;
            }
            while (cnt < this._footers.length) {
                view = this.$_borrowFixedFooterView(this._footers[cnt]);
                this.addElement(view);
                this._fixedFooterViews.push(view);
                cnt++;
            }
            while (cnt > this._footers.length) {
                cnt--;
                this.$_removeFixedFooterView(this._fixedFooterViews[cnt]);
                this._fixedFooterViews.pop();
            }
            wBar = grid.body().fixedColumnBarWidth()
            for (i = 0; i < cnt; i++) {
                footer = this._footers[i];
                view = this._fixedFooterViews[i];
                view._fixed = true;
                dirty = (view.item() !== footer);
                view.updateElement(footer, rowGroup.footerStyles());
                r = lm.itemBounds(footer.index() - top);
                w = levels * levelIndent;
                r.setLeft(w);
                r.width = wFixed - wBar;
                view.setRect(r);
                if (dirty || !view.recycling) {
                    view.layoutContent(lm);
                }
            }
        }
    },
    $_removeFooterView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._footerBuff.push(view);
        }
    },
    $_removeFixedFooterView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._fixedFooterBuff.push(view);
        }
    },
    $_borrowFooterView: function (footer) {
        var view;
        if (this._footerBuff.length > 0) {
            view = this._footerBuff.pop();
        } else {
            view = this.grid().delegate().borrowItemView(footer, false);
        }
        view.recycling = false;
        return view;
    },
    $_borrowFixedFooterView: function (footer) {
        var view; // RowGroupFooterElement
        if (this._fixedFooterBuff.length > 0) {
            view = this._fixedFooterBuff.pop();
        } else {
            view = this.grid().delegate().borrowItemView(footer, true);
        }
        view.recycling = false;
        return view;
    },
    $_layoutCustomFooters: function (grid, lm) {
        var i, view, footer, dirty, r, w,
            rowGroup = this.model(),
            levelIndent = rowGroup.levelIndent(),
            cnt = this._customFooterViews.length;
        for (i = 0; i < cnt; i++) {
            this._customFooterViews[i].recycling = false;
        }
        while (cnt < this._customFooters.length) {
            view = this.$_borrowCustomFooterView(this._customFooters[cnt++]);
            this.addElement(view);
            this._customFooterViews.push(view);
        }
        while (cnt > this._customFooters.length) {
            this.$_removeCustomFooterView(this._customFooterViews[--cnt]);
            this._customFooterViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            footer = this._customFooters[i];
            view = this._customFooterViews[i];
            dirty = (view.item() !== footer);
            view.updateElement(footer, footer.model().styles());
            r = lm.itemBounds(footer.index() - grid.topIndex());
            w = (footer.level() - 1) * levelIndent;
            r.setLeft(w);
            r.width = this.width() - w - grid.leftPos();
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
    },
    $_borrowCustomFooterView: function (footer) {
        var view;
        if (this._customFooterBuff.length > 0) {
            view = this._customFooterBuff.pop();
        } else {
            view = footer.model().createRowView(this._dom);
        }
        view.recycling = false;
        return view;
    },
    $_removeCustomFooterView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._customFooterBuff.push(view);
        }
    }
});
/** @abstract */
var GridMergeRule = defineClass("GridMergeRule", null, {
	init: function() {
		this._super();
	},
	parseInit: function (items, column, start, count, flags) {
		_throwAbstractError();
	},
	parseBounds: function (items, column, start, end, flags) {
		_throwAbstractError();
	}
});
var RowGroupMergeRule = defineClass("RowGroupMergeRule", GridMergeRule, {
	init: function() {
		this._super();
		this._level = 0;
		this._mergeMode = false;
	},
	parseInit: function (items, column, start, count, flags) {
		var itemCount = items.rowCount(),
        	field = column.dataIndex();
		count = Math.min(itemCount - start, count);
		if (count < 1) {
			return;
		}
		if (this._mergeMode) {
			this.$_parseMerged(items, field, start, count, flags);
		} else {
			this.$_parseNormal(items, field, start, count, flags);
		}
	},
	parseBounds: function (items, column, start, end, flags) {
		var itemCount = items.rowCount();
        if (itemCount < 1) return;
		var item,
        	field = column.dataIndex();
		start = Math.max(0, start);
		while (start >= 0 && flags[start] <= 0) {
			item = items.getItem(start);
			if (item == this.$_getAncestor(item, this._level)) {
				break;
			}
			start--;
		}
		start = Math.max(0, start);
		while (start <= end && flags[start] > 0) {
			start++;
		}
		if (start <= end) {
			if (this._mergeMode) {
				this.$_parseMergedBounds(items, field, start, end, flags);
			} else {
				this.$_parseNormalBounds(items, field, start, end, flags);
			}
		}
	},
	$_getAncestor: function (row, level) {
		var group = _cast(row, GroupRow);
		if (!group) {
			group = row.parent();
		}
		while (group.level() > level) {
			group = group.parent();
		}
		return group;
	},
	$_parseNormal: function (items, field, start, count, flags) {
		var itemCount = items.rowCount();
		if (itemCount < 1) return;
		var item = items.getItem(start),
			prev = item,
			p = start,
			i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			if (item.level() != prev.level() || item.constructor !== prev.constructor) {
				p = i;
			}
			flags[i] = p + 1;
			i++;
			prev = item;
		}
	},
	$_parseMerged: function (items, field, start, count, flags) {
		var itemCount = items.rowCount();
		if (itemCount < 1) return;
		var item = items.getItem(start),
			group = this.$_getAncestor(item, this._level),
			parent,
			p = start,
			i = flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			parent = this.$_getAncestor(item, this._level);
			if (parent != group) {
				if (i >= count) {
					break;
				}
				group = parent;
				p = i;
			}
			flags[i] = p + 1;
			i++;
		}
	},
	$_parseNormalBounds: function (items, field, start, end, flags) {
		var itemCount = items.rowCount();
		if (itemCount < 1) return;
		var item = items.getItem(start),
			prev = item,
			p = start,
			i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			if (item.level() != prev.level() || item.constructor !== prev.constructor) {
				p = i;
			}
			flags[i] = p + 1;
			i++;
			prev = item;
		}
	},
	$_parseMergedBounds: function (items, field, start, end, flags) {
		var itemCount = items.rowCount();
		if (itemCount < 1) return;
		var item = items.getItem(start),
			group = this.$_getAncestor(item, this._level),
			parent,
			p = start,
			i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			parent = this.$_getAncestor(item, this._level);
			if (parent != group) {
				if (i > end) {
					break;
				}
				group = parent;
				p = i;
			}
			flags[i] = p + 1;
			i++;
		}
	}
});
RowGroupMergeRule.$_default = new RowGroupMergeRule();
RowGroupMergeRule.INIT_COUNT = 200;
RowGroupMergeRule.getDefault = function (groupLevel, mergeMode) {
	var rule = RowGroupMergeRule.$_default;
	rule._level = groupLevel;
	rule._mergeMode = mergeMode;
	return rule;
};
var ColumnMergeRule = defineClass("ColumnMergeRule", GridMergeRule, {
	init: function(criteria) {
		this._super();
        this._runtime = ColumnMergeRule.$_runtime = ColumnMergeRule.$_runtime || new ColumnMergeRuntime();
		this._exprNode = null;
		criteria && this.setCriteria(criteria);
	},
	criteria: null,
	setCriteria: function (value) {
		value = value ? value.trim() : null;
		if (value != this._criteria) {
			this._criteria = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value, null) : null;
			this._changed();
		}
	},
	setCallback: function (value) {
		value = _asFunction(value);
		if (value != this._callback) {
			this._callback = value;
			this._changed();
		}
	},
    active: function () {
        return this._exprNode || this._callback;
    },
	$_isRow: function (item, header) {
		var group, row = item instanceof DataRow;
		if (row && !header) {
			group = item.parent();
			row = group.expanded() || group.firstLeaf() != item;
		}
		return row;
	},
	$_getValueFunc: function (column, isValue) {
		var self, fld;
		if (this._callback) {
			return this._callback;
		} else if (isValue) {
            if (column instanceof SeriesColumn) {
                return function (row, column) {
                    return column.getValue(row).join("");
                };
            } else {
                fld = column.dataIndex();
                return function (row, column) {
                    return row.getValue(fld);
                };
            }
		} else {
            self = this;
            fld = column.dataIndex ? column.dataIndex() : -1;
			return function (item) {
				self._runtime.setItem(item, fld);
				return self._exprNode.evaluate(self._runtime);
			};
		}
	},
	parseInit: function (items, column, start, count, flags) {
		var itemCount = items.rowCount();
		count = Math.min(itemCount - start, count);
		if (count < 1) {
			return;
		}
        var isValue, func, p, isDate, prev, v, c,
			header = false,
			item = null,
			i = start;
		while (i < itemCount) {
			item = items.getItem(i);
			if (this.$_isRow(item, header)) {
				break;
			}
			flags[i] = i + 1;
			i++;
		}
		if (i >= itemCount) {
			return;
		}
		this._runtime.setDataSource(items.dataSource(), column.grid());
		isValue = !this._callback && this._exprNode.isIdentifier("value");
		func = this.$_getValueFunc(column, isValue);
		p = start = i;
		isDate = isValue && (column.valueType() == ValueType.DATETIME);
		flags[p] = p + 1;
		prev = func(item, column);
		for (i = start + 1; i < itemCount; i++) {
			item = items.getItem(i);
			if (this.$_isRow(item, header)) {
				v = func(item, column);
				if (isDate) {
					c = (v && prev) ? (v.getTime() == prev.getTime()) : v == prev;
				} else {
					c = v == prev;
				}
				if (!c) {
					if (i >= count) {
						break;
					}
					p = i;
					prev = v;
				}
				flags[i] = p + 1;
			} else {
				if (i >= count) {
					break;
				}
				prev = UNDEFINED;
				p = i;
				flags[i] = p + 1;
			}
		}
	},
	parseBounds: function (items, column, start, end, flags) {
		var itemCount = items.rowCount();
        if (itemCount < 1) {
            return;
        }
		var item, prev, i, y, c,
        	header = false,
			isValue = !this._callback && this._exprNode.isIdentifier("value"),
			func = this.$_getValueFunc(column, isValue),
			v = UNDEFINED,
			p = Math.max(0, start),
			s = p,
			cont = -1,
			isDate = isValue && (column.valueType() == ValueType.DATETIME);
		if (p > 0 && flags[p] <= 0) {
			item = items.getItem(p);
			if (this.$_isRow(item, header)) {
				prev = func(item, column);
				p--;
				while (p >= 0) {
					item = items.getItem(p);
					if (!this.$_isRow(item, header)) {
						break;
					}
					v = func(item, column);
					if (isDate) {
						c = (v && prev) ? (v.getTime() == prev.getTime()) : v == prev;
					} else {
						c = v == prev;
					}
					if (!c) {
						break;
					}
					p--;
				}
				for (i = s - 1; i > p; i--) {
					flags[i] = p + 2;
				}
				if (s - 1 > p) {
					cont = p + 1;
				}
			} else {
				flags[p] = p + 1;
				for (i = s - 1; i > p; i--) {
					flags[i] = p + 2;
				}
				if (s - 1 > p + 1) {
					cont = p + 2;
				}
				p--;
				while (p >= 0 && flags[p] <= 0 && !this.$_isRow(items.getItem(p), header)) {
					flags[p] = p + 1;
					p--;
				}
			}
		}
		p = Math.max(0, start);
		while (p <= end && flags[p] > 0) {
			p++;
		}
		while (p <= end && !this.$_isRow(items.getItem(p), header)) {
			flags[p] = p + 1;
			p++;
		}
		if (p <= end && p < itemCount) {
			s = p;
			item = items.getItem(p);
			prev = func(item, column);
			p++;
			while (p < itemCount) {
				item = items.getItem(p);
				if (this.$_isRow(item, header)) {
					v = func(item, column);
					if (isDate) {
						c = (v && prev) ? (v.getTime() == prev.getTime()) : v == prev;
					} else {
						c = v == prev;
					}
					if (!c) {
						y = s;
						if (cont >= 0) {
							y = cont;
							cont = -1;
						}
						for (i = s; i < p; i++) {
							flags[i] = y + 1;
						}
						if (p >= end) {
							break;
						}
						prev = v;
						s = p;
					} else {
						flags[p] = s + 1;
					}
					p++;
				} else {
					y = s;
					if (cont >= 0) {
						y = cont;
						cont = -1;
					}
					for (i = s; i < p; i++) {
						flags[i] = y + 1;
					}
					flags[p] = p + 1;
					p++;
					while ((p < itemCount) && !this.$_isRow(items.getItem(p), header)) {
						flags[p] = p + 1;
						p++;
					}
					s = p;
					if (p >= end) {
						break;
					}
				}
			}
            if (isDate) {
                c = (v && prev) ? (v.getTime() == prev.getTime()) : v == prev;
            } else {
                c = v == prev;
            }
			if (p == itemCount && c) {
				y = (cont >= 0) ? cont : s;
				for (i = s; i < p; i++) {
					flags[i] = y + 1;
				}
			}
		}
	},
	_changed: function () {
	}
}, {
	INIT_COUNT: 200
}, function (f) {
	f.$_runtime = null;
});
/** @abstract */
var GridMergeRoom = defineClass("GridMergeRoom", null, {
	init: function() {
		this._super();
	},
	scope: function () {
	},
	group: function () /* GroupRow */ {
	},
	headItem: function () {
		return -1;
	},
	tailItem: function () {
		return -1;
	},
	length: function () {
		return this.tailItem() - this.headItem() + 1;
	},
	getHead: function (index) /* CellIndex */ {
	},
	getTail: function (index) /* CellIndex */ {
	},
	isHead: function (index) {
	},
	isTail: function (index) {
	},
	contains: function (index) {
	},
    containsRow: function (rowIndex) {
    }
});
var ColumnMergeRoom = defineClass("ColumnMergeRoom", GridMergeRoom, {
	init: function(range) {
		this._super();
		this._column = range.C1();
		this._head = range.top();
		this._tail = range.bottom();
		this._group = null;
	},
	column: function () {
		return this._column;
	},
	head: function () {
		return this._head;
	},
	tail: function () {
		return this._tail;
	},
	scope: function () {
		return this._column;
	},
	group: function () {
		return this._group;
	},
	setGroup: function (value) {
		this._group = value;
	},
	headItem: function () {
		return this._head;
	},
	tailItem: function () {
		return this._tail;
	},
	length: function () {
		return this._tail - this._head + 1;
	},
	getHead: function (index)/* CellIndex */ {
		if (!index) {
			index = this._column.grid().getIndex(this._head, this._column);
		} else {
			index.set(this._head, this._column);
		}
		return index;	
	},
	getTail: function (index)/* CellIndex */ {
		if (!index) {
			index = this._column.grid().getIndex(this._tail, this._column);
		} else {
			index.set(this._tail, this._column);
		}
		return index;	
	},
	isHead: function (index) {
		return (index.column == this._column) && (index.rowIndex == this._head);
	},
	isTail: function (index) {
		return (index.column == this._column) && (index.rowIndex == this._tail);
	},
	contains: function (index) {
		return (index.column == this._column) && (index.rowIndex >= this._head) && (index.rowIndex <= this._tail);
	},
    containsRow: function (rowIndex) {
        return (rowIndex >= this._head) && (rowIndex <= this._tail);
    }
}, {
	$_rooms: [],
	$_roomCount: 0, // for debug
	borrow: function (range) {
		var room = ColumnMergeRoom.$_rooms.pop();
		if (!room) {
			room = new ColumnMergeRoom(range);
		} else {
			room._head = range.top();
			room._tail = range.bottom();
		}
		return room;
	},
	returnTo: function (room) {
        var rooms, i, cnt;
		if (room) {
			rooms = ColumnMergeRoom.$_rooms;
			for (i = 0, cnt = rooms.length; i < cnt; i++) {
				if (rooms[i] === room) {
					return;
				}
			}
			rooms.push(room);
		}
	}
});
var ColumnMergeManager = defineClass("ColumnMergeManager", null, {
	init: function(column) {
		this._super();
		this._column = column;
		this._flags = null;
		this._rooms = [];
		this._inited = false;
	},
	count: function () {
		return this._rooms.length;
	},
	clear: function () {
		this._flags = null;
		this._rooms.splice(0, this._rooms.length);
		this._inited = false;
	},
	initialize: function (count) {
		if (this._inited) {
			return;
		}
		var flags, i,
			col = this._column,
			dcolumn = _cast(col, DataColumn),
			grid = col.grid(),
			rowGroup = grid.rowGroup(),
			items = grid.itemSource(),
			rule = grid.isGroupedColumn(dcolumn) ? RowGroupMergeRule.getDefault(grid.getGroupLevel(dcolumn.dataIndex()), rowGroup.mergeMode()) : col.mergeRule();
		if (rule) {
			flags = this._flags = new Array(items.rowCount());
			for (i = items.rowCount(); i--;) {
				flags[i] = 0;
			}
			rule.parseInit(items, col, grid.layoutManager().fixedItemCount(), count, flags);
		}
        this._inited = true;
	},
	refresh: function (first, last) {
		if (!this._inited || !this._flags || last < first) {
			return;
		}
		var range, room, item, group,
			col = this._column,
			dcolumn = _cast(col, DataColumn),
			grid = col.grid(),
			forceMerge = !col._canSplit() || (grid.editOptions().mergedWhenUpdating() && !grid.isColumnEdited(col)),
			fixed = grid.layoutManager().fixedItemCount(),
			items = grid.itemSource(),
			level = dcolumn ? grid.getGroupLevel(dcolumn.dataIndex()) : -1,
			rule = level > 0 ? RowGroupMergeRule.getDefault(level, grid.rowGroup().mergeMode()) : col.mergeRule(),
			i = first;
		this._rooms.length = 0;
		if (rule) {
			rule.parseBounds(items, col, first, last, this._flags);
		}
		while (i <= last) {
			range = this.$_checkMerge(items, col, i, this._rooms.length == 0, fixed, forceMerge);
			if (range) {
				if (level < 1) { // rowGrouping이 아닐 때
					room = new ColumnMergeRoom(range);
					this._rooms.push(room);
				} else { // rowGrouping일 때
					item = items.getItem(range.top());
					if (item.level() >= level) {
						group = (item instanceof GroupRow) ? item : item.parent();
						while (group.level() > level) {
							group = group.parent();
						}
						room = new ColumnMergeRoom(range);
						room.setGroup(group);
						this._rooms.push(room);
					}
				}
				i = range.R2() + 1;
			} else {
				i += 1;
			}
		}
	},
	getRooms: function () {
		return this._rooms.slice();
	},
	scroll: function (delta) {
	},
	getRoom: function (index) {
		var rooms = this._rooms;
		for (var i = rooms.length - 1; i >=  0; i--) {
			if (rooms[i].contains(index))
				return rooms[i];
		}
		return null;
	},
    getRoomAtRow: function (rowIndex, force) {
        var i, r,
			rooms = this._rooms,
            cnt = rooms.length;
        for (i = cnt - 1; i >=  0; i--) {
			r = rooms[i];
			if (r.containsRow(rowIndex)) return r;
        }
		if (force) {
			this.refresh(i, this._column.grid().rowCount() - 1);
            for (i = cnt; i < rooms.length; i++) {
                r = rooms[i];
                if (r.containsRow(rowIndex)) return r;
            }
		}
    },
	$_isEditing: function (row, forceMerge) {
		var s = row.rowState();
		return s == GridRowState.INSERTING || s == GridRowState.APPENDING || (s == GridRowState.UPDATING && !forceMerge);
	},
	$_checkMerge: function (items, column, start, first, fixed, forceMerge) {
		if (items && column && start >= 0) {
			var count, i, level, editing,
				p = start,
				f = this._flags[p],
				item = items.getItem(p);
			if (f <= 0 || this.$_isEditing(item, forceMerge)) {
				return null;
			}
			if (first) {
				while (p > fixed) {
					if (this._flags[p - 1] < f || this.$_isEditing(items.getItem(p - 1), forceMerge)) {
						break;
					}
					p--;
				}
			}
			count = items.rowCount();
			i = start + 1;
			level, editing;
			while (i < count) {
				editing = this.$_isEditing(items.getItem(i), forceMerge);
				if (this._flags[i] > f || this._flags[i] <= 0 || editing) {
					if (i > p + 1) { // 적어도 아이템이 두 개 이상
						return CellRange.createRange(p, column, i - 1, column);
					} else {
						item = items.getItem(p);
						level = (column instanceof DataColumn) ? column.groupLevel() : -1;
						if (item instanceof MergedGroupHeader && item.collapsed()) {
							return CellRange.createRange(p, column, i - 1, column);
						}
						/*
						if (item instanceof MergedGroupHeader && item.level() == level && item.collapsed()) {
							return CellRange.createRange(p, column, i - 1, column);
						}
						*/
						if (item instanceof MergedGroupFooter && item.parent().level() == level &&
							(i == start + 1 || // 첫번째 행에 footer가 있을 때 expander를 표시할 수 있도록
							 item.parent().collapsed())) {
							return CellRange.createRange(p, column, i - 1, column);
						}
						if (item instanceof MergedGroupFooter)  {
							return null;
						}
						if ((item instanceof MergedGroupHeader || item instanceof MergedGroupFooter) && item.parent().level() > level )  {
							return CellRange.createRange(p, column, i - 1, column);
						}
						return null;
					}
				} 
				i++;
			}
			if (i > p) {
				if (i > p + 1) { 
					return CellRange.createRange(p, column, i - 1, column);
				} else {
					item = items.getItem(p);
					level = (column instanceof DataColumn) ? column.groupLevel() : -1;
					if (item instanceof MergedGroupHeader && item.collapsed()) {
						return CellRange.createRange(p, column, i - 1, column);
					}
					/*
					if (item instanceof MergedGroupHeader && item.level() == level && item.collapsed()) {
						return CellRange.createRange(p, column, i - 1, column);
					}
					*/
					if (item instanceof MergedGroupFooter && item.parent().level() == level && 
						(i == start + 1 || item.parent().collapsed())) {
						return CellRange.createRange(p, column, i - 1, column);
					}
					if (item instanceof MergedGroupFooter)  {
						return null;
					}
					if ((item instanceof MergedGroupHeader || item instanceof MergedGroupFooter) && item.parent().level() > level )  {
						return CellRange.createRange(p, column, i - 1, column);
					}
					return null;
				}
			}
		}
		return null;
	}
}, {
	MERGE_ROOMS: "mergeRooms"
});
var MergedGroupFooter = defineClass("MergedGroupFooter", GroupFooter, {
	init: function() {
		this._super();
	},
    merged: function () {
        return true;
    }
});
var MergedGroupHeader = defineClass("MergedGroupHeader", GroupRow, {
	init: function(groupField, value) {
		this._super();
		this._groupField = groupField;
        this._value = value;
		this._footer = null;
	},
	groupField: function () {
		return this._groupField;
	},
    groupValue: function () {
        return this._groupValue;
    },
	footer: function () {
		return this._footer;
	},
    merged: function () {
        return true;
    },
	_addChild: function (item, index) {
		this._super(item, index);
		if (item instanceof GroupFooter) {
			this._footer = item;
		}
	}
});
var MergedDataCell = defineClass("MergedDataCell", DataCell, {
	init: function(grid, name) {
		this._super(grid, name || "mergedDataCell");
		this._grid = grid;
        this._runtime = null;
	},
	value: function() {
		var v, group, callback, node,
			index = this.index(),
			column = index.column,
			row = index.getRow(this._grid);
		if (row instanceof DataRow) {
			v = this._super();
		} else {
			group = (row instanceof GroupRow) ? row : row.parent();
            row = group.firstLeaf();
			v = row.getValue(index.dataField());
		}
        callback = column.mergeValueCallback();
        if (callback) {
            v = callback(row, column, v);
        } else {
            node = this._exprNode;
            if (node) {
                this._runtime.setValue(row, column.dataIndex(), v);
                v = node.evaluate(this._runtime);
            }
        }
        return v;
	},
    $_setMergeValue: function (node, runtime) {
        this._exprNode = node;
        this._runtime = runtime;
        return this;
    }
});
var MergedSeriesCell = defineClass("MergedSeriesCell", SeriesCell, {
	init: function(grid, name) {
		this._super(grid, name || "mergedSeriesCell");
        this._room = null;
	},
    room: function () {
        return this._room;
    },
    merged: function () {
        return true;
    }
});
var MergedChartCell = defineClass("MergedChartCell", MergedSeriesCell, {
    init : function(grid) {
        this._super(grid, "mergedChartCell");
    },
    chart: function () {
        var config = this._index.column.chart();
        if (config) {
            return new GridChart(this._grid).loadChart(config);
        } else {
            return null;
        }
    }
});
var MergedDataCellElement = defineClass("MergedDataCellElement", DataCellElement, {
	init: function(dom) {
		this._super(dom, "mergedDataCellView");
        this._topIndex = -1;
        this._bottomIndex = -1;
        this._hoverIndex = -1;
        this._selRanges = [];
		this._rowBottom = 0;
	},
    groupRow: function () {
        return this._mergeRoom && this._mergeRoom._group;
    },
	splittable: function () {
		return true;
	},
	mergeRoom: function () {
		return this._mergeRoom;
	},
	$_setMergeRoom: function (value) {
		this._mergeRoom = value;
	},
    $_setHoverIndex: function (grid, x, y) {
        var r = this.$_calcInnerIndex(grid, x, y);
        r = r >= 0 ? r - this._mergeRoom.headItem() : r;
        if (r != this._hoverIndex) {
            this._hoverIndex = r;
            this.invalidate(false, true);
        }
    },
	_doDraw: function (g, needOpaque) {
		this._rowView = this._fixed ? this.grid()._fixedBodyView : this.grid()._bodyView;
		this._super(g, needOpaque);
	},
	_doRenderHtml: function (rc) {
		this._super(rc);
	},
	/*,
	_doPrepareValue: function (cell) {
		this._super(cell);
	},
	_doPrepareElement: function (model) {
		this._super(model);
	},
	_doUpdateContent: function (cell) {
		this._super(cell);
	},
	_doRenderCell: function (g, r) {
		this._super(g, r);
	},
	*/
	$_canSelected: function () {
		return true;
	},
    $_calcInnerIndex: function (grid, x, y) {
        var k, r,
            lm = grid.lm(),
            p = grid.containerToElement(x, y);
        y -= lm.bodyBounds().y;
        for (k = this._topIndex; k <= this._bottomIndex; k++) {
            r = lm.itemBounds(k);
            if (y >= r.y && y < r.bottom()) {
                return k + grid.topIndex();
            }
        }
        if (k - 1 == this._bottomIndex && y >= r.bottom()) {
            return k + grid.topIndex();
        }
        return -1;
    }
});
var MergedSeriesCellElement = defineClass("MergedSeriesCellElement", SeriesCellElement, {
	init: function(dom, name) {
		this._super(dom, name || "mergedSeriesCellView");
        this._topIndex = -1;
        this._bottomIndex = -1;
		this._rowBottom = 0;
	},
	splittable: function () {
		return true;
	},
	mergeRoom: function () {
		return this._mergeRoom;
	},
	_doDraw: function (g, needOpaque) {
		this._rowView = this.grid()._bodyView;
		this._super(g, needOpaque);
	},
	_doRenderHtml: function (rc) {
		this._super(rc);
	},
	$_setMergeRoom: function (value) {
		this._mergeRoom = value;
	},
	$_canSelected: function () {
		return true;
	},
    $_setHoverIndex: function (grid, x, y) {
        var r = this.$_calcInnerIndex(grid, x, y);
        r = r >= 0 ? r - this._mergeRoom.headItem() : r;
        if (r != this._hoverIndex) {
            this._hoverIndex = r;
        }
    },
    $_calcInnerIndex: function (grid, x, y) {
        var k, r,
            lm = grid.lm(),
            p = grid.containerToElement(x, y);
        y -= lm.bodyBounds().y;
        for (k = this._topIndex; k <= this._bottomIndex; k++) {
            r = lm.itemBounds(k);
            if (y >= r.y && y < r.bottom()) {
                return k + grid.topIndex();
            }
        }
        if (k - 1 == this._bottomIndex && y >= r.bottom()) {
            return k + grid.topIndex();
        }
        return -1;
    }
});
var MergedChartCellElement = defineClass("MergedChartCellElement", MergedSeriesCellElement, {
    init: function(dom) {
        this._super(dom, "mergedChartCellView");
    },
    canEditable: function () {
        return false;
    },
	splittable: function () {
		return false;
	},
    _doUpdateContent: function (model) {
        this._super(model);
        var chart = model.chart();
        if (chart) {
            if (!this._chartView) {
                this._chartView = new GridChartView(this._dom, this.container());
                this.addChild(this._chartView);
            }
            chart.setItemSource(model);
            this._chartView.setModel(chart);
        } else if (this._chartView) {
            this.removeChild(this._chartView);
            this._chartView = null;
        }
    },
    _doLayoutContent: function (lm) {
        this._super(lm);
        if (this._chartView) {
            var r = this._getRenderRect();
            this.deflatePadding2(r);
            this._chartView.setRectI(r);
            this._chartView.layoutContent(lm);
        }
    },
    _doRenderCell: function (g, r) {
    },
	$_canSelected: function () {
		return true;
	}
});
var MergedHeaderElement = defineClass("MergedHeaderElement", RowElement, {
	init: function(dom) {
		this._super(dom, "mergedHeaderView");
		this._cellView = new RowGroupHeaderCellElement(dom);
		this.addElement(this._cellView);
	},
    cellView: function () {
        return this._cellView;
    },
	setFixed: function (fixed) {
	},
	_doUpdateElement: function (styles) {
		this._super(styles);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this._cellView.updateCell(this.grid().rowGroup().getHeaderCell(this.rowIndex()));
		this._cellView.setRect(this.clientRect());
	},
	_doRender: function (g, r) {
		/*
		g.beginFill(0xffff00, 0.2);
		g.drawRect(r.x, r.y, r.width, r.height);
		g.endFill();
		*/
	}
});
var MergedFooterElement = defineClass("MergedFooterElement", RowElement, {
	init: function(dom, fixed) {
		this._super(dom, "mergedFooterView");
		this._fixed = fixed;
		this._cells = [];
	},
	fixed: false,
    setFixed: function(value) {
        this._fixed = value;
    },
	_doUpdateElement: function(styles) {
		this._super(styles);
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doLayoutContent: function(lm) {
		this.$_prepareCells(lm);
		this.$_layoutCells(lm);
	},
	_doRender: function(g, r) {
	},
	$_prepareCells: function (lm) {
        var i, column, view, index, model,
		    grid = this.grid(),
            level = this.item().parent().level(),
            fixed = lm.fixedColCount(),
            start = Math.max(level, this._fixed ? 0 : lm.firstCol()),
            end = this._fixed ? fixed - 1 : lm.lastCol(),
            rowGroup = grid.rowGroup();
		if (grid.columnLayoutChanged()) {
			this.clear();
			this._cells = [];
		}
		this.hideAll();
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
			view = _cast(this._cells[column.$_hash], CellElement);
			if (!view) {
				if (column instanceof ColumnGroup) {
					view = new GroupFooterGroupCellElement(this._dom);
				} else {
					view = new GroupFooterCellElement(this._dom);
				}
				this._cells[column.$_hash] = view;
				this.addElement(view);
			}
			view.setVisible(true);
			index = CellIndex.temp(this.item().index(), column);
			model = rowGroup.getFooterCell(index);
            view.updateCell(model);
			if (view instanceof GroupFooterCellElement) {
			} else {
			}
		}
	},
	$_layoutCells: function (lm) {
        var i, view, r,
		    level = this.item().parent().level(),
		    fixed = lm.fixedColCount(),
		    start = Math.max(level, this._fixed ? 0 : lm.firstCol()),
		    end = this._fixed ? fixed - 1 : lm.lastCol(),
		    x = this.x(),
		    h = this.height();
		for (i = start; i <= end; i++) {
			view = this._cells[lm.getColumn(i).$_hash];
			r = lm.columnBounds(i);
			r.x -= x;
			r.height = h;
			view.setRect(r);
			view.layoutContent(lm);
		}
	}
});
var GridMergeHeaderElement = defineClass("GridMergeHeaderElement", VisualObjectElement, {
	init: function(dom) {
		this._super(dom, "mergedHeadersContainer", null);
		this._views = [];
		this._headerMap = {};
	},
	clearHeaders: function() {
		var i, view;
		this._views = [];
		this._headerMap = {};
		for (i = this.childCount() - 1; i >= 0; i--) {
			view = this.getChild(i);
			view.setVisible(false);
			this._views.push(view);
		}
	},
	addHeader: function(header) {
		var view = this._headerMap[header._id];
		if (!view) {
			view = this._views.length > 0 ? this._views.pop() : null;
			if (!view) {
				view = new MergedHeaderElement(this._dom);
				this.addElement(view);
			}
			view._item = header;
			this._headerMap[header._id] = view;
		}
		view.setVisible(true);
	},
	getHeaderView: function(header) {
		return this._headerMap[header._id];
	},
	getCellView: function(index) {
		var header = _cast(index.getRow(this._grid), MergedGroupHeader);
		if (header) {
			return this._headerMap[header._id];
		}
		return null;
	},
	isLayer: function () {
		return true;
	},
	_doAttached: function (parent) {
		this._super(parent);
		this._headIndex = new CellIndex();
		this._tailIndex = new CellIndex();
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this.$_layoutHeaders(lm);
	},
	_doDraw: function(g) {
	},
	$_layoutHeaders: function (lm) {
        var h, view, header, idx, r, c, x, 
		    grid = this.grid(),
		    styles = grid.rowGroup().headerStyles(),
		    leftPos = lm.leftPos(),
		    topIndex = grid.topIndex(),
		    fixedCols = lm.fixedColCount(),
		    fixedItems = lm.fixedItemCount(),
		    fixedWidth = lm.fixedWidth(),
		    w = this.width();
		for (h in this._headerMap) {
			view = this._headerMap[h];
			header = view.item();
            idx = header.index();
			view.updateElement(header, styles);
			idx = (idx < fixedItems) ? idx : idx - topIndex;
			r = lm.itemBounds(idx);
			r.width = w;
			c = header.level() - 1;
			x = lm.columnBounds(c).right();
			if (fixedCols > 0) {
				if (c >= fixedCols) {
					x = Math.max(x + fixedWidth - leftPos, fixedWidth);
				} else if (c == fixedCols - 1) {
					x = fixedWidth;
				}
			} else if (fixedCols == 0) {
				x -= leftPos;
			}
			r.setLeft(x);
			r.width -= leftPos;
			view.setRectI(r);
			view.layoutContent(lm);
		}
		this._views = null;
	}
});
var GridMergeElement = defineClass("GridMergeElement", VisualObjectElement, {
	init: function (dom, fixed) {
		this._super(dom, "mergeLayer", null);
		this._fixed = fixed;
		this._footerLayer = new LayerElement(dom, "mergedFooterLayer");
		this.addElement(this._footerLayer);
		this._cellLayer = new LayerElement(dom, "mergedCellLayer");
		this.addElement(this._cellLayer);
		this._roomMap = {};
		this._scopeViews = {};
		this._footerMap = {};
		this._footerViews = [];
	},
	fixed: function () { return this._fixed; },
	clearFooters: function () {
		this._footerViews = [];
		this._footerMap = {};
		for (var i = this._footerLayer.childCount(); i--;) {
			var view = this._footerLayer.getChild(i);
			view.setVisible(false);
			this._footerViews.push(view);
		}
	},
	addFooter: function (footer) {
		var view = this._footerMap[footer._id];
		if (!view) {
			view = this._footerViews.pop();
			if (!view) {
				view = new MergedFooterElement(this._dom, this._fixed);
				this._footerLayer.addElement(view);
			}
			view._item = footer;
			this._footerMap[footer._id] = view;
		}
		view.setVisible(true);
	},
	clearRooms: function () {
		var i, view, room, views;
		this._roomMap = {};
		for (i = this._cellLayer.childCount() - 1; i >= 0; i--) {
			view = this._cellLayer.getChild(i);
			view.setVisible(false);
			room = view.mergeRoom();
			views = this.$_getViews(room.scope());
			if (views.indexOf(view) < 0) {
				views.push(view);
			}
		}
	},
	addColumnRooms: function (column, rooms) {
		var i, room, view,
			views = this.$_getViews(column);
		for (i = rooms.length - 1; i >= 0; i--) {
			room = rooms[i];
			if (views.length > 0) {
				view = views.pop();
			} else {
				view = this._createElement(room);
				this._cellLayer.addElement(view);
			}
			view.setVisible(true);
			view.$_setMergeRoom(room);
			this._roomMap[room.$_hash] = view;
		}
	},
	getCellView: function (index) {
		var view, room, r, row;
		for (r in this._roomMap) {
			view = this._roomMap[r];
			room = view.mergeRoom();
            if (room.contains(index)) {
				return view && view.visible() ? view : null;
			}
		}
		row = index.getRow(this._grid);
		if (row instanceof MergedGroupFooter) {
			return this._footerMap[row._id];
		}
		return null;
	},
	getFooterView: function (footer) {
		return this._footerMap[footer._id];
	},
    findRowView: function (rowIndex) {
    },
	isLayer: function () {
		return true;
	},
	_doAttached: function (parent) {
		this._super(parent);
		this._headIndex = new CellIndex();
		this._tailIndex = new CellIndex();
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this.$_layoutCells(lm);
		this.$_layoutFooters(lm);
	},
	_doDraw: function(g) {
	},
	$_getViews: function (scope) {
		var views = this._scopeViews[scope.$_hash];
		if (!views) {
			views = [];
			this._scopeViews[scope.$_hash] = views;
		}
		return views;
	},
	_createElement: function (room)/* DataCellElement */ {
		var column, view = null;
		if (room instanceof ColumnMergeRoom) {
			column = room.column();
            if (column instanceof ChartColumn) {
                view = new MergedChartCellElement(this._dom);
            } else
            if (column instanceof SeriesColumn) {
				view = new MergedSeriesCellElement(this._dom);
			} else if (column instanceof DataColumn) {
				view = new MergedDataCellElement(this._dom);
			}
		}
		return view;
	},
	$_layoutFooters: function (lm) {
        var f, view, footer, idx, r, c, x,
		    styles = this.grid().rowGroup().footerStyles(),
		    fixedCols = lm.fixedColCount(),
		    fixedItems = lm.fixedItemCount(),
		    topIndex = lm.topIndex(),
		    itemCount = lm.itemCount(),
		    fixed = this._fixed,
            leftPos = fixedCols > 0 ?  lm.leftPos() : 0;
		for (f in this._footerMap) {
			view = this._footerMap[f];
			footer = view._item;
            idx = footer.index();
            view.updateElement(footer, styles);
			idx = (idx < fixedItems) ? idx : idx - topIndex;
			if (idx < 0 || idx >= itemCount + fixedItems) {
				throw new Error("Invalid MergedGroupFooter index: " + idx);
			}
			r = lm.itemBounds(idx, fixed);
			if (fixed) {
				c = footer.parent().level();
				x = lm.columnBounds(c).x;
				r.setLeft(x);
			} else {
				c = Math.max(fixedCols, footer.parent().level());
				x = lm.columnBounds(c).x;
				r.setLeft(x);
			}
			view.setRect(r);
            /*
            if (!fixed) {
			 _console && _trace('%%%%%%%%%%%%%%% ' + r.x);
                if (leftPos > 0 && r.x > leftPos) {
                    r.y = 0;
                    r.x = leftPos;
                    r.width -= leftPos;
                    view.setMask(r);
                } else {
                    view.setMask(null);
                }
            }
            */
			view.layoutContent(lm);
		}
		this._footerViews = null;
	},
	$_layoutCells: function (lm) {
		var cell, r, x, w, i, y, i2, group, col, h, views,
			hash, view, room,
			map = this._roomMap,
			grid = this.grid(),
			merged = grid.rowGroup().mergeMode(),
			mergeExpander = grid.rowGroup().expanderVisible(),
			topItem = grid.topRow(),
			topIndex = grid.topIndex(),
			itemCount = lm.itemCount(),
			fixedItems = lm.fixedItemCount();
		for (hash in map) {
			view = map[hash];
			room = view.mergeRoom();
			room.getHead(this._headIndex);
			if (this._headIndex.rowIndex - topItem > itemCount - 1) {
				view.setVisible(false);
				views = this.$_getViews(room.column());
				if (views.indexOf(view) < 0) {
					views.push(view);
				}
				continue;
			}
			room.getTail(this._tailIndex);
			cell = grid.body().getCell(this._headIndex, room);
			view._fixed = this._fixed;
			view.updateCell(cell);
            col = this._headIndex.column;
            if (col.group()) {
                r = col._layoutRect.clone();
                r.x += lm.columnBounds(col._parent.displayIndex()).x;
            } else {
                r = lm.columnBounds(col.displayIndex());
            }
			x = r.x;
			w = r.width;
			i = Math.min(fixedItems + itemCount - 1, Math.max(fixedItems, this._headIndex.rowIndex - topIndex));
			r = lm.itemBounds(i);
            view._topIndex = i;
			y = r.y;
			i2 = this._tailIndex.rowIndex;
			group = room.group();
			i2 = Math.min(fixedItems + itemCount - 1, Math.max(fixedItems, i2 - topIndex));
            view._bottomIndex = i2;
			r = lm.itemBounds(i2);
			h = r.bottom() - y;
			view.setBoundsI(x, y, w, h);
			if (view instanceof MergedDataCellElement) {
				view.setExpanderVisible(merged && mergeExpander && group != null);
			}
			view.layoutContent(lm);
		}
	},
	$_clearSelections: function () {
		var h, view,
			map = this._roomMap;
		for (h in map) {
			view = map[h];
			view.$_setSelected(false);
		}
	},
	$_setSelections: function (selItems) {
		var h, view, selected, i, sel, rng, r1, r2, row1, row2, ranges, rows, cnt, filled, room, can,
            grid = this.grid(),
			mergedSel = grid.displayOptions().mergedSelection(),
            top = grid.topIndex(),
			body = grid.body(),
            bodyView = grid.bodyView(),
            lm = grid.lm(),
            itemCount = lm.itemCount(),
			len = selItems.length,
			map = this._roomMap,
            idx = GridMergeElement.$_index;
		for (h in map) {
			view = map[h];
			can = view.$_canSelected();
			selected = false;
            ranges = undefined;
			for (i = len; i--;) {
                sel = selItems[i];
				if (sel.intersects(view._index, idx.assign(view._index).setRowIndex(view.mergeRoom().tailItem()))) {
					selected = true;
					if (mergedSel && can) break;
                    if (!ranges) {
						rows = [];
                        ranges = [];
                        view.$_setSelStyles(_isMobile() ? body.mobileSelectionStyles() : body.selectionStyles());
                    }
                    rng = sel.getBounds();
					rows.push({r1: row1 = rng.R1(), r2: row2 = rng.R2()});
                    if (row2 >= top && row1 < top + itemCount) {
                        r1 = grid.translateBy(view, bodyView.boundsBy(grid, lm.getItemBounds(Math.max(0, row1 - top))));
                        r2 = grid.translateBy(view, bodyView.boundsBy(grid, lm.getItemBounds(Math.max(0, Math.min(itemCount - 1, row2 - top)))));
                        ranges.push(r1.y, r2.bottom());
                    } else {
                        ranges.push(0, 0);
                    }
				}
			}
			if (ranges) {
                room = view.mergeRoom();
				cnt = rows.length;
				if (cnt > 1) {
					rows.sort(function (r1, r2) {
						return r1.r1 - r2.r1;
					});
				}
				filled = rows[0].r1 <= room.headItem() && rows[cnt - 1].r2 >= room.tailItem();
				if (filled && cnt > 1) {
					filled = true;
					for (i = cnt - 1; i > 0; i--) {
						r1 = rows[i];
						r2 = rows[i - 1];
						if (r1.r1 > r2.r2 + 1) {
							filled = false;
							break;
						}
					}
				}
                if (filled) {
                    ranges = undefined;
                }
			}
			view.$_setSelected(selected && can, ranges);
		}
	}
}, {
    $_index: new CellIndex()
});
var GridBaseOptions = defineClass("GridBaseOptions", null, {
    init: function (grid) {
        this._super();
        this._grid = grid;
    },
    stylesChanged: function (/*stypeProp*/) {
        this._layoutOwner();
    },
    grid: function () {
        return this._grid;
    },
    _invalidateOwner: function () {
        this._grid && this._grid.invalidate();
    },
    _layoutOwner: function () {
        this._grid && this._grid.invalidateLayout();
    },
    _refreshOwner: function () {
        this._grid && this._grid.refreshView();
    },
    _invalidateEditor: function () {
        var ec = this._grid && this._grid.editController();
        if (ec) {
            ec.invalidateEditor();
            ec.reprepareEditor(this._grid.$_focusedIndex());
        }
    },
    _refreshEditor: function () {
        this._refreshOwner();
        this._invalidateEditor();
    }
});
var DisplayOptions = defineClass("DisplayOptions", GridBaseOptions, {
    init: function (grid) {
        this._super(grid);
        this._tooltipStyles = new GridStyles(null, "tooltip");
        this._rowHoverMask = new RowHoverMask(grid);
    },
    focusBorder: null,
    innerFocusBorder: null,
    summaryMode: EnumProp(SummaryMode, SummaryMode.AGGREGATE),
    hideDeletedRows: false,
    columnResizable: true,
    checkChildColumnResizable: true,
    columnMovable: true,
    columnExcludable: false,
    hideColumnWhenExcluded: true,
    parentChangable: false,
    defaultColumnWidth: 120,
    fitStyle: EnumProp(GridFitStyle, GridFitStyle.NONE),
    rowResizable: false,
    rowHeight: 0,
    minRowHeight: 4,
    maxRowHeight: 0,
    variableRowHeight: false,
    liveScroll: true,
    horzLiveScroll: true,
    hintDuration: 2000,
    rowChangeDelay: 0,
    horzScrollStep: 8,
    emptyGridMessage: null,
    emptyDataMessage: null,
    checkDataInited: false,
    heightMeasurer: null,
    fillWhenResized: true,
    focusVisible: true,
    bubbleWheelEvents: true,
    wheelDelta: 3,
    horzWheelDelta: 16,
    customItemsVisible: true,
    rightClickable: true,
    fixedColumnCount: 0,
    fixedRowCount: 0,
    fixedColumnResizable: false,
    fixedRowResizable: false,
    fixedColumnMovable: false,
    fixedColumnExcludable: false,
    preventSystemMenu: false,
    alertCellError: true,
    focusable: true,
    autoRowFocus: true,
    hideBordersWhenFitted: true,
    keepSelection: true,
    rowHoverMask: null,
    cursorCallback: null, // function (index: CellIndex): Cursors || undefined
    showTooltip: true,
    tooltipStyles: null,
    tooltipLineBreak: true,
    tooltipMaxWidth: IntProp_0,
    tooltipMinWidth: IntProp_0,
    tooltipDelay: IntProp(400),
    tooltipDuration: IntProp(4000),
    tooltipAnimation: false,
    includeHeaderWhenFitColumn: false,
    nanText: null,
    setFocusBorder: function (value) {
        if (value !== this._focusBorder) {
            this._focusBorder = _createStroke(value);
            this._refreshOwner();
        }
        return this;
    },
    setInnerFocusBorder: function (value) {
        if (value !== this._innerFocusBorder) {
            this._innerFocusBorder = _createStroke(value);
            this._refreshOwner();
        }
        return this;
    },
    setSummaryMode: function (value) {
        if (_checkEnumValue(SummaryMode, value) != this._summaryMode) {
            this._summaryMode = value;
            this._grid && this._grid.$_summaryModeChanged();
        }
        return this;
    },
    hideDeletedRows_: function () {
        return this._grid && this._grid.itemSource().hideDeleted();
    },
    setHideDeletedRows: function (value) {
        this._grid && this._grid.itemSource().setHideDeleted(value);
        return this;
    },
    showSingleSelection: {
        value: false,
        set: function (value) {
            if (value != this._showSingleSelection) {
                this._showSingleSelection = value;
                if (this._grid && this._grid.selections().isSingleCell()) {
                    this._refreshOwner();
                }
            }
            return this;
        }
    },
    mergedSelection: {
        value: false,
        set: function (value) {
            if (value != this._mergedSelection) {
                var grid = this._grid;
                this._mergedSelection = value;
                grid && grid.clearSelection();
                grid && grid.selections().isSingleCell() && grid.refreshView();
            }
            return this;
        }
    },
    selectDisplay: {
        value: SelectionDisplay.MASK,
        set: function (value) {
            if (value != this._selectDisplay) {
                var grid = this._grid;
                grid && grid.clearSelection();
                this._selectDisplay = value;
                grid && grid.selections().isSingleCell() && grid.refreshView();
            }
            return this;
        }
    },
    selectMode: {
        value: SelectionMode.SINGLE,
        set: function (value) {
            this._selectMode = value;
            this._grid && this._grid.clearSelection();
            return this;
        }
    },
    selectStyle: {
        value: SelectionStyle.BLOCK,
        set: function (value) {
            if (value != this._selectStyle) {
                var grid = this._grid;
                if (grid) {
                    var sels = grid.selections();
                    if (sels.count() > 0) {
                        var item = sels.getItem(0);
                        var rng = item.getBounds();
                        sels.clear();
                        if (value != SelectionStyle.NONE) {
                            sels.setItemStyle(value);
                            if (this._keepSelection) {
                                var row, column;
                                if (value == SelectionStyle.SINGLE_ROW || value == SelectionStyle.SINGLE_COLUMN || value == SelectionStyle.SINGLE) {
                                    sels.add(grid.focusedIndex().clone(), null, value);
                                } else {
                                    sels.add(new CellIndex(rng.R1(), rng.C1()), new CellIndex(rng.R2(), rng.C2()), value);
                                }
                            } else {
                                sels.add(new CellIndex(rng.R1(), rng.C1()), new CellIndex(rng.R1(), rng.C1()), value);
                            }
                        }
                    }
                }
                this._selectStyle = value;
            }
            return this;
        }
    },
    setFitStyle: function (value) {
        if (_checkEnumValue(GridFitStyle, value) != this._fitStyle) {
            this._fitStyle = value;
            this._refreshOwner();
        }
        return this;
    },
    setRowHeight: function (value) {
        value = Math.max(0, value);
        if (value != this._rowHeight) {
            this._rowHeight = value;
            this._refreshOwner();
        }
        return this;
    },
    setMinRowHeight: function (value) {
        value = Math.max(0, value);
        if (value != this._minRowHeight) {
            this._minRowHeight = value;
            this._refreshOwner();
        }
        return this;
    },
    setMaxRowHeight: function (value) {
        value = Math.max(0, value);
        if (value != this._maxRowHeight) {
            this._maxRowHeight = value;
            this._refreshOwner();
        }
        return this;
    },
    setVariableRowHeight: function (value) {
        if (value != this._variableRowHeight) {
            this._variableRowHeight = value;
            this._refreshOwner();
        }
        return this;
    },
    setHeightMeasurer: function (value) {
        if (value != this._heightMeasurer) {
            this._heightMeasurer = value;
            this._grid.setHeightMeasurer(this._grid._createHeightMeasurer(value));
        }
        return this;
    },
    setFillWhenResized: function (value) {
        if (value != this._setFillWhenResized) {
            this._setFillWhenResized = value;
            this._refreshOwner();
        }
        return this;
    },
    setFocusVisible: function (value) {
        if (value != this._focusVisible) {
            this._focusVisible = value;
            this._refreshOwner();
        }
        return this;
    },
    setFixedColumnCount: function (value) {
        value = Math.max(0, value);
        if (value != this._fixedColumnCount) {
            this._fixedColumnCount = value;
            this._refreshOwner();
        }
        return this;
    },
    setFixedRowCount: function (value) {
        value = Math.max(0, value);
        if (value != this._fixedRowCount) {
            this._fixedRowCount = value;
            this._grid && this._grid.fixedRowsChanged();
        }
        return this;
    },
    setHideBordersWhenFitted: function (value) {
        if (value != this._hideBordersWhenFitted) {
            this._hideBordersWhenFitted = value;
            this._refreshOwner();
        }
        return this;
    },
    setRowHoverMask: function (value) {
        if (value !== this._rowHoverMask) {
            this._rowHoverMask.assign(value);
            this._refreshOwner();
        }
        return this;
    },
    setEmptyGridMessage: function (value) {
        if (value !== this._emptyGridMessage) {
            this._emptyGridMessage = value;
            this._grid && this._grid.isEmptyColumns() && this._refreshOwner();
        }
        return this;
    },
    setEmptyDataMessage: function (value) {
        if (value !== this._emptyDataMessage) {
            this._emptyDataMessage = value;
            this._grid && this._grid.isEmptyData() && this._refreshOwner();
        }
        return this;
    },
    setCheckDataInited: function (value) {
        if (value !== this._checkDataInited) {
            this._checkDataInited = value;
            this._refreshOwner();
        }
        return this;
    },
    setNanText: function (value) {
        if (value !== this._nanText) {
            this._nanText = value;
            this._refreshOwner();
        }
        return this;
    },
    setCursorCallback: function (value) {
        if (!_isFunction(value)) value = null;
        this._cursorCallback = value;
    },
    setTooltipStyles: function (value) {
        if (value !== this._tooltipStyles) {
            this._tooltipStyles.extend(value);
        }
        return this;
    },
    checkColumnExcludable: function (column) {
        return column.fixed() ? this._fixedColumnExcludable : this._columnExcludable;
    }
});
var EditOptions = defineClass("EditOptions", GridBaseOptions, {
    init: function (grid) {
        this._super(grid);
        this._validations = new EditValidationCollection();
        this._dateWriter = null;
        this._boolWriter = null;
        this._numberWriter = null;
        this._boolReader = null;
        this._dateReaders = null;
        this._numberCharExp = _isArray(this._pasteNumberChars) ? this.$_createNumberCharExp(this._pasteNumberChars) : null;
    },
    readOnly: false,
    editable: true,
    checkable: true,
    updatable: true,
    appendable: false,
    insertable: false,
    deletable: false,
    erasable: false,
    revertable: false,
    undoable: true,
    updateByCell: false,
    insertByCell: false,
    cancelWhenUndo: true, // 마지막 편집 이력에서 undo하면 cancel
    fixedColumnEditable: true,
    fixedRowEditable: true,
    deletedRowEditable: false,
    fixedColumnReadOnly: false,
    fixedRowReadOnly: false,
    deletedRowReadOnly: true,
    editWhenFocused: false,
    commitKey: null,
    commitWhenNoEdit: false,
    commitOnLastCell: false,
    crossWhenExitLast: false,
    crossWhenExitFirst: false,
    hideOnLastCell: true,
    validateOnEdited: true,
    validateOnExit: false,
    hintOnError: true,
    deleteMessage: null,
    confirmWhenDelete: true,
    editWhenClickFocused: false,
    commitLevel: EnumProp(ValidationLevel, ValidationLevel.IGNORE),
    useTabKey: true,
    moveByArrowKeys: true,
    moveInSelection: true,
    skipReadOnly: false,
    keepFocusedWhenSelecting: true,
    enterToTab: true,
    enterToNextRow: false,
    enterToEdit: false,
    forceInsert: false,
    forceAppend: false,
    checkDiff: false,
    checkCellDiff: false,
    strictDiff: false,
    deletableWhenEdit: true,
    eraseWheDelete: false,
    showCommitError: true,
    validations: null,
    validateAtStart: false,
    firstCellWhenInsert: false,
    appendWhenInsertKey: false,
    appendWhenExitLast: false,
    showOnlyValidationMessage: true,
    /* copy properties */
    copyEnabled: true,
    singleCopy: false,
    copyDatetimeFormat: null,
    copyBooleanFormat: null,
    copyNumberFormat: null,
    useStyleFormats: true,
    copyCallback: null,     // function (row:GridRow, column: ValueColumn, field:DataField, value):String
    /* paste properties */
    pasteEnabled: true,
    singlePaste: false,
    pasteByCell: false,
    pasteDatetimeFormats: null,
    pasteBooleanFormat: null,
    pasteNumberChars: [','],
    pasteCallback: null,    // function (row:GridRow, field:DataField, text):*
    maskWhenPaste: false,
    startEditWhenPaste: true,
    commitWhenPaste: true,
    enableAppendWhenPaste: true,
    fillFieldDefaultsWhenPaste: false,
    fillColumnDefaultsWhenPaste: false,
    forceRowValidationWhenPaste: false,
    forceColumnValidationWhenPaste: false,
    stopPasteOnError: true,
    selectionBasePaste: false,
    noEditEventWhenPaste: false,
    noDataEventWhenPaste: false,
    checkReadOnlyWhenPaste: true,
    checkReadOnlyWhenErase: true,
    fontName: 'Tahoma',
    fontSize: '10pt',
    minEditorHeight: 22,
    noSelectWhenEdit: false,
    autoCommit: false,
    aletInvalidFormatError: true,
    invalidFormatMessage: undefined,
    alertMinLengthError: true,
    minLengthMessage: undefined,
    rowEventsWhenCheckAll: false,
    readOnlyCallback: null,
    editableCallback: null,
    hideEditorOnFailed: false,
    showEditorWhenDblClicked: true,
    mergedWhenUpdating: false,
    useCopyKey: true,
    forceButtonVisible: false,
    allowKeysOnMenu: false,
    setUpdatable: function (value) {
        if (value != this._updatable) {
            this._updatable = value;
            this._refreshEditor();
        }
        return this;
    },
    setAppendable: function (value) {
        if (value != this._appendable) {
            this._appendable = value;
            this._refreshEditor();
        }
        return this;
    },
    setInsertable: function (value) {
        if (value != this._insertable) {
            this._insertable = value;
            this._refreshEditor();
        }
        return this;
    },
    setReadOnly: function (value) {
        if (value != this._readOnly) {
            this._readOnly = value;
            this._refreshEditor();
        }
        return this;
    },
    setEditable: function (value) {
        if (value != this._editable) {
            this._editable = value;
            this._refreshEditor();
        }
        return this;
    },
    setFixedColumnEditable: function (value) {
        if (value != this._fixedColumnEditable) {
            this._fixedColumnEditable = value;
            this._refreshEditor();
        }
        return this;
    },
    setFixedRowEditable: function (value) {
        if (value != this._fixedRowEditable) {
            this._fixedRowEditable = value;
            this._refreshEditor();
        }
        return this;
    },
    setDeletedRowEditable: function (value) {
        if (value != this._deletedRowEditable) {
            this._deletedRowEditable = value;
            this._refreshEditor();
        }
        return this;
    },
    setFixedColumnReadOnly: function (value) {
        if (value != this._fixedColumnReadOnly) {
            this._fixedColumnReadOnly = value;
            this._refreshEditor();
        }
        return this;
    },
    setFixedRowReadOnly: function (value) {
        if (value != this._fixedRowReadOnly) {
            this._fixedRowReadOnly = value;
            this._refreshEditor();
        }
        return this;
    },
    setDeletedRowReadOnly: function (value) {
        if (value != this._deletedRowReadOnly) {
            this._deletedRowReadOnly = value;
            this._refreshEditor();
        }
        return this;
    },
    setEditableCallback: function (value) {
        var value = _asFunction(value);
        if (value !== this._editableCallback) {
            this._editableCallback = value;
            this._refreshEditor();
        }
        return this;
    },
    setReadOnlyCallback: function (value) {
        var value = _asFunction(value);
        if (value !== this._readOnlyCallback) {
            this._readOnlyCallback = value;
            this._refreshEditor();
        }
        return this;
    },
    setValidations: function (value) {
        this._validations.assign(value);
        return this;
    },
    setCheckDiff: function (value) {
        this._checkDiff = value;
        this._diffsChanged();
    },
    setCheckCellDiff: function (value) {
        this._checkCellDiff = value;
        this._diffsChanged();
    },
    setStrictDiff: function (value) {
        this._strictDiff = value;
        this._diffsChanged();
    },
    setCopyDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            if (value) {
                this._dateWriter = new DateTimeWriter(value);
            } else {
                this._dateWriter = null;//DateTimeWriter.DEFAULT;
            }
        }
        return this;
    },
    setCopyBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._boolWriter = new BooleanFormatter(value);
            } else {
                this._boolWriter = null;
            }
        }
        return this;
    },
    setCopyNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
            if (value) {
                this._numberWriter = new DecimalFormatter(value);
            } else {
                this._numberWriter = null;
            }
        }
        return this;
    },
    setCopyCallback: function (value) {
        if (!_isFunction(value)) value = null;
        this._copyCallback = value;
    },
    setPasteDatetimeFormats: function (value) {
        if (value != this._datetimeFormats) {
            if (_isArray(value)) {
                this._datetimeFormats = value.concat();
            } else if (value) {
                this._datetimeFormats = [value];
            } else {
                this._datetimeFormats = null;
            }
            if (this._datetimeFormats) {
                this._dateReaders = [];
                for (var i = 0; i < this._datetimeFormats.length; i++) {
                    this._dateReaders.push(new DateTimeReader(this._datetimeFormats[i]));
                }
            } else {
                this._dateReaders = null;
            }
        }
        return this;
    },
    setPasteBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._boolReader = new BooleanConverter(value);
            } else {
                this._boolReader = null;
            }
        }
        return this;
    },
    $_createNumberCharExp: function (chars) {
        var s = "[";
        for (var i = 0; i < chars.length; i++) {
            var c = chars[i];
            if (c == "\\") {
                s += "\\" + c;
            } else {
                s += c;
            }
        }
        s += "]";
        return new RegExp(s, "g");
    },
    setPasteNumberChars: function (value) {
        if (value != this._numberChars) {
            this._numberChars = value;
            if (value && value.length > 0) {
                this._numberCharExp = this.$_createNumberCharExp(value);
            } else {
                this._numberCharExp = null;
            }
        }
        return this;
    },
    setPasteCallback: function (value) {
        if (!_isFunction(value)) value = null;
        this._pasteCallback = value;
    },
    canUpdate: function () {
        return !this._readOnly && this._updatable;
    },
    canInsert: function () {
        return !this._readOnly && this._insertable;
    },
    canAppend: function () {
        return !this._readOnly && this._appendable;
    },
    canDelete: function () {
        return !this._readOnly && this._deletable;
    },
    dateWriter: function () {
        return this._dateWriter;
    },
    boolWriter: function () {
        return this._boolWriter;
    },
    numberWriter: function () {
        return this._numberWriter;
    },
    dateReaders: function () {
        return this._dateReaders;
    },
    boolReader: function () {
        return this._boolReader;
    },
    pasteNumberCharExp: function () {
        return this._numberCharExp;
    },
    getDeleteRowsMessage: function () {
        return this._deleteMessage || GridLocale._default.deleteRowsConfirm;
    },
    $_getDateWriter: function (column) {
        var w = this._dateWriter;
        if (!w && column && this._useStyleFormats) {
            var f = column.styles().datetimeFormat();
            if (f) {
                w = DateTimeWriter.getWriter(f);
            }
        }
        return w;
    },
    $_getBoolWriter: function (column) {
        var w = this._boolWriter;
        if (!w && column && this._useStyleFormats) {
            var f = column.styles().booleanFormat();
            if (f) {
                w = BooleanFormatter.getFormatter(f);
            }
        }
        return w;
    },
    $_getNumberWriter: function (column) {
        var w = this._numberWriter;
        if (!w && column && this._useStyleFormats) {
            var f = column.styles().numberFormat();
            if (f) {
                w = DecimalFormatter.getFormatter(f);
            }
        }
        return w;
    },
    _diffsChanged: function () {
        this._grid && this._grid.$_checkDiffsChanged();
    }
});
var OperateOptions = defineClass("GroupingOptions", GridBaseOptions, {
    init: function (grid, config) {
        this._super(grid);
        this._sortHandleRendererObj = new DefaultSortHandleRenderer();
        this._filterHandleRendererObj = new DefaultFilterHandleRenderer();
        this._sortingToast = new ToastOptions({
            visible: false,
            resourceId: 'sortingToast'
        });
        this._filterSelector = new FilterSelectorOptions();
        this._filteringToast = new ToastOptions({
            visible: false,
            resourceId: 'filteringToast'
        });
        this._groupingToast = new ToastOptions({
            visible: false,
            resourceId: 'groupingToast'
        });
        config && this.assign(config);
    },
    sortMode: EnumProp(SortMode, SortMode.AUTO),
    sortingEnabled: true,
    sortStyle: EnumProp(SortStyle, SortStyle.EXCLUSIVE),
    sortHandleVisibility: EnumProp(HandleVisibility, HandleVisibility.VISIBLE),
    sortHandleRenderer: null,
    alwaysSorting: true,
    triStateSorting: true,
    exceptFixedRowsFromSorting: true,
    commitBeforeSorting: true,
    sortingToast: null,
    keepFocusedRowWhenSort: false,
    sortTextCase: EnumProp(SortCase, SortCase.SENSITIVE),
    filteringEnabled: true,
    filterMode: EnumProp(FilterMode, FilterMode.AUTO),
    dataStateFiltering: true,
    dataTagFiltering: false,
    passiveFiltering: false, // true면 최대한 남긴다
    sortFirst: false,
    filterHandleVisibility: EnumProp(HandleVisibility, HandleVisibility.VISIBLE),
    filterHandleRenderer: null,
    commitBeforeFiltering: true,
    filterSelector: null,
    filteringToast: null,
    exceptFixedRowsFromFiltering: true,
    groupingEnabled: true,
    expandWhenGrouping: true,
    summarizeWhenGrouping: true,
    commitBeforeGrouping: true,
    commitBeforeExpand: true,
    commitBeforeCollapse: true,
    mergeGroupedColumnsFixed: true,
    groupingToast: null,
    groupSorting: true,
    groupSortDirection: EnumProp(SortDirection, SortDirection.ASCENDING),
    groupSortCase: EnumProp(SortCase, SortCase.SENSITIVE),
    pageSorting: true,
    pageFiltering: true,
    $_getRs: function () {
        return this._grid && this._grid.rowSource();
    },
    sortMode_: function () {
        var rs = this.$_getRs();
        return rs ? rs.sortMode() : this._sortMode;
    },
    setSortMode: function (value) {
        var rs = this.$_getRs();
        var v = _checkEnumValue(SortMode, value);
        rs ? rs.setSortMode(v) : (this._sortMode = v);
        return this;
    },
    filterMode_: function () {
        var rs = this.$_getRs();
        return rs ? rs.filterMode() : this._filterMode;
    },
    setFilterMode: function (value) {
        var rs = this.$_getRs();
        var v = _checkEnumValue(FilterMode, value);
        rs ? rs.setFilterMode(v) : (this._filterMode = v);
        return this;
    },
    dataStateFiltering_: function () {
        var rs = this.$_getRs();
        return rs ? rs.dataStateFiltering() : this._dataStateFiltering;
    },
    setDataStateFiltering: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setDataStateFiltering(value) : (this._dataStateFiltering = v);
        return this;
    },
    dataTagFiltering_: function () {
        var rs = this.$_getRs();
        return rs ? rs.dataTagFiltering() : this._dataTagFiltering;
    },
    setDataTagFiltering: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setDataTagFiltering(value) : (this._dataTagFiltering = v);
        return this;
    },
    passiveFiltering_: function () {
        var rs = this.$_getRs();
        return rs ? rs.passiveFiltering() : this._passiveFiltering;
    },
    setPassiveFiltering: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setPassiveFiltering(value) : (this._passiveFiltering = value);
        return this;
    },
    sortFirst_: function () {
        var rs = this.$_getRs();
        return rs ? rs.sortFirst() : this._sortFirst;
    },
    setSortFirst: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setSortFirst(value) : (this._sortFirst = value);
        return this;
    },
    pageSorting_: function () {
        var rs = this.$_getRs();
        return rs ? rs.pageSorting() : this._pageSorting;
    },
    setPageSorting: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setPageSorting(value) : (this._pageSorting = value);
        return this;
    },
    pageFiltering_: function () {
        var rs = this.$_getRs();
        return rs ? rs.pageFiltering() : this._pageFiltering;
    },
    setPageFiltering: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setPageFiltering(value) : (this._pageFiltering = value);
        return this;
    },
    setSortHandleRenderer: function (value) {
        this._sortHandleRendererObj.assign(value);
    },
    setSortHandleVisibility: function (value) {
        if (_checkEnumValue(HandleVisibility, value) != this._sortHandleVisibility) {
            this._sortHandleVisibility = value;
            this._refreshOwner();
        }
        return this;
    },
    alwaysSorting_: function () {
        var rs = this.$_getRs();
        return rs ? rs.alwaysSorting() : this._alwaysSorting;
    },
    setAlwaysSorting: function (value) {
        var rs = this.$_getRs();
        rs ? rs.setAlwaysSorting(value) : (this._alwaysSorting = value);
        return this;
    },
    setExceptFixedRowsFromSorting: function (value) {
        if (value != this._exceptFixedRowsFromSorting) {
            this._exceptFixedRowsFromSorting = value;
            this._grid && this._grid.fixedRowsChanged();
        }
        return this;
    },
    setSortingToast: function (value) {
        if (value != this._sortingToast) {
            this._sortingToast.assign(value);
        }
        return this;
    },
    setFilterHandleRenderer: function (value) {
        this._filterHandleRendererObj.assign(value);
    },
    setFilterSelector: function (value) {
        this._filterSelector.assign(value);
        return this;
    },
    setFilteringToast: function (value) {
        this._filteringToast.assign(value);
        return this;
    },
    setGroupingToast: function (value) {
        if (value != this._groupingToast) {
            this._groupingToast.assign(value);
        }
        return this;
    },
    setExceptFixedRowsFromFiltering: function (value) {
        if (value != this._exceptFixedRowsFromFiltering) {
            this._exceptFixedRowsFromFiltering = value;
            this._grid && this._grid.fixedRowsChanged();
        }
    },
    propertyChanged: function () {
        this._grid && this._grid.operateOptionsChanged();
        this._layoutOwner();
    },
    $_sortHandleRenderer: function () {
        return this._sortHandleRendererObj;
    },
    $_filterHandleRenderer: function () {
        return this._filterHandleRendererObj;
    }
});
var FilterSelectorOptions = defineClass("FilterSelectorOptions", null, {
    init: function (config) {
        this._super();
        this._styles = new GridStyles(null, "filterSelector");
        config && this.assign(config);
    },
    minWidth: null,
    maxWidth: null,
    minHeight: null,
    maxHeight: null,
    styles: null,
    closeWhenClick: false,
    setMinWidth: function (value) {
        this._minWidth = value ? PercentSize.createFrom(value) : undefined;
        return this;
    },
    setMaxWidth: function (value) {
        this._maxWidth = value ? PercentSize.createFrom(value) : undefined;
        return this;
    },
    setMinHeight: function (value) {
        this._minHeight = value ? PercentSize.createFrom(value) : undefined;
        return this;
    },
    setMaxHeight: function (value) {
        this._maxHeight = value ? PercentSize.createFrom(value) : undefined;
        return this;
    },
    setStyles: function (value) {
        if (value !== this._styles) {
            this._styles.extend(value);
        }
        return this;
    },
    getMinWidth: function (width) {
        return this._minWidth ? this._minWidth.getSize(width) : undefined;
    },
    getMaxWidth: function (width) {
        return this._maxWidth ? this._maxWidth.getSize(width) : undefined;
    },
    getMinHeight: function (height) {
        return this._minHeight ? this._minHeight.getSize(height) : undefined;
    },
    getMaxHeight: function (height) {
        return this._maxHeight ? this._maxHeight.getSize(height) : undefined;
    }
});
var EffectOptions = defineClass("EffectOptions", GridBaseOptions, {
    init: function (grid, config) {
        this._super(grid);
    },
    animationEnabled: false,
    setAnimationEnabled: function (value) {
        if (value != this._animationEnabled) {
            this._animationEnabled = value;
            if (!value) {
                if (this.grid().stopAnimations()) {
                    this._refreshOwner();
                }
            }
        }
    }
});
var ValueColumn = defineClass("ValueColumn", GridColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._mergeRule = null;
        this._mergeValueNode = null;
		this._rendererChanged = false;
		this._rendererObj = null;
	},
	rendererChanged: function (renderer) {
		if (renderer == this._rendererObj) {
			this._changed();
		}
	},
	renderer: null,
	displayCallback: null, 		// function (index:CellIndex, value):String
    styleCallback: null,	    // function (CellIndex, GridStyles, merged):void;
	summaryCallback: null,		// function (column):Number - NaN을 리턴하면 계산하지 않은 것으로 판단.
	mergeExpression: null,
	mergeCallback: null,		// function (row:GridRow, column:ValueColumn):*
    mergeValueExpression: null,
    mergeValueCallback: null,	// function (row:GridRow, column:ValueColumn, value):*
    cursor: null,
	ignoreRowDynamicStyles: false,
    ignoreDefaultDynamicStyles: false,
	blankWhenCopy: false,
	blankWhenExport: false,
    copyCallback: null,     	// function (row:GridRow, field:DataField, value):String
    pasteCallback: null,    	// function (row:GridRow, field:DataField, text):*
	tooltipCallback: null,		// function (index): String;
    valueType: null,
	mergeRule: function () {
		return (this._mergeExpression || this._mergeCallback) ? this._mergeRule : null;
	},
	rendererObj: function () {
		return this._rendererObj || this._defaultRenderer();
	},
	setRenderer: function (value) {
		if (value != this._renderer) {
            var obj = this._rendererObj;
            if (obj && _isObject(value) && (!value.Type || value.type == obj.$_type)) {
                obj.assign(value);
            } else if (obj && value == obj.$_type) {
                return;
            } else {
                this._rendererChanged = true;
            }
            this._renderer = value;
			this._changed();
		}
	},
	setDisplayCallback: function (value) {
		value = _asFunction(value);
		if (value !== this._displayCallback) {
			this._displayCallback = value;
			var grid = this.grid();
			grid && grid.refreshView();
		}
	},
    setStyleCallback: function (value) {
        if (value !== this._styleCallback) {
            this._styleCallback = _asFunction(value);
            this._changed();
        }
    },
	setSummaryCallback: function (value) {
		if (value !== this._summaryCallback) {
			this._summaryCallback = _asFunction(value);
			var grid = this.grid();
			grid && grid.clearRowSummary();
			this._changed();
		}
		return this;
	},
	setMergeExpression: function (value) {
		if (value != this._mergeExpression) {
			if (value && !this._mergeRule) {
				this._mergeRule = new ColumnMergeRule;
			}
			this._mergeRule.setCriteria(value);
			this._mergeExpression = value;
			if (!this._mergeCallback) {
				var grid = this.grid();
				grid && grid._columnMergeRuleChanged(this);
			}
		}
	},
	setMergeCallback: function (value) {
		value = _asFunction(value);
		if (value !== this._mergeCallback) {
			if (value && !this._mergeRule) {
				this._mergeRule = new ColumnMergeRule();
			}
			this._mergeRule.setCallback(value);
			this._mergeCallback = value;
			var grid = this.grid();
			grid && grid._columnMergeRuleChanged(this);
		}
	},
    setMergeValueExpression: function (value) {
        if (value != this._mergeValueExpression) {
            this._mergeValueExpresson = value;
            this._mergeValueNode = value ? ExpressionParser.Default.parse(value, null) : null;
            if (this._mergeRule && this._mergeRule.active()) {
                var grid = this.grid();
                grid && grid.refreshView();
            }
        }
    },
    setMergeValueCallback: function (value) {
        value = _asFunction(value);
        if (value != this._mergeValueCallback) {
            this._mergeValueCallback = value;
            if (this._mergeRule && this._mergeRule.active()) {
                var grid = this.grid();
                grid && grid.refreshView();
            }
        }
    },
    setCopyCallback: function (value) {
        if (!_isFunction(value)) value = null;
        this._copyCallback = value;
    },
	setPasteCallback: function (value) {
		if (!_isFunction(value)) value = null;
		this._pasteCallback = value;
	},
	dataIndex: function () {
		return -1;
	},
	assign: function (source) {
		this._super(source);
	},
    canMerge: function () {
        return this._mergeRule !== null;
    },
    prepareLayout: function (grid, fixed) {
		this._super(grid, fixed);
        this.$_styleCallback = this._styleCallback || grid._body._styleCallback;
        if (this._rendererChanged) {
			var delegate = grid.delegate();
			this._rendererObj = delegate.createRenderer(this._renderer, this);
			this._rendererChanged = false;
		}
	},
	clean: function () {
		this._super();
		this._footer.clean();
	},
	_footerChanged: function () {
		this._changed();
	},
	_defaultRenderer: function () {
		return TextCellRenderer.Default;
	}
}); 
var DataColumn = defineClass("DataColumn", ValueColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._dataIndex = -1;
		this._dataFieldName = null;
		this._valueType = ValueType.TEXT;
		this._sortOrder = -1;
        this._sortDirection = SortDirection.ASCENDING;
		this._menu = null;
		this._images = null;
		this._lookupSource = null;
		this._lookupKeyFields = null;
		this._lookupKeyFieldIds = null;
		this._lookupMap = null;
		this._labelFieldIndex = -1;
		this._mergeGrouped = false;
		this._editorOptions = {};
		this._filters = new ColumnFilterCollection(this);
		this._filters.addListener(this);
        this._autoFilter = new ColumnAutoFilter(this);
		this._dynamicStyles = new DynamicStyleCollection(this);
		this._validations = new EditValidationCollection();
		this._animations = new AnimationInfoCollection(this);
        this._defExprNode = null;
        this._menuChanged = false;
	},
	editCallback: null,	     // function (index:CellIndex, editResult:Object):Void
    editTextCallback: null, // function (index:CellIndex, value:*):String
	fieldIndex: -1,
	fieldName: null,
	editable: true,
    editableCallback: null, // function (index:CellIndex):Boolean
    readOnlyCallback: null, // function (index:CellIndex):Boolean
	readOnly: false,
    erasable: true,
    imeMode: EnumProp(ImeMode, ImeMode.AUTO),
    emptyValue: undefined,
	sortable: true,
	filterable: true,
	groupable: true,
	button: EnumProp(CellButton, CellButton.NONE),
	buttonDisplayCallback: null, // function (index:CellIndex):Boolean
    buttonVisibility: EnumProp(ButtonVisibility, ButtonVisibility.DEFAULT),
    editorButtonVisibility: EnumProp(ButtonVisibility, ButtonVisibility.DEFAULT),
    customButtons: null,
	popupMenu: null,
	popupMenuCallback: null,// function (CellIndex): *;
	required: false,
	requiredMessage: null,
	requiredLevel: EnumProp(ValidationLevel, ValidationLevel.ERROR),
	defaultValue: undefined,
    defaultExpression: null,
    defaultCallback: null, // function (DataColummn):*;
	minimum: NaN,
	maximum: NaN,
	maxLength: 0,
	nanText: null,
	dynamicStyles: null,
	validations: null,
	animations: null,
	autoFilter: null,
	lookupDisplay: false,
	lookupCase: EnumProp(LookupCase, LookupCase.SENSITIVE),
	lookupValues: null,
	lookupLabels: null,
	labelField: null,
	lookupSourceId: null,
	lookupKeyFields: null,
	editor: null,
	editorCallback: null, 	// function (index:CellIndex):String;
	imageList: null,
	groupLevel: -1,
	filters: null,
	error: null,
	errorLevel: EnumProp(ValidationLevel, ValidationLevel.IGNORE),
	excelFormat: undefined,
	textInputCase: EnumProp(TextInputCase, TextInputCase.NORMAL),
    setEditableCallback: function (value) {
		value = _asFunction(value);
		if (value !== this._editableCallback) {
			this._editableCallback = value;
			var grid = this.grid();
			grid && grid._editColumnChanged(this);
		}
    },
    setReadOnlyCallback: function (value) {
        value = _asFunction(value);
		if (value !== this._readOnlyCallback) {
			this._readOnlyCallback = value;
			var grid = this.grid();
			grid && grid._editColumnChanged(this);
		}
    },
	setEditable: function (value) {
		if (value != this._editable) {
			this._editable = value;
			var grid = this.grid();
			grid && grid._editColumnChanged(this);
		}
        return this;
	},
	setReadOnly: function (value) {
		if (value != this._readOnly) {
			this._readOnly = value;
			var grid = this.grid();
			grid && grid._editColumnChanged(this);
		}
        return this;
	},
    setDefaultExpression: function (value) {
        value = trim(value);
        if (value != this._defaultExpression) {
            this._defaultExpression = value;
            this._defExprNode = value ? ExpressionParser.Default.parse(value) : undefined;
            this._changed();
        }
    },
    setDefaultCallback: function (value) {
        if (value !== this._defaultCallback) {
            this._defaultCallback = _asFunction(value);
            this._changed();
        }
    },
	setValidations: function (value) {
		if (value != this._validations) {
			this._validations.assign(value);
		}
		return this;
	},
	setAnimations: function (value) {
		if (value != this._animations) {
			this._animations.assign(value);
		}
		return this;
	},
	filters_: function () {
		return this._filters.items();
	},
	setFilters: function (value) {
        if (value != this._filters) {
            this._filters.assign(value);
        }
        return this;
	},
	setAutoFilter: function (value) {
		if (value !== this._autoFilter) {
			this._autoFilter.assign(value);
		}
		return this;
	},
	setLookupValues: function (value) {
		if (value != this._lookupValues) {
			this._lookupValues = value && value.slice();
			this._lookupMap = null;
			this._changed();
		}
        return this;
	},
	setLookupLabels: function (value) {
		if (value != this._lookupLabels) {
			this._lookupLabels = value && value.slice();
			this._lookupMap = null;
			this._changed();
		}
        return this;
	},
	labelFieldIndex: function () {
		return this._labelFieldIndex;
	},
	lookupSource: function () {
		return this._lookupSource;
	},
	setLookupKeyFields: function (value) {
		if (value != this._lookupKeyFields) {
			if (value && !isArray(value)) {
				value = [value];
			}
			this._lookupKeyFields = value;
			this._changed();
		}
        return this;
	},
	lookupKeyFieldIds: function () {
		return this._lookupKeyFieldIds;
	},
	setDynamicStyles: function (value) {
        if (value != this._dynamicStyles) {
            this._dynamicStyles.setItems(value);
            this._changed();
        }
        return this;
	},
	setEditor: function (value) {
		if (typeof value == "string") {
			this._editor = value;
		} else if (value) {
			if (value.hasOwnProperty("type")) {
				this._editor = value.type;
			}
			this._editorOptions = this._editorOptions || {};
			for (var prop in value) {
				var v = value[prop];
				if (v === undefined) {
					delete this._editorOptions[prop];
				} else if (_isArray(v)) {
					this._editorOptions[prop] = v.slice();
				} else {
					this._editorOptions[prop] = v;
				}
			}
		}
        this._editorChanged();
        return this;
	},
    setPopupMenu: function (value) {
        if (value != this._popupMenu) {
            this._popupMenu = value;
            this._menuChanged = true;
        }
        return this;
    },
	setPopupMenuCallback: function (value) {
		if (value !== this._popupMenuCallback) {
			this._popupMenuCallback = _asFunction(value);
		}
		return this;
	},
    setCustomButtons: function (value) {
        if (value !== this._customButtons) {
            var i, b,
                buttons = null;
            if (_isArray(value)) {
                for (i = 0; i < value.length; i++) {
                    b = value[i];
                    if (!(b instanceof CustomButton) && _isObject(b) && _isFunction(b.callback)) {
                        b = new CustomButton(b);
                    }
                    if (b) {
                        buttons = buttons || [];
                        buttons.push(b);
                    }
                }
            }
            this._customButtons = buttons;
        }
    },
	editorOptions: function () {
		return this._editorOptions;
	},
	dataIndex: function () {
		return this._dataIndex;
	},
	dataFieldName: function () {
		return this._dataFieldName;
	},
	valueType: function () {
		return this._valueType;
	},
	sortOrder: function () {
		return this._sortOrder;
	},
	sortDirection: function () {
		return this._sortDirection;
	},
	hasFilters: function () {
		return this._filters.count() > 0 || this._autoFilter.active(); //this._filterActions.length > 0
	},
	/** @deprecated Use filtered() instead. */
	isFiltered: function () {
		return this.filtered();
	},
	filtered: function () {
		return this._filters.activeCount() > 0 || this._autoFilter.checkedCount() > 0;
	},
	$_images: function () {
		return this._images;
	},
	/** @deprecated Use mergeGrouped() instead. */
	isMergeGrouped: function () {
		return this._mergeGrouped;
	},
	mergeGrouped: function () {
		return this._mergeGrouped;
	},
	/** @deprecated Use getDataField() instead. */
	getField: function () {
		return this.getDataField();
	},
    getDataField: function () {
        var grid, ds,
            f = this._dataIndex;
        if (f >= 0) {
            grid = this.grid();
            ds = grid.dataSource();
            if (ds) {
                return ds.getField(f);
            }
        }
        return null;
    },
	getLookupLabel: function (value) {
        var lookupValues, lookupLabels, i, label;
		if (!this._lookupMap) {
			lookupValues = this._lookupValues;
			lookupLabels = this._lookupLabels;
			if (lookupValues && lookupValues.length > 0) {
				this._lookupMap = {};
				for (i = 0; i < lookupValues.length; i++) {
					if (lookupLabels && lookupLabels.length > i) {
						this._lookupMap[lookupValues[i]] = lookupLabels[i];
					} else {
						this._lookupMap[lookupValues[i]] = lookupValues[i];
					}
				}
			}
		}
		label = this._lookupMap ? this._lookupMap[value] : undefined;
		return label ? label : value;
	},
	getLookupIndex: function (value) {
		if (this._lookupValues && this._lookupValues.length > 0) {
			for (var i = 0, cnt = this._lookupValues.length; i < cnt; i++) {
				if (this._lookupValues[i] == value) {
					return i;
				}
			}
		}
		return -1;
	},
	getLookupValue: function (index) {
		if (this._lookupValues && this._lookupValues.length > 0) {
			return this._lookupValues[index];
		}
		return undefined;
	},
	getSourceValue: function (label) {
		var lookupValues = this._lookupValues;
		var lookupLabels = this._lookupLabels;
		if (lookupLabels && lookupValues) {
			var i = lookupLabels.indexOf(label);
			if (i >= 0 && lookupValues.length > i) {
				return lookupValues[i];
			}
			i = lookupValues.indexOf(label);
			if (i >= 0) {
				return lookupValues[i];
			}
		}
		return undefined;
	},
	/*
	getEditorOptions: function (props) {
        var options = this._editorOptions;
		if (typeof props === "string") {
			return options ? options[props] : undefined;
		} else if (options) {
			var v, p;
			if (_isArray(props)) {
				v = {};
				for (var i = props.length; i--;) {
					p = props[i];
					if (options.hasOwnProperty(p)) {
						v[p] = options[p];
					}
				}
				return v;
			} else {
				v = {};
				for (p in options) {
					v[p] = options[p];
				}
				return v;
			}
		} else {
            return {};
        }
	},
	*/
	clearFilters: function () {
		this.setFilters(null);
	},
	addFilters: function (filters, overwrite) {
		if (filters) {
            this._filters.addItems(filters, overwrite);
		}
	},
	removeFilters: function (filterNames) {
		if (filterNames) {
            this._filters.removeItems(_makeArray(filterNames));
		}
	},
	activateFilters: function (filterNames, active) {
		if (filterNames) {
            this._filters.activateItems(_makeArray(filterNames), active);
		}
	},
	activateAllFilters: function (active) {
        this._filters.activateAll(active);
	},
	toggleFilters: function (filterNames) {
        this._filters.toggleItems(_makeArray(filterNames));
	},
	toggleAllFilters: function () {
        this._filters.toggleAll();
	},
	getFilter: function (filterName) {
		return this._filters.getItem(filterName);
	},
	getActiveFilters: function (active) {
		return this._filters.getActiveItems(active);
	},
	assign: function (source) {
		this._super(source);
	},
	clean: function () {
		this._super();
		this._editorDirty = false;
	},
	canMerge: function () {
		return this.dataIndex() >= 0 && (this._mergeGrouped || this._super());
	},
	canEditable: function () {
		return true;
	},
	canEdit: function () {
		return this._editable;
	},
    prepareLayout: function (grid, fixed) {
		var len, i,
			ds = grid.dataSource();
		this._super(grid, fixed);
        if (this._menuChanged) {
            this._menu = this._popupMenu ? grid.popupMenuManager().getMenu(this._popupMenu) : null;
            this._menuChanged = false;
        }
		if (this._saveFieldName != this._fieldName || this._saveLabelField != this._labelField) {
			this._resetDataIndex(ds);
		}
		if (this._lookupKeyFields && (len = this._lookupKeyFields.length) > 0) {
			this._lookupKeyFieldIds = new Array(len);
			for (i = 0; i < len; i++) {
				this._lookupKeyFieldIds[i] = ds.getFieldIndex(this._lookupKeyFields[i]); 
			}
			if (this._lookupSourceId) {
				this._lookupSource = grid.lookupProvider().getSource(this._lookupSourceId);
			} else {
				this._lookupSource = null;
			}
		} else {
			this._lookupKeyFieldIds = null;
			this._lookupSource = null;
		}
        this._images = grid.getImageList(this._imageList);
	},
	/*
	getAdapter: function (adapter) {
		if (adapter === ColumnFilterCollection) {
			return this._filters;
		}
		return this._super(adapter);
	},
	*/
	$_getMenu: function (index) {
		return this._popupMenuCallback ? index.grid().popupMenuManager().getMenu(this._popupMenuCallback(index)) : this._menu;
	},
	_setSortOrder: function (value) {
		this._sortOrder = value;
	},
    _setSortDirection: function (value) {
        this._sortDirection = value;
    },
	_resetDataIndex: function (ds) {
		var fld, grid;
		this._dataIndex = -1;
        this._keyFn = this._keyPath = undefined;
		this._labelFieldIndex = -1;
		if (ds) {
			if (this._fieldName) { 
				this._dataIndex = ds.getFieldIndex(this._fieldName);
			} else {
				this._dataIndex = this._fieldIndex;
			}
			if (this._dataIndex >= 0) {
				this.$_field = fld = ds.getField(this._dataIndex);
				this._valueType = fld._dataType;
				this._dataFieldName = fld._fieldName;
				this._keyPath = fld._keyPath;
                this._keyFn = fld._keyCallback;
			} else {
                this._valueType = undefined;
				this._dataFieldName = null;
			}
			this._labelFieldIndex = ds.getFieldIndex(this._labelField);
			this._saveFieldName = this._fieldName;
			this._saveLabelField = this._labelField;
			grid = this.grid();
			grid && grid._columnMergeRuleChanged(this);
		}
	},
    $_getDefaultValue: function (runtime) {
        if (this._defaultCallback) {
            return this._defaultCallback(this);
        } else if (this._defExprNode) {
            runtime.setColumn(this);
            return this._defExprNode.evaluate(runtime);
        } else {
            return this._defaultValue;
        }
    },
	_setMergeGrouped: function (value) {
		this._mergeGrouped = value;
	},
	_editorChanged: function (value) {
		if (!this._editorDirty) {
			this._editorDirty = true;
			var grid = this.grid();
            grid && grid.$_invalidateEditor(this);
		}
	},
	$_autoFilterChecked: function (index, value, checked) {
		var grid = this.grid();
		grid &&	grid.$_columnFiltersChanged(this._autoFilter);
	},
    $_autoFilterChanged: function (filter) {
        var grid = this.grid();
        grid &&	grid.$_columnFiltersChanged(filter);
    },
    $_buttonClicked: function (index, button) {
        var cb = this._customButtons[button].callback();
        if (cb) {
            cb(index);
            return true;
        }
    },
	onColumnFilterChanged: function (filter) {
        var grid = this.grid();
		grid &&	grid.$_columnFiltersChanged(filter);
	}
});
var LabelColumn = defineClass("LabelColumn", ValueColumn, {
	init: function (config) {
		this._super(config);
		this.setValueType(ValueType.TEXT);
	},
	_initColumn: function () {
		this._super();
	},
	text: "Label"
}, {
	$_columnType: "label"
});
var DerivedColumn = defineClass("DerivedColumn", ValueColumn, {
	init: function (config) {
		this._super(config);
	},
    _initColumn: function () {
        this._super();
    },
    editable: true,
    setEditable: function (value) {
        if (value != this._editable) {
            this._editable = value;
            var grid = this.grid();
            if (grid) {
                grid._editColumnChanged(this);
            }
        }
        return this;
    },
    canEditable: function () {
        return true;
    },
    canEdit: function () {
        return this._editable;
    }
});
var SeriesColumn = defineClass("SeriesColumn", DerivedColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._fieldArray = [];
	},
    cached: false,
	fieldNames: null,
    setCached: function (value) {
        if (value != this._cached) {
            this._cached = value;
            var grid = this.grid();
            grid && grid.$_seriesColumnChanged(this);
        }
    },
	setFieldNames: function (value) {
		if (value != this._fieldNames) {
			this._fieldNames = value;
			this._fieldArray = value ? value.split(",") : [];
		}
	},
    fieldCount: function () {
        return this._fields.length;
    },
	fields: function () {
		return this._fields;
	},
    fieldLabels: function () {
        return this._fieldLabels;
    },
	resetIndices: function (dataSource) {
		this._fields = [];
        this._fieldLabels = [];
		if (dataSource) {
			for (var i = 0, cnt = this._fieldArray.length; i < cnt; i++) {
				var fld = this._fieldArray[i];
				var arr = fld.split("..");
				if (arr.length > 1) {
					var first = dataSource.getFieldIndex(arr[0]);
					var last = dataSource.getFieldIndex(arr[1]);
					if (first >= 0 && last >= 0) {
						var f1 = Math.min(first, last);
						var f2 = Math.max(first, last);
						for (var j = f1; j <= f2; j++) {
							this._fields.push(j);
                            this._fieldLabels.push(dataSource.getFieldLabel(j));
						}
					}
				} else {
					var f = dataSource.getFieldIndex(fld);
					if (f >= 0) {
						this._fields.push(f);
                        this._fieldLabels.push(dataSource.getFieldLabel(f));
					}
				}
			}
		}
        var grid = this.grid();
        grid && grid.$_seriesColumnChanged(this);
	},
    getField: function (index) {
        return this._fields[index];
    },
    getFieldName: function (index) {
        return this._fields[index].fieldName();
    },
    getValue: function (row) {
        if (row) {
            if (this._cached && !row.isEditing()) {
                var tag = this._dataTag;
                if (tag) {
                    return tag.getValues(row.dataIndex());
                }
            } else {
                var fields = this._fields;
                var cnt;
                if (fields && (cnt = fields.length) > 0) {
                    var vals = new Array(cnt);
                    for (var i = 0; i < cnt; i++) {
                        if (fields[i] >= 0) {
                            vals[i] = row.getValue(fields[i]);
                        }
                    }
                    return vals;
                }
            }
        }
        return [];
    },
    clearCache: function () {
        this._dataTag && this._dataTag.clearValues();
    },
	_defaultRenderer: function () {
		return SeriesTextCellRenderer.Default;
	},
    $_setDataTag: function (tag) {
        this._dataTag = tag;
    }
}, {
    $_columnType: "series"
});
var CalculatedColumn = defineClass("CalculatedColumn", DerivedColumn, {
    init: function (config) {
        this._super(config);
    },
    _initColumn: function () {
        this._super();
        this._runtime = new CalculatedColumnRuntime(this);
        this._dataTag = undefined;
        this._noRange = true;
        this._dynamicStyles = new DynamicStyleCollection(this);
        this.setValueType(ValueType.NUMBER);
    },
    cached: false,
    calcRange: ColumnCalcRange.ROWS,
    calcBounds: ColumnCalcBounds.GRID,
    nanText: null,
    nanValue: undefined,
    expression: null,
    valueExpression: null,
    valueCallback: null,    // function (column, row):*;
    dynamicStyles: null,
    styleCallback: null,    // function (CellIndex, GridStyles):void;
    excelFormat: undefined,
    setValueType: function (value) {
        if (value != this._valueType) {
            this._valueType = value;
            this._numeric = value == ValueType.NUMBER;
            this._changed();
        }
        return this;
    },
    setCached: function (value) {
        if (value != this._cached) {
            this._cached = value;
            var grid = this.grid();
            grid && grid.$_calculatedColumnChanged(this);
        }
        return this;
    },
    /** @Deprecated use valueExpression instead */
    expression_: function () { return this.valueExpression(); },
    setExpression: function (value) { return this.setValueExpression(value); },
    setValueExpression: function (value) {
        if (value != this._valueExpression) {
            this._valueExpression = value;
            if (value) {
                this._exprNode = ExpressionParser.Default.parse(value, null);
            } else {
                this._exprNode = null;
            }
            this._changed();
            this.clearCache();
        }
        return this;
    },
    setValueCallback: function (value) {
        value = _isFunction(value) ? value : null;
        if (value != this._valueCallback) {
            this._valueCallback = value;
            this._changed();
            this.clearCache();
        }
    },
    setDynamicStyles: function (value) {
        if (value != this._dynamicStyles) {
            this._dynamicStyles.setItems(value);
            this._changed();
        }
        return this;
    },
    setStyleCallback: function (value) {
        if (value !== this._styleCallback) {
            this._styleCallback = _asFunction(value);
            this._changed();
        }
        return this;
    },
    setCalcRange: function (value) {
        if (value != this._calcRange) {
            this._calcRange = value;
            this._noRange = !value || value == ColumnCalcRange.ROWS;
            this.clearCache();
        }
        return this;
    },
    setNanValue: function (value) {
        var v = Number(value);
        if (!isNaN(v) && v !== this._nanValue) {
            this._nanValue = v;
            this._changed();
            this.clearCache();
        }
        return this;
    },
    getValue: function (row) {
        var tag = this._cached && !row.isEditing() && this._dataTag;
        return tag ? tag.getValue(this, row) : this.$_calcValue(row);
    },
    $_calcValue: function (row) {
        var v;
        if (this._valueCallback) {
            v = this._valueCallback(this, row);
        } else if (this._exprNode) {
            this._runtime.setRow(row);
            v = this._exprNode.evaluate(this._runtime);
        }
        if (this._numeric && isNaN(v) && !isNaN(this._nanValue)) {
            v = this._nanValue;
        }
        return v;
    },
    $_calcRange: function (rows, index) {
        var v;
        this._dataTag.$_setRange(rows);
        if (this._valueCallback) {
            v = this._valueCallback(this, rows[index], rows, index, this._dataTag);
        } else if (this._exprNode) {
            this._runtime.setRange(rows, index);
            v = this._exprNode.evaluate(this._runtime);
        }
        if (this._numeric && isNaN(v) && !isNaN(this._nanValue)) {
            v = this._nanValue;
        }
        return v;
    },
    clearCache: function () {
        this._dataTag && this._dataTag.clearValues();
    },
    prepareLayout: function (grid, fixed) {
        this._super(grid, fixed);
        var r, r1, r2, tag = this._dataTag;
        !this._valueCallback && this._runtime.prepare();
        if (this._cached && !this._noRange && tag.hasReqRow()) {
            if (tag.isAllRequested()) {
                tag.calcValues(grid, this, null, null);
            } else {
                r = grid.rowCount();
                r1 = Math.min(tag.firstRequest(), r - 1);
                r2 = Math.min(tag.lastRequest(), r - 1);
                if (r1 <= r2) {
                    tag.calcValues(grid, this, grid.getRow(r1), grid.getRow(r2));
                }
            }
            tag.clearReqRows();
        }
    },
    $_setDataTag: function (tag) {
        this._dataTag = tag;
    }
}, {
    $_columnType: "calced"
});
var ChartColumn = defineClass("ChartColumn", SeriesColumn, {
    init: function (config) {
        this._super(config);
    },
    _initColumn: function () {
        this._super();
    },
    async: false,
    chart: null,
    setChart: function (value) {
        if (value !== this._chart) {
            this._chart = value;
            this._changed();
        }
    },
    refreshChart: function () {
        this._changed();
    },
    _canSplit: function () {
        return false;
    }
}, {
   $_columnType: "chart"
});
var /* @internal */ ColumnGroupProxy = defineClass("ColumnGroupProxy", ColumnGroup, {
	init: function (source) {
        ColumnGroupProxy.Base.init.call(this);
		this._items = null;
		if (source) {
            /*
			this.assignProps(source, [
				"name", "tag", "saveWidth", "width", "fillWidth", "fillHeight",
				"visible", "resizable", "movable",
				"styles",
				"orientation", "hiddenChildHeaders"
			]);
			var header = source.header;
			if (typeof header == "string") {
				this.header().setText(header);
			} else if (header) {
				this.header().assign(header);
			}
             */
            this.assign(source);
		}
	},
	build: function (grid) {
		var columns = ColumnGroupProxy.buildColumns(grid, this._items);
        ColumnGroupProxy.Base.setColumns.call(this, columns);
	},
	setColumns: function (value) {
		this._items = value;
	}
}, {
	buildColumns: function (grid, items) {
		var columns = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = items[i];
                var column;
				if (item instanceof ColumnGroupProxy) {
					item.build(grid);
					columns.push(item);
				} else if (item instanceof GridColumn) {
					columns.push(item);
				} else if (typeof item == "string") {
					column = grid.layoutColumnByName(item);
					if (column) {
                        column.setVisible(true);
						columns.push(column);
					}
				} else if (item && item.name) {
					column = grid.layoutColumnByName(item.name);
					if (column) {
                        /*
						column.assignProps(item, [
							"tag", "saveWidth", "width", "fillWidth", "fillHeight",
							"visible", "resizable", "movable",
							"styles"
						]);
						*/
                        column.setVisible(true);
                        column.assign(item);
						columns.push(column);
					}
				}
			}
		}
		return columns;
	}
}); 
var ColumnLayout = defineClass("ColumnLayout", null, {
	init: function (name, items) {
		Base.init.call(this);
		this._name = name;
		this._items = items;
	},
	name: null,
	items: null,
	build: function (grid) {
		var columns = ColumnGroupProxy.buildColumns(grid, this._items);
		this.$_validate(columns);
		return columns;
	},
	$_validate: function (columns) {
		if (columns && columns.length > 0) {
			var list = [];
			this.$_validateColumns(columns, list);
		}
	},
	$_validateColumns: function (columns, list) {
		for (var i = columns.length - 1; i >= 0; i--) {
			var column = columns[i];
			if (list.indexOf(column) >= 0) {
				throw new Error("Column is dupulicated: " + column.name());
			}
			list.push(column);
			if (column instanceof ColumnGroup) {
				this.$_validateColumns(column.columns(), list);
			}
		}
	}
}, {
	create: function (source) {
        if (source instanceof ColumnLayout) {
            return source;
        } else 	if (source) {
			var items = _isArray(source) ? source : source.columns;
			var colMap = {};
			items = ColumnLayout.$_parseColumns(items, colMap);
			if (items) {
				var layout = new ColumnLayout(_isArray(source) ? null : source.name);
				layout.setItems(items);
				return layout;
			}
		}
		return null;
	},
	$_parseColumns: function (items, colMap) {
		var columns = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var c = items[i];
				var col = null;
				if (typeof c == "string") {
					if (!colMap.hasOwnProperty(c)) {
						colMap[c] = 1;
						col = c;
					}
				} else if (c) {
					if (c.type == "group") {
						col = ColumnLayout.$_parseGroup(c, colMap);
					} else if (c.hasOwnProperty("columns") && _isArray(c.columns) && c.columns.length > 0) {
						col = ColumnLayout.$_parseGroup(c, colMap);
					} else if (c.name) {
						if (!colMap.hasOwnProperty(c.name)) {
							colMap[c.name] = 1;
							col = c;
						}
					}
				}
				if (col) {
					columns.push(col);
				}
			}
		}
		return columns;
	},
	$_parseGroup: function (source, colMap) {
		var group = new ColumnGroupProxy(source);
		var columns = source.columns;
		if (columns) {
			columns = ColumnLayout.$_parseColumns(columns, colMap);
			group.setColumns(columns);
		}
		return group;
	}
}); 
var ColumnLayoutCollection = defineClass("ColumnLayoutCollection", null, {
	init : function() {
		Base.init.call(this);
		this._layouts = [];
	},
	items: function () {
		return this._layouts.concat();
	},
	count: function () {
		return this._layouts.length;
	},
	getItem: function (index) {
		if (index < 0 || index >= this._layouts.length) {
			throw "Invalid ColumnLayoutCollection index: " + index;
		}
		return this._layouts[index];
	},
	find: function (name) {
		for (var i = 0, cnt = this._layouts.length; i < cnt; i++) {
			if (this._layouts[i].name() == name) {
				return this._layouts[i];
			}
		}
		return null;
	},
	clear: function () {
		this._layouts = [];
	},
	load: function (source) {
		if (source) {
			var layout;
			if (_isArray(source)) {
				for (var i = 0, cnt = source.length; i < cnt; i++) {
					layout = ColumnLayout.create(source[i]);
					if (layout) {
						this._layouts.push(layout);
					}
				}
			} else {
				layout = ColumnLayout.create(source);
				if (layout) {
					this._layouts.push(layout);	
				}
			}
		}
	}
}); 
var GridDelegate = defineClass("GridDelegate", null, {
	init : function(grid) {
		this._super();
		this._grid = grid;
        this._dom = grid._dom;
		this._defaultEditor = null;
		this._defaultButtonRenderer = new DefaultCellButtonRenderer();
        this._defaultCustomButtonRenderer = new CustomButtonRenderer();
		this._defaultEditorButtonRenderer = new EditorButtonRenderer();
		this._cellEditors = {};
		this._selectionViews = [];
		this._rowViews = [];
		this._bandedHeaderViews = [];
		this._groupHeaderViews = [];
		this._groupFooterViews = [];
		this._mergedHeaderViews = [];
		this._mergedFooterViews = [];
        this._groupItemViews = {};
        this._cellRenderers = {
            "text": TextCellRenderer,
            "bar": BarCellRenderer,
            "check": CheckCellRenderer,
            "icon": IconCellRenderer,
            "shape": ShapeCellRenderer,
            "signal": SignalBarCellRenderer,
            "image": ImageCellRenderer,
            "link": LinkCellRenderer,
            "button": ButtonCellRenderer,
            "code39": Code39CellRenderer,
            "code128": Code128CellRenderer,
            "circleGauge": CircleGaugeCellRenderer,
            "linearGauge": LinearGaugeCellRenderer,
            "seriesText": SeriesTextCellRenderer,
            "sparkLine": SparkLineRenderer,
            "sparkColumn": SparkColumnRenderer,
            "sparkWinLoss": SparkWinLossRenderer,
            "seriesLegend": SeriesLegendCellRenderer
        }
	},
	isFixed: function () { return this._fixed; },
	prepareResources: function () {
		this._defaultButtonRenderer.prepare(this._grid);
	},
    registerRenderer: function (id, rendererClass) {
        if (id && _isFunction(rendererClass)) {
            this._cellRenderers[id] = rendererClass;
        }
    },
	createRenderer: function (renderer, owner) {
		var options, type, f,
            r = null;
		if (renderer) {
			options = null;
			if (_isString(renderer)) {
				type = renderer;
			} else {
				type = renderer.type || "text";
				options = renderer;
			}
            f = this._cellRenderers[type];
            if (f) {
                r = new f();
            }
			if (r) {
				r._owner = owner;
                r.$_type = type;
				options && r.assign(options);
			}
		}
		return r;
	},
	borrowItemView: function (item, fixed) {
		var view = null;
		if (item instanceof DataRow) {
			view = this._rowViews.pop() || new DataRowElement(this._dom);
			view.setFixed(fixed);
		} else if (item instanceof GroupRowImpl) {
			if (this._grid.rowGroup().displayMode() == RowGroupDisplayMode.BANDED) {
				view = this._bandedHeaderViews.pop() || new BandedRowGroupHeaderElement(this._dom);
			} else {
			}
		} else if (item instanceof MergedGroupFooter) {
			view = this. _mergedFooterViews.pop() || new MergedFooterElement(this._dom);
			view.setFixed(fixed);
		} else if (item instanceof GroupFooter) {
			view = this._groupFooterViews.pop() || new RowGroupFooterElement(this._dom);
			view.setFixed(fixed);
		} else if (item instanceof MergedGroupHeader) {
			view = this._mergedHeaderViews.pop() || new MergedHeaderElement(this._dom);
			view.setFixed(fixed);
		} else if (item instanceof CustomGroupItemRow) {
            var clazz = item.model().constructor.prototype.$name;
            view = this._groupItemViews[clazz];
            if (!view) {
                this._groupItemViews[clazz] = view = item.model().createRowView(this._dom);
            }
        }
		return view;
	},
	returnItemView: function (view) {
		if (view instanceof DataRowElement && this._rowViews.indexOf(view) < 0) {
			this._rowViews.push(view);
		} else if (view instanceof BandedRowGroupHeaderElement && this._bandedHeaderViews.indexOf(view) < 0) {
			this._bandedHeaderViews.push(view);
		} else if (view instanceof RowGroupFooterElement && this._groupFooterViews.indexOf(view) < 0) {
			this._groupFooterViews.push(view);
		} else if (view instanceof MergedHeaderElement && this._mergedHeaderViews.indexOf(view) < 0) {
			this._mergedHeaderViews.push(view);
		} else if (view instanceof MergedFooterElement && this._mergedFooterViews.indexOf(view) < 0) {
			this._mergedFooterViews.push(view);
		} else if (view instanceof GroupRowElement) {
            var clazz = view.item().model().constructor.prototype.$name;
            this._groupItemViews[clazz] = view;
        }
	},
	borrowSelectionView: function (item) {
		var view = this._selectionViews.pop() || (_isMobile() ? new MobileSelectionView(this._dom) : new SelectionView(this._dom));
		return view;
	},
	returnSelectionView: function (view) {
		if (view && this._selectionViews.indexOf(view) < 0) {
			this._selectionViews.push(view);
		}
	},
	getDefaultCellRenderer: function () {
		return TextCellRenderer.Default;
	},
	getCellButtonRenderer: function () {
		return this._defaultButtonRenderer;
	},
    getCustomButtonRenderer: function () {
        return this._defaultCustomButtonRenderer;
    },
    deleteCellEditors: function () {
        if (this._defaultEditor instanceof CellEditor) {
            this._defaultEditor.dispose();
            this._defaultEditor = null;
        }
        for (var t in this._cellEditors) {
            var editor = this._cellEditors[t];
            if (editor instanceof CellEditor) {
                editor.dispose();
            }
        }
        this._cellEditors = {};
    },
	createDefaultCellEditor: function () {
		var parent = this._grid._container._container,
		    editor = new LineCellEditor(this._grid, parent);
        editor.setController(this._grid._editController);
        return editor;
	},
	getDefaultCellEditor: function () {
		if (!this._defaultEditor) {
			var parent = this._grid._container._container;
			this._defaultEditor = new LineCellEditor(this._grid, parent);
            this._defaultEditor.setController(this._grid._editController);
		}
		return this._defaultEditor;
	},
	getCellEditor: function (index) {
        var editorType = this.$_getCellEditorType(index),
            parent = this._grid._container._container,
            editor = this._cellEditors[editorType];
        if (!editor) {
            switch (editorType) {
                case "list":
                    editor = new ListCellEditor(this._grid, parent);
                    break;
                case "multiline":
                    editor = new MultiLineCellEditor(this._grid, parent);
                    break;
                case "number":
                    editor = new NumberCellEditor(this._grid, parent);
                    break;
                case "date":
                    editor = new DateCellEditor(this._grid, parent);
                    break;
                case "search":
                    editor = new SearchCellEditor(this._grid, parent);
                    break;
                case "mask":
                    editor = new MaskCellEditor(this._grid, parent);
                    break;
                case "line":
                default:
                    editor = this.getDefaultCellEditor();
                    break;
            }
            this._cellEditors[editorType] = editor;
		}
		return editor;
	},
    hasEditorButton: function (index) {
        var editorType = this.$_getCellEditorType(index);
        if (editorType) {
            switch (editorType) {
                case "list":
                case "date":
                case "search":
                    return true;
                case "multiline":
                case "number":
                case "mask":
                case "line":
                default:
                    return false;
            }
        }
        return false;
    },
	getCellEditorButtonRenderer: function (index) {
		var editorType,
            renderer = null,
		    column = index.dataColumn();
		if (column) {
			editorType = this.$_getCellEditorType(index);
			renderer = this._defaultEditorButtonRenderer;
			if (editorType == "date") {
				renderer.setButtonType(EditorButtonType.CALENDAR);
			} else {
				renderer.setButtonType(EditorButtonType.COMBO);
			}
		}
		return renderer;
	},
	createGridEventHandler: function () {
		return {
            onGridBaseRowCountChanged: function (grid, newCount, oldCount) {
                grid.onRowCountChanged && grid.onRowCountChanged(grid, newCount, oldCount);
            },
            onGridBaseDisplayRowCountChanged: function (grid, newCount, oldCount) {
                grid.onDisplayRowCountChanged && grid.onDisplayRowCountChanged(grid, newCount, oldCount);
            },
            onGridBaseDescendantRowCountChanged: function (grid, newCount, oldCount) {
                grid.onDescendantRowCountChanged && grid.onDescendantRowCountChanged(grid, newCount, oldCount);
            },
            onGridBaseDescendantDataCountChanged: function (grid, newCount, oldCount) {
                grid.onDescendantDataCountChanged && grid.onDescendantDataCountChanged(grid, newCount, oldCount);
            },
			onGridBaseCurrentChanging: function (grid, newIndex, oldIndex) {
				if (grid.onCurrentChanging) {
                    return grid.onCurrentChanging(grid, newIndex, oldIndex)
                }
			},
			onGridBaseCurrentChanged: function (grid, newIndex) {
				grid.onCurrentChanged && grid.onCurrentChanged(grid, newIndex);
			},
			onGridBaseCurrentRowChanged: function (grid, newRow, oldRow) {
				grid.onCurrentRowChanged && grid.onCurrentRowChanged(grid, newRow, oldRow);
			},
            onGridBaseTopIndexChanged: function (grid, newTop, oldTop) {
                grid.onTopIndexChanged && grid.onTopIndexChanged(grid, newTop, oldTop);
            },
            onGridBaseScrollToBottom: function (grid) {
                grid.onScrollToBottom && grid.onScrollToBottom(grid);
            },
            onGridBaseScrollToTop: function (grid) {
                grid.onScrollToTop && grid.onScrollToTop(grid);
            },
            onGridBaseLeftPosChanged: function (grid, newPos, oldPos) {
                grid.onLeftPosChanged && grid.onLeftPosChanged(grid, newPos, oldPos);
            },
            onGridBaseSelectionChanged: function (grid, selection) {
                grid.onSelectionChanged && grid.onSelectionChanged(grid, selection);
            },
            onGridBaseSelectionAdded: function (grid, selection) {
                grid.onSelectionAdded && grid.onSelectionAdded(grid, selection);
            },
            onGridBaseSelectionRemoved: function (grid) {
                grid.onSelectionRemoved && grid.onSelectionRemoved(grid);
            },
            onGridBaseSelectionCleared: function (grid) {
                grid.onSelectionCleared && grid.onSelectionCleared(grid);
            },
            onGridBaseSelectionResized: function (grid, selection) {
                grid.onSelectionResized && grid.onSelectionResized(grid, selection);
            },
            onGridBaseSelectionEnded: function (grid, selection) {
                grid.onSelectionEnded && grid.onSelectionEnded(grid, selection);
            },
            onGridBaseValidateCell: function (grid, index, inserting, value) {
                grid.onValidateCell && grid.onValidateCell(grid, index, inserting, value);
            },
            onGridBaseValidateRow: function (grid, row, inserting, values) {
                grid.onValidateRow && grid.onValidateRow(grid, row, inserting, values);
            },
            onGridBaseUpdating: function (grid, rowIndex, editor) {
                if (grid.onUpdating) {
                    return grid.onUpdating(grid, rowIndex, editor);
                }
            },
            onGridBaseInserting: function (grid, rowIndex, shift, ctrl) {
                if (grid.onInserting) {
                    return grid.onInserting(grid, rowIndex, shift, ctrl);
                }
            },
            onGridBaseDeleting: function (grid, rows) {
                if (grid.onDeleting) {
                    return grid.onDeleting(grid, rows);
                }
            },
            onGridBaseUpdateStarted: function (grid, row) {
                grid.onUpdateStarted && grid.onUpdateStarted(grid, row);
            },
            onGridBaseInsertStarted: function (grid, row, appending) {
                grid.onInsertStarted && grid.onInsertStarted(grid, row, appending);
            },
            onGridBaseKeyDown: function (grid, key, ctrl, shift, alt) {
                if (grid.onKeyDown) {
                    return grid.onKeyDown(grid, key, ctrl, shift, alt);
                }
            },
            onGridBaseShowEditor: function (grid, index) {
                if (grid.onShowEditor) {
                    return grid.onShowEditor(grid, index);
                }
            },
            onGridBaseEditChange: function (grid, index, value) {
                grid.onEditChanged && grid.onEditChanged(grid, index, value);
            },
            onGridBaseEditCommit: function (grid, index, newValue, oldValue) {
                if (grid.onEditCommitted) {
                    return grid.onEditCommitted(grid, index, newValue, oldValue);
                }
            },
            onGridBaseEditCanceled: function (grid, index, edited) {
                return grid.onEditCanceled && grid.onEditCanceled(grid, index, edited);
            },
            onGridBaseEditSearch: function (grid, index, text) {
                return grid.onEditSearch && grid.onEditSearch(grid, index, text);
            },
            onGridBaseEditCellUpdated: function (grid, row, fieldIndex, newValue, oldValue) {
                return grid.onEditCellUpdated && grid.onEditCellUpdated(grid, row, fieldIndex, newValue, oldValue);
            },
            onGridBaseEditRowCommitted: function (grid, row, editingState) {
                return grid.onEditRowCommitted && grid.onEditRowCommitted(grid, row, editingState);
            },
            onGridBaseEditRowCanceled: function (grid, orgRow, editingState) {
                return grid.onEditRowCanceled && grid.onEditRowCanceled(grid, orgRow, editingState);
            },
            onGridBaseCopy: function (grid, range, data) {
                return grid.onCopy && grid.onCopy(grid, range, data);
            },
            onGridBasePaste: function (grid, index, data) {
                return grid.onPaste && grid.onPaste(grid, index, data);
            },
            onGridBaseEditRowPasted: function (grid, row, fields, newValues, oldValues) {
                return grid.onEditRowPasted && grid.onEditRowPasted(grid, row, fields, newValues, oldValues);
            },
            onGridBasePasted: function (grid, row, updatedCount, appendedCount) {
                return grid.onPasted && grid.onPasted(grid, row, updatedCount, appendedCount);
            },
            onGridBaseRowChecked: function (grid, row, checked) {
                return grid.onRowChecked && grid.onRowChecked(grid, row, checked);
            },
            onGridBaseRowsChecked: function (grid, rows, checked) {
                return grid.onRowsChecked && grid.onRowsChecked(grid, rows, checked);
            },
            onGridBaseCheckedChanged: function (grid, rows) {
                return grid.onCheckedChanged && grid.onCheckedChanged(grid, rows);
            },
            onGridBaseAllCheck: function (grid, checked) {
                if (grid.onAllCheck) {
                    return grid.onAllCheck(grid, checked);
                }
            },
            onGridBaseAllChecked: function (grid, checked) {
                return grid.onAllChecked && grid.onAllChecked(grid, checked);
            },
            onGridBaseErrorClicked: function (grid, index, error) {
                return grid.onErrorClicked && grid.onErrorClicked(grid, index, error);
            },
            onGridBaseSorting: function (grid, fields, directions) {
                if (grid.onSorting) {
                    return grid.onSorting(grid, fields, directions);
                }
            },
            onGridBaseSorted: function (grid) {
                return grid.onSorted && grid.onSorted(grid);
            },
            onGridBaseFiltering: function (grid, column) {
                if (grid.onFiltering) {
                    return grid.onFiltering(grid, column);
                }
            },
            onGridBaseFiltered: function (grid) {
                return grid.onFiltered && grid.onFiltered(grid);
            },
            onGridBaseAutoFilling: function (grid, selection, dir, idx1, idx2) {
                if (grid.onAutoFilling) {
                    return grid.onAutoFilling(grid, selection, dir, idx1, idx2);
                }
            },
            onGridBaseAutoFilled: function (grid, dir, idx1, idx2, result) {
                return grid.onAutoFilled && grid.onAutoFilled(grid, dir, idx1, idx2, result);
            },
            onGridBaseMenuPopup: function (grid, target, menu) {
                return grid.onPopupMenuPopup && grid.onPopupMenuPopup(grid, target, menu);
            },
            onGridBaseMenuItemClicked: function (grid, menuItem) {
                grid.onPopupMenuClicked && grid.onPopupMenuClicked(grid, menuItem);
            },
            onGridBaseContextMenuPopup: function (grid, x, y) {
                if (grid.onContextMenuPopup) {
                    return grid.onContextMenuPopup(grid, x, y);
                }
            },
            onGridBaseContextMenuItemClicked: function (grid, menuItem, index) {
                grid.onContextMenuClicked && grid.onContextMenuClicked(grid, menuItem, index);
            },
            onGridBaseUndoStateChanged: function (grid, canUndo, canRedo) {
                grid.onUndoStateChanged && grid.onUndoStateChanged(grid, canUndo, canRedo);
            },
            onGridBaseColumnWidthChanged: function (grid, column, newWidth, oldWidth) {
                return grid.onColumnWidthChanged && grid.onColumnWidthChanged(grid, column, newWidth, oldWidth);
            },
			onGridBaseColumnHeaderClicked: function (grid, column, rightClicked) {
				return grid.onColumnHeaderClicked && grid.onColumnHeaderClicked(grid, column, rightClicked);
			},
			onGridBaseColumnHeaderDblClicked : function (grid, column) {
				grid.onColumnHeaderDblClicked && grid.onColumnHeaderDblClicked(grid, column);
			},
            onGridBaseColumnChecked: function (grid, column, checked) {
                grid.onColumnChecked && grid.onColumnChecked(grid, column, checked);
            },
            onGridBaseHeaderHeadClicked: function (grid) {
                return grid.onHeaderHeadClicked && grid.onHeaderHeadClicked(grid);
            },
            onGridBaseHeaderHeadDblClicked: function (grid) {
                return grid.onHeaderHeadDblClicked && grid.onHeaderHeadDblClicked(grid);
            },
            onGridBaseRowIndicatorCellClick: function (grid, rowIndex) {
                return grid.onRowIndicatorCellClick && grid.onRowIndicatorCellClick(grid, rowIndex);
            },
			onGridBaseRowIndicatorCellClicked: function (grid, rowIndex) {
				return grid.onRowIndicatorCellClicked && grid.onRowIndicatorCellClicked(grid, rowIndex);
			},
            onGridBaseRowIndicatorCellDblClicked: function (grid, rowIndex) {
                return grid.onRowIndicatorCellDblClicked && grid.onRowIndicatorCellDblClicked(grid, rowIndex);
            },
            onGridBaseStateCellClicked: function (grid, rowIndex) {
                return grid.onStateCellClicked && grid.onStateCellClicked(grid, rowIndex);
            },
            onGridBaseStateCellDblClicked: function (grid, rowIndex) {
                return grid.onStateCellDblClicked && grid.onStateCellDblClicked(grid, rowIndex);
            },
            onGridBaseCheckCellClicked: function (grid, rowIndex) {
                return grid.onCheckCellClicked && grid.onCheckCellClicked(grid, rowIndex);
            },
            onGridBaseCheckCellDblClicked: function (grid, rowIndex) {
                return grid.onCheckCellDblClicked && grid.onCheckCellDblClicked(grid, rowIndex);
            },
            onGridBaseCheckBarHeadClicked: function (grid) {
                return grid.onCheckBarHeadClicked && grid.onCheckBarHeadClicked(grid);
            },
            onGridBaseCheckBarHeadDblClicked: function (grid) {
                return grid.onCheckBarHeadDblClicked && grid.onCheckBarHeadDblClicked(grid);
            },
            onGridBaseFooterCellClicked: function (grid, column) {
                return grid.onFooterCellClicked && grid.onFooterCellClicked(grid, column);
            },
            onGridBaseFooterCellDblClicked: function (grid, column) {
                return grid.onFooterCellDblClicked && grid.onFooterCellDblClicked(grid, column);
            },
            onGridBaseFooterHeadClicked: function (grid) {
                return grid.onFooterHeadClicked && grid.onFooterHeadClicked(grid);
            },
            onGridBaseFooterHeadDblClicked: function (grid) {
                return grid.onFooterHeadDblClicked && grid.onFooterHeadDblClicked(grid);
            },
            onGridBaseHeaderSummaryCellClicked: function (grid, column) {
                return grid.onHeaderSummaryCellClicked && grid.onHeaderSummaryCellClicked(grid, column);
            },
            onGridBaseHeaderSummaryCellDblClicked: function (grid, column) {
                return grid.onHeaderSummaryCellDblClicked && grid.onHeaderSummaryCellDblClicked(grid, column);
            },
            onGridBaseHeaderSummaryHeadClicked: function (grid) {
                return grid.onHeaderSummaryHeadClicked && grid.onHeaderSummaryHeadClicked(grid);
            },
            onGridBaseHeaderSummaryHeadDblClicked: function (grid) {
                return grid.onHeaderSummaryHeadDblClicked && grid.onHeaderSummaryHeadDblClicked(grid);
            },
            onGridBaseRowGroupHeadCellClicked: function (grid, level) {
                grid.onRowGroupHeadCellClicked && grid.onRowGroupHeadCellClicked(grid, level);
            },
            onGridBaseRowGroupHeadCellDblClicked: function (grid, level) {
                grid.onRowGroupHeadCellDblClicked && grid.onRowGroupHeadCellDblClicked(grid, level);
            },
            onGridBaseRowGroupHeaderClicked: function (grid, rowIndex) {
                grid.onRowGroupHeaderClicked && grid.onRowGroupHeaderClicked(grid, rowIndex);
            },
            onGridBaseRowGroupHeaderDblClicked: function (grid, rowIndex) {
                grid.onRowGroupHeaderDblClicked && grid.onRowGroupHeaderDblClicked(grid, rowIndex);
            },
            onGridBaseRowGroupFooterCellClicked: function (grid, index) {
                grid.onRowGroupFooterCellClicked && grid.onRowGroupFooterCellClicked(grid, index);
            },
            onGridBaseRowGroupFooterCellDblClicked: function (grid, index) {
                grid.onRowGroupFooterCellDblClicked && grid.onRowGroupFooterCellDblClicked(grid, index);
            },
            onGridBaseCellButtonClicked: function (grid, index, button) {
                grid.onCellButtonClicked && grid.onCellButtonClicked(grid, index, button);
            },
            onGridBaseEditorButtonClicked: function (grid, index) {
                grid.onEditorButtonClicked && grid.onEditorButtonClicked(grid, index);
            },
            onGridBaseDataButtonClicked: function (grid, index) {
                grid.onDataButtonClicked && grid.onDataButtonClicked(grid, index);
            },
            onGridBaseClickableCellClicked: function (grid, index, source, data) {
                grid.onClickableCellClicked && grid.onClickableCellClicked(grid, index, source, data);
            },
            onGridBaseDataCellClick: function (grid, index) {
                grid.onDataCellClick && grid.onDataCellClick(grid, index);
            },
            onGridBaseDataCellClicked: function (grid, index) {
                grid.onDataCellClicked && grid.onDataCellClicked(grid, index);
            },
            onGridBaseDataCellDblClicked: function (grid, index) {
                grid.onDataCellDblClicked && grid.onDataCellDblClicked(grid, index);
            },
            onGridBaseColumnParentChanged: function (grid, column, newParent, oldParent) {
                grid.onColumnParentChanged && grid.onColumnParentChanged(grid, column, newParent, oldParent);
            },
            onGridBaseColumnMoved: function (grid, column, newIndex, oldIndex) {
                grid.onColumnMoved && grid.onColumnMoved(grid, column, newIndex, oldIndex);
            },
            onGridBaseColumnVisibleChanged: function (grid, column) {
                grid.onColumnVisibleChanged && grid.onColumnVisibleChanged(grid, column);
            },
            onGridBaseExcludeColumn: function (grid, column) {
                grid.onExcludeColumn && grid.onExcludeColumn(grid, column);
            },
            onGridBaseColumnResizing: function (grid, column, newWidth, oldWidth) {
                if (grid.onColumnResizing) {
                    return grid.onColumnResizing(grid, column, newWidth, oldWidth)
                }
            },
            onGridBaseColumnResized: function (grid, column, newWidth, oldWidth) {
                grid.onColumnResized && grid.onColumnResized(grid, column, newWidth, oldWidth)
            },
            onGridBaseRowResizing: function (grid, rowIndex, newHeight, oldHeight) {
                if (grid.onRowResizing) {
                    return grid.onRowResizing(grid, rowIndex, newHeight, oldHeight)
                }
            },
            onGridBaseRowResized: function (grid, rowIndex, newHeight, oldHeight) {
                grid.onRowResized && grid.onRowResized(grid, rowIndex, newHeight, oldHeight)
            }
		};
	},
    $_getCellEditorType: function (index) {
        var s, opt, fn,
            column = index.dataColumn();
        if (column) {
            fn = column.editorCallback();
            if (fn) {
                s = fn(index);
                opt = this._grid.getCellEditor(s);
                if (_isObject(opt)) {
                    s = opt.type || "";
                }
            }
            if (s === undefined) {
                s = column.editor();
            }
            return s && s.toLowerCase();
        }
        return null;
    },
    getCellEditorOptions: function (index) {
        var id, opt, fn,
            column = index.dataColumn();
        if (column) {
            fn = column.editorCallback();
            if (fn) {
                id = fn(index);
                opt = this._grid.getCellEditor(id);
                if (_isObject(opt)) {
                    return opt;
                }
            }
            return column.editorOptions();
        }
        return null;
    }
});
var $$_FONT_HEIGHT_EX = 3;
/** @internal */
var HeightMeasurer = defineClass("HeightMeasurer", null, {
	init : function() {
		this._super();
		this._itemHeight = 0;
		this._headerHeight = 0;
		this._footerHeight = 0;
        this._summaryHeight = 0;
        this._groupHeaderHeight = 0;
        this._groupFooterHeight = 0;
	},
    itemHeight: function () { return this._itemHeight; },
    headerHeight: function () { return this._headerHeight; },
    footerHeight: function () { return this._footerHeight; },
    summaryHeight: function () { return this._summaryHeight; },
    groupHeaderHeight: function () { return this._groupHeaderHeight; },
    groupFooterHeight: function () { return this._groupFooterHeight; },
    calculate: function (grid, body, header, footer, summary, rowGroup) {
    },
    getGroupHeaderHeight: function (row, rowGroup) {
        if (row && rowGroup) {
            var lev = rowGroup.getLevel(row.level() - 1);
            if (lev) {
                var h = lev.headerHeight();
                if (!isNaN(h) && h > 0) return h;
            }
        }
        return this._groupHeaderHeight;
    },
    getGroupFooterHeight: function (row, rowGroup) {
        if (row && rowGroup) {
            var lev = rowGroup.getLevel(row.level() - 1);
            if (lev) {
                var h = lev.footerHeight();
                if (!isNaN(h) && h > 0) return h;
            }
        }
        return this._groupFooterHeight;
    },
    $_calcLine: function (styles) {
        var h = styles.fontSize() + $$_FONT_HEIGHT_EX;
        h = h + Math.max(1, styles.borderTopWidth()) + Math.max(1, styles.borderBottomWidth()) +
        Math.max(1, styles.paddingTop()) + Math.max(1, styles.paddingBottom());
        return _int(h);
    },
    $_indicatorHeight: function (indicator) {
        return indicator.styles().fontSize() + $$_FONT_HEIGHT_EX;
    },
	_calcItemLine: function (grid) {
        var h = this.$_calcLine(grid.body().cellStyles());
		var indicator = grid.rowIndicator();
        if (indicator.visible()) {
            h = Math.max(h, this.$_indicatorHeight(indicator));
        }
        return h;
	},
	_calcHeaderLine: function (grid) {
        return this.$_calcLine(grid.header().styles());
	},
	_calcFooterLine: function (grid) {
        return this.$_calcLine(grid.footer().styles());
	},
    _calcSummaryLine: function (grid) {
        return this.$_calcLine(grid.header().summary().styles());
    },
    _calcGroupHeaderLine: function (rowGroup) {
        return this.$_calcLine(rowGroup.headerStyles());
    },
    _calcGroupFooterLine: function (rowGroup) {
        return this.$_calcLine(rowGroup.footerStyles());
    },
	_setMeasuredHeight: function (column, value) {
		column._measuredHeight = value;
	},
	_getRootColumn: function (grid) {
		return grid._rootGroup();
	}
});
/** @internal */
var SimpleHeightsMeasurer = defineClass("SimpleHeightsMeasurer", HeightMeasurer, {
	init : function() {
		this._super();
	},
	calculate: function (grid, body, header, footer, summary, rowGroup) {
		grid.$_calcGroupLevels();
		this._itemHeight = body ? this.$_calcItemHeights(grid, grid.getDataLevel()) : 0;
		this._headerHeight = header ? this.$_calcHeaderHeights(grid, grid.getHeaderLevel()) : 0;
		this._footerHeight = footer ? this.$_calcFooterHeights(grid, grid.getFooterLevel()) : 0;
        this._summaryHeight = summary ? this.$_calcSummaryHeights(grid, grid.getHeaderSummaryLevel()) : 0;
        this._groupHeaderHeight = rowGroup ? this.$_calcGroupHeaderHeights(rowGroup, grid.getGroupHeaderLevel()) : 0;
        this._groupFooterHeight = rowGroup ? this.$_calcGroupFooterHeights(rowGroup, grid.getGroupFooterLevel()) : 0;
	},
	$_arrangeItemHeights: function (group, hConst) {
		var	total = 0;
		var cnt = group.visibleCount();
        var i, h, column;
		if (group.vertical()) {
			var hLevel = _int(hConst / group.dataLevel());
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (i == cnt - 1) {
					h = Math.max(0, hConst - total);
				} else if (column instanceof ColumnGroup) {
					h = hLevel * column.dataLevel();
					total += h;
				} else {
					h = hLevel;
					total += h;
				}
				this._setMeasuredHeight(column, h);
				if (column instanceof ColumnGroup) {
					this.$_arrangeItemHeights(column, h);
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				this._setMeasuredHeight(column, hConst);
				if (column instanceof ColumnGroup) {
					this.$_arrangeItemHeights(column, hConst);
				}
			}
		}
	},
	$_calcItemHeights: function (grid, levels, noDefault) {
		var options = grid.displayOptions();
		var hItem = noDefault ? 0 : _int(options.rowHeight());
        var h;
		if (hItem <= 0) {
			h = this._calcItemLine(grid);
			hItem = levels * h;
		}
		hItem = _int(Math.max(options.minRowHeight(), hItem));
		if ((h = options.maxRowHeight()) > 0 && hItem > h) {
			hItem = h;
		}
		var root = this._getRootColumn(grid);
		this.$_arrangeItemHeights(root, hItem);
		return hItem;
	},
	$_calcHeaderHeights: function (grid, levels) {
		var header = grid.header();
		var hItem = _int(header.height());
        var h;
		if (hItem <= 0) {
			h = this._calcHeaderLine(grid);
			hItem = levels * h;
		}
		hItem = _int(Math.max(header.minHeight(), hItem));
		return hItem;
	},
	$_calcFooterHeights: function (grid, levels) {
		var footer = grid.footer();
		var hItem = _int(footer.height());
		if (hItem <= 0) {
			hItem = levels * this._calcFooterLine(grid);
		}
		hItem = _int(Math.max(footer.minHeight(), hItem));
		return hItem;
	},
    $_calcSummaryHeights: function (grid, levels) {
        var summary = grid.header().summary();
        var hItem = _int(summary.height());
        if (hItem <= 0) {
            hItem = levels * this._calcSummaryLine(grid);
        }
        hItem = _int(Math.max(summary.minHeight(), hItem));
        return hItem;
    },
    $_calcGroupHeaderHeights: function (rowGroup, levels) {
        var hItem = _int(rowGroup.headerHeight());
        if (hItem <= 0) {
            hItem = levels * this._calcGroupHeaderLine(rowGroup);
        }
        hItem = _int(Math.max(rowGroup.minHeaderHeight(), hItem));
        return hItem;
    },
    $_calcGroupFooterHeights: function (rowGroup, levels) {
        var hItem = _int(rowGroup.footerHeight());
        if (hItem <= 0) {
            hItem = levels * this._calcGroupFooterLine(rowGroup);
        }
        hItem = _int(Math.max(rowGroup.minFooterHeight(), hItem));
        return hItem;
    }
});
SimpleHeightsMeasurer.Default = new SimpleHeightsMeasurer();
/** @internal */
var FixedHeightsMeasurer = defineClass("FixedHeightsMeasurer", SimpleHeightsMeasurer, {
	init : function() {
		this._super();
	},
	calculate: function (grid, body, header, footer, summary, rowGroup) {
        this._super(grid, null, header, footer, summary, rowGroup)
		this._itemHeight = body ? this.$_calcItemHeights(grid) : 0;
	},
	$_checkHeight: function (group, hLine) {
		var cnt = group.visibleCount();
		for (var i = 0; i < cnt; i++) {
			var column = group.getVisibleItem(i);
			column._value = column.height() > 0 ? column.height() : hLine;
			if (column instanceof ColumnGroup) {
				this.$_checkHeight(column, hLine);
			}
		}
	},
	$_calcGroupHeight: function (group) {
		var h = 0;
		var cnt = group.visibleCount();
        var i, column;
		if (group.vertical()) {
			for (var i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (column instanceof ColumnGroup) {
					h += this.$_calcGroupHeight(column);
				} else {
					h += column._value;
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (column instanceof ColumnGroup) {
					h = Math.max(h, this.$_calcGroupHeight(column));
				} else {
					h = Math.max(h, column._value);
				}
			}
		}
		group._sum = h;
		return h;
	},
	$_arrangeHeights: function (group, hConst) {
		var i, h, column, hFill;
		var cnt = group.visibleCount();
		if (group.vertical()) {
			var total = 0;
			if (group._sum > hConst) {
				for (i = 0; i < cnt; i++) {
					var column = group.getVisibleItem(i);
					if (i < cnt - 1) {
						h = _int(hConst * column._value / group._sum);
						total += h;
					} else {
						h = Math.max(0, hConst - total);
					}
					this._setMeasuredHeight(column, h);
					if (column instanceof ColumnGroup) {
						this.$_arrangeHeights(column, h);
					}
				}
			} else if (group._sum < hConst) {
				var fillSum = 0;
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					if ((hFill = column.fillHeight()) > 0) {
						fillSum += hFill;
					}
				}
				if (fillSum > 0) {
					var surplus = hConst - group._sum;
					for (i = 0; i < cnt; i++) {
						column = group.getVisibleItem(i);
						if (i < cnt - 1) {
							h = column._value;
							if ((hFill = column.fillHeight()) > 0) {
								h += _int(surplus * hFill / fillSum);
							}
							total += h;
						} else {
							h = Math.max(0, hConst - total);
						}
						this._setMeasuredHeight(column, h);
						if (column instanceof ColumnGroup) {
							this.$_arrangeHeights(column, h);
						}
					}
				} else {
					for (i = 0; i < cnt; i++) {
						column = group.getVisibleItem(i);
						if (i < cnt - 1) {
							h = _int(hConst * column._value / group._sum);
							total += h;
						} else {
							h = Math.max(0, hConst - total);
						}
						this._setMeasuredHeight(column, h);
						if (column instanceof ColumnGroup) {
							this.$_arrangeHeights(column, h);
						}
					}
				}
			} else {
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					if (i < cnt - 1) {
						h = column._value;
						total += h;
					} else {
						h = Math.max(0, hConst - total);
					}
					this._setMeasuredHeight(column, h);
					if (column instanceof ColumnGroup) {
						this.$_arrangeHeights(column, column._value);
					}
				}
			}
		}
		else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				this._setMeasuredHeight(column, hConst);
				if (column instanceof ColumnGroup) {
					this.$_arrangeHeights(column, hConst);
				}
			}
		}
	},
	$_calcItemHeights: function (grid) {
		var hLine = this._calcItemLine(grid);
		var root = this._getRootColumn(grid);
		this.$_checkHeight(root, hLine);
		var options = grid.displayOptions();
		var hItem = this.$_calcGroupHeight(root);
		var h = _int(options.rowHeight());
		if (h > 0) {
			hItem = h;
		}
		hItem = _int(Math.max(hItem, options.minRowHeight()));
		if ((h = _int(options.maxRowHeight())) > 0 && hItem > h) {
			hItem = h;
		}
		this.$_arrangeHeights(root, hItem);
		return hItem;
	}
});
var LM_RECT = new Rectangle();
var GridLayoutManager = defineClass("GridLayoutManager", null, {
	init: function (grid) {
		this._super();
		this._grid = grid;
        this._options = grid ? grid.displayOptions() : null;
		this._items = grid ? grid.itemSource() : null;
		this._columnCount = 0;
		this._columns = [];
		this._fixedColumnPoints = [];
		this._columnPoints = [];
		this._fixedItemCount = 0;
		this._itemCount = 0;
		this._fullItemCount = 0;
		this._availableItemCount = 0;
		this._fixedItemPoints = [];
		this._itemPoints = [];
		this._fixedCols = 0;
		this._fixedRows = 0;
		this._fixedWidth = 0;
		this._fixedHeight = 0;
		this._columnsLength = 0;
		this._prevFirst = 0;
		this._prevLast = 0;
		this._firstCol = 0;
		this._lastCol = 0;
		this._lastCol2 = 0;
		this._leftPos = 0;
		this._topIndex = 0;
	},
	heightMeasurer: null,
	grid: function () {
		return this._grid;
	},
	columnMerged: function () {
		return this._columnMerged;
	},
	itemCount: function () {
		return this._itemCount;
	},
	fullItemCount: function () {
		return this._fullItemCount;
	},
	columnCount: function () {
		return this._columnCount;
	},
	hscrolled: function () {
		return this._hscrolled;
	},
	vscrolled: function () {
		return this._vscrolled;
	},
    isColumnsFitted: function () {
        return this._columnsFitted;
    },
	columnsLength: function () {
		return this._columnsLength;
	},
	topIndex: function () {
		return this._topIndex;
	},
	leftPos: function () {
		return this._leftPos;
	},
	prevFirst: function () {
		return this._prevFirst;
	},
	prevLast: function () {
		return this._prevLast;
	},
	firstCol: function () {
		return this._firstCol;
	},
	lastCol: function () {
		return this._lastCol;
	},
	lastCol2: function () {
		return this._lastCol2;
	},
	fixedItemCount: function () {
		return this._fixedItemCount;
	},
	fixedColCount: function () {
		return this._fixedCols;
	},
	fixedRowCount: function () {
		return this._fixedRows;
	},
	rowGrouped: function () {
		return false;
	},
	rowGroupView: function () {
		return this._grid.bandedGroupView();
	},
	rowGroupLevels: function () {
		return 0;
	},
	panelBounds: function () {
		return this._panelBounds.clone();
	},
    groupPanelBounds: function () {
        return this._groupPanelBounds.clone();
    },
	rowIndicatorBounds: function () {
		return this._rowIndicatorBounds.clone();
	},
	stateBarBounds: function () {
		return this._stateBarBounds.clone();
	},
	checkBarBounds: function () {
		return this._checkBarBounds.clone();
	},
	rowGroupHeadBounds: function () {
		return this._rowGroupBounds.clone();
	},
	rowGroupBounds: function () {
		return this._rowGroupBounds.clone();
	},
	headerBounds: function () {
		return this._headerBounds.clone();
	},
    fixedHeaderBounds: function () {
        return this._fixedHeaderBounds.clone();
    },
    editBarBounds: function () {
        return this._editBarBounds.clone();
    },
    summaryBounds: function () {
        return this._summaryBounds.clone();
    },
    fixedSummaryBounds: function () {
        return this._fixedSummaryBounds.clone();
    },
    headerItemsBounds: function () {
        return this._headerItemsBounds.clone();
    },
    footerItemsBounds: function () {
        return this._footerItemsBounds.clone();
    },
	footerBounds: function () {
		return this._footerBounds.clone();
	},
    fixedFooterBounds: function () {
        return this._fixedFooterBounds.clone();
    },
	fixedBounds: function () {
		return this._fixedBounds.clone();
	},
	nonfixedBounds: function () {
		return this._nonfixedBounds.clone();
	},
	bodyBounds: function () {
		return this._bodyBounds.clone();
	},
	gridBounds: function () {
		return this._gridBounds.clone();
	},
	clientRect: function () {
		return this._clientRect.clone();
	},
	fixedWidth: function () {
		return this._fixedWidth;
	},
	fixedHeight: function () {
		return this._fixedHeight;
	},
	cellIsVisible: function (index) {
		var t = this._topIndex;
        var i = index.rowIndex;
		var fixed = this._fixedItemCount;
		if (i >= fixed) {
			if (i < t + fixed) {
				return false;
			}
			if (this._fullItemCount == 0 && i == t + fixed) {
				return true;
			}
			if (i >= t + fixed + this._fullItemCount) {
				return false;
			}
		}
		var column = index.column;
        var root = column.root();
		var c = root.displayIndex();
		fixed = this._fixedCols;
		if (c >= fixed) {
			var x = this.columnBounds(c).x;
			while (column != root) {
				x += column.displayOffset();
				column = column.parent();
			}
			if (x < this._leftPos) {
				return false;
			}
			if (x + index.column.displayWidth() - this._leftPos > this._nonfixedBounds.width) {
				return false;
			}
		}
		return true;
	},
	makeCellVisible: function (index) {
		this._focusIndex = index.clone();
	},
	makeRowVisible: function (rowIndex) {
		this._focusRow = rowIndex;
	},
	getColumn: function (index) {
		return this._columns[index];
	},
	getColumnBounds: function (index) {
        return this.columnBounds(index);
	},
    columnBounds: function (index) {
        var r, i;
        if (index < this._fixedCols) {
            r = new Rectangle(this._fixedColumnPoints[index], 0,
				this._fixedColumnPoints[index + 1] - this._fixedColumnPoints[index], 0);
        } else {
            i = index - this._fixedCols;
            r = new Rectangle(this._columnPoints[i], 0, this._columnPoints[i + 1] - this._columnPoints[i], 0);
        }
        return r;
    },
    getDataColumnBounds: function (column) {
        return this.dataColumnBounds(column);
    },
    dataColumnBounds: function (column) {
		var root = column.root();
		var	dataRoot = column.dataRoot();
		var	r = this.columnBounds(root.displayIndex());
		if (dataRoot !== root) {
			r.x += column.$_getOffset();
			r.width = dataRoot.groupWidth();
		}
		return r;
	},
	yU: function () {
		return this._grid._feedbackLayer;
	},
	getColumnRect: function (index) {
		return this.columnRect(index);
	},
	columnRect: function (index) {
		var sx, i, r;
		if (index < this._fixedCols) {
			sx = this._gridBounds.x; 
			i = index;
			r = new Rectangle(this._fixedColumnPoints[i] + sx, 0, this._fixedColumnPoints[i + 1] - this._fixedColumnPoints[i], 0);
		} else {
			sx = this._bodyBounds.x; // leftPos를 뺀 값이다.
			i = index - this._fixedCols;
			r = new Rectangle(this._columnPoints[i] + sx, 0, this._columnPoints[i + 1] - this._columnPoints[i], 0);
		}
		return r;
	},
	getDataColumnRect: function (column) {
        return this.dataColumnRect(column);
    },
    dataColumnRect: function (column) {
		var root = column.root();
		var	dataRoot = column.dataRoot();
		var	r = this.columnRect(root.displayIndex());
		if (dataRoot !== root) {
			r.leftBy(column.$_getOffset());
			r.width = dataRoot.groupWidth();
		}
		return r;
	},
	dataRootBounds: function (column) {
		var root = column.root();
		var dataRoot = column.dataRoot();
		var r = this.columnBounds(root.displayIndex());
		if (dataRoot != root) {
			this._getColumnRectInRoot(dataRoot, root, LM_RECT);
			r.leftBy(LM_RECT.x);
			r.width = dataRoot.displayWidth();
		}
		return r;
	},
	dataRootRect: function (column) {
		var root = column.root();
		var dataRoot = column.dataRoot();
		var r = this.columnRect(root.displayIndex());
		if (dataRoot != root) {
            this._getColumnRectInRoot(dataRoot, root, LM_RECT);
            r.leftBy(LM_RECT.x);
            /*
            var x = r.x + dataRoot.displayOffset();
            var p = dataRoot.parent();
            while (p != root) {
                x += p.displayOfset();
                p = p.parent();
            }
			r.setLeft(x);
			*/
			r.width = dataRoot.displayWidth();
		}
		return r;
	},
	itemBounds: function (index, fixed) {
		var r = fixed ? this._fixedBounds : this._bodyBounds;
		if (index < this._fixedItemCount) {
			return new Rectangle(0, this._fixedItemPoints[index], r.width, this._fixedItemPoints[index + 1] - this._fixedItemPoints[index]);
		} else {
			return new Rectangle(0, this._itemPoints[index - this._fixedItemCount], r.width, this._itemPoints[index - this._fixedItemCount + 1] - this._itemPoints[index - this._fixedItemCount]);
		}
	},
	getItemBounds: function (index, fixed) {
		return this.itemBounds(index, fixed);
	},
	itemRect: function (index, fixed) {
		var r = fixed ? this._fixedBounds : this._bodyBounds;
		var sy = r.y;
		if (index < this._fixedItemCount) {
			return new Rectangle(0, this._fixedItemPoints[index] + sy, r.width, this._fixedItemPoints[index + 1] - this._fixedItemPoints[index]);
		} else {
			return new Rectangle(0, this._itemPoints[index - this._fixedItemCount] + sy, r.width, this._itemPoints[index - this._fixedItemCount + 1] - this._itemPoints[index - this._fixedItemCount]);
		}
	},
	getItemRect: function (index, fixed) {
		return this.itemRect(index, fixed);
	},
	dataCellRect: function (index) {
		var grid = this._grid;
		if (!grid.isValidCell(index) || this._fixedItemCount + this._itemCount < 1) {
			return new Rectangle();
		}
		var column = index.column;
		var	root = column.root();// column.group() ? column.root() : index.column;
		var	r = this.columnRect(root.displayIndex());
		var	rc = null;
		var	row;
		if (root.displayIndex() >= this._fixedCols) {
		}
		if (index.rowIndex < this._fixedItemCount) {
			rc = this.getItemBounds(index.rowIndex);
			r.y = rc.y + this._bodyBounds.y;
			r.height = rc.height;
		} else {
			row = index.rowIndex - grid.topIndex();
			if (row < 0 || row >= this._itemCount + this._fixedItemCount) {
				r.y = this.getItemBounds(0).y + this._bodyBounds.y;
				r.height = 0;
			} else {
				rc = this.getItemBounds(row);
				r.y = rc.y + this._bodyBounds.y;
				r.height = rc.height;
			}
		}
		if (column !== root) {
			if (!rc) {
				rc = new Rectangle();
			}
			this._getColumnRectInRoot(column, root, rc);
			rc.offset(r.x, r.y);
			r.copy(rc);
		}
		return r;
	},
	mouseToIndex: function (x, y, index) {
		index.rowIndex = -1;
        index.column = null;
		if (this._columnCount < 1) {
			return index;
		}
		var	r = -1;
		var	grid = this.grid();
		var	h = this._summaryBounds.bottom();
        var i;
		if (y >= h && y < this._footerBounds.y) {
			for (i = 0; i < this._fixedItemCount; i++) {
				if (y >= h + this._fixedItemPoints[i] && y < h + this._fixedItemPoints[i + 1]) {
					r = i;
					y -= h + this._fixedItemPoints[i];
					break;
				}
			}
			if (r < 0 && this._itemCount > 0) {
				for (i = 0; i < this._itemCount; i++) {
					if (y >= h + this._itemPoints[i] && y < h + this._itemPoints[i + 1]) {
						r = i;
						y -= h + this._itemPoints[i];
						break;
					}
				}
				if (r >= 0) {
					r += grid.topRow();
				}
			}
		} else if (y >= this._footerBounds.y) { // footer
			r = -2;
		} else if (y < this._headerBounds.y) { // panel
			r = -3;
		}
		index.rowIndex = r;
		var c = -1;
		var w = this._gridBounds.x;
		if (x >= w && x <= this._clientRect.width) {
			x = x - w;
			for (i = 0; i < this._fixedCols; i++) {
				if (x >= this._fixedColumnPoints[i] && x < this._fixedColumnPoints[i + 1]) {
					c = i;
					x -= this._fixedColumnPoints[i];
					break;
				}
			}
			if (c < 0) {
				x = x - this._fixedWidth + this._leftPos;
				for (i = this._firstCol; i <= this._lastCol; i++) {
					if (x >= this._columnPoints[i - this._fixedCols] && x < this._columnPoints[i - this._fixedCols + 1]) {
						c = i;
						x -= this._columnPoints[i - this._fixedCols];
						break;
					}
				}
			}
		}
		if (c >= 0 && c < grid.visibleColumnCount()) {
			index.column = grid.getVisibleColumn(c);
			var root = _cast(index.column.root(), ColumnGroup);
			if (root) {
				index.column = root.columnAtPoint(x, y);
			}
		} else {
			index.rowIndex = -1;
			index.column = null;
		}
        return index;
	},
	mouseToIndexEx: function (x, y, index) {
		if (this._columnCount < 1) {
			return index;
		}
		var r = 0;
		var grid = this.grid();
		var topItem = this._topIndex + this._fixedItemCount;
		var h = this._bodyBounds.y;
        var i;
		if (y < h) { 
			r = -1;
		} else if (y >= this._bodyBounds.bottom() && y < this._footerBounds.y) {
			r = topItem + this._fullItemCount;
		} else if (y >= this._footerBounds.y) {
			r = topItem + this._fullItemCount;
		} else {
			r = -1;
			for (i = 0; i < this._fixedItemCount; i++) {
				if (y >= h + this._fixedItemPoints[i] && y < h + this._fixedItemPoints[i + 1]) {
					r = i;
					break;
				}
			}
			if (r < 0 && this._itemCount > 0) {
				for (i = 0; i < this._itemCount; i++) {
					if (y >= h + this._itemPoints[i] && y < h + this._itemPoints[i + 1]) {
						r = i;
						break;
					}
				}
				if (r >= 0) {
					r += topItem;
				}
			}
		}
		index.rowIndex = r;
		var c = -1;
		var w = this._gridBounds.x;
		if (x < w) {
			c = Math.max(0, this._firstCol - 1);
		} else if (x >= this._bodyBounds.right() && x < this._clientRect.right()) {
			c = grid.visibleColumnCount() - 1;
		} else if (x > this._clientRect.right()) {
			c = Math.min(grid.visibleColumnCount() - 1, this._lastCol + 1);
		} else {
			x = x - w;
			for (i = 0; i < this._fixedCols; i++) {
				if (x >= this._fixedColumnPoints[i] && x < this._fixedColumnPoints[i + 1]) {
					c = i;
					break;
				}
			}
			if (c < 0) {
				x = x - this._fixedWidth + this._leftPos;
				for (i = this._firstCol; i <= this._lastCol; i++) {
					if (x >= this._columnPoints[i - this._fixedCols] && x < this._columnPoints[i - this._fixedCols + 1]) {
						c = i;
						break;
					}
				}
			}
		}
		if (c >= 0 && c < grid.visibleColumnCount()) {
			index.column = grid.getVisibleColumn(c);
		} else {
			index.column = null;
		}
        return index;
	},
	measure: function (bounds, leftPos, topIndex, scrollBarWidth, scrollBarHeight) {
		this._items = this._grid.itemSource();
        this._options = this._grid.displayOptions();
		this._leftPos = leftPos;
		this._topIndex = topIndex;
		this._columnMerged = false;
		this._vcolgrouped = this._grid._columnVerticalGrouped;
		this._leafCols = null;
		this._doMeasure(bounds, scrollBarWidth, scrollBarHeight);
		this._focusIndex = null;
		this._focusRow = -1;
	},
	layout: function (bounds) {
		this._doLayout(bounds);
	},
	fitColumnWidth: function (column, visibleOnly, minWidth, maxWidth, includeHeader) {
        if (this._grid) {
            if (column instanceof ColumnGroup) {
                this._doFitGroupWidth(column, visibleOnly, minWidth, maxWidth, includeHeader);
            } else if (column instanceof ValueColumn) {
                this._doFitColumnWidth(column, visibleOnly, minWidth, maxWidth, false, includeHeader);
            }
        }
	},
	fitRowHeight: function (row, minHeight, maxHeight) {
		var cols = this._leafCols;
		if (!cols) {
			cols = this._leafCols = this._grid.getLeafColumns();
		}
		var w, col, mh,
            ih = this._heightMeasurer.$_calcItemHeights(this._grid, 1, true),
            min = Math.max(minHeight, ih),
            h = 0,
            r = row.index();
        maxHeight = maxHeight > 0 ? maxHeight : 1000000;
		for (var i = cols.length; i--;) {
            col = cols[i];
            if (col.isRoot()) {
                w = this.columnBounds(col.displayIndex()).width;
            } else {
                w = this.dataColumnBounds(col).width;
            }
            mh = this._measureColumnHeight(this._grid, r, cols[i], w, maxHeight);
            if (!isNaN(mh) && mh > 0) {
                h = Math.max(h, mh);
            }
		}
        if (!isNaN(maxHeight) && maxHeight) {
            h = Math.min(h, maxHeight);
        }
        if (!isNaN(minHeight)) {
            h = Math.max(h, min);
        }
        return h;
	},
	isMergedCell: function (index) {
        var grid = this._grid;
		if (this._getRowGroup().mergeMode()) {
			if (grid.isGroupedColumn(index.dataColumn())) {
				return true;
			}
		}
		var column = index.column;
		if (column instanceof ValueColumn && column.canMerge()) {
			var merges = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
			if (merges) {
				return merges.getRoom(index) != null;
			}
		}
		return false;
	},
	getMergedCell: function (index) {
		var merges, column = index.column;
		if (column.canMerge()) {
			merges = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
			if (merges) {
				return merges.getRoom(index);
			}
		}
		return null;
	},
	scrollToNextColumn: function () {
		for (var i = 0; i < this._columnCount; i++) {
			if (this._columnPoints[i] > this._leftPos) {
				return this._columnPoints[i];
			}
		}
		return this._leftPos;
	},
	scrollToPrevColumn: function () {
		for (var i = this._columnCount - 1; i >= 0; i--) {
			if (this._columnPoints[i] < this._leftPos) {
				return this._columnPoints[i];
			}
		}
		return this._leftPos;
	},
	getDataColumns: function () {
		var cols = [];
		for (var i = 0; i < this._columns.length; i++) {
			var col = this._columns[i];
			if (col instanceof DataColumn) {
				cols.push(col);
			} else if (col instanceof ColumnGroup) {
				$_collectDataColumns(col, cols, true);
			}
		}
		return cols;
	},
	getDataColumnsOf: function (fieldIndex) {
		var cols = [];
		for (var i = 0; i < this._columns.length; i++) {
			var col = this._columns[i];
			if (col instanceof DataColumn && col.dataIndex() >= 0) {
				cols.push(col);
			} else if (col instanceof ColumnGroup) {
				$_collectDataColumnsOf(col, fieldIndex, cols, true);
			}
		}
		return cols;
	},
	containsDataRow: function (dataRowId) {
		return this._grid.bodyView().findRowViewById(dataRowId) != null;
	},
	getCellValue: function (dataRowId, column) {
		var rowView = this._grid.bodyView().findRowViewById(dataRowId);
		if (rowView != null) {
			var cellView = rowView.getCell(column);
			if (cellView) {
				return cellView.value();
			}
		}
		return undefined;
	},
    _getRowGroup: function () {
        return null;
    },
	_isColumnsDirty: function () {
		return this._grid._isColumnsDirty();
	},
	_isHeaderDirty: function () {
		return this._grid._isStylesDirty() || this._grid.header().dirty() || this._grid._isColumnsDirty();
	},
	_isFooterDirty: function () {
		return this._grid._isStylesDirty() || this._grid.footer().dirty() || this._grid._isColumnsDirty();
	},
	_getFixedRowCount: function () {
		var items = this._grid.itemSource();
		if (items) {
			return Math.min(items.fixedCount(), items.rowCount());
		} else {
			return 0;
		}
	},
	_getItem: function (index) {
		return this._items.getItem(index);
	},
	_doMeasure: function (bounds, sw, sh) {
		var view, sz, x, y,
        	grid = this._grid,
        	options = grid.displayOptions(),
            indicator = grid.rowIndicator(),
        	rowGroup = this.rowGrouped() ? this._getRowGroup() : null,
			r = bounds.clone();
		this._vscrolled = this._hscrolled = false;
		this._prevFirst = this._firstCol;
		this._prevLast = this._lastCol;
		this._firstCol = 0;
		this._lastCol = -1;
        if (rowGroup) {
                grid.bandedGroupView().setVisible(true);
        } else {
            grid.bandedGroupView().setVisible(false);
        }
		this.$_calcFixedColumnPoints();
		this.$_calcColumnPoints();
        this._heightMeasurer.calculate(grid, true, grid.header().visible(), grid.footer().visible(), grid.header().summary().visible(), rowGroup);
        this._panelBounds = r.clone();
        /*
		this._panelBounds = r.clone();
		if (grid.panel().visible() && (view = grid.panelView())) {
			view.setModel(grid.panel());
			sz = view.measure(grid, r.width, r.height);		
		} else { 
			sz = Size.EMPTY;
		}
		this._panelBounds.height = sz.height;
		r.topBy(sz.height);
		*/
        this._groupPanelBounds = r.clone();
        if (grid.groupPanel().visible() && (view = grid.groupPanelView())) {
            view.setModel(grid.groupPanel());
            sz = view.measure(grid, r.width, r.height);
        } else {
            sz = Size.EMPTY;
        }
        this._groupPanelBounds.height = sz.height;
        r.topBy(sz.height);
		this._rowIndicatorBounds = r.clone();
		if (indicator.$_indicatorVisible()) {
			view = grid.rowIndicatorView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._rowIndicatorBounds.width = sz.width;
		r.leftBy(sz.width);
		this._stateBarBounds = r.clone();
		if (indicator.$_stateVisible()) {
			view = grid.stateBarView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._stateBarBounds.width = sz.width;
		r.leftBy(sz.width);
		this._checkBarBounds = r.clone();
		if (grid.checkBar().visible()) {
			view = grid.checkBarView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._checkBarBounds.width = sz.width;
		r.leftBy(sz.width);
        this._rowGroupBounds = r.clone();
        this._rowGroupHeadBounds = r.clone();
		if (rowGroup) {
            sz = this.rowGroupView().measure(grid, r.width, r.height);
			this._rowGroupBounds.width = sz.width;
			this._rowGroupHeadBounds.width = sz.width;
			r.leftBy(sz.width);
		} else {
            this._rowGroupBounds.width = 0;
            this._rowGroupHeadBounds.width = 0;
        }
		this._fixedBounds = r.clone();
		this._fixedBounds.width = this._fixedWidth;
		r.leftBy(this._fixedWidth);
		this._headerBounds = r.clone();
		if (grid.header().visible()) {
			view = grid.headerView();
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.headerHeight());
		} else {
			sz = Size.EMPTY;
		}
		this._headerBounds.height = sz.height;
		this._headerBounds.width = sz.width;
		this._fixedHeaderBounds = new Rectangle(this._fixedBounds.x, this._headerBounds.y, this._fixedBounds.width, this._headerBounds.height);
        r.topBy(sz.height);
		this._editBarBounds = r.clone();
		if (grid.editBar().visible()) {
			view = grid.editBarRenderer();
			view.setModel(grid.editBar());
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.itemHeight(0));
		} else {
			sz = Size.EMPTY;
		}
		this._editBarBounds.height = sz.height;
		this._editBarBounds.width = sz.width;
		r.topBy(sz.height);
        this._summaryBounds = r.clone();
        if (grid.header().summary().visible()) {
            view = grid.summaryView();
            sz = view.measure(grid, r.width, r.height);
            sz.height = Math.max(sz.height, this._heightMeasurer.summaryHeight());
        } else {
            sz = Size.EMPTY;
        }
        this._summaryBounds.height = sz.height;
        this._summaryBounds.width = sz.width;
        this._fixedSummaryBounds = new Rectangle(this._fixedBounds.x, this._summaryBounds.y, this._fixedBounds.width, this._summaryBounds.height);
        r.topBy(sz.height);
        this._headerItemsBounds = r.clone();
        if (options.customItemsVisible() && grid.headerItems().visible()) {
            view = grid.headerItemsView();
            sz = view.measure(grid, r.width, r.height);
        } else {
            sz = Size.EMPTY;
        }
        this._headerItemsBounds.height = sz.height;
        this._headerItemsBounds.width = sz.width;
        r.topBy(sz.height);
		this._footerBounds = r.clone();
		if (grid.footer().visible()) {
			view = grid.footerView();
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.footerHeight());
		} else {
			sz = Size.EMPTY;
		}
		this._footerBounds.y = r.bottom() - sz.height;
		this._footerBounds.width = sz.width;
		this._footerBounds.height = sz.height;
		this._fixedFooterBounds = new Rectangle(this._fixedBounds.x, this._footerBounds.y, this._fixedBounds.width, this._footerBounds.height);
        r.bottomBy(-sz.height);
        this._footerItemsBounds = r.clone();
        if (options.customItemsVisible() && grid.footerItems().visible()) {
            view = grid.footerItemsView();
            sz = view.measure(grid, r.width, r.height);
        } else {
            sz = Size.EMPTY;
        }
        this._footerItemsBounds.y = r.bottom() - sz.height;
        this._footerItemsBounds.width = sz.width;
        this._footerItemsBounds.height = sz.height;
        y = this._headerItemsBounds.bottom();
		this._gridBounds = new Rectangle(this._fixedBounds.x, y,
			bounds.right() - this._fixedBounds.x, this._footerItemsBounds.y - y);
		var rBody = new Rectangle(this._headerBounds.x, y,
			this._headerBounds.width, this._footerItemsBounds.y - y + 1);
		this.$_calcHorzScroll(sh, rBody, this._gridBounds);
		if (this._hscrolled) {
			rBody.bottomBy(-sh);
		}
		this._calcItemPoints(rBody);
		this._bodyBounds = rBody.clone();
		this.$_updateScrollInfo(bounds, sw, sh);
		this.$_checkColumnMerging();
		this._fixedBounds.y = this._bodyBounds.y;
		this._fixedBounds.height = this._bodyBounds.height;
		this._nonfixedBounds = this._gridBounds.clone();
		this._nonfixedBounds.leftBy(this._fixedWidth);
		if (this._fixedHeight > 0) {
			this._nonfixedBounds.topBy(this._fixedHeight + grid.body().fixedRowBarHeight());
		}
		this.$_measureFitting(this._nonfixedBounds, this._vscrolled ? sw : 0);
		if (this._columnsFitted) {
			this.$_fitColumns(this._nonfixedBounds.width);
			this._bodyBounds.width = this._columnsLength;
		} else {
			this._clearFitWidths();
		}
		this.$_calcLeftPos();
		if (rowGroup) {
			this._rowGroupBounds.setRight(this._bodyBounds.right());
			this._rowGroupBounds.setTop(this._bodyBounds.y);
			this._rowGroupBounds.setBottom(this._footerItemsBounds.y);
		}
        x = this._bodyBounds.right();
		this._bodyBounds.x -= this._leftPos;
		this._panelBounds.setRight(x - this._leftPos);
        this._groupPanelBounds.setRight(x - this._leftPos);
		this._headerBounds.x = this._bodyBounds.x;
		this._headerBounds.width = this._bodyBounds.width;
		this._editBarBounds.x = this._bodyBounds.x;
		this._editBarBounds.width = this._bodyBounds.width;
        this._summaryBounds.x = this._bodyBounds.x;
        this._summaryBounds.width = this._bodyBounds.width;
        this._headerItemsBounds.x = this._groupPanelBounds.x;
        this._headerItemsBounds.width = this._groupPanelBounds.width;
        this._footerItemsBounds.x = this._headerItemsBounds.x;
        this._footerItemsBounds.width = this._headerItemsBounds.width;
		this._footerBounds.x = this._bodyBounds.x;
		this._footerBounds.width = this._bodyBounds.width;
		this._rowGroupHeadBounds.y = this._headerBounds.y;
		this._rowGroupHeadBounds.height = this._headerBounds.height;
        y = Math.min(this._footerItemsBounds.y, this._bodyBounds.bottom());
		this._rowIndicatorBounds.y = this._bodyBounds.y;
		this._rowIndicatorBounds.setBottom(y);
		this._stateBarBounds.y = this._bodyBounds.y;
		this._stateBarBounds.setBottom(y);
		this._checkBarBounds.y = this._bodyBounds.y;
		this._checkBarBounds.setBottom(y);
        var h1 = 0;
        var h2 = 0;
        var h;
        if (this._topIndex == 0 && (this._headerItemsBounds.height > 0 || this._footerItemsBounds.height > 0) && (h = this._footerItemsBounds.y - this._bodyBounds.bottom()) > 0) {
            h1 = grid.headerItemsView().getFillHeights();
            h2 = grid.footerItemsView().getFillHeights();
            if (h1 > 0) {
                h1 = h2 > 0 ? _int(h1 * h / (h1 + h2)) : h;
            }
            if (h2 > 0) {
                h2 = h - h1;
            }
            if (h1 > 0) {
                this._bodyBounds.y += h1;
                this._fixedBounds.y += h1;
                this._rowIndicatorBounds.y += h1;
                this._stateBarBounds.y += h1;
                this._checkBarBounds.y += h1;
                this._headerItemsBounds.height += h1;
            }
            if (h2 > 0) {
                this._footerItemsBounds.topBy(-h2);
            }
        }
        grid.headerItemsView().setFillHeights(h1);
        grid.footerItemsView().setFillHeights(h2);
	},
	$_calcHorzScroll: function (sh, rBody, bounds) {
		this._hscrolled = /*sh > 0 &&*/ this._options.fitStyle() != GridFitStyle.EVEN_FILL;
        if (this._hscrolled) {
            if (this._fixedWidth >= bounds.width) {
                this._hscrolled = this._columnsLength > 0;
            } else {
                this._hscrolled = this._columnsLength > bounds.width - this._fixedWidth;
            }
        }
		rBody.width = this._columnsLength;
	},
	$_updateScrollInfo: function (bounds, sw, sh) {
		var i, w, h, y, dy,
			even = this._options.fitStyle() == GridFitStyle.EVEN_FILL,
			rBody = this._bodyBounds,
			rFooter = this._footerBounds,
        	rFooterItems = this._footerItemsBounds,
			hscroll = !even && /*sw > 0 &&*/ this._columnsLength > 0 && (this._leftPos > 0 || rBody.right() > bounds.right()),
			vscroll = /*sh > 0 &&*/ this._itemCount > 0 && (this._topIndex > 0 || rBody.bottom() > rFooterItems.y);
		if (hscroll) {
			w = vscroll ? sw : 0;
			if (this._columnsLength < this._gridBounds.width - this._fixedBounds.width - w) {
				hscroll = false;
			}
		}
		if (hscroll != vscroll) {
			if (hscroll) {
				vscroll = /*sh > 0 &&*/ this._itemCount > 0 && rBody.bottom() > rFooterItems.y - sh;
			} else { // vscroll
				hscroll = !even && /*sw > 0 &&*/ this._columnsLength > 0 && rBody.right() > bounds.right() - sw;
			}
		}
		if (!hscroll) {
			this._leftPos = 0;
		} else /*if (this._itemCount > 0)*/ {
			if (!this._hscrolled && this._itemCount > 0) { // vscrollbar로 인해 hscrollbar가 생긴 경우
				var r = rBody.clone();
				r.setBottom(rFooter.y - sh);
				this._calcItemPoints(r);
				if (this._itemCount > 0) {
					rBody.height = this._itemPoints[this._itemCount];
				}
			}
			this._fixedFooterBounds.y = rFooter.y -= sh;
            rFooterItems.y -= sh;
			rBody.setBottom(Math.min(rBody.bottom(), rFooterItems.y));
			this._gridBounds.setBottom(rFooterItems.y);
			if (this._itemCount > 0) {
				i = this._fullItemCount;
				while (i > 0 && rBody.y + this._itemPoints[i] > rFooterItems.y) {
					this._fullItemCount--;
					i--;
				}
				i = this._itemCount;
				while (i > 0 && rBody.y + this._itemPoints[i - 1] > rFooterItems.y) {
					this._itemCount--;
					this._itemPoints.pop();
					i--;
				}
			}
		}
		y = rBody.bottom();
		if (this._itemCount > 0 && y < this._footerItemsBounds.y) {
			/*
			h = this._heightMeasurer.itemHeight(0);
			dy = _int((this._fixedFooterBounds.y - y) / h);
			this._availableItemCount = this._fullItemCount + dy;
			while (this._topIndex >  0 && dy > 0) {
				this._topIndex--;
				this._itemCount++;
				this._fullItemCount++;
				this._itemPoints.push(this._itemPoints[this._itemPoints.length - 1] + h);
				rBody.bottomBy(h);
				dy--;
			}
			*/
			var grid = this.grid();
			var delegate = grid.delegate();
			dy = this._footerItemsBounds.y - y;
			while (this._topIndex > 0 && dy > 0) {
				h = this.$_getItemHeight(grid, delegate, this._topIndex + this._fixedItemCount - 1);
				if (h > dy) break;
				this._topIndex--;
				this._itemCount++;
				this._fullItemCount++;
				if (this._itemPoints.length < 1) {
					this._itemPoints.push(0, h);
				} else {
					for (var t = this._itemPoints.length; t > 0; t--) {
						this._itemPoints[t] = this._itemPoints[t - 1] + h;
					}
					this._itemPoints[1] = h;
				}
				rBody.bottomBy(h);
				dy -= h;
			}
			if (vscroll && this._topIndex == 0 && dy > 0) {// this._availableItemCount >= this._fullItemCount) {
				vscroll = false;
				if (hscroll) {
					hscroll = rBody.right() > bounds.right();
				}
				h = this._heightMeasurer.itemHeight(0);
				dy = dy / h;
				this._availableItemCount = this._fullItemCount + dy;
			}
		} else {
			this._availableItemCount = this._fullItemCount;
		}
		this._hscrolled = hscroll;
		this._vscrolled = vscroll;
		this._scrollBarWidth = vscroll ? sw : 0;
		this._scrollBarHeight = hscroll ? sh : 0;
		this._clientRect = bounds.clone();
		this._clientRect.width -= this._scrollBarWidth;
		this._clientRect.height -= this._scrollBarHeight;
		this._gridBounds.setRight(this._clientRect.right());
		this._gridBounds.setBottom(this._footerItemsBounds.y);
	},
	$_calcLeftPos: function () {
		var column, root, i, dx, x;
		if (this._leftPos > 0) {
			i = this._columnPoints.length - 1;
			dx = this._nonfixedBounds.width - (this._columnPoints[i] - this._leftPos);
			if (dx > 0) {
				this._leftPos = Math.max(0, this._leftPos - dx);
			}
		}
		if (this._focusIndex && (column = this._focusIndex.column)) {
            root = column.root();
            i = root.displayIndex();
            if (i >= this._fixedCols) {
                x = this._columnPoints[i - this._fixedCols];
                while (column != root) {
                    x += column.displayOffset();
                    column = column.parent();
                }
                if (x < this._leftPos) {
                    this._leftPos = x;
                } else {
                    dx = x + this._focusIndex.column.displayWidth() - this._leftPos - this._nonfixedBounds.width;
                    if (dx > 0) {
                        this._leftPos = Math.min(x, this._leftPos + dx);
                    }
                }
            }
		}
		var leftPos = this._leftPos;
		var cw = this._clientRect.width;
		this._firstCol = this._fixedCols;
		this._lastCol2 = this._lastCol = -1;
		for (i = this._fixedCols; i < this._columnCount; i++) {
			if (this._columnPoints[i + 1 - this._fixedCols] > leftPos) {
				this._firstCol = i;
				break;
			}
		}
		cw -= this._headerBounds.x; // this._headerBounds.x는 스크롤과 상관없다.
		for (i = this._columnCount - 1; i >= this._fixedCols; i--) {
			x = this._columnPoints[i - this._fixedCols] - leftPos;
			if (x < cw) {
				this._lastCol2 = this._lastCol = i;
				if (i < this._columnCount - 1 && this._scrollBarHeight > 0 && this._scrollBarWidth > 0 && this._columnPoints[i + 1 - this._fixedCols] - leftPos < cw + this._scrollBarWidth ) {
					this._lastCol2++;
				}
				break;
			}
		}
        x = this._columnPoints[this._columnCount - this._fixedCols] - leftPos;
		this._needVscrollIndent =  x <= cw + this._scrollBarWidth;
        this._allScrolled = x <= cw;
	},
	_doLayout: function (bounds) {
		var elt, r,
			gr = this._gridBounds,
			grid = this._grid,
			rowGroup = this._getRowGroup(),
			header = grid.header(),
        	summary = header.summary(),
			footer = grid.footer(),
			indicator = grid.rowIndicator(),
			checkBar = grid.checkBar(),
			fixed = this._fixedCols > 0,
        	sb = (this._vscrolled && this._hscrolled) ? this._scrollBarWidth : 0;
		if ((elt = grid.panelView())) {
            elt.setVisible(false);
            /*
			elt.setVisible(grid.panel().visible());
			if (elt.visible()) {
				elt.setRect(this._panelBounds);
				elt.layoutContent(this);
			}
			*/
		}
        if ((elt = grid.groupPanelView())) {
            elt.setVisible(grid.groupPanel().visible());
            if (elt.visible()) {
                elt.setRect(this._groupPanelBounds);
				elt.setClipBounds(0, 0, bounds.width, bounds.height);
                elt.layoutContent(this);
            }
        }
        elt = grid.headerItemsView();
        elt.setVisible(this._headerItemsBounds.height > 0);
        if (elt.visible()) {
            elt.setRect(this._headerItemsBounds);
            elt.layoutContent(this);
        }
		elt = grid.rowIndicatorView();
		elt.setVisible(indicator.$_indicatorVisible());
		if (elt.visible()) {
			elt.setRect(this._rowIndicatorBounds);
			elt.layoutContent(this);
		}
		elt = grid.stateBarView();
		elt.setVisible(indicator.$_stateVisible());
		if (elt.visible()) {
			elt.setRect(this._stateBarBounds);
			elt.layoutContent(this);
		}
		elt = grid.checkBarView();
		elt.setVisible(checkBar.visible());
		if (elt.visible()) {
			elt.setRect(this._checkBarBounds);
			elt.layoutContent(this);
		}
		elt = rowGroup && this.rowGroupView();
        if (elt) {
            elt.setVisible(this.rowGrouped());
            if (elt.visible()) {
                elt.setRect(r = this._rowGroupBounds);
                elt.setClipBounds(r.x, r.y, gr.right() - r.x + sb, r.height);
            }
        }
		elt = grid.headerView();
		elt.setVisible(header.visible());
		if (elt.visible()) {
			elt.setRect(this._headerBounds);
			elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width + sb, bounds.height);
			elt.layoutContent(this);
		}
		elt = grid.fixedHeaderView();
		elt.setVisible(fixed && header.visible());
		if (elt.visible()) {
			elt.setRect(this._fixedHeaderBounds);
			elt.layoutContent(this);
		}
        elt = grid.summaryView();
        elt.setVisible(summary.visible());
        if (elt.visible()) {
            elt.setRect(this._summaryBounds);
			elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width + sb, bounds.height);
            elt.layoutContent(this);
        }
        elt = grid.fixedSummaryView();
        elt.setVisible(fixed && summary.visible());
        if (elt.visible()) {
            elt.setRect(this._fixedSummaryBounds);
            elt.layoutContent(this);
        }
		elt = grid.headerHeadView();
		elt.setVisible(header.visible() && indicator.visible() && header.head().visible());
		if (elt.visible()) {
			elt.updateCell(header.getHeadCell());
			elt.setBounds(this._rowIndicatorBounds.x, this._headerBounds.y, this._rowIndicatorBounds.width + this._stateBarBounds.width, this._headerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.checkBarHeadView();
		elt.setVisible(checkBar.visible() && header.visible() && checkBar.headVisible());
		if (elt.visible()) {
			elt.updateCell(checkBar.getHeadCell());
			elt.setBounds(this._checkBarBounds.x, this._headerBounds.y, this._checkBarBounds.width, this._headerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.rowGroupHeadView();
		elt.setVisible(grid.rowGrouped() && !rowGroup.mergeMode());
		if (elt.visible()) {
			elt.setRect(this._rowGroupHeadBounds);
			elt.layoutContent(this);
		}
		elt = grid.summaryHeadView();
		r = 0;
		if (summary.visible() && summary.head().visible()) {
			if (indicator.visible()) r += this._rowIndicatorBounds.width + this._stateBarBounds.width;
			if (checkBar.visible()) r += this._checkBarBounds.width;
			r += this._rowGroupHeadBounds.width;
		}
		elt.setVisible(r > 0);
		if (elt.visible()) {
			elt.updateCell(summary.getHeadCell());
			elt.setBounds(this._rowIndicatorBounds.x, this._summaryBounds.y, r, this._summaryBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.footerView();
		elt.setVisible(footer.visible());
		if (elt.visible()) {
			elt.setRect(this._footerBounds);
			elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width, this._footerBounds.bottom());
			elt.layoutContent(this);
		}
		elt = grid.fixedFooterView();
		elt.setVisible(fixed && footer.visible());
		if (elt.visible()) {
			elt.setRect(this._fixedFooterBounds);
			elt.layoutContent(this);
		}
        elt = grid.footerItemsView();
        elt.setVisible(this._footerItemsBounds.height > 0);
        if (elt.visible()) {
            elt.setRect(this._footerItemsBounds);
            elt.layoutContent(this);
        }
        elt = grid.footerHeadView();
        r = 0;
        if (footer.visible() && footer.head().visible()) {
            if (indicator.visible()) r += this._rowIndicatorBounds.width + this._stateBarBounds.width;
            if (checkBar.visible()) r += this._checkBarBounds.width;
			r += this._rowGroupHeadBounds.width;
        }
        elt.setVisible(r > 0);
        if (elt.visible()) {
            elt.updateCell(footer.getHeadCell());
            elt.setBounds(this._rowIndicatorBounds.x, this._footerBounds.y, r, this._footerBounds.height);
            elt.layoutContent(this);
        }
		var fixedView = grid.fixedBodyView();
		elt = grid.bodyView();
		if (this._fixedItemCount + this._itemCount > 0) {
			if (this._fixedCols > 0) {
				fixedView.setVisible(true);
				fixedView.setRect(this._fixedBounds);
                fixedView.setClipBounds(this._fixedBounds.x, this._gridBounds.y, this._fixedBounds.width, this._gridBounds.height);
			} else {
				fixedView.setVisible(false);
			}
            elt.setVisible(true);
			elt.setRect(this._bodyBounds);
			elt.setClipBounds(this._nonfixedBounds.x, this._gridBounds.y, this._nonfixedBounds.width + sb, this._gridBounds.height);
			this._layoutItems(elt, this._bodyBounds);
		} else {
            fixedView.setVisible(false);
            elt.setVisible(false);
			this._layoutItems(elt, this._bodyBounds);
		}
		elt = grid.fixedMergeView();
		elt.setVisible(fixed);
		if (fixed) {
			r = this._fixedBounds;
			elt.setRect(r);
			elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
		}
		elt = grid.mergeView();
		r = this._bodyBounds;
		elt.setRect(r);
        if (fixed) {
            elt.setClipBounds(Math.max(r.x, this._fixedBounds.right()), r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
        } else {
            elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
        }
		r = this._fixedBounds;
		grid.mergeHeaderView().setBounds(r.x, r.y, r.width + this._bodyBounds.width, r.height);
		grid.mergeHeaderView().setClipBounds(r.x, r.y, Math.min(r.width + this._bodyBounds.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
		this.$_layoutMerges();
		/*
		elt = grid.getEditBarRenderer();
		elt.setVisible(editBar.visible());
		if (elt.visible()) {
			elt.setRect(this._editBarBounds);
			elt.layoutContent(this);
		}
		*/
	},
	$_calcFixedColumnPoints: function () {
		var i, x, column,
		    grid = this._grid;
        this._columns = [];
		this._columnCount = grid.visibleColumnCount();
		this._fixedCols = Math.min(grid.displayOptions().fixedColumnCount(), this._columnCount);
		this._fixedColumnPoints = [];
		this._fixedWidth = 0;
		if (this._fixedCols > 0) {
			x = 0;
			this._fixedColumnPoints.push(x);
			for (i = 0; i < this._fixedCols; i++) {
				column = grid.getVisibleColumn(i);
				this._columns.push(column);
				x += column.width();
				this._fixedColumnPoints.push(x);
			}
			this._fixedWidth = this._fixedColumnPoints[this._fixedCols] + Math.max(0, grid.body().fixedColumnBarWidth());
		}
	},
	$_calcColumnPoints: function () {
		var	gd = this._grid,
		    n = this._columnCount - this._fixedCols,
		    pts = this._columnPoints = [];
        this._columnsLength = 0;
		if (n > 0) {
			var i, column,
				x = 0;
			pts.push(x);
			for (i = 0; i < n; i++) {
				column = gd.getVisibleColumn(i + this._fixedCols);
				this._columns.push(column);
				x += column.width();
				pts.push(x);
			}
			this._columnsLength = x;
		}
	},
	$_measureFitting: function (bounds) {
        var	grid = this._grid;
		this._columnsFitted = this._options.fitStyle() != GridFitStyle.NONE;
		if (this._columnsFitted) {
			var cnt = this._columnPoints.length;
			if (cnt > 0) {
                var w = bounds.width;
				if (this._options.fitStyle() == GridFitStyle.EVEN_FILL) {
                    /*
					for (var i = 1; i < cnt; i++) {
						this._columnPoints[i] = _int(this._columnPoints[i] * w / this._columnsLength);
					}
					this._columnPoints[cnt - 1] = w;
					this._columnsLength = w;
					*/
				} else {
					this._columnsFitted = w - this._columnPoints[cnt - 1] > 0;
				}
			} else {
				this._columnsFitted = false;
			}
		}
        grid.$_hideBorders = grid.$_hideBorders && this._columnsFitted;
	},
	$_fitColumns: function (w) {
        if (!this._columnsFitted) return;
		var cols = this._columns,
			pts = this._columnPoints,
			cnt = pts.length;
		if (cnt > 0) {
			var i, dx, column, sum, fsum,
            	cw = this._columnsLength,
            	options = this._options,
            	fitStyle = options.fitStyle();
			if (fitStyle == GridFitStyle.EVEN || fitStyle == GridFitStyle.EVEN_FILL) {
				for (i = 1; i < cnt; i++) {
					pts[i] = _int(pts[i] * w / cw);
				}
			} else if (fitStyle == GridFitStyle.FILL) {
				sum = 0;
				fsum = 0;
				for (i = 0; i < cnt - 1; i++) {
					if ((dx = cols[i].fillWidth()) > 0) {
						fsum += dx;
					} else {
						sum += cols[i].width();
					}
				}
				if (fsum > 0) {
					sum = w - sum;
					for (i = 1; i < cnt; i++) {
						if ((dx = cols[i - 1].fillWidth()) > 0) {
							pts[i] = _int(pts[i - 1] + dx * sum / fsum);
						} else {
							pts[i] = _int(pts[i - 1] + cols[i - 1].width());
						}
					}
				} else {
					for (i = 1; i < cnt; i++) {
						pts[i] = _int(pts[i] * w / cw);
					}
				}
			}
            pts[cnt - 1] = w;
			for (i = 0; i < cnt - 1; i++) {
				column = cols[this._fixedCols + i];
				this._setFitWidth(column, pts[i + 1] - pts[i]);
			}
		}
		this._columnsLength = w;
	},
	$_getItemHeight: function (grid, delegate, index) {
		var h, view, groupHeader, styles, sz,
		    item = this._items.getItem(index);
		if (!this._vcolgrouped) {
			h = item.$_height(grid);
			if (!isNaN(h)) {
				return h;
			}
		}
		view = delegate.borrowItemView(item, false);
        groupHeader = false;
		styles = null;
		if (view instanceof GroupRowElement) {
            if (item instanceof GroupRow) {
                styles = this._getRowGroup().headerStyles();
                groupHeader = true;
            } else if (item instanceof GroupFooter) {
                styles = this._getRowGroup().footerStyles();
                groupHeader = true;
            } else if (item instanceof CustomGroupItemRow) {
                groupHeader = true;
            }
		}
        if (!styles && item instanceof GridRow) {
			styles = grid.body().cellStyles();
		} 
		view.updateElement(item, styles);
        if (groupHeader) {
            h = item instanceof GroupFooter ? this._heightMeasurer.getGroupFooterHeight(item, grid.rowGroup())
                : this._heightMeasurer.getGroupHeaderHeight(item, grid.rowGroup());
        } else {
            h = this._heightMeasurer.itemHeight();
        }
		sz = view.measure(grid, 10000, h);
		delegate.returnItemView(view);
		return sz.height;
	},
	$_compensateItems: function (bounds) {
        var i, y, h, cnt, pts,
		    grid = this.grid(),
            delegate = grid.delegate(),
            nFixed = this._fixedItemCount,
		    focusIndex = this._focusIndex ? this._focusIndex.rowIndex : this._focusRow;
		if (focusIndex >= this._topIndex + nFixed + this._fullItemCount) {
			this._topIndex = focusIndex - nFixed - Math.max(0, this._fullItemCount - 1); // fullItemCount가 0일 수 있다.
			if (nFixed > 0) {
				y = this._fixedHeight + grid.body().fixedRowBarHeight();
			} else {
				y = 0;
			}
            pts = this._itemPoints = [y];
			this._itemCount = 0;
			this._fullItemCount = 0;
			this._availableItemCount = 0;
			cnt = grid.rowCount() - nFixed;
			for (i = this._topIndex; i < cnt && y < bounds.height; i++) {
				h = this.$_getItemHeight(grid, delegate, i + nFixed);
				y += h;
				this._itemCount++;
				pts.push(y);
			}
            if (focusIndex == this._topIndex + nFixed + this._itemCount - 1 && y >= bounds.height) {
                while (this._itemCount > 1 && pts[this._itemCount] > bounds.height) {
                    h = pts[1] - pts[0];
                    pts.shift();
                    this._itemCount--;
                    for (i = 0; i <= this._itemCount; i++) {
                        pts[i] -= h;
                    }
                    this._topIndex++;
                    y = pts[this._itemCount];
                }
                while (y < bounds.height && this._topIndex + this._itemCount < cnt) {
                    h = this.$_getItemHeight(grid, delegate, this._topIndex + this._itemCount + nFixed);
                    y += h;
                    this._itemCount++;
                    pts.push(y);
                }
            }
			this._fullItemCount = this._itemCount - (y >= bounds.height ? 1 : 0);
			return y;
		} else {
			return -1;
			/*
			y =  this._itemPoints[this._itemCount];
			while (this._topIndex > 0 && y < bounds.height) {
				h = this.$_getItemHeight(grid, delegate, this._topIndex + this._fixedItemCount);
				if (y + h <= bounds.height) {
					this._topIndex--;
					this._itemCount++;
					this._fullItemCount++;
					this._itemPoints.unshift(this._itemPoints[0] - h);
				}
				y += h;
			}
			h = this._itemPoints[0];
			if (h < 0) {
				for (i = 0, cnt = this._itemPoints.length; i < cnt; i++) {
					this._itemPoints[i] += -h;
				}
			}
			*/
		}
	},
	_calcItemPoints: function (bounds) {
        var i, cnt, h, top,
		    focusIndex = -1,
		    grid = this._grid,
		    delegate = grid.delegate(),
		    y = 0;
		this._fixedRows = this._getFixedRowCount();
		this._fixedItemCount = 0;
		this._fixedHeight = 0;
		this._fixedItemPoints = [];
		if (this._fixedRows > 0) {
			this._fixedItemPoints.push(y);
			for (i = 0; i < this._fixedRows && y < bounds.height; i++) {
				h = this.$_getItemHeight(grid, delegate, i);
				y += h;
				this._fixedItemPoints.push(y);
				this._fixedItemCount++;
			}
			this._fixedHeight = y;
			y += grid.body().fixedRowBarHeight();
		}
		cnt = grid.rowCount() - this._fixedItemCount;
		this._itemPoints = [];
		this._itemCount = 0;
		this._fullItemCount = 0;
		this._availableItemCount = 0;
		if (cnt > 0 && y < bounds.height) {
			this._itemPoints.push(y);
			top = this._topIndex;
			focusIndex = this._focusIndex ? this._focusIndex.rowIndex : this._focusRow;
			if (focusIndex >= this._fixedItemCount && focusIndex < top + this._fixedItemCount) {
				top = this._topIndex = focusIndex - this._fixedItemCount;
			}
			for (i = top; i < cnt && y < bounds.height; i++) {
				h = this.$_getItemHeight(grid, delegate, i + this._fixedItemCount);
				y += h;
				this._itemCount++;
				this._itemPoints.push(y);
			}
			this._fullItemCount = this._itemCount - (y >= bounds.height ? 1 : 0);
			h = this.$_compensateItems(bounds);
			if (h >= 0) y = h;
		}
		bounds.height = y;
	},
    $_checkMerging: function (col, first, last, mergeView) {
        var merges, rooms;
        if (col instanceof ValueColumn && col.canMerge()) {
            merges = col.stateFor(ColumnMergeManager.MERGE_ROOMS);
            if (!merges) {
                merges = new ColumnMergeManager(col);
                col.setState(ColumnMergeManager.MERGE_ROOMS, merges);
            }
            merges.refresh(first, last);
            rooms = merges.getRooms();
            mergeView.addColumnRooms(col, rooms);
            this._columnMerged = true;
        }
    },
    $_checkMergingGroup: function (group, first, last, mergeView) {
        for (var i = group.visibleCount(); i--;) {
            this.$_checkMerging(group.getVisibleItem(i), first, last, mergeView);
        }
    },
	$_checkColumnMerging: function () {
        var i, j, cnt, col, merges, rooms,
		    grid = this._grid,
		    mergeView = grid.mergeView(),
		    fixedMergeView = grid.fixedMergeView(),
		    first = this._fixedItemCount + this._topIndex,
		    last = Math.min(grid.rowCount() - 1, this._fixedItemCount + this._topIndex + this._itemCount - 1),
		    fixed = this._fixedCols > 0;
        fixed && fixedMergeView.clearRooms();
		mergeView.clearRooms();
		for (i = 0, cnt = this._fixedCols; i < cnt; i++) {
            col = this._columns[i];
            this.$_checkMerging(col, first, last, fixedMergeView);
            if (col instanceof ColumnGroup && col.horizontal()) {
                this.$_checkMergingGroup(col, first, last, fixedMergeView);
            }
		}
		for (i = this._fixedCols, cnt = this._columns.length; i < cnt; i++) {
			col = this._columns[i];
            this.$_checkMerging(col, first, last, mergeView);
            if (col instanceof ColumnGroup && col.horizontal()) {
                this.$_checkMergingGroup(col, first, last, mergeView);
            }
		}
        fixed && fixedMergeView.clearFooters();
		mergeView.clearFooters();
		grid.mergeHeaderView().clearHeaders();
	},
	_layoutItems: function (parent, r) {
        var i, model, top,
		    grid = this._grid,
            rowGroup = this._getRowGroup(),
            rowGroupView = rowGroup && this.rowGroupView(),
		    bodyView = grid.bodyView(),
		    fixedView = grid.fixedBodyView(),
		    fixed = this._fixedCols > 0;
        rowGroupView && rowGroupView.clearBody();
		bodyView.clearItems();
		fixedView.clearItems();
		for (i = 0; i < this._fixedItemCount; i++) {
			model = this._items.getItem(i);
			if (model instanceof GroupRowImpl) {
				rowGroupView.addHeader(model);
			} else if (model instanceof GroupFooter && rowGroupView) {
				rowGroupView.addFooter(model);
			} else if (!model.merged()) {
				model.$_state = model.dataState();
                model.$_checked = model.$_isChecked(grid);
				bodyView.addItem(model);
				if (fixed) {
					fixedView.addItem(model);
				}
			}
		}
		top = this._topIndex + this._fixedRows;
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof GroupRowImpl) {
				rowGroupView.addHeader(model);
			} else if (model instanceof GroupFooter && rowGroupView) {
                rowGroupView.addFooter(model);
            } else if (model instanceof CustomGroupItemRow) {
                model.model().isHeader() ? rowGroupView.addCustomHeader(model) : rowGroupView.addCustomFooter(model);
			} else if (!model.merged()) {
				model.$_state = model.dataState();
                model.$_checked = model.$_isChecked(grid);
				bodyView.addItem(model);
				if (fixed) {
					fixedView.addItem(model);
				}
			}
		}
		bodyView.layoutContent(this);
		if (fixed) {
			fixedView.layoutContent(this);
		}
		if (rowGroup && this.rowGrouped()) {
			rowGroupView.layoutContent(this);
		}
	},
	$_layoutMerges: function () {
		var	grid = this._grid;
		var	fixed = this._fixedCols > 0;
		var i, mergeView, top, model, fixedView, headerView;
		mergeView = grid.mergeView();
		top = this._topIndex + this._fixedRows;
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof MergedGroupFooter) {
				mergeView.addFooter(model);
			}
		}
		mergeView.layoutContent(this);
		if (fixed) {
			fixedView = grid.fixedMergeView();
			for (i = 0; i < this._itemCount; i++) {
				model = this._items.getItem(i + top);
				if (model instanceof MergedGroupFooter) {
					fixedView.addFooter(model);
				}
			}
			fixedView.layoutContent(this);
		}
		headerView = grid.mergeHeaderView();
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof MergedGroupHeader) {
				headerView.addHeader(model);
			}
		}
		headerView.layoutContent(this);
	},
	_doFitGroupWidth: function (group, visibleOnly, minWidth, maxWidth, includeHeader) {
        var wmax, i, column, w, cellView,
		    grid = this._grid,
			bHeader = includeHeader && grid.header().visible(),
		    itemCount = grid.rowCount();
		if (itemCount < 1) {
			return 2;
		}
		maxw = 0;
		for (i = group.visibleCount(); i--;) {
			column = group.getVisibleItem(i);
			if (column instanceof ColumnGroup) {
				w = this._doFitGroupWidth(column, visibleOnly, minWidth, maxWidth, bHeader);
			} else {
				w = this._doFitColumnWidth(column, visibleOnly, minWidth, maxWidth, true, bHeader);
			}
			if (group.layout() == ColumnGroupLayout.HORIZONTAL) {
				ColumnGroup.changeWidth(column, w - column.groupWidth(), false);
				maxw += w;
			} else {
				maxw = Math.max(maxw, w);
			}
		}
		if (bHeader) {
			cellView = grid._headerView.findCell(column, true);
			if (cellView && cellView.visible()) {
				maxw = Math.max(maxw, cellView.measureWidth(grid, 0, MAX_INT, MAX_INT));
			}
		}
		if (group.layout() == ColumnGroupLayout.VERTICAL) {
			if (maxWidth > 0) {
				maxw = Math.min(maxw, maxWidth);
			}
			if (minWidth > 0) {
				maxw = Math.max(maxw, minWidth);
			}
			maxw = Math.max(maxw,2);
			ColumnGroup.changeWidth(group, maxw - group.groupWidth(), false);
		}
		return maxw;
	},
	_doFitColumnWidth: function (column, visibleOnly, minWidth, maxWidth, calcOnly, includeHeader) {
		var height, start, end, i, cellView, renderer, sz,
			w = 2,
			grid = this._grid,
			delegate = grid.delegate(),
			body = grid.body(),
			defWidth = this._options.defaultColumnWidth(),
			itemCount = grid.rowCount();
		if (itemCount < 1) {
			return w;
		}
		cellView = (column instanceof SeriesColumn) ? new TestSeriesCellElement(grid) : new TestDataCellElement(grid);
        start = 0,
        end = itemCount;
		if (visibleOnly) {
			start = grid.topRow();
			end = start + this.itemCount();
			if ((itemCount = this.fixedItemCount()) > 0) {
				height = this.$_getItemHeight(grid, delegate, 0);
				for (i = 0; i < itemCount; i++) {
					cellView.updateCell(body.getCell(CellIndex.temp(i, column)));
					sz = cellView.measureWidth(grid, defWidth, MAX_INT, height);
					w = Math.max(w, sz);
				}
			}
		}
		if (start < end) {
			height = this.$_getItemHeight(grid, delegate, start);
			for (i = start; i < end; i++) {
				cellView.updateCell(body.getCell(CellIndex.temp(i, column)));
				sz = cellView.measureWidth(grid, defWidth, MAX_INT, height);
				w = Math.max(w, sz);
			}
		}
		if (maxWidth > 0) {
			w = Math.min(w, maxWidth);
		}
		if (minWidth > 0) {
			w = Math.max(w, minWidth);
		}
        if (includeHeader && grid.header().visible()) {
            cellView = (column.fixed() ? grid._fixedHeaderView : grid._headerView).findCell(column);
			if (cellView && cellView.visible()) {
				w = Math.max(w, cellView.measureWidth(grid, 0, MAX_INT, MAX_INT));
			}
        }
		!calcOnly && ColumnGroup.changeWidth(column, w - column.groupWidth(), false);
		return w;
	},
	_measureColumnHeight: function (grid, row, column, width, maxHeight) {
        var view = (column instanceof SeriesColumn) ? new TestSeriesCellElement(grid) : new TestDataCellElement(grid);
        view.updateCell(grid._body.getCell(CellIndex.temp(row, column)));
        return view.measureHeight(grid, width, maxHeight);
	},
	_getColumnRectInRoot: function (column, root, r) {
		var c = column.parent();
		r.copy(column._layoutRect);
		while (c != root) {
			r.offset(c._layoutRect.x, c._layoutRect.y);
			c = c.parent();
		}
	},
	_clearFitWidths: function () {
		this.grid()._clearFitWidths();
	},
	_getColumnWidth: function (index) {
		return index < this._fixedCols ? (this._fixedColumnPoints[index + 1] - this._fixedColumnPoints[index]) :
			this._columnPoints[index - this._fixedCols + 1] - this._columnPoints[index - this._fixedCols];
	},
	_setFitWidth: function (column, w) {
		column._fitWidth = w;
		var group = _cast(column, ColumnGroup);
		if (group) {
			group.resetFitWidths();
		}
	}
});
var TestDataCellElement = defineClass("TestDataCellElement", DataCellElement, {
	init : function(grid) {
		this._super(grid._dom);
		this._grid = grid;
	},
	grid: function () {
		return this._grid;
	},
    container: function () {
        return this._grid.container();
    }
});
var TestSeriesCellElement = defineClass("TestSeriesCellElement", SeriesCellElement, {
	init : function(grid) {
		this._super(grid._dom);
		this._grid = grid;
	},
	grid: function () {
		return this._grid;
	},
	container: function () {
		return this._grid.container();
	}
});
var $$_EDITOR_THRESHOLD = _isSafari ? 1 : 0;
var $$_EMPTY_TEXT_VALUE = '***1-da*&23%^1//+)(lu%v\\3d!#~`{``~er';
var CellEditor = defineClass("CellEditor", EventAware, {
	init: function (grid, parentElement/* <body> */) {
		this._super();
		this._grid = grid;
		this._parentElement = parentElement;
		this._editor = this._createEditor(parentElement);
		this._editor.$_owner = this;
		this._editIndex = new CellIndex();
		this._controller = null;
		this._started = false;
		this._oldValue = undefined;
		this._dateConverter =  DatetimeConverter.Default;
		this._saveDateConverter = null;
		this._boolConverter = BooleanConverter.Default;
		this._saveBoolConverter = null;
		this._setCallback = null;
		this._getCallback = null;
		this._cellBounds = new Rectangle();
		if (this._editor) {
			if (this._editor.addEventListener) {
				this._editor.addEventListener("focus", function (e) {
					this._grid.$_setEditFocused(true);
				}.bind(this));
				this._editor.addEventListener("focusin", function (e) {
					this._grid.$_setEditFocused(true);
				}.bind(this));
				this._editor.addEventListener("blur", function (e) {
					this._grid.$_setEditFocused(false);
				}.bind(this));
				this._editor.addEventListener("focusout", function (e) {
					this._grid.$_setEditFocused(false);
				}.bind(this));
			} else {
				this._editor.attachEvent("onfocus", function (e) {
					this._grid.$_setEditFocused(true);
				}.bind(this));
				this._editor.attachEvent("onfocusin", function (e) {
					this._grid.$_setEditFocused(true);
				}.bind(this));
				this._editor.attachEvent("onblur", function (e) {
					this._grid.$_setEditFocused(false);
				}.bind(this));
				this._editor.attachEvent("onfocusout", function (e) {
					this._grid.$_setEditFocused(false);
				}.bind(this));
			}
		}
		this.setVisible(false, true);
	},
	emptyValue: undefined,
	textCase: EnumProp(TextInputCase, TextInputCase.DEFAULT),
	fontName: undefined,
	fontSize: undefined,
	datetimeFormat: null,
	booleanFormat: null,
    visible: false,
	readOnly: false,
	onSetEditValue: null,
	onGetEditValue: null,
    setReadOnly: function (value) {
        if (_isIE && !this.visible()) {
            this._readOnly = value;
        } else {
            this._editor.readOnly = this._readOnly = value;
        }
    },
    setDatetimeFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
			if (value) {
				if (!this._saveDateConverter) {
					this._saveDateConverter = new DatetimeConverter(value);
				}
				this._saveDateConverter.setFormatString(value);
				this._dateConverter = this._saveDateConverter;
			} else {
				this._dateConverter = DatetimeConverter.Default;
			}
		}
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				if (!this._saveBoolConverter) {
					this._saveBoolConverter = new BooleanConverter(value);
				}
				this._saveBoolConverter.setFormat(value);
				this._boolConverter = this._saveBoolConverter;
			} else {
				this._boolConverter = BooleanConverter.Default;
			}
		}
	},
	setOnSetEditValue: function (value) {
		if (value != this._onSetEditValue) {
			this._onSetEditValue = value;
			this._setCallback = _createCallback(value);
		}
	},
	setOnGetEditValue: function (value) {
		if (value != this._onGetEditValue) {
			this._onGetEditValue = value;
			this._getCallback = _createCallback(value);
		}
	},
	editor: function () {
		return this._editor;
	},
	visible_: function () {
		return parseInt(this._container.style.width) > $$_EDITOR_THRESHOLD && parseInt(this._container.style.height) > $$_EDITOR_THRESHOLD;
	},
	setVisible: function (value, force) {
        var v;
		if (value) {
			if (this._fontName) {
				v = this._fontName;
			} else {
				v = this._grid ? this._grid.editOptions().fontName() : "";
			}
			if (v != this._editor.style.fontFamily) {
				this._editor.style.fontFamily = v || 'Tahoma';
			}
			if (this._fontSize) {
				v = this._fontSize;
			} else {
				v = this._grid ? this._grid.editOptions().fontSize() : "";
			}
            if (!isNaN(v)) v = v + 'px';
			if (v != this._editor.style.fontSize) {
				this._editor.style.fontSize = v || '10pt';
			}
		}
        if (value && this._editor.value == $$_EMPTY_TEXT_VALUE) {
            this._editor.value = "";
        } else if (!value && (this._editor.value == null || this._editor.value == undefined || this._editor.value == "")) {
            this._editor.value = $$_EMPTY_TEXT_VALUE;
            if (this._grid.$_editFocused) {
                this.selectAll();
            }
        }
		if (!value) {
            Dom.setSize(this._container, $$_EDITOR_THRESHOLD, $$_EDITOR_THRESHOLD);
        }
        if (value && _isIE) {
            this._editor.readOnly = this._readOnly || this._textReadOnly;
        }
	},
	isEditing: function () {
		return this._started;
	},
	editIndex: function () {
		return this._editIndex;
	},
	hasButton: function () {
		return false;
	},
	maskable: function () {
		return false;
	},
    dispose: function () {
        this._deleteEditor();
    },
	initOptions: function () {
		this._emptyValue = undefined;
		this._booleanFormat = null;
		this._datetimeFormat = null;
		this._textCase = TextInputCase.DEFAULT;
		this._fontName = null;
		this._fontSize = null;
	},
	applyOptions: function (options) {
		options && this.assign(options);
	},
    setController: function (value) {
        this._controller = value;
    },
	beginEdit: function (clear, select) {
		if (!this._started) {
			this._started = this._doBeginEdit();
            clear && this.clear();
            select && this.selectAll();
		}
	},
	endEdit: function () {
		if (this._started) {
			this._doEndEdit();
			this._started = false;
		}
	},
    caretToLast: function () {
    },
	commit: function () {
		this._doCommit();
	},
	setEditIndex: function (index) {
		this._editIndex.assign(index);
	},
	getEditValue: function (committing, throwError) {
		return undefined;
	},
	setEditValue: function (value) {
		this._oldValue = value;
	},
	getEditText: function () {
		return "";
	},
	clear: function () {
		this._editor.value = "";
	},
	setFocus: function () {
            this._editor.focus();
	},
	selectAll: function () {
        if (this._grid.$_editFocused) {
            this._selectAll();
        }
	},
	setBounds: function (x, y, w, h) {
	},
	setCellBounds: function (x, y, w, h) {
		this._cellBounds.set(x, y, w, h);
	},
    showList: function (force) {
    },
	closeList: function (accept) {
	},
	buttonClicked: function (index) {
	},
	_createEditor: function (parent) {
		return null;
	},
    _deleteEditor: function () {
    },
    _selectAll: function () {
    },
	_editField: function () {
		return this._grid.dataSource() ? this._grid.dataSource().getField(this._editIndex.dataField()) : null;
	},
    _isDateEditor: function () {
        return false;
    },
	_doBeginEdit: function () {
		return true;
	},
	_doEndEdit: function () {
	},
    _doBack: function () {
    },
    _doDelete: function () {
    },
    _doChar: function (key, code) {
    },
    _doCopy: function (e) {
    },
    _doCut: function (e) {
    },
    _doPaste: function (e) {
    },
	_requestStart: function () {
		if (!this._started) {
			this.selectAll();
			this._controller.onEditorStart(this);
		}
		return this._started;
	},
	$_valToStr: function (value) {
        var fld, col,
		    index = this.editIndex(),
		    s = "";
		try {
			if (value !== UNDEFINED) {
				fld = index.grid().dataSource().getField(index.dataField());
				if (fld) {
					switch (fld.dataType()) {
						case ValueType.DATETIME:
							if (value) {
								s = this._dateConverter.getText(value);
							}
							break;
						case ValueType.BOOLEAN:
							s = this._boolConverter.toText(value);
							break;
						case ValueType.NUMBER:
							if (!isNaN(value)) {
								s = _toStr(value);
							}
							break;
						case ValueType.OBJECT:
							if (value) {
                                col = index.column;
								s = col._keyFn ? col._keyFn(fld, value) : DataPath.extractJson(value, col._keyPath, true);
							}
							break;
						default:
							s = value;
							break;
					}
				} else {
					s = _toStr(value);
				}
			}
		} catch (err) {
			_throwDebug(err);
			s = value;
		}
		return s === null || s === undefined ? "" : s;
	},
	$_strToVal: function (s) {
        var fld, t, dateFld, d,
		    index = this._editIndex,
		    tcase = index.dataColumn() && this._textCase == TextInputCase.DEFAULT ? index.dataColumn().textInputCase() : this._textCase;
        s = _toStr(s);
			fld = index.grid().dataSource().getField(index.dataField());
			if (fld) {
                t = fld.dataType();
				if (t == ValueType.DATETIME || (s && this._isDateEditor() && t == ValueType.TEXT)) {
                    dateFld = fld.dataType() == ValueType.DATETIME;
                    d = null;
                    if (!d) {
                        d = this._dateConverter.getDate(s, index.getValue());
                    }
					return dateFld ? fld.getZonedDate(d) : this._dateConverter.getText(d);
				} else if (t == ValueType.BOOLEAN) {
					return this._boolConverter.toBoolEx(s);
				} else if (t == ValueType.NUMBER) {
                    return parseFloat(s);
                }
			}
			if (tcase === TextInputCase.UPPER) {
				return s ? s.toLocaleUpperCase() : s;
			} else if (tcase === TextInputCase.LOWER) {
				return s ? s.toLocaleLowerCase() : s;
			} else {
				return s;
			}
	},
    $_readEditValue: function (s, committing) {
        var t,
            fld = this._editField(),
            v = this._emptyValue;
        t = fld.dataType();
        if (this._minLength > 0 && (!s || s.length < this._minLength)) {
            return CellEditor.ShortLength;
        }
        if (t == ValueType.TEXT) {
            if (!s && this._emptyValue !== undefined) {
                s = this._emptyValue;
            }
            v = this.$_strToVal(s);
            if (v === undefined) {
                v = "";
            }
        } else {
            if (!_isWhiteSpace(s)) {
                v = this.$_strToVal(s);
            } else if (this._emptyValue !== undefined) {
                v = this.$_strToVal(this._emptyValue);
            } else {
                switch (t) {
                    case ValueType.NUMBER:
                        if (isNaN(this._oldValue)) {
                            v = NaN;
                        }
                        break;
                    case ValueType.DATETIME:
                        if (this._oldValue === null) {
                            v = null;
                        }
                        break;
                    case ValueType.BOOLEAN:
                        break;
                }
            }
        }
        v = fld.readValue(v);
        return v;
    },
	_dispatchKeyDown: function (keyCode, ctrl, shift, alt) {
        if (!this._controller) debugger;
		return this._controller.onEditorKeyDown(this, keyCode, ctrl, shift, alt);
	},
    _dispatchKeyUp: function (keyCode, ctrl, shift, alt) {
        if (!this._controller) debugger;
        return this._controller.onEditorKeyUp(this, keyCode, ctrl, shift, alt);
    },
	_dispatchChange: function () {
		this._controller.onEditorChange(this);
	},
	_dispatchSearch: function (text) {
		this._controller.onEditorSearch(this, text);
	},
    _dispatchCommit: function () {
        this._controller.onEditorCommit(this);
    },
	_ignoreHandler: function (e) {
		_ignoreEvent(e);
	},
	_sendToParent: function (e, stop) {
        stop && e.stopImmediatePropagation();
        _ieTen && (this._editor.oninput = null);
		var ctrl = _isMac && (e.metaKey || e.ctrlKey) || !_isMac && e.ctrlKey;
        if (this._dispatchKeyDown(e.keyCode, ctrl, e.shiftKey, e.altKey)) {
            _stopEvent(e);
			return true;
		}
		return false;
	},
	_pasteHandler: function (e) {
		if (this.visible()) {
            if (this._doPaste(e) === true) {
                _stopEvent(e);
            }
			this._doChanged();
		} else {
			e.preventDefault();
			try {
				var text = _getClipboardText(e);
				if (text) {
					this._grid.pasteFromClipboard(text);
				}
			} catch (err) {
				if (err instanceof AbortError) {
					_alert(err.message);
					_throwDebug(err);
				} else {
					throw err;
				}
			}
		}
	},
    _cutHandler: function (e) {
        if (this.visible()) {
            if (this._doCut(e) === true) {
                _stopEvent(e);
            }
        }
    },
	_copyHandler: function (e) {
        if (this.visible()) {
            if (this._doCopy(e) === true) {
                _stopEvent(e);
            }
        } else {
			e.preventDefault();
            try {
                var data = this._grid.copyToClipboard();
                _defined(data) && _setClipboardText(e, data);
            } catch (err) {
                _rethrow(err);
            }
		}
	},
	$_setInputCase: function (index, textCase) {
		var tcase = textCase == TextInputCase.DEFAULT && index.dataColumn() ? index.dataColumn().textInputCase() : textCase;
		switch (tcase) {
			case TextInputCase.LOWER:
				this._editor.style.textTransform = "lowercase";
				break;
			case TextInputCase.UPPER:
				this._editor.style.textTransform = "uppercase";
				break;
			default:
				this._editor.style.textTransform = "none";
				break;
		}
	},
    _clearHanguls: function () {
        if (this.visible()) {
            var p = this._editor.selectionEnd;
            this._editor.value = this._editor.value.replace($$_HANGUL_REG, '');
            this._editor.setSelectionRange(p, p);
        }
    }
}, {
	Unselected: {},
    ShortLength: {},
    InvalidFormat: {}
});
/** @internal */
var CellEditorCollection = function (delegate) {
	var _options = {};
	this.addEditors = function (editors) {
		var i, cnt, e;
		if (editors) {
			if (!_isArray(editors)) {
				editors = [editors];
			}
			for (i = 0, cnt = editors.length; i < cnt; i++) {
				e = editors[i];
				if (e && e.hasOwnProperty("id") && e.id) {
					_options[e.id] = _extend({}, e);
				}
			}
		}
	};
	this.removeEditors = function (editorIds) {
		if (isArray(editorIds)) {
			for (var i = editorIds.length; i--;) {
				delete _options[editorIds[i]];
			}
		} else if (editorIds) {
			delete _options[editorIds];
		}
	};
	this.getEditor = function (id) {
		return _options[id];
	};
};
var TextCellEditor = defineClass("TextCellEditor", CellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._borderable = true;
		this._modified = false;
		this._inputValue = undefined;
        this._imeMode = ImeMode.AUTO;
	},
    keyCallback: null,  // function (key, code, pos, text):Boolean;
    noHangul: false,
    minLength: 0,
	maxLength: 0,
	text: function () {
		return this._editor.value;
	},
	setAlignment: function (align) {
		this._container.style.textAlign = "left";
	},
	setText: function (value) {
		if (this._editor && value != this._editor.value) {
			this._editor.value = value;
			this._doChanged();
		}
	},
	initOptions: function () {
		this._super();
        this._keyCallback = null;
        this._minLength = 0;
		this._maxLength = 0;
	},
	_selectAll: function () {
        this._editor.select();
	},
	caretToLast: function () {
		var len = _toStr(this._editor.value).length;
		this._editor.setSelectionRange(len, len);
	},
	_doBeginEdit: function (clear, select) {
		this._modified = false;
        if (this.visible()) { // 당연히 visible이어야 한다.
            if (!this._editor.value) {
                this._editor.setSelectionRange(0, 0);
            }
        }
		return true;
	},
	_doEndEdit: function () {
		this._modified = false;
	},
	_doCommit: function () {
	},
	setEditIndex: function (index) {
		if (!index) return;
		this._super(index);
		/*
		var grid = index.grid();
		if (grid) {
			 m_editor.useArrowKeys = grid.editOptions.useArrowKeys;
			 if (index.dataField >= 0 && grid.dataSource.getValueType(index.dataField) == GridValueType.Datetime) {
			 }
			 m_editor.tabConsumer = grid;
		}
		*/
		/*
		 m_editor.editable = !readOnly;
		 m_editor.maxChars = maxLength;
		 m_editor.textCase = textCase == TextInputCase.Default ? index.dataColumn.textInputCase : textCase;
		 setEditFont(grid, m_editor);
		 */
        this.$_setInputCase(index, this._textCase);
		this._editor.maxLength = this._maxLength > 0 ? this._maxLength : this._defMaxLength;
	},
	setEditValue: function (value) {
		this._super(value);
		return this._editor.value = this.$_valToStr(value);
	},
	getEditValue: function (committing, throwError) {
		throwError = arguments.length > 1 ? throwError : true;
        try {
            return this.$_readEditValue(this._editor.value, committing);
        } catch (e) {
            if (throwError) throw e;
            return this._emptyValue;
        }
	},
	getEditText: function () {
		return this._editor.value;
	},
	isEdited: function () {
		return this._modified;
	},
	setVisible: function (value, force) {
		this._super(value, force);
		if (value && this._borderable) {
			this._container.style["border"] = "2px solid rgb(82, 146, 247)";
			this._container.style["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		} else {
			this._container.style["border"] = "none";
			this._container.style["box-shadow"] = "none";
		}
	},
	/*
	_createContainer2: function () {
		var elt = document.createElement("div");
		var css = elt.style;
		elt["spellCheck"] = false;
		elt["aria-hidden"] = false;
		css["position"] = "absolute";
		css["z-index"] = 2000;
		css["resize"] = "none";
		css["border"] = "none";
		css["outline"] = "none";
		css["aria-hidden"] = false;
		css["font-family"] = "Tahoma";
		css["font-style"] = "normal";
		css["font-variant"] = "normal";
		css["font-weight"] = "normal";
		css["font-size"] = "13px";
		css["line-height"] = "normal";
		css["text-align"] = "left";
		css["padding"] = "1px 2px";
		css["margin"] = "0px";
		css["max-width"] = "none";
		css["max-height"] = "none";
		css["overflow"] = "hidden";
		css["background-color"] = "rgb(255, 255, 255)";
		css["box-shadow"] = "none";
		css["color"] = "rgb(68, 84, 106)";
		css["word-wrap"] = "break-word";
		return elt;
	},
	_createEditor2: function (parent) {
		this._container = this._createContainer2();
		parent.appendChild(this._container);
		var elt = document.createElement("div");
		var css = elt.style;
		elt["contenteditable"] = true;
		css["width"] = "100%";
		css["height"] = "100%";
		css["margin"] = 0;
		css["outline"] = "none";
		css["cursor"] = "text";
		css["-webkit-user-modify"] = "read-write-plaintext-only";
		css["white-space"] = "pre-wrap";
		css["-webkit-transform"] = "translateZ(0)";
		this._container.appendChild(elt);
		return elt;
	},
	*/
	_createContainer: function () {
		var elt = document.createElement("div");
		var css = elt.style;
		elt.spellcheck = false;
		elt["aria-hidden"] = false;
		css["outline"] = "none";
		css["aria-hidden"] = false;
		css["position"] = "absolute";
		css["z-index"] = 2000;
		css.boxSizing = "border-box";
		css["overflow"] = "hidden";
		css["border"] = "none";
		css["width"] = "0px";
		css["height"] = "0px";
		css["padding"] = "0px";
		css["margin"] = "0px";
		css.border = "2px solid rgb(82, 146, 247)";
		css.boxShadow = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		css.resize = "none";
		/*
		elt["spellCheck"] = false;
		elt["aria-hidden"] = false;
		css["outline"] = "none";
		css["aria-hidden"] = false;
		css["max-width"] = "none";
		css["max-height"] = "none";
		css["background-color"] = "rgb(255, 255, 255)";
		css["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		css["color"] = "rgb(68, 84, 106)";
		css["word-wrap"] = "break-word";
		*/
		return elt;
	},
	_createEditor: function (parent) {
		this._container = this._createContainer();
		parent && parent.appendChild(this._container);
		var elt = document.createElement("input");
		var css = elt.style;
		elt.autoComplete = "off";
		css.position = "absolute";
		css.margin = "0px";
		css.padding = "0px 1px 0px 2px";
		css.fontFamily = "";
		css.fontStyle = "normal";
		css.fontVariant = "normal";
		css.fontWeight = "normal";
		css.fontSize = "";
		css.lineHeight = "normal";
		css.wordWrap = "normal";
		css.overflow = "hidden";
		css.resize = "none";
		css.border = "none";
		css.outline = "none";
		css.textAlign = "left";
		css.color = "rgb(68, 84, 106)";
		css.left = "0px";
		css.top = "0px";
		css.width = "100%";
		css.height = "100%";
		css.imeMode = "auto";
		css.cursor = "text";
		css["-webkit-user-modify"] = "read-write-plaintext-only";
		css["white-space"] = "pre-wrap";
		css["-webkit-transform"] = "translateZ(0)";
		elt.onmousedown =
			elt.onmousemove =
				elt.onmouseup =
					elt.onclick =
						elt.ondblclick = this._ignoreHandler.bind(this);
		elt.onkeydown = this._keyDownHandler.bind(this);
		elt.onkeyup = this._keyUpHandler.bind(this);
		elt.onkeypress = this._keyPressHandler.bind(this);
		elt.onchange = this._changeHandler.bind(this);
		elt.oninput = this._inputHandlerStock = this._inputHandler.bind(this);
		elt.onpaste = this._pasteHandler.bind(this);
        elt.oncut = this._cutHandler.bind(this);
		elt.oncopy = this._copyHandler.bind(this);
		if (elt.addEventListener) {
			elt.addEventListener("compositionstart", this._compositionstartHandler.bind(this));
			elt.addEventListener("compositionupdate", this._compositionupdatetHandler.bind(this));
			elt.addEventListener("compositionend", this._compositionendHandler.bind(this));
			elt.addEventListener("text", this._textHandler.bind(this));
			elt.addEventListener("selectionchange", function (ev) {
			});
		} else {
			elt.attachEvent("oncompositionstart", this._compositionstartHandler.bind(this));
			elt.attachEvent("oncompositionupdate", this._compositionupdatetHandler.bind(this));
			elt.attachEvent("oncompositionend", this._compositionendHandler.bind(this));
			elt.attachEvent("ontext", this._textHandler.bind(this));
			elt.attachEvent("onselectionchange", function (ev) {
			});
		}
		this._container.appendChild(elt);
		this._defMaxLength = elt.maxLength > 0 ? elt.maxLength : 1000000; // ff에서는 기본값이 -1
		return elt;
	},
    _deleteEditor: function () {
        var p = this._container && this._container.parentElement;
        p && p.removeChild(this._container);
    },
    _disableIme: function () {
        this._editor.style.imeMode = "disabled";
        this._editor.style["-webkit-ime-mode"] = "disabled";
        this._editor.style["-moz-ime-mode"] = "disabled";
        this._editor.style["-ms-ime-mode"] = "disabled";
    },
	_focusHandler: function () {
		if ($_debug) debugger;
	},
	_keyDownHandler: function (e) {
		var grid = this._grid;
		if (grid.popupShowing()) {
			return false;
		}
        if ((e.keyCode == 229 || e.keyCode == 197/* opera? */) && this._imeMode == ImeMode.DISABLED) {
            _stopEvent(e);
            return false;
        }
		var editor = this._editor,
            undoable = grid.undoable() && grid.editOptions().undoable(),
            fld = this._editField(),
            k = e.keyCode,
		    shift = e.shiftKey,
            ctrl = e.ctrlKey,
            alt = e.altKey;
        if (_isIE && ctrl && (k == Keys.Z || k == Keys.Y)) {
			if (!this.visible() || undoable && grid.isRowEditing() && fld && fld.sameValues(this.getEditValue(), this._oldValue)) {
				_stopEvent(e);
				this._sendToParent(e);
                return false;
			}
            return this.visible() && (!fld || !fld.sameValues(this.getEditValue(), this._oldValue));
        }
        this._inputValue = editor.value;
		if (this.visible() && shift && _included(k, Keys.LEFT, Keys.RIGHT, Keys.UP, Keys.DOWN, Keys.HOME, Keys.END, Keys.PAGEUP, Keys.PAGEDOWN)) {
			_ignoreEvent(e);
			return true;
		}
		switch (k) {
			case Keys.BACK:
			case Keys.DELETE:
                if (_isIE && (this._readOnly || this._textReadOnly) && this.visible()) {
                    _stopEvent(e);
                    return false;
                }
                if (this._sendToParent(e)) {
                    return true;
                }
                if (!this.visible() && this._requestStart()) {
                    _stopEvent(e);
                    if (!this._editor.readOnly && this._editor.value) {
                        this.setText("");
                    }
                }
                if (k == Keys.BACK) {
                    if (this._doBack() === true) {
                        _stopEvent(e);
                        return true;
                    }
                } else {
                    if (this._doDelete() === true) {
                        _stopEvent(e);
                        return true;
                    }
                }
				break;
			case Keys.TAB:
				return !this._sendToParent(e, true);
			case Keys.LEFT:
				if (!this.visible() || (grid.editOptions().moveByArrowKeys() && editor.selectionEnd == 0 && editor.selectionEnd == editor.selectionStart)) {
					e.stopImmediatePropagation();
					return !this._sendToParent(e);
				}
				if (this._editor.readOnly && _isChrome) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.RIGHT:
				if (!this.visible() || (grid.editOptions().moveByArrowKeys() && editor.selectionEnd == editor.value.length && editor.selectionEnd == editor.selectionStart)) {
					e.stopImmediatePropagation();
					return !this._sendToParent(e);
				}
				if (this._editor.readOnly && _isChrome) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.HOME:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.END:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.SPACE:
				if (!this.visible()) {
					e.stopImmediatePropagation();
					return !this._sendToParent(e);
				}
				break;
			case Keys.UP:
			case Keys.DOWN:
			case Keys.PAGEUP:
			case Keys.PAGEDOWN:
			case Keys.ENTER:
			case Keys.ESCAPE:
			case Keys.F2:
			case Keys.INSERT:
				e.preventDefault(); // 이걸 먼저 하지 않으면 ff 등에서 input 이벤트로 발생된다.
				e.stopImmediatePropagation();
				return !this._sendToParent(e);
			case Keys.I:
			case Keys.D:
				if (_isMac && alt && ctrl) {
                    _stopEvent(e);
					return !this._sendToParent(e);
				}
			case 229: // ime 변환 키 등...
				break;
			default:
                if (_isIE && (this._readOnly || this._textReadOnly) && this.visible()) {
                    _stopEvent(e);
                    return false;
                }
                if (ctrl && (k == Keys.Z || k == Keys.Y)) {
					if (!this.visible() || undoable && grid.isRowEditing() && fld && fld.sameValues(this.getEditValue(), this._oldValue)) {
						_stopEvent(e);
						return !this._sendToParent(e);
					}
                } else if (this._sendToParent(e)) {
					return false;
				}
				break;
		}
		if (_isFirefox) {
			if (!ctrl && !alt && (k == 0 || k >= 32) && (k < 0x70 || k > 0x82)) {
				this._requestStart();
			}
		}
		else if (_isIE) {
			if (k == 229 && e.char) {
			}
		}
		return true; // false를 return하면 chrome에서는 key 입력이 진행되지 않는다.
	},
	_keyUpHandler: function (e) {
		var key = e.keyCode;
		if (key == Keys.BACK || key == Keys.DELETE) {
			if (_ieOld && this.visible() && !this._editor.readOnly && this._editor.value != this._inputValue) {
				this._doChanged();
                return;
			}
		}
        if (!this.isEditing()) {
            var ctrl = _isMac && (e.metaKey || e.ctrlKey) || !_isMac && e.ctrlKey;
            this._dispatchKeyUp(e.keyCode, ctrl, e.shiftKey, e.altKey);
        }
	},
	_keyPressHandler: function (e) {
        if (!this.visible() && _isIE && (this._readOnly || this._textReadOnly)) {
            this._editor.readOnly = true;
            _stopEvent(e);
            this._requestStart();
            return;
        }
        var k = e.which || e.keyCode,
            cb = this._keyCallback;
        if (cb && cb(e.key, k, this._editor.selectionEnd, this._editor.value) === false) {
            _stopEvent(e);
            return true;
        }
        if (_isFirefox) {
            if (!e.ctrlKey && !e.altKey && (k == 0 || k >= 32) && (k < 0x70 || k > 0x82)) {
                this._requestStart();
            }
        } else if (k >= 32) {
			this._requestStart();
		}
		if (_ieTen) {
			this._editor.oninput = this._inputHandlerStock;
		}
        if (this._doChar(e.key, k) === true) {
            _stopEvent(e);
            return true;
        }
	},
    _textHandler: function () {
        this._requestStart();
    },
    _compositionstartHandler: function (e) {
        if (/*!this.visible() &&*/ _isIE && (this._readOnly || this._textReadOnly)) {
            this._editor.readOnly = true;
            this._editor.value = this._oldValue;
            return;
        }
        this._composing = true;
        this._requestStart();
        if (this._started && !this._editor.readOnly) {
            this._modified = true;
            this._dispatchChange();
        }
    },
    _compositionupdatetHandler: function (e) {
        this._composing = true;
    },
    _compositionendHandler: function (e) {
        this._composing = false;
    },
	/*
	  키 입력 외에 값이 변겨됐을 때 모두 호출되므로 피해야 한다.
	_changeHandler: function (e) {
		if (this.visible() && !this._editor.readOnly) {
			this._doChanged();
		}
	},
     */
    _changeHandler: function (e) {
        /*
        if (this.visible() && !this._editor.readOnly) {
            console.log("### EDITOR.VALUE = " + this._editor.value);
        }
        */
    },
	_inputHandler: function (e) {
		this._doChanged();
	},
	_doChanged: function () {
        if (!_isMobile()) {
            this._requestStart();
        }
		if (this._started && !this._editor.readOnly) {
			this._modified = true;
			this._dispatchChange();
		}
	},
    _dispatchChange: function () {
        if (this.visible() && this._noHangul) {
            this._clearHanguls();
        }
        this._super();
    },
	setBounds: function (x, y, w, h) {
		Dom.setBounds(this._container, x, y, w, h);
	}
});
var LineCellEditor = defineClass("LineCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
	}
});
var MaskCellEditor = defineClass("MaskCellEditor", TextCellEditor, {
    init: function (grid, parentElement) {
        this._super(grid, parentElement);
        this._me = new MaskEditor(this._editor, true);
        this._me.setChangeCallback(function () {
            this._doChanged();
        }.bind(this));
        this._disableIme();
    },
    mask: {
        get: function () { this._me.format(); },
        set: function (value) { this._me.setFormat(value); }
    },
    insertMode: {
        get: function () { this._me.insertMode(); },
        set: function (value) { this._me.setInsertMode(value); }
    },
	fillFromEnd: false,
	includeSeparators: {
		get: function () { this._me.includeSeparators(); },
		set: function (value) { this._me.setIncludeSeparators(value); }
	},
    includeLiterals: {
        get: function () { this._me.includeLiterals(); },
        set: function (value) { this._me.setIncludeLiterals(value); }
    },
	stripBegin: {
		get: function () { this._me.stripBegin(); },
		set: function (value) { this._me.setStripBegin(value); }
	},
	stripEnd: {
		get: function () { this._me.stripEnd(); },
		set: function (value) { this._me.setStripEnd(value); }
	},
	stripInner: {
		get: function () { this._me.stripInner(); },
		set: function (value) { this._me.setStripInner(value); }
	},
	fitToSeparators: {
		get: function () { this._me.fitToSeparators(); },
		set: function (value) { this._me.setFitToSeparators(value); }
	},
    trimWhenCopy: {
        get: function () { this._me.trimWhenCopy(); },
        set: function (value) { this._me.setTrimWhenCopy(value); }
    },
	maskCallback: null,     // function (index, value, editText):String
	unmaskCallback: null,   // function (index, editText):*
	seiveText: function (value) {
		var s = '';
		if (value !== undefined) {
			s = this.$_maskedValue(value);
			s = this._me.seiveText(s);
		}
		return s;
	},
    setMinLength: function () { this._minLength = 0; },
    setMaxLength: function () { this._maxLength = 0; },
	maskable: function () { return true; },
    initOptions: function () {
        this._super();
        this._mask = null;
        this._insertMode = true;
        this._fillFromEnd = false;
        this._includeSeparators = true;
        this._includeLiterals = false;
        this._stripBegin = false;
        this._stripEnd = false;
        this._stripInner = false;
        this._fitToSeparators = true;
        this._trimWhenCopy = true;
        this._maskCallback = null;
        this._unmaskCallback = null;
    },
    setEditValue: function (value) {
        var s = this._super(value);
            v = this.$_maskedValue(value, s);
        if (v !== undefined) {
            s = v;
        }
        this._me.initValue(s, this._fillFromEnd);
    },
	getEditValue: function (committing, throwError) {
		var t, s, v,
			fld = this._editField();
		try {
            s = this.$_unmaskedValue(this._editor.value, committing);
            if (committing) {
                t = fld.dataType();
                if (s === CellEditor.InvalidFormat) {
                    return s;
                }
                if ((t == ValueType.DATETIME && _isDate(s) ||
                    (t == ValueType.NUMBER && _isNumber(s)) ||
                    (t == ValueType.BOOLEAN && _isBoolean(s)))) {
                    v = fld.readValue(s);
                    return v;
                }
            }
            return committing ? this.$_readEditValue(s, committing) : s;
        } catch (e) {
            if (throwError) throw e;
            return this._emptyValue;
        }
	},
    _doBack: function () {
        if (this._me._doBack()) {
			return true;
		}
    },
    _doDelete: function () {
        if (this._me._doDelete()) {
			return true;
		}
    },
    _doChar: function (key, code) {
        if (_isIE && code == 32) key = ' ';
        if (this._me._doChar(key, code)) {
			return true;
		}
    },
    _doCopy: function (e) {
        return this._me._doCopy(e);
    },
    _doCut: function (e) {
        if (this._me._doCut(e)) {
			return true;
		}
    },
    _doPaste: function (e) {
        if (this._me._doPaste(e)) {
			return true;
		}
    },
    _keyDownHandler: function (e) {
        if ((e.keyCode == 229 || e.keyCode == 197/* opera? */)) {
            _stopEvent(e);
            return false;
        }
        return this._super(e);
    },
    _dispatchChange: function () {
        if (this.visible()) {
            this._clearHanguls();
            this._super();
        }
    },
	$_maskedValue: function (value, text) {
		var cb = this._maskCallback,
			s = undefined;
		if (cb) {
			s = cb(this._editIndex, value, text);
		}
		if (!_isString(s)) {
			s = text;
		}
		return s;
	},
	$_unmaskedValue: function (text, committing) {
		var cb = this._unmaskCallback,
			v = undefined;
        if (committing) {
            if (cb) {
                v = cb(this._editIndex, this._me.getText(text));
            } else if (!this._me.checkValid()) {
                return CellEditor.InvalidFormat;
            }
            if (v === undefined) {
                v = this._me.unmaskText(text);
            }
        } else {
            v = this._me.getText(text);
        }
		return v;
	}
});
var MultiLineCellEditor = defineClass("MultiLineCellEditor", CellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._modified = false;
        this._scrolled = false;
	},
	maxLength: 0,
	minLength: 0,
    useCtrlEnter: false,
	text: function () {
		return this._editor.value;
	},
	setAlignment: function (align) {
		this._container.style.textAlign = "left";
	},
	initOptions: function () {
		this._super();
		this._maxLength = 0;
		this._minLength = 0;
	},
	_selectAll: function () {
		this._editor.select();
	},
	caretToLast: function () {
		var len = _toStr(this._editor.value).length;
		this._editor.setSelectionRange(len, len);
	},
	_doBeginEdit: function (clear, select) {
		this._modified = false;
        if (this.visible()) { // 당연히 visible이어야 한다.
            if (!this._editor.value) {
                this._editor.setSelectionRange(0, 0);
            }
        }
		return true;
	},
	_doEndEdit: function () {
		this._modified = false;
	},
	_doCommit: function () {
	},
	setEditIndex: function (index) {
		if (!index) return;
		this._super(index);
		/*
		var grid = index.grid();
		if (grid) {
			 m_editor.useArrowKeys = grid.editOptions.useArrowKeys;
			 if (index.dataField >= 0 && grid.dataSource.getValueType(index.dataField) == GridValueType.Datetime) {
			 }
			 m_editor.tabConsumer = grid;
		}
		 */
		/*
		 m_editor.editable = !readOnly;
		 m_editor.maxChars = maxLength;
		 m_editor.textCase = textCase == TextInputCase.Default ? index.dataColumn.textInputCase : textCase;
		 setEditFont(grid, m_editor);
		 */
		this.$_setInputCase(index, this._textCase);
		this._editor.maxLength = this._maxLength > 0 ? this._maxLength : 2000000000;
	},
	setEditValue: function (value) {
		this._super(value);
		this._editor.value = this.$_valToStr(value);
	},
    getEditValue: function (committing, throwError) {
        throwError = arguments.length > 1 ? throwError : true;
        try {
            return this.$_readEditValue(this._editor.value, committing);
        } catch (e) {
            if (throwError) throw e;
            return this._emptyValue;
        }
    },
	getEditText: function () {
		return this._editor.value;
	},
	isEdited: function () {
		return this._modified;
	},
	setVisible: function (value, force) {
		this._super(value, force);
		if (value) {
			this._container.style["border"] = "2px solid rgb(82, 146, 247)";
			this._container.style["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		} else {
			this._container.style["border"] = "none";
			this._container.style["box-shadow"] = "none";
		}
	},
	_createContainer: function () {
		var elt = document.createElement("div"),
			css = elt.style;
		elt.spellcheck = false;
		css["position"] = "absolute";
		css["z-index"] = 2000;
		css.boxSizing = "border-box";
		css["overflow"] = "hidden";
		css["border"] = "none";
		css["width"] = "0px";
		css["height"] = "0px";
		css["padding"] = "0px";
		css["margin"] = "0px";
		css.backgroundColor = "#fff";
		css.border = "none";
		css.boxShadow = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		css.resize = "none";
		return elt;
	},
	_createEditor: function (parent) {
		var elt = document.createElement("textarea"),
			css = elt.style;
		this._container = this._createContainer();
		parent.appendChild(this._container);
		elt.autoComplete = "off";
		css.boxSizing = "border-box";
		css.tabIndex = -1;
		css.position = "absolute";
		css.margin = "0px";
		css.padding = "0px 2px 0px 1px";
		css.fontFamily = "";
		css.fontStyle = "normal";
		css.fontVariant = "normal";
		css.fontWeight = "normal";
		css.fontSize = "";
		css.lineHeight = "normal";
		css.wordWrap = "normal";
		css.overflow = "hidden";
		css.resize = "none";
		css.border = "none";
		css.outline = "none";
		css.textAlign = "left";
		css.color = "rgb(68, 84, 106)";
		css.left = "0px";
		css.top = "0px";
		css.width = "100%";
		css.height = "100%";
		css.imeMode = "auto";
		css.cursor = "text";
		css["-webkit-user-modify"] = "read-write-plaintext-only";
		css["white-space"] = "pre";
		css["-webkit-transform"] = "translateZ(0)";
		elt.onmousedown =
			elt.onmousemove =
				elt.onmouseup =
					elt.onclick =
						elt.ondblclick = this._ignoreHandler.bind(this);
		elt.onkeydown = this._keyDownHandler.bind(this);
		elt.onkeyup = this._keyUpHandler.bind(this);
		elt.onkeypress = this._keyPressHandler.bind(this);
		elt.oninput = this._inputHandlerStock = this._inputHandler.bind(this);
		elt.onpaste = this._pasteHandler.bind(this);
        elt.oncut = this._cutHandler.bind(this);
		elt.oncopy = this._copyHandler.bind(this);
		if (elt.addEventListener) {
			elt.addEventListener("compositionstart", this._compositionstartHandler.bind(this));
			elt.addEventListener("text", this._textHandler.bind(this));
		} else {
			elt.attachEvent("oncompositionstart", this._compositionstartHandler.bind(this));
			elt.attachEvent("ontext", this._textHandler.bind(this));
		}
		this._container.appendChild(elt);
		return elt;
	},
    _deleteEditor: function () {
        var p = this._container && this._container.parentElement;
        p && p.removeChild(this._container);
    },
	_keyDownHandler: function (e) {
		var editor = this._editor;
        var grid = this._grid;
        var undoable = grid.undoable() && grid.editOptions().undoable();
        var fld = this._editField();
        var k = e.keyCode;
        var alt = e.altKey;
        var ctrl = e.ctrlKey;
        var shift = e.shiftKey;
        if (_isIE && ctrl && (k == Keys.Z || k == Keys.Y)) {
            if (!this.visible() || undoable && grid.isRowEditing() && fld && fld.sameValues(this.getEditValue(), this._oldValue)) {
                _stopEvent(e);
                this._sendToParent(e);
                return false;
            }
            return this.visible() && (!fld || !fld.sameValues(this.getEditValue(), this._oldValue));
        }
		if (_isIE && !this.visible() && ctrl && k == Keys.V) {
			this.selectAll();
		}
		if (this.visible() && shift && _included(k, Keys.LEFT, Keys.RIGHT, Keys.UP, Keys.DOWN, Keys.HOME, Keys.END, Keys.PAGEUP, Keys.PAGEDOWN)) {
			_ignoreEvent(e);
			return true;
		}
        switch (k) {
			case Keys.BACK:
			case Keys.DELETE:
                if (_isIE && (this._readOnly || this._textReadOnly) && this.visible()) {
                    _stopEvent(e);
                    return false;
                }
                if (this._sendToParent(e)) {
                    return true;
                }
                if (!this.visible() && this._requestStart()) {
                    _stopEvent(e);
                    if (!this._editor.readOnly && this._editor.value) {
                        this._editor.value = ""; // null이라고 하면 "NULL"이라 쓰는 브라우저가 있더라...
                        this._modified = true;
                        this._dispatchChange();
                    }
                }
				break;
			case Keys.TAB:
				return !this._sendToParent(e, true);
			case Keys.LEFT:
				if (!this.visible() || (editor.selectionEnd == 0 && editor.selectionEnd == editor.selectionStart)) {
					return !this._sendToParent(e, true);
				}
				break;
			case Keys.RIGHT:
				if (!this.visible() || (editor.selectionEnd == editor.value.length && editor.selectionEnd == editor.selectionStart)) {
					return !this._sendToParent(e, true);
				}
				break;
			case Keys.HOME:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.END:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.UP:
			case Keys.PAGEUP:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.DOWN:
			case Keys.PAGEDOWN:
                e.stopImmediatePropagation();
				if (!this.visible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.SPACE:
				if (!this.visible()) {
					return !this._sendToParent(e, true);
				}
				break;
			case Keys.ENTER:
				if (!ctrl && !shift && !alt) {
					return !this._sendToParent(e, true);
				}
				if (ctrl && !shift && this._useCtrlEnter) {
					e.stopImmediatePropagation();
					var s = editor.value;
					if (s) {
						var i = editor.selectionEnd;
						s = s.substring(0, i) + "\r\n" + s.substring(i);
						editor.value = s;
						editor.setSelectionRange(i + 1, i + 1);
						this._doChanged();
						if (_isMac) {
							return false;
						}
					}
				}
				_ignoreEvent(e);
				break;
			case Keys.ESCAPE:
			case Keys.F2:
			case Keys.INSERT:
                _stopEvent(e);
				return !this._sendToParent(e);
			case 229: // ime 변환 키 등...
				break;
			default:
                if (_isIE && (this._readOnly || this._textReadOnly) && this.visible()) {
                    _stopEvent(e);
                    return false;
                }
                if (ctrl && (k == Keys.Z || k == Keys.Y)) {
                    if (!this.visible() || undoable && grid.isRowEditing() && fld && fld.sameValues(this.getEditValue(), this._oldValue)) {
                        _stopEvent(e);
                        return !this._sendToParent(e);
                    }
                } else if (this._sendToParent(e)) {
					return false;
				}
				break;
		}
		if (k == 0) {
		} else if (_isIE) {
			if (k == 229 && e.char) {
				this._requestStart();
			}
		}
		return true;
	},
	_keyUpHandler: function (e) {
		var key = e.keyCode;
		if (key == Keys.BACK || key == Keys.DELETE) {
			if (_ieOld && this.visible() && !this._editor.readOnly && this._editor.value != this._inputValue) {
				this._doChanged();
				return;
			}
		}
		if (!this.isEditing()) {
			var ctrl = _isMac && (e.metaKey || e.ctrlKey) || !_isMac && e.ctrlKey;
			this._dispatchKeyUp(e.keyCode, ctrl, e.shiftKey, e.altKey);
		}
	},
	_keyPressHandler: function (e) {
        if (!this.visible() && _isIE && (this._readOnly || this._textReadOnly)) {
            this._editor.readOnly = true;
            _stopEvent(e);
            this._requestStart();
            return;
        }
        var k = e.which || e.keyCode;
		if (_isFirefox) {
			if (!e.ctrlKey && !e.altKey && (k == 0 || k >= 32) && (k < 0x70 || k > 0x82)) {
				this._requestStart();
			}
		} else if (k >= 32) {
			this._requestStart();
		}
		if (_ieTen) {
			this._editor.oninput = this._inputHandlerStock;
		}
	},
	_textHandler: function () {
		this._requestStart();
	},
	_compositionstartHandler: function () {
        if (/*!this.visible() &&*/ _isIE && (this._readOnly || this._textReadOnly)) {
            this._editor.readOnly = true;
            this._editor.value = this._oldValue;
            return;
        }
		this._composing = true;
		this._requestStart();
		if (this._started && !this._editor.readOnly) {
			this._modified = true;
			this._dispatchChange();
		}
	},
	_compositionupdatetHandler: function () {
		this._composing = true;
	},
	_compositionendHandler: function (e) {
		this._composing = false;
	},
	_inputHandler: function (e) {
		this._doChanged();
	},
	setBounds: function (x, y, w, h, scrolled) {
        this._scrolled = scrolled;
		Dom.setBounds(this._container, x, y, w, h);
		this.$_resetBounds();
	},
	_doChanged: function () {
		this._requestStart();
		if (this._started && !this._editor.readOnly) {
			this._modified = true;
			this._dispatchChange();
			this.$_resetBounds();
		}
	},
	$_resetBounds: function () {
        if (this._scrolled) return;
		if (this._editor.value == $$_EMPTY_TEXT_VALUE) return;
		if (this.visible()) {
			this._container.style["border"] = "2px solid rgb(82, 146, 247)";
			this._container.style["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		}
		var r = Dom.getBounds(this._container),
			x = r.cx,
			y = r.cy,
			w = r.width,	// Math.max(r.width, this._editor.scrollWidth + 4),
			h = r.height; 	//Math.max(r.height, this._editor.scrollHeight + 4);
		if (this._editor.scrollWidth + 4 /* contaner's border */ > r.width) {
			w = this._editor.scrollWidth + 4;;
		}
		if (this._editor.scrollHeight + 4 > r.height) {
			h = this._editor.scrollHeight + 5; // 4를 주면 ie 에서 1px 쯤 수직 스크롤 된다.
		}
		r = Dom.getBounds(this._parentElement);
		w = Math.min(r.width, w);
		h = Math.min(r.height, h);
		if (x + w > r.width) {
			x = r.width - w;
		}
		if (y + h > r.height) {
			y = r.height - h;
		}
		Dom.setBounds(this._container, Math.max(x, 0), Math.max(y, 0), w, h);
	}
});
var DropDownPosition = _enum('DropDownPosition', {
	BUTTON: "button",
	EDITOR: "editor"
});
var DropDownSortStyle = _enum('DropDownSortStyle', {
	NONE: "none",
	ASCENDING: "ascending",
	DESCENDING: "descending"
});
/*
var ListItemStyles = defineClass("ListItemStyles", null, {
	init: function (styles) {
		this._super();
		styles && this.assign(styles);
	},
	fontSize: 12,
	fontName: "Tahoma",
	itemColor: undefined,
	selectedItemColor: undefined,
	hoveredItemColor: undefined,
	background: undefined,
	selectedBackground: undefined,
	hoveredBackground: undefined,
	textDecoration: "none",
	selectedTextDecoration: "none",
	hoveredTextDecoration: "underline",
	setItemColor: function (value) {
		if (value !== this._itemColor) {
			this._setItemColor = value ? new SolidBrush(value) : null;
		}
	},
	setSelectedItemColor: function (value) {
		if (value !== this._selectedItemColor) {
			this._selectedItemColor = value ? new SolidBrush(value) : null;
		}
	},
	setHoveredItemColor: function (value) {
		if (value !== this._hoveredItemColor) {
			this._hoveredItemColor = value ? new SolidBrush(value) : null;
		}
	},
	setBackground: function (value) {
		if (value !== this._background) {
			this._background = value ? new SolidBrush(value) : null;
		}
	},
	setSelectedBackground: function (value) {
		if (value !== this._selectedBackground) {
			this._selectedBackground = value ? new SolidBrush(value) : null;
		}
	},
	setHoveredBackground: function (value) {
		if (value !== this._hoveredBackground) {
			this._hoveredBackground = value ? new SolidBrush(value) : null;
		}
	}
});
*/
var ListCellEditor = defineClass("ListCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._list = new DropDownList(grid._container);
		this._list.addListener(this);
		this._items = null;     // listing items
        this._subItems = null;  // listing sub-items
		this._values = [];
		this._labeling = false;
		this._lookup = false;
		this._domain = null;
		this._closing = false;
		this._value = undefined;
		this._selectedIndex = -1;
		this._borderable = false;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._list._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
		this._itemStyles = {
			fontSize: 12,
			fontName: 'Tahoma',
			color: "#000",
			hoveredColor: "#000",
			selectedColor: "#fff",
			background: "#fff",
			selectedBackground: "#333",
			hoveredBackground: "#10000000"
		};
        this._subStyles = {
            hoveredBackground: null
        };
		this._listItemStyles = new GridStyles(null, 'listEditorItem');
        this._subItemStyles = new GridStyles(null, 'listEditorSubItem');
        this._subItemStyles.setParent(this._listItemStyles);
	},
	values: null,
	labels: null,
    listItemDisplay: EnumProp(ListItemDisplay, ListItemDisplay.DEFAULT),
    listItemColumned: false,
    listItemGap: 10,
    listItemSeparator: null,
	itemsCallback: null, // function (CellIndex): { values: [], labels: [] }
	displayLabels: true,
	domainOnly: false,
	textReadOnly: false,
	partialMatch: false,
	narrowSearch: false,
    insideSearch: false,
	dropDownWidth: -1,
	dropDownPosition: EnumProp(DropDownPosition, DropDownPosition.BUTTON),
	dropDownCount: 8,
	dropDownMinLeft: undefined,
	listItemStyles: undefined,
    subItemStyles: undefined,
	itemSortStyle: EnumProp(DropDownSortStyle, DropDownSortStyle.NONE),
	caseSensitive: false,
	commitOnSelect: true,
	setValues: function (value) {
		this._values = value ? value.slice() : [];
		return this;
	},
	setLabels: function (value) {
		this._labels = value ? value.slice() : [];
		return this;
	},
	setListItemStyles: function (value) {
		if (value !== this._listItemStyles) {
			this._listItemStyles.extend(value);
		}
		return this;
	},
    setSubItemStyles: function (value) {
        if (value !== this._subItemStyles) {
            this._subItemStyles.extend(value);
        }
        return this;
    },
	/** @deprecated Use listing() instead. */
	isListing: function () {
		return this._list.isListing();
	},
	listing: function () {
		return this._list.isListing();
	},
	dropDown: function (force) {
        var r, st, list = this._list;
		if (!this.readOnly() && !this.isListing() && !this._closing) {
            if (force || this._items && this._items.length > 0) {
                r = Dom.getBounds(this._container);
                list.setItems(this._items, this._subItems);
				this._saveIndex = this._selectedIndex;
				this._saveText = this._editor.value;
				list.setListItemStyles(this._listItemStyles);
                list.setSubItemStyles(this._subItemStyles);
                list.setListItemDisplay(this._listItemDisplay);
                list.setListItemGap(this._listItemGap);
                list.setListItemSeparator(this._listItemSeparator);
                list.setListItemColumned(this._listItemColumned);
				list.setPartialMatch(this._partialMatch);
				list.setNarrowSearch(this._narrowSearch);
                list.setCaseSensitive(this._caseSensitive);
                list.setInsideSearch(this._insideSearch);
                list.setDropDownCount(this._dropDownCount);
				list.setDropDownWidth(this._dropDownWidth);
				list.setDropDownPosition(this._dropDownPosition);
				list.setDropDownMinLeft(this._dropDownMinLeft);
				list.setSortStyle(this._itemSortStyle);
                list.setValueIndex(this._selectedIndex);
                list.show(this._grid.container()._popupOwner || _doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
                list.$_search(this._editor.value, true);
                Dom.addWindowListener("mousedown", this._globalMouseHandler);
                return true;
            }
		}
		return false;
	},
	closeUp: function (accept) {
        var idx;
        if (this.isListing()) {
			this._closing = true;
			try {
				Dom.removeWindowListener("mousedown", this._globalMouseHandler);
				this._list.hide();
				if (accept && this._list.isSelected() && (idx = this._list.itemIndex()) >= 0 && this._items && this._items.length > idx) {
					this._selectedIndex = this._list.valueIndex();
					this._editor.value = this._items[idx];
					if (this._selectedIndex != this._saveIndex || this._editor.value != this._saveText) {
						this._dispatchChange();
					}
                    if (this._commitOnSelect) {
                        this._dispatchCommit();
                    }
				} else {
					this._selectedIndex = -1;
				}
			} finally {
				this._closing = false;
			}
			return true;
		}
		return false;
	},
    $_valToStr: function (value) {
        if (typeof value === 'string' && this._labeling) {
            return value;
        }
        return this._super(value);
    },
	hasButton: function () {
		return true;
	},
	initOptions: function () {
		this._super();
		this._values = [];
		this._labels = [];
		this._callbackItems = false;
		this._displayLabels = true;
		this._domainOnly = false;
		this._textReadOnly = false;
		this._partialMatch = false;
		this._narrowSearch = false;
		this._insidSearch = false;
		this._dropDownWidth = -1;
		this._dropDownPosition = DropDownPosition.BUTTON;
		this._dropDownCount = 8;
		this._itemSortStyle = DropDownSortStyle.NONE;
		this._caseSensitive = false;
		this._commitOnSelect = true;
        this._listItemDisplay = ListItemDisplay.DEFAULT;
        this._listItemGap = 10;
        this._listItemSeparator = null;
        this._listItemColumned = false;
		this._listItemStyles.initialize(this._itemStyles);
        this._subItemStyles.initialize(this._subStyles);
        this._itemsCallback = null;
	},
    _doBeginEdit: function () {
        if (!this.readOnly()) {
            this._refreshItems();
        }
        return this._super();
    },
	setEditIndex: function (index) {
		this._super(index);
		this._lookup = false;
		this._labeling = false;
		this._domain = null;
		this._items = null;
		/*
		m_editor.editable = !readOnly && !textReadOnly;
		m_editor.listable = !readOnly;
		m_editor.dropDownCount = dropDownCount;
		m_editor.sortStyle = itemSortStyle;
		m_editor.caseSensitive = caseSensitive;
		*/
		if (this._textReadOnly) {
			this._editor.readOnly = true;
		}
		/*
		var col = index.dataColumn();
		if (col) {
			this.setItems(col.lookupValues());
		}
		*/
	},
	setEditValue: function (value) {
		var i, cnt, v, domain,
		    index = -1;
		this._value = v = value;
		if (this._lookup) {
			domain = this._domain;
			if (domain) {
				i = index = domain.keys ? domain.keys.indexOf(value) : -1;
				v = (i >= 0 && domain.values && domain.values.length > i) ? domain.values[i] : value;
			} else {
				index = this._editIndex.dataColumn().getLookupIndex(value);
			}
			if (this._labeling) {
				if (domain) {
					v = (index >= 0 && domain.values && domain.values.length > index) ? domain.values[index] : value;
				} else {
					v = index >= 0 ? this._editIndex.dataColumn().getLookupLabel(value) : value;
				}
			}
		} else if (this._values) {
			for (i = 0, cnt = this._values.length; i < cnt; i++) {
				if (value == this._values[i]) {
					index = i;
					break;
				}
			}
			if (this._labeling && this._labels && (index < 0 || this._labels.length > index)) {
				v = index >= 0 ? this._labels[i] : value;
			}
		}
        this._super(v);
		this._selectedIndex = index;
	},
	isEdited: function () {
		var modified = this._super();
		if (modified && this.domainOnly()) {
			modified = this.$_getEditValue(false) !== undefined;
		}
		return modified;
	},
	getEditValue: function (committing, throwError) {
		if (!this.isEdited() && this._selectedIndex < 0) {
			return this._value;
		} else {
			return this.$_getEditValue(committing, throwError);
		}
	},
    setBounds: function (x, y, w, h) {
        x += 2;
        y += 2;
        w -= 4;
        h -= 4;
        this._super(x, y, w, h);
    },
	_createContainer: function () {
		var elt = this._super();
		elt.style.border = "none";
		elt.style.boxShadow = "none";
		return elt;
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		return editor;
	},
    _deleteEditor: function () {
        this.closeUp();
        this._super();
    },
	_textHandler: function () {
		this._requestStart();
	},
	_keyDownHandler: function (e) {
		var list = this._list;
		switch (e.keyCode) {
			case Keys.ENTER:
				if (this.closeUp(true)) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.ESCAPE:
				if (this.closeUp(false)) {
                    _stopEvent(e);
					return true;
				}
				break;
			case Keys.DOWN:
				if (e.altKey && !this.isListing()) {
					this._requestStart();
                    _stopEvent(e);
					return true;
				} else if (this.isListing()) {
                    this._list.setItemIndex(Math.min(list.itemCount() - 1, list.itemIndex() + 1));
                    _stopEvent(e);
					return true;
				}
				break;
			case Keys.PAGEDOWN:
				if (this.isListing()) {
					this._list.setItemIndex(Math.min(list.itemCount() - 1, list.itemIndex() + list.dropDownCount()));
                    _stopEvent(e);
					return true;
				}
				break;
			case Keys.UP:
				if (e.altKey && this.isListing()) {
					this.closeUp(false);
                    _stopEvent(e);
					return true;
				} else if (this.isListing()) {
					this._list.setItemIndex(Math.max(0, list.itemIndex() - 1));
                    _stopEvent(e);
					return true;
				}
				break;
			case Keys.PAGEUP:
				if (this.isListing()) {
					this._list.setItemIndex(Math.max(0, list.itemIndex() - list.dropDownCount()));
                    _stopEvent(e);
					return true;
				}
				break;
		}
		return this._super(e);
	},
	_requestStart: function () {
		if (this._super()) {
			this.dropDown();
			return true;
		}
		return false;
	},
	_doChanged: function () {
		this._super();
		if (this.isListing()) {
			this._list.$_search(this._editor.value);
		}
	},
    showList: function (force) {
        this.dropDown(force);
    },
	closeList: function (accept) {
		this.closeUp(accept);
	},
	buttonClicked: function (index) {
		this.isListing() ? this.closeUp(false) : this.dropDown();
	},
	_refreshItems: function (updateList, force) {
		var items, labels, values, column, flds, keys, i, domain,
            index = this._editIndex,
		    item = index.getRow(this._grid);
		this._labeling = false;
		this._items = null;
        this._subItems = null;
        this._callbackItems = false;
		if (typeof this._itemsCallback === 'function') {
			items = this._itemsCallback(index.clone());
			labels = this._callbackLabels = items && items.labels;
			values = this._callbackValues = items && items.values;
            if (values && (values.length > 0 || force)) {
				this._items = values;
				this._callbackItems = true;
			}
		} else if ((values = this._values) && (values.length > 0 || force)) {
            labels = this._labels;
		} else if (index.dataColumn() && item && (index.getDataIndex(this._grid) >= 0 || GridRowState.isEditing(item.rowState()))) {
			column = index.dataColumn();
			if (column.lookupSource()) {
				flds = column.lookupKeyFieldIds();
				keys = [];
				for (i = 0; i < flds.length - 1; i++) {
					keys.push(item.getValue(flds[i]));
				}
				domain = column.lookupSource().getTextDomain(keys);
				if (domain && domain.values && domain.values.length > 0) {
                    values = domain.values;
					this._labeling = true;
					this._lookup = true;
					this._domain = domain;
				}
			} else if ((values = column.lookupValues()) && values.length > 0) {
                labels = column.lookupLabels();
				this._lookup = true;
			}
		}
        this._items = values;
        if (labels && labels.length >= values.length) {
            switch (this._listItemDisplay) {
                case 'valueLabel':
                    this._items = values;
                    this._subItems = labels;
                    break;
                case 'labelValue':
                    this._items = labels;
                    this._subItems = values;
                    this._labeling = true;
                    break;
                default:
                    if (this.displayLabels()) {
                        this._items = labels;
                        this._labeling = true;
                    }
                    break;
            }
        }
		if (updateList && this.isListing()) {
			this._list.setItems(this._items, this._subItems);
			this._list.$_resetList();
		}
	},
	$_getEditValue: function (committing, throwError) {
        var i, labels, values,
		    t = this.text(),
		    org = TextCellEditor.prototype.getEditValue.call(this, throwError),
		    v = org,
		    col = this._editIndex.dataColumn(),
		    index = this._selectedIndex,
		    selected = index >= 0;
		if (this._lookup) {
			if (this._domain) {
				if (this._labeling) {
					i = selected ? index : this._domain.values ? this._domain.values.indexOf(t) : -1;
					v = (i >= 0 && this._domain.keys && this._domain.keys.length > i) ? this._domain.keys[i] : v;
				}
				if (this.domainOnly()) {
					if (!this._domain.keys || this._domain.keys.indexOf(v) < 0) {
						return CellEditor.Unselected;
					}
				}
			} else {
				if (this._labeling) {
					if (selected) {
						v = col.getLookupValue(index);
					} else {
						v = col.getSourceValue(t);
					}
					if (v === undefined) {
						v = org;
					}
				}
				if (this.domainOnly()) {
					if (!col.lookupValues() || col.lookupValues().indexOf(v) < 0) {
						return CellEditor.Unselected;
					}
				}
			}
		} else {
			labels = this._callbackItems ? this._callbackLabels : this._labels;
			values = this._callbackItems ? this._callbackValues : this._values;
			if (this._labeling) {
				i = selected ? index : labels ? labels.indexOf(t) : -1;
				if (i >= 0 && i < values.length) {
					v = values[i];
				}
			}
			if (this.domainOnly()) {
				if (!values || values.indexOf(v) < 0) {
					return CellEditor.Unselected;;
				}
			}
		}
		return v;
	},
	onDropDownListCloseUp: function (list, accept) {
		this.closeUp(accept);
		this.setFocus();
	}
});
/** @internal */
var DropDownList = defineClass("DropDownList", EventAware, {
	init: function (container) {
		this._super();
		this._container = container; // grid container
		this._containerElement = null; // list parent element
		this._dom = new Dom(this._element = this.$_createList());
		this._firstChild = null;
		this._selected = false;
		this._mouseoverHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			if (Dom.getChildIndex(div) != this._itemIndex) {
				div.style.background = this.$_getItemBackground(false, true);
				div.style.color = this.$_getItemColor(false, true);
                div.$_span.style.textDecoration = this.$_getTextDecoration(false, true);
                if (div.$_span2) {
                    div.$_span2.style.background = this.$_getSubBackground(false, true);
                    div.$_span2.style.color = this.$_getSubColor(false, true);
                }
			}
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			if (Dom.getChildIndex(div) != this._itemIndex) {
				div.style.background = this.$_getItemBackground();
                div.style.color = this.$_getItemColor();
				div.$_span.style.textDecoration = this.$_getTextDecoration();
                if (div.$_span2) {
                    div.$_span2.style.background = this.$_getSubBackground();
                    div.$_span2.style.color = this.$_getSubColor();
                }
			}
		}.bind(this);
		this._clickHandler = function (e) {
			var div = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			if (idx >= 0) {
				this._itemIndex = idx;
				this.fireEvent(DropDownList.CLOSE_UP, true);
			}
		}.bind(this);
        if (_isChrome) this._needChromInit = true;
		this._newItemArr = [];
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	caseSensitive: false,
	partialMatch: false,
	narrowSearch: false,
    insideSearch: false,
    listItemDisplay: ListItemDisplay.DEFAULT,
    listItemGap: 10,
    listItemSeparator: null,
	listItemColumned: false,
	listItemStyles: null,
    subItemStyles: null,
	sortStyle: DropDownSortStyle.NONE,
	items: null,
    subItems: null,
	itemIndex: -1,
	dropDownPosition: DropDownPosition.BUTTON,
	dropDownMinLeft: undefined,
	dropDownWidth: -1, // -1: column width, 0: measured width, 0 < explicit width
    isListing: function () {
        return this._containerElement && this._containerElement.contains(this._element);
    },
	setItems: function (items, subItems) {
		this._items = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				this._items.push({ label: items[i], subLabel: subItems && subItems[i], index: i });
			}
		}
	},
	setItemIndex: function (value, forceRefresh) {
        var items = this._narrowSearch ? this._newItemArr : this._items;
		value = Math.max(-1, value);
		if (value < items.length && (forceRefresh || value != this._itemIndex)) {
			this._itemIndex = value;
			this.isListing() && this.$_refreshItems();
			this._selected = value >= 0;
		}
	},
	itemCount: function () {
		return this._items && this._items.length;
	},
    displayItemCount: function () {
        return this._displayCount;
    },
	valueIndex: function () {
        var items = this._items,
        	i = this._itemIndex;
		return (items && i >= 0 && i < items.length) ? items[i].index : -1;
	},
	setValueIndex: function (value) {
		value = Math.max(-1, value);
			this._itemIndex = -1;
			if (value >= 0) {
				for (var i = 0, cnt = this._items.length; i < cnt; i++) {
					if (this._items[i].index == value) {
						this._itemIndex = value;
						break;
					}
				}
			}
			this.isListing() && this.$_refreshItems();
			this._selected = true;
	},
	isSelected: function () {
		return this._selected;
	},
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = containerElement;
        this.$_sortItems();
		this.$_show(x, y, cellWidth, editBounds);
        if (this._needChromInit) {
            this._element.style.width = (this._width + 0.1) + 'px';
        }
	},
	hide: function () {
		this._dom.detach();
		this._containerElement = null;
		this._editBounds = null;
	},
	$_createList: function () {
		var element = document.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.fireEvent(DropDownList.CLOSE_UP, false);
			}
		}.bind(this);
		return element;
	},
	$_sortItems: function () {
		if (this._sortStyle == DropDownSortStyle.ASCENDING) {
			this._items.sort(function (i1, i2) {
				return i1.label < i2.label ? -1 : i1.label > i2.label ? 1 : 0;
			});
		} else if (this._sortStyle == DropDownSortStyle.DESCENDING) {
			this._items.sort(function (i1, i2) {
				return i1.label > i2.label ? -1 : i1.label < i2.label ? 1 : 0;
			});
		}
	},
	$_show: function (x, y, cellWidth, editBounds) {
		var elt = this._element;
		if (!elt) {
			return;
		}
		elt = this._dom.element();
		this._dom.setStyles({
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: _ieOld ? "" : "border-box",
			minWidth: "20px",
			minHeight: "10px",
			overflow: "auto",
			zIndex: 3000,
			background: "#fff",// "rgb(233, 233, 233)",
			border: "1px solid rgb(50, 50, 50)", //"1px solid rgb(200, 200, 200)",
			boxShadow: "rgba(0, 0, 0, 0.8) 1px 2px 5px",
			fontFamily: "Tahoma",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			fontSize: "10pt",
			padding: "0px",
			margin: "0px"
		});
        this._firstChild = null;
		this._dom.clearChildren();
		this._dom.disableSelection();
		this._containerElement.appendChild(elt);
        this.$_buildItems();
		this.$_resetHeight();
        this.$_resetWidth(this._cellWidth = cellWidth);
		this.$_resetPosition(this._editX = x, this._editY = y, cellWidth, this._editBounds = editBounds);
		this._selected = false;
	},
	$_resetHeight: function () {
		var newcount, cr, h,
			elt = this._dom.element();
		elt.style.height = "10px";
		newCount = this._items.length;
		if (this._firstChild) {
			cr = Dom.getBounds(this._firstChild);
			if (this._narrowSearch) {
                newCount = this._newItemArr.length;
            }
			h = (this._dropDownCount > 0) ? Math.min(this._dropDownCount, newCount) : this._items.length;
            elt.style.overflowY = this._items.length > h ? 'auto' : 'hidden';
			elt.style.height = (cr.height * h + 4) + "px";
		}
	},
    $_resetWidth: function (cellWidth) {
        var w2, childs, i,
            elt = this._dom.element(),
		    r = Dom.getBounds(elt),
            w = this._dropDownWidth;
		if (w < 0) {
			w = cellWidth;
		} else if (w == 0) {
			w = r.width;
		}
        elt.style.width = w + "px";
		w2 = 0;
        if (this._firstChild && elt.scrollWidth > elt.clientWidth) {
            childs = elt.childNodes;
            for (i = 0; i < childs.length; i++) {
                w2 = Math.max(w2, childs[i].scrollWidth);
            }
            w2 += elt.offsetWidth - elt.clientWidth + 2;// + 4;
        }
		r = Dom.getBounds(elt);
		w = Math.max(w, r.width, w2);
		r = _getBrowserSize();//Dom.getBounds(this._containerElement);
		w = Math.min(w, r.width);
        elt.style.width = (this._width = w) + "px";
    },
	$_resetPosition: function (x, y, cellWidth, editBounds) {
        var br = _getBrowserSize(),
            pr = Dom.getBounds(this._containerElement),
		    cr = !$_testing ? Dom.getBounds(this._container._container) : { left: 0, top: 0},
		    w = br.width, // this._container.width(); // _container: grid container
		    h = br.height, //this._container.height();
		    r = this._dom.getBounds(),
			body = document.documentElement,
            sx = window.pageXOffset || body.scrollLeft,
            sy = window.pageYOffset || body.scrollTop;
        if (body.scrollWidth > body.clientWidth) {
            h -= 18;
        }
        if (body.scrollHeight > body.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += body.scrollLeft;
			y += body.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		if (!isNaN(this._dropDownMinLeft)) {
			x = Math.max(x, this._dropDownMinLeft + cr.left);
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
	$_resetList: function () {
		this._dom.clearChildren();
		this._firstChild = null;
		this.$_buildItems();
		this.$_resetHeight();
        this.$_resetWidth(this._cellWidth);
		this.$_resetPosition(this._editX, this._editY, this._cellWidth, this._editBounds);
		if (this._needChromInit) {
			this._element.style.width = (this._width + 0.1) + 'px';
		}
	},
	$_narrowSearch: function (input, item) {
		if (this._partialMatch) {
			return !input || DropDownList.checkHangul(input, item.label) != 0;
		} else {
			return item.label.indexOf(input) == 0;
		}
	},
	$_getItemColor: function (selected, hovered) {
		var color, s = this._listItemStyles;
		if (selected) {
			color = s.selectedColor();
		} else if (hovered) {
			color = s.hoveredColor();
		} else {
			color = s.color();
		}
		return color ? color.css() : "";
	},
    $_getSubColor: function (selected, hovered) {
        var color, s = this._subItemStyles;
        if (selected) {
            color = s.selectedColor();
        } else if (hovered) {
            color = s.hoveredColor();
        } else {
            color = s.color();
        }
        return color ? color.css() : "";
    },
	$_getItemBackground: function (selected, hovered) {
		var color, s = this._listItemStyles;
		if (selected) {
			color = s.selectedBackground();
		} else if (hovered) {
			color = s.hoveredBackground();
		} else {
			color = s.background();
		}
        return color ? color.css() : "";
	},
    $_getSubBackground: function (selected, hovered) {
        var color, s = this._subItemStyles;
        if (selected) {
            color = s.selectedBackground();
        } else if (hovered) {
            color = s.hoveredBackground();
        } else {
            color = s.background();
        }
        return color ? color.css() : "";
    },
	$_getTextDecoration: function (selected, hovered) {
		return hovered ? "underline" : "none";
	},
	$_buildItems: function (narrow, input) {
		var items, newItems, font, font2, i, cnt, item, selected, div, s, s2, span, span2, w, gap, sep, subLabeled, divs,
            element = this._element,
            itemIndex = this._itemIndex;
		element.style.width = null;
		element.style.height = null;
        this._displayCount = 0;
		narrow && Dom.clearChildren(this._element);
		items = this._items;
		if (!items || items.length < 1) {
			return;
		}
        newItems = this._newItemArr = [];
        subLabeled = ListItemDisplay.subLabeled(this._listItemDisplay);
        if (subLabeled) {
            divs = [];
            w = 0;
        };
    	font = this._listItemStyles.font();
        font2 = this._subItemStyles.font();
        gap = this._listItemGap + 'px';
        sep = this._listItemSeparator;
		for (i = 0, cnt = items.length; i < cnt; i++) {
			item = items[i];
			if (!narrow || this.$_narrowSearch(input, item)) {
                selected = i == itemIndex;
				div = Dom.createElement("div", {
					position: "relative",
					float: "none",
					paddingTop: "1px",
					paddingBottom: "1px",
					paddingLeft: "2px",
					paddingRight: "2px",
					whiteSpace: "nowrap",
					cursor: "default",
					font: font.font,
					background: this.$_getItemBackground(selected),
					color: this.$_getItemColor(selected)
				});
				Dom.disableSelection(div);
				element.appendChild(div);
				if (!this._firstChild) {
					this._firstChild = div;
				}
                this._displayCount++;
				div.onmouseover = this._mouseoverHandler;
				div.onmouseout = this._mouseoutHandler;
				div.onclick = this._clickHandler;
				if (item) {
                    s = item.label.toString().trim();
                    if (subLabeled) {
                        s2 = item.subLabel;
                        if (s2 && sep) s2 = sep + s2;
                    } else {
                        s2 = "";
                    }
                } else {
                    s = s2 = "";
                }
				span = Dom.createElement("span", {
                    display: "inline-block",
                    textDecoration: this.$_getTextDecoration(selected)
                });
				span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
				span.tabIndex = -1;
				Dom.disableSelection(span);
				div.appendChild(span);
                if (s2) {
                    span2 = Dom.createElement("span", {
                        display: "inline-block",
                        font: font2.font,
                        background: this.$_getSubBackground(selected),
                        color: this.$_getSubColor(selected),
                        marginLeft: gap,
                        marginRight: "2px"
                    });
                    span2.innerHTML = s2 ? Dom.htmlEncode(s2) : "&nbsp;";
                    span2.tabIndex = -1;
                    Dom.disableSelection(span2);
                    div.appendChild(span2);
                }
                div.$_span = span;
                div.$_span2 = span2;
				newItems.push(item);
                if (divs) {
                    divs.push(div);
                    w = Math.max(w, span.offsetWidth);
                }
			}
		}
        var x, y;
        if (divs) {
            if (this._listItemColumned) {
                w = w + 'px';
                for (i = divs.length; i--;) {
                    div = divs[i];
                    span = div.$_span;
                    span.style.minWidth = w;
                }
            }
            if (font.size > font2.size) {
                for (i = divs.length; i--;) {
                    div = divs[i];
                    span = div.$_span;
                    span2 = div.$_span2;
                    x = span2.offsetLeft;
                    y = span.offsetTop  + (span.offsetHeight - span2.offsetHeight) / 2;
                    span2.style.position = 'absolute';
                    span2.style.left = x + 'px';
                    span2.style.top = y + 'px';
                    span2.style.marginLeft = 0;
                }
            }
        }
	},
	$_refreshItems: function () {
		var i, cnt, item, idx, y, selected,
			items = this._element.childNodes;
		for (i = 0, cnt = items.length; i < cnt; i++) {
            selected = i == this._itemIndex;
			item = items[i];
			item.style.background = this.$_getItemBackground(selected);
			item.style.color = this.$_getItemColor(selected);
            if (item.$_span2) {
                item.$_span2.style.background = this.$_getSubBackground(selected);
                item.$_span2.style.color = this.$_getSubColor(selected);
            }
		}
		idx = this._itemIndex;
		if (idx >= 0 && idx < items.length) {
			item = items[idx];
			if (item.offsetTop < this._element.scrollTop) {
				this._element.scrollTop = item.offsetTop;
			} else {
				y = item.offsetTop + Dom.getSize(item).height;
				if (y >= this._element.scrollTop + this._element.clientHeight) {
					this._element.scrollTop = y - this._element.clientHeight;
				}
			}
		}
	},
	$_search: function (text, ignoreSelected) {
		var items, cnt, t, list, i, s, s2, check;
		try {
			if (this._narrowSearch) {
				this._firstChild = null;
				this.$_buildItems(true, text);
				this.$_resetHeight();
				this.$_resetWidth(this._cellWidth);
				this.$_resetPosition(this._editX, this._editY, this._cellWidth, this._editBounds);
                if (this._needChromInit) {
                    this._element.style.width = (this._width + 0.1) + 'px';
                }
			}
			if (this._items && text) {
                items = this._narrowSearch ? this._newItemArr : this._items;
                cnt = items.length;
				t = this._caseSensitive ? text : text.toLowerCase();
                list = [];
				for (i = 0; i < cnt; i++) {
					s = items[i].label.toString();
					if (s) {
						s = this._caseSensitive ? s : s.toLowerCase();
						if (s == t) {
							this.setItemIndex(i, ignoreSelected);
							return;
						}
					}
					list.push({i:i, s:s});
				}
                for (i = 0; i < cnt; i++) {
                    s = list[i].s;
                    if (s && s.indexOf(t) == 0) {
                        this.setItemIndex(list[i].i, this._narrowSearch || ignoreSelected);
                        return;
                    }
					if (this._partialMatch) {
						check = DropDownList.checkHangul(t, s);
						if (check == 2 || check == 1) {
							this.setItemIndex(list[i].i, this._narrowSearch || ignoreSelected);
							return;
						} else {
						}
					}
				}
                if (this._insideSearch) {
                    for (i = 0; i < cnt; i++) {
                        s = list[i].s;
                        if (s && s.indexOf(t) > 0) {
                            this.setItemIndex(list[i].i, ignoreSelected);
                            return;
                        }
                    }
                }
			}
			this.setItemIndex(-1);
		} finally {
			if (ignoreSelected) {
				this._selected = true;
			}
		}
	}
}, {
	getHangulSyl: function (char) {
		var firstKeyCode, lastKeyCode, char3, char2, char1,
			key = char.charCodeAt(0);
		if (key >= "ㄱ".charCodeAt(0) && key <= "ㅎ".charCodeAt(0)) {
			return char;
		}
		firstKeyCode = 0xac00;
		lastKeyCode = 0xd7a3;
		if (key >= firstKeyCode && key <= lastKeyCode) {
			key -= 0xac00;
			char3 = key % 28;
			char2 = ((key - char3) / 28) % 21;
			char1 = (((key - char3) / 28) - char2) / 21;
			return DropDownList.HAN_CHOS[char1];
		} else if (DropDownList.HAN_CHOS.indexOf(char) >= 0) {
			return char;
		}
		return null;
	},
	checkHangul: function (input, label) {
		var match, i, c1, c2, s1, s2, min;
		if (input && input.length <= label.length) {
			match = [];
			for (i = 0; i < input.length; i++) {
				c1 = input.charAt(i);
				c2 = label.charAt(i);
				if (!this._caseSensitive) {
					c1 = c1.toLowerCase();
					c2 = c2.toLowerCase();
				}
				if (c1 != c2) {
					s1 = DropDownList.getHangulSyl(c1);
					if (s1 == c1) {
						s2 = DropDownList.getHangulSyl(c2);
						if (s1 && s2 && s1 == s2) {
							match.push(1);
						} else {
							match.push(0);
						}
					} else {
						match.push(0);
					}
				} else {
					match.push(2);
				}
			}
			min = match[0];
			for (i = 1; i < match.length; i++) {
				if (match[i] < min) {
					min = match[i];
				}
			}
			return min;
		}
		return 0;
	}
});
DropDownList.HAN_CHOS = [
	"ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ",
	"ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"
];
DropDownList.CLOSE_UP = "onDropDownListCloseUp";
var SearchCellEditor = defineClass("SearchCellEditor", ListCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._searchKey = null;
		this._timer = undefined;
	},
	keyLength: 1,
	searchDelay: 1000,
    requestWhenCtrlEnter: false,
    requestWhenEnter: false,
    setKeyLength: function (value) {
        this._keyLength = isNaN(value) ? 1 : Math.max(1, value);
    },
    setSearchDelay: function (value) {
        this._searchDelay = isNaN(value) ? 0 : Math.max(0, value);
    },
	fillItems: function (key/*String*/, values/*[]*/, labels/*[]*/) {
		if (this.isListing() && key == this.getEditText()) {
			this.setValues(values);
			this.setLabels(labels);
			this._refreshItems(true, true);
			this._list.$_search(this._editor.value);
			return true;
		}
		return false;
	},
    initOptions: function () {
        this._super();
        this._keyLength = 1;
        this._searchDelay = 1000;
        this._requestWhenCtrlEnter = false;
        this._requestWhenEnter = false;
    },
    _keyDownHandler: function (e) {
        var key = e.keyCode == Keys.ENTER;
        if (key) {
            /*
            if (e.ctrlKey) {
                key = this.requestWhenCtrlEnter();
            } else {
                key = this.requestWhenEnter() && (!this._items || this._items.length < 1);
            }
            */
            key = (this.requestWhenCtrlEnter() && e.ctrlKey) || this.requestWhenEnter();
        }
        if (key && this.isEditing()) {
            _stopEvent(e);
            this.$_stopTimer();
            this.$_requestItems();
            return true;
        }
        return this._super(e);
    },
    _keyUpHandler: function (e) {
        this._super(e);
        if (_isChrome) {
            this.$_search();
        }
    },
	_inputHandler: function (e) {
		this._super(e);
        if (!_isChrome) {
            this.$_search();
        }
	},
	_doEndEdit: function () {
		this._super();
		this.$_stopTimer();
		this._searchKey = null;
	},
	dropDown: function () {
		this._super(true);
	},
    $_search: function () {
        var s = this.getEditText();
        if (s && s.length >= this._keyLength) {
            this.$_startTimer();
        } else {
            /*
            if (this._values && this._values.length > 0) {
                this.fillItems(this.getEditText(), [], []);
                this._searchKey = null;
            }
            */
            this.$_stopTimer();
        }
    },
	$_startTimer: function () {
		this.$_stopTimer();
		this._timer = setInterval(function () {
            if (this.$_requestItems()) {
                this.$_stopTimer();
            }
		}.bind(this), this._searchDelay)
	},
	$_stopTimer: function () {
        this._timer && clearInterval(this._timer);
    },
    $_requestItems: function () {
        var s = this.getEditText();
        if (s && (s != this._searchKey)) {
            this._searchKey = s;
            this._dispatchSearch(s);
            return true;
        }
        return false;
    }
});
SearchCellEditor.SEARCH = "onSearchCellEditorSearch";
var $$_HANGUL_REG = /[ㄱ-ㅎㅏ-ㅣ가-힣]/g;
var NumberCellEditor = defineClass("NumberCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._regxNumber = /[0-9]|,|\.|\-|\+/;
		this._regxAll = /[0-9]|,|\.|\-|\+|e|E/;
		this._regxPos = /[0-9]|,|\.|\+/;
		this._regxPosAll = /[0-9]|,|\.|\+|e|E/;
		this._regxInt = /[0-9]|,|\+|\-/;
		this._regxIntAll = /[0-9]|,|\+|\-|\+|e|E/;
		this._regxPosInt = /[0-9]|,|\+/;
		this._regxPosIntAll = /[0-9]|,|\+|e|E/;
		this._regx = this._regxAll;
        this._disableIme();
	},
	positiveOnly: false,
    scientific: true,
	maxDigits: NaN,
    minValue: NaN,
    maxValue: NaN,
    checkMaxValue: true,
	setPositiveOnly: function (value) {
		if (value != this._positiveOnly) {
			this._positiveOnly = value;
			this.$_resetRistrict();
		}
	},
    setScientific: function (value) {
        if (value != this._scientific) {
            this._scientific = value;
            this.$_resetRistrict();
        }
    },
	setMaxDigits: function (value) {
		value = Number(value);
		if (value != this._maxDigits) {
			this._maxDigits = value;
			this.$_resetRistrict();
		}
	},
	initOptions: function () {
		this._super();
		this.setPositiveOnly(false);
        this.setScientific(true);
		this.setMaxDigits(NaN);
        this.setMinValue(NaN);
        this.setMaxValue(NaN);
	},
	/*
	_keyDownHandler: function (e) {
		this._editor.value = this._editor.value.replace(/[ㄱ-ㅎㅏ-ㅣ가-힣]/g, '');
		return this._super(e);
	},
	_compositionstartHandler: function (e) {
		this._super(e);
		this._editor.value = this._editor.value.replace(/[ㄱ-ㅎㅏ-ㅣ가-힣]/g, '');
	},
	_compositionupdatetHandler: function (e) {
		this._super(e);
		this._editor.value = this._editor.value.replace(/[ㄱ-ㅎㅏ-ㅣ가-힣]/g, '');
	},
	_compositionendHandler: function (e) {
		this._super(e);
		this._editor.value = this._editor.value.replace(/[ㄱ-ㅎㅏ-ㅣ가-힣]/g, '');
	},
	 */
    _keyDownHandler: function (e) {
        if ((e.keyCode == 229 || e.keyCode == 197/* opera? */)) {
            _stopEvent(e);
            return false;
        }
        return this._super(e);
    },
	_keyPressHandler: function (e) {
		var c, s, p, nSel, checkMax, d, i;
        if (_isFirefox) {
            if (e.ctrlKey) {
                this._super(e);
                return;
            }
        }
        c = String.fromCharCode(e.keyCode || e.charCode);
		if (!this._regx.test(c)) {
			e.preventDefault();
			return;
		}
        s = this._editor.value;
        p = this._editor.selectionEnd;
		nSel = p - this._editor.selectionStart;
		checkMax = this._checkMaxValue && p == this._editor.selectionStart;
        d = this._maxDigits;
		if (d > 0 && c >= "0" && c <= "9") {
			i = s ? s.indexOf('.') : -1;
			if (i >= 0 && (s.length - i) > d && p > i && nSel < 1) {
				e.preventDefault();
				return;
			}
		}
        if (!isNaN(this._maxValue) && checkMax) {
            s = s.substring(0, p) + c + s.substr(p);
            d = parseFloat(s);
            if (!isNaN(d) && !isNaN(this._maxValue) && d > this._maxValue) {
                e.preventDefault();
                return;
            }
        }
		this._super(e);
	},
	_dispatchChange: function () {
        if (this.visible()) {
            this._clearHanguls();
            this._super();
        }
	},
	setEditValue: function (value) {
		var v = this._oldValue = parseFloat(value);
		this._editor.value = isNaN(v) ? "" : v;
	},
	getEditValue: function (committing, throwError) {
		var fld, v, s;
		this._clearHanguls();
		fld = this._editField();
		v = undefined;
		try {
			s = this._editor.value;
			s = s && s.trim();
			if (s) {
				s = s.replace(/,/g, "");
				s = s.replace(/[.]+/g, ".");
				s = s.replace(/\++/g, "+");
				s = s.replace(/\-+/g, "-");
				s = s.replace(/\+\-/g, "+");
				s = s.replace(/\-\+/g, "-");
			}
			v = s ? parseFloat(s) : this.emptyValue();
			/*
			if (!isNaN(v) && this._maxDigits > 0) {
				v = v.toFixed(this._maxDigits);
			}
			*/
            if (!isNaN(v)) {
                if (!isNaN(this._maxValue)) {
                    v = Math.min(v, this._maxValue);
                }
                if (!isNaN(this._minValue)) {
                    v = Math.max(v, this._minValue);
                }
            }
		} catch (e) {
			if (throwError) throw e;
		}
		return v;
	},
	$_resetRistrict: function () {
		var intOnly = !isNaN(this._maxDigits) && this._maxDigits <= 0;
		if (this._positiveOnly && intOnly) {
			this._regx = this._scientific ? this._regxPosIntAll : this._regxPosInt;
		} else if (this._positiveOnly) {
			this._regx = this._scientific ? this._regxPosAll : this._regxPos;
		} else if (intOnly) {
			this._regx = this._scientific ? this._regxIntAll : this._regxInt;
		} else {
			this._regx = this._scientific ? this._regxAll : this._regxNumber;
		}
	}
});
var Holiday = defineClass("Holiday", null, {
	init: function (source) {
		this._super();
        this.setBackground('#f5f5f5');
        this.setColor('#ccc');
        this.setBorder('#eee');
		source && this.load(source);
	},
	background: null,
	color: null,
	border:  null,
	description: null,
    setBackground: function (value) {
        this._background = value ? new SolidBrush(value) : null;
    },
    setColor: function (value) {
        this._color = value ? new SolidBrush(value) : null;
    },
    setBorder: function (value) {
        this._border = value ? new SolidPen(value) : null;
    },
	contains: function (date) {
		return false;
	},
	load: function (source) {
		source && this.assign(source);
	},
	prepare: function (editor) {
	},
	compare: function (d1, d2) {
        return new Date(d1).setHours(0, 0, 0, 0) - new Date(d2).setHours(0, 0, 0, 0);
	}
});
var DateHoliday = defineClass("DateHoliday", Holiday, {
	init: function (source) {
		this._super(source);
	},
	dates: null,
	setDates: function (value) {
		if (value != this._dates) {
			if (!_isArray(value)) {
				value = [value];
			}
			this._dates = value;
		}
	},
	contains: function (date) {
		for (var i = 0; i < this._preparedDates.length; i++) {
			if (this.compare(date, this._preparedDates[i]) == 0) {
				return true;
			}
		}
		return false;
	},
	prepare: function (editor) {
		var dates = this._dates;
		if (dates) {
			this._preparedDates = [];
			for (var i = 0; i < dates.length; i++) {
				var d = _toDate(dates[i], editor._dateConverter);
				this._preparedDates.push(d);
			}
		}
	}
});
var RangeHoliday = defineClass("RangeHoliday", Holiday, {
	init: function (source) {
		this._super(source);
        this._dateConverter = DatetimeConverter.Default;
	},
	startDate: null,
	endDate: null,
	contains: function (date) {
		if (this._psDate && this._peDate) {
			if (this._psDate > this._peDate) {
				if (this.compare(this._psDate, date) <= 0 || this.compare(this._peDate, date) >= 0) {
					return true;
				}
			} else {
				if (this.compare(this._psDate, date) <= 0 && this.compare(this._peDate, date) >= 0) {
					return true;
				}
			}
		} else if (this._psDate) {
			if (this.compare(this._psDate, date) <= 0) {
				return true;
			}
		} else if (this._peDate) {
			if (this.compare(this._peDate, date) >= 0) {
				return true;
			}
		}
		return false;
	},
	prepare: function (editor) {
		this._psDate = _toDate(this._startDate, editor._dateConverter);
		this._peDate = _toDate(this._endDate, editor._dateConverter);
	}
});
var DayHoliday = defineClass("DayHoliday", Holiday, {
	init: function (source) {
		this._super(source);
	},
	days: null,
	setDays: function (value) {
		if (value != this._days) {
			if (!_isArray(value)) {
				value = [value];
			}
			this._days = value;
		}
	},
	contains: function (date) {
		var d = date.getDay();
		return 	this._dayValues.indexOf(d) >= 0 || this._enValues && this._enValues.indexOf(d) >= 0;
	},
	prepare: function () {
		var days = Locale._default.shortWeekDays;
		this._dayValues = [];
		for (var i = 0; i < this._days.length; i++) {
			this._dayValues.push(days.indexOf(this._days[i]))
		}
		if (Locale._default !== Locale.en) {
			days = Locale.en.shortWeekDays;
			this._enValues = [];
			for (var i = 0; i < this._days.length; i++) {
				this._enValues.push(days.indexOf(this._days[i]))
			}
		}
	}
});
var BaseHoliday = defineClass("BaseHoliday", Holiday, {
	init: function (source) {
		this._super(source);
        this._dateConverter = DatetimeConverter.Default;
	},
	baseDate: null,
	prevDays: 0,
	nextDays: 0,
	contains: function (date) {
		var pdate = this._prevDate;
		var ndate = this._nextDate;
		if (pdate && ndate) {
			if (this.compare(pdate, date) <= 0 && this.compare(ndate, date) >= 0) {
				return true;
			} else {
				return false;
			}
		}
	},
	prepare: function (editor) {
		var p1, p2;
		p1 = _toDate(this._baseDate, editor._dateConverter);
		p2 = _toDate(this._baseDate, editor._dateConverter);
		p1.setDate(p1.getDate() - this._prevDays);
		p2.setDate(p2.getDate() + this._nextDays);
		this._prevDate = p1;
		this._nextDate = p2;
	}
});
var HolidayCollection = defineClass("HolidayCollection", null, {
	init: function () {
		this._super();
        this._items = [];
	},
	count: function () {
		return this._items.length;
	},
	load: function (source) {
		var i, s, h;
		this._items = [];
		if (source) {
			if (!_isArray(source)) {
				source = [source];
			}
			for (i = 0; i < source.length; i++) {
				s = source[i];
				if (s.hasOwnProperty("type")) {
					switch (s.type) {
						case "day" :
							h = new DayHoliday(s);
							break;
						case "range" :
							h = new RangeHoliday(s);
							break;
						case "date" :
							h = new DateHoliday(s);
							break;
						case "base" :
							h = new BaseHoliday(s);
							break;
					}
				}
				this._items.push(h);
			}
		}
	},
	contains: function (date, delta) {
		var i, cnt, item;
		if (delta !== undefined) {
			date = new Date(date.getFullYear(), date.getMonth(), date.getDate() + delta);
		}
		for (i = 0, cnt = this.count(); i < cnt; i++) {
			item = this.getItem(i);
			if (item.contains(date)) {
				return item;
			}
		}
		return null;
	},
	getItem: function (index) {
		return this._items[index];
	},
	add: function (item) {
	},
	clear: function () {
		this._items = [];
	},
	prepare: function (editor) {
		for (var i = this.count(); i--;) {
			this.getItem(i).prepare(editor);
		}
	}
});
var DateCellEditor = defineClass("DateCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._list = new DatePicker(grid._container, this);
		this._list.addListener(this);
		this._closing = false;
		this._date = undefined;
		this._borderable = false;
        this._regx = /[0-9]|\.|\-|\//;
        this._regxtime = /[0-9]|\.|\-|\/|a|A|p|P|m|\s|:/;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p === this._list._element) {
					this._list._monthPicker.hide();
					return;
				}
				if (p === this._list._monthPicker._dom._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
		this._holidays = new HolidayCollection();
	},
	minDate: new Date(1970, 0, 1),
	maxDate: new Date(2100, 11, 31),
	yearNavigation: false,
	textReadOnly: false,
	dropDownPosition: EnumProp(DropDownPosition, DropDownPosition.BUTTON),
    showToday: true,
    commitOnSelect: true,
    hasTime: false,
	holidays: null,
	setMinDate: function (value) {
		this._minDate = _toDate(value, this._dateConverter);
	},
	setMaxDate: function (value) {
		this._maxDate = _toDate(value, this._dateConverter);
	},
	setHolidays: function (value) {
		if (value !== this._holidays) {
			this._holidays.load(value);
		}
	},
	/** @deprecated Use listing() instead. */
	isListing: function () {
		return this._list.isListing();
	},
	listing: function () {
		return this._list.isListing();
	},
	isMonthListing: function () {
		return this._list.isMonthListing();
	},
	dropDown: function () {
		var list, r;
		if (!this.readOnly() && !this.isListing() && !this._closing) {
			list = this._list;
            r = Dom.getBounds(this._container);
			this._holidays.prepare(this);
			list._minDate = this._minDate;
			list._maxDate = this._maxDate;
			list.setYearNavigation(this._yearNavigation);
			list.setDropDownPosition(this._dropDownPosition);
            list.setShowToday(this._showToday);
			list.setHolidays(this._holidays);
			this.$_setListDate();
            list.show(this._grid.container()._popupOwner || _doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
			Dom.addWindowListener("mousedown", this._globalMouseHandler);
			return true;
		}
		return false;
	},
	closeUp: function (accept) {
		if (this.isListing()) {
			this._closing = true;
			try {
				Dom.removeWindowListener("mousedown", this._globalMouseHandler);
				this._list.hide();
				if (accept && this._list.isSelected()) {
					var d = this._list.date();
					if (!this._textReadOnly) {
						var d2 = this.$_getEditDate();
						if (d2) {
							d.setHours(d2.getHours(), d2.getMinutes(), d2.getSeconds(), d2.getMilliseconds());
						}
					}
					this.$_selectDate(d);
					if (this._commitOnSelect) {
						this._dispatchCommit();
					}
				}
			} finally {
				this._closing = false;
			}
			return true;
		}
		return false;
	},
	initOptions: function () {
		this._super();
		this._minDate = new Date(1970, 0, 1);
		this._maxDate = new Date(2100, 11, 31);
		this._yearNavigation = false;
		this._textReadOnly = false;
		this._dropDownPosition = DropDownPosition.BUTTON;
        this._showToday = true;
		this._commitOnSelect = true;
		this._holidays.clear();
	},
    _isDateEditor: function () {
        return true;
    },
	hasButton: function () {
		return true;
	},
	setEditIndex: function (index) {
		this._super(index);
		if (this._textReadOnly) {
			this._editor.readOnly = true;
		}
	},
	setEditValue: function (value) {
		this._super(value);
		this._date = value;
		this._editor.value = this.$_valToStr(value);
	},
	getEditValue: function (committing, throwError) {
		var d = this._super(committing, throwError);
		if (d && committing) {
			this._minDate && (d = Math.max(this._minDate, d));
			this._maxDate && (d = Math.min(this._maxDate, d));
		}
		return d;
	},
	_createContainer: function () {
		var elt = this._super();
		elt.style.border = "none";
		elt.style.boxShadow = "none";
		return elt;
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		return editor;
	},
    _deleteEditor: function () {
        this.closeUp();
        this._super();
    },
	_textHandler: function () {
		this._requestStart();
	},
	_oncompositionstartHandler: function () {
		this._requestStart();
	},
	_keyDownHandler: function (e) {
		var d, listing, focused,
			list = this._list;
		if (list.isMonthListing()) {
			if (e.keyCode == Keys.ESCAPE) {
				this.closeMonthList();
                _stopEvent(e);
				return true;
			}
			return false;
		}
		listing = this.isListing();
		focused = listing && list.isFocused();
		switch (e.keyCode) {
			case Keys.ENTER:
				if (this.closeUp(true)) {
                    _stopEvent(e);
					return !this._sendToParent(e);
				}
				break;
			case Keys.ESCAPE:
				if (this.closeUp(false)) {
                    _stopEvent(e);
					return true;
				}
				break;
			case Keys.HOME:
				if (focused) {
                    _stopEvent(e);
					this.$_selectDate(list.firstDay());
					return true;
				}
				break;
			case Keys.END:
				if (focused) {
                    _stopEvent(e);
					this.$_selectDate(list.lastDay());
					return true;
				}
				break;
			case Keys.LEFT:
				if (focused) {
                    _stopEvent(e);
					this.$_selectDate(list.incDay(-1));
					return true;
				}
				break;
			case Keys.RIGHT:
				if (focused) {
                    _stopEvent(e);
					this.$_selectDate(list.incDay(1));
					return true;
				}
				break;
			case Keys.PAGEDOWN:
				if (listing) {
                    _stopEvent(e);
					if (focused) {
						this.$_selectDate(e.altKey ? list.incMonth(12) : list.incMonth(1));
					} else {
						this._list.setFocused(true);
						this.$_setListDate();
					}
					return true;
				}
				break;
			case Keys.PAGEUP:
				if (listing) {
                    _stopEvent(e);
					if (focused) {
						d = list.date();
						if (!e.altKey && d.getDate() <= 7) {//} && d.getDay() + 1 >= d.getDate()) {
							this._list.setFocused(false);
						} else {
							this.$_selectDate(e.altKey ? list.incMonth(-12) : list.incMonth(-1));
						}
					} else {
						this._list.setFocused(false);
					}
					return true;
				}
				break;
			case Keys.DOWN:
				if (e.altKey && !listing) {
					this._requestStart();
                    _stopEvent(e);
					return true;
				} else if (listing) {
                    _stopEvent(e);
					if (focused) {
						this.$_selectDate(list.incDay(7));
					} else {
						this._list.setFocused(true);
						this.$_setListDate();
					}
					return true;
				}
				break;
			case Keys.UP:
				if (e.altKey && listing) {
					this.closeUp(false);
                    _stopEvent(e);
					return true;
				} else if (listing) {
                    _stopEvent(e);
					if (focused) {
						d = list.date();
						if (e.shiftKey) {
							this._list.setFocused(false);
						} else {
							this.$_selectDate(list.incDay(-7));
						}
					} else {
						this._list.setFocused(false);
					}
					return true;
				}
				break;
            case Keys.T:
                if ((e.altKey || e.altKey && e.ctrlKey) && listing) {
                    _stopEvent(e);
                    this._list.setDate(new Date());
					this.$_selectDate(this._list._date);
                }
                break;
		}
		return DateCellEditor.Base._keyDownHandler.call(this, e);
	},
	_keyPressHandler: function (e) {
        var regx,
			list = this._list,
        	c = String.fromCharCode(e.keyCode || e.charCode);
        /*if (c.toLocaleLowerCase() == this.todayChar()) {
            _stopEvent(e);
            if (this.isListing()) {
                list.setFocused(true);
                this.$_selectDate(list.today());
                return true;
            }
        } else*/ {
            regx = this.hasTime() ? this._regxtime : this._regx;
            if (!regx.test(c)) {
                e.preventDefault();
                return;
            }
        }
		return this._super(e);
	},
    _dispatchChange: function () {
        if (this.visible()) {
            this._clearHanguls();
            this._super();
        }
    },
	_requestStart: function () {
		if (this._super()) {
			this.dropDown();
			return true;
		}
		return false;
	},
	setBounds: function (x, y, w, h) {
		x += 2;
		y += 2;
		w -= 4;
		h -= 4;
		this._super(x, y, w, h);
	},
	closeList: function (accept) {
		this.closeUp(accept);
	},
	closeMonthList: function () {
		this._list.closeMonth();
	},
	buttonClicked: function (index) {
		this.isListing() ? this.closeUp(false) : this.dropDown();
	},
	$_selectDate: function (d) {
		if (d && d != this._date) {
			this._date = d;
			this._editor.value = this._dateConverter.getText(this._date);
			this._dispatchChange();
		}
	},
	$_getEditDate: function () {
		var d = this._dateConverter.getDateNull(this._editor.value);
		return d;
	},
	$_setListDate: function () {
		var d = this.$_getEditDate();
		if (d) {
			this._list.setDate(d);
		}
	},
	onDatePickerCloseUp: function (list, accept) {
		this.closeUp(accept);
		this.setFocus();
	}
});
/** @internal */
var DatePicker = defineClass("DatePicker", EventAware, {
	init: function (container, editor) {
		this._super();
        this._container = container;
		this._editor = editor;
		this._containerElement = null;
		this._headerElement = null;
		this._headElement = null;
        this._todayElement = null;
		this._monthPicker = new MonthPicker();
		this._monthPicker.addListener({
			onMonthPickerCloseUp: function (picker, month) {
				var delta = month - this._currDate.getMonth();
				if (delta) {
					_incMonth(this._currDate, delta);
					this.$_buildCalendar();
				}
				this._editor.setFocus();
			}.bind(this)
		});
		this._date = new Date();
		this._currDate = null;
		this._today = null;
		this._selected = false;
		this._cellBackground = "#f5f5f5";
		this._todayBackground = "#d5d5d5";
		this._focusedBackground = "rgba(255, 255, 0, 0.3)";
		this._hoveredBackground = "";// "rgba(0, 255, 0, 0.2)";
		this._cellBorder = "1px solid #eee";
		this._nullBorder = "1px solid #fff";
		this._focusedBorder = "1px solid #aaa";
		this._todayBorder = "1px solid #aaa";
		this._hoveredBorder = "1px solid #111";
		this._cellColor = "#222";
		this._nullColor = "#ccc";
        this._focused = true;
		this._mouseoverHandler = function (e) {
			var td = e.currentTarget;
			td.style.background = this._hoveredBackground;
			td.style.border = this._hoveredBorder;
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var date = this._currDate;
			var y = date.getFullYear();
			var m = date.getMonth();
			var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
			var td = e.currentTarget;
			var css = td.style;
			var d = td.$_day;
			if (d < 0 || d >= mdays) {
				css.background = "";
				css.border = this._nullBorder;
				css.color = this._nullColor;
			} else if (this.$_isFocusedDay(this._currDate, d + 1)) {
				css.background = this._focusedBackground;
				css.border = this._focusedBorder;
				css.color = this._cellColor;
			} else if (this.$_isToday(this._currDate, d + 1)) {
				css.background = this._todayBackground;
				css.border = this._todayBorder;
				css.color = this._cellColor;
			} else if (	e.currentTarget.$_holiday) {
				var h = e.currentTarget.$_holiday;
				css.background = h._background && h._background.css();
				css.border = h._border && h._border.css();
				css.color = h._color && h._color.css();
			} else if (e.currentTarget.$_outed) {
				css.background = "";
				css.border = this._nullBorder;
				css.color = this._nullColor;
			} else {
				css.background = this._cellBackground;
				css.border = this._cellBorder;
				css.color = this._cellColor;
			}
		}.bind(this);
		this._clickHandler = function (e) {
			var h = e.currentTarget.$_holiday || e.currentTarget.$_outed;
			if (h) {
				return;
			}
			var d = e.currentTarget.$_day;
			this._date = new Date(this._currDate);
			this._date.setDate(d + 1);
			this._selected = true;
			this.fireEvent(DatePicker.CLOSE_UP, true);
		}.bind(this);
		this._dom = new Dom(this._element = this.$_createPicker());
	},
	minWidth: 0,
	maxWidth: 0,
	yearNavigation: false,
	dropDownPosition: EnumProp(DropDownPosition, DropDownPosition.BUTTON),
    showToday: true,
	minDate: null,
	maxDate: null,
	holidays: null,
	date: function () {
		return this._date;
	},
	setDate: function (value) {
		if (value.getTime() != this._date.getTime()) {
			this._currDate = new Date(value);
			this._date = new Date(value);
			if (this.isListing()) {
                this.$_buildCalendar();
			}
		}
		return this._date;
	},
	isListing: function () {
		return this._containerElement && this._containerElement.contains(this._element);
	},
	isMonthListing: function () {
		return this._monthPicker.isListing();
	},
	closeMonth: function () {
		this._monthPicker.hide(0);
	},
	isSelected: function () {
		return this._selected;
	},
	isFocused: function () {
		return this._focused;
	},
    setFocused: function (value) {
        if (value != this._focused) {
			this._focused = value;
			this._element.style.border = value ? "1px solid rgba(50, 50, 50, 1)" : "1px solid rgba(50, 50, 50, 0.3)";
			this._element.style.boxShadow = value ? "rgba(0, 0, 0, 0.8) 1px 2px 5px" : "rgba(0, 0, 0, 0.5) 1px 2px 5px";
			this._headerElement.style.backgroundColor = value ? "rgba(0, 200, 200, 0.1)" : "#e8e8e8";
			this._headElement.style.opacity = value ? "1.0" : "0.5";
        }
    },
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = containerElement;
		this.$_show(x, y, cellWidth, editBounds);
	},
	hide: function () {
		this.setFocused(false);
		this._monthPicker.hide();
		this._dom.detach();
		this._containerElement = null;
	},
    today: function () {
        return this.setDate(new Date());
    },
	incDay: function (delta, checkMonth) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			d.setDate(this._date.getDate() + delta);
			if (checkMonth && d.getMonth() != this._date.getMonth()) return;
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	incMonth: function (delta) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			this._date && _incMonth(d, delta);
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	firstDay: function () {
		var d = new Date(this._currDate);
        this._date && d.setDate(1);//this._date.getDate() - this._date.getDay());
		return this.setDate(d);
	},
	lastDay: function () {
		var d = new Date(this._currDate);
		if (this._date) {
            var y = d.getFullYear();
            var m = d.getMonth();
            var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
            d.setDate(mdays);//this._date.getDate() + 6 - this._date.getDay());
        }
		return this.setDate(d);
	},
	$_createPicker: function () {
		var element = Dom.createElement("div", {
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			margin: "0px",
			cursor: "default",
			fontFamily: "Verdana",
			fontSize: "11px",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			overflow: "auto",
			zIndex: 3000,
			background: "#fff",// "rgb(233, 233, 233)",
			border: "1px solid rgba(50, 50, 50, 0.5)",
			boxShadow: "rgba(0, 0, 0, 0.5) 1px 2px 5px",
			padding: "0px"
		});
        element.id = '$dl_datepicker';
        element.class = '$dl_datepicker';
		this._header = this.$_createHeader();
		element.appendChild(this._header);
		this._calendar = this.$_createCalendar();
		element.appendChild(this._calendar);
		element.addEventListener("keydown", function (e) {
			if (e.keyCode == 27) {
				if (this.isMonthListing()) {
					this.closeMonth();
				} else {
					this.fireEvent(DropDownList.CLOSE_UP, false);
				}
			}
		}.bind(this));
		element.addEventListener("mouseup", function (e) {
			this._editor.setFocus();
		}.bind(this));
		return element;
	},
	$_createHeader: function () {
        var prev, next, today, title, year, yearSpin, month, p,
			loc = Locale._default,
			list = this,
			elt = this._headerElement = Dom.createElement("div", {
			position: "relative",
			paddingLeft: "4px",
			paddingRight: "4px",
			paddingTop: "4px",
			paddingBottom: "0px",
            fontFamily: "Verdana",
            fontSize: "12px",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
			backgroundColor: "#e8e8e8",
			margin: "0px"
		});
		prev = Dom.createElement("span", {
			position: "absolute",
			left: "4px",
			top: "3px",
			minWidth: "17px",
			minHeight: "17px",
			backgroundImage: _getAsset("cal_prev.png"),
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		elt.appendChild(elt.$_prev = prev);
		prev.onclick = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_hover.png")
			});
            _incMonth(this._currDate, -1);
			this.$_buildCalendar();
		}.bind(this);
		prev.onmouseover = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_hover.png")
			});
		};
		prev.onmousedown = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_active.png")
			});
		};
		prev.onmouseout = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev.png")
			});
		};
		next = Dom.createElement("span", {
			position: "absolute",
			right: "4px",
			top: "3px",
			minWidth: "17px",
			minHeight: "17px",
			backgroundImage: _getAsset("cal_next.png"),
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		elt.appendChild(elt.$_next = next);
		next.onclick = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_hover.png")
			});
            _incMonth(this._currDate, 1);
			this.$_buildCalendar();
		}.bind(this);
		next.onmouseover = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_hover.png")
			});
		};
		next.onmousedown = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_active.png")
			});
		};
		next.onmouseout = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next.png")
			});
		};
        today = this._todayElement = Dom.createElement("span", {
            position: "absolute",
            right: "18px",
            top: "2px",
            padding: "2px",
            fontSize: "10px",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            border: "1px solid transparent",
            borderRadius: "3px"
        });
        elt.appendChild(today);
        today.innerHTML = "Today";
        today.onclick = function (e) {
            list.setFocused(true);
            list.setDate(new Date());
			list._editor.$_selectDate(list._currDate);
        };
        today.onmouseover = function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#00f",
                border: "1px solid #aaa",
                backgroundColor: "#fff",
                textDecoration: "underline"
            });
        };
        today.onmouseup = function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#00f",
                border: "1px solid #aaa",
                backgroundColor: "#fff"
            });
        };
        today.onmousedown = function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#800",
                backgroundColor: "#eee"
            });
        };
        today.onmouseout = function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "",
                border: "1px solid transparent",
                backgroundColor: "",
                textDecoration: ""
            });
        };
		title = Dom.createElement("div", {
			position: "relative",
			textAlign: "center",
			marginLeft: "20px",
			marginRight: "50px"
		});
		elt.appendChild(elt.$_title = title);
		year = Dom.createElement("span", {
            fontFamily: "Verdana",
            fontSize: "11px",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
			verticalAlign: "top",
			height: "16px"
		});
		title.appendChild(title.$_year = year);
		year.innerHTML = "2015" + loc.year;
		year.onclick = function (e) {
		};
		yearSpin = this.$_createYearSpin();
		title.appendChild(title.$_yearSpin = yearSpin);
		month = Dom.createElement("span", {
            fontFamily: "Verdana",
            fontSize: "11px",
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
			verticalAlign: "top"
		});
		title.appendChild(title.$_month = month);
		month.innerHTML = loc.shortMonths[0];
		month.onmousedown = function (e) {
            _stopEvent(e);
			/*
			var r = Dom.getBounds(this._headerElement.$_title.$_month);
			var x = r.left + (window.pageXOffset || document.documentElement.scrollLeft);
			var y = r.top + (window.pageXOffset || document.documentElement.scrollLeft);
			this._monthPicker.show(this._containerElement, x, y);
			*/
			var p = Dom.getOffset(this._headerElement.$_title.$_month);
			this._monthPicker.show(this._containerElement, p.x, p.y);
		}.bind(this);
		return elt;
	},
	$_createYearSpin: function () {
		var div, upper, lower;
		div = Dom.createElement("div", {
			display: "inline-block",
			visibility: "hidden",
			position: "relative",
			width: "15px",
			height: "16px",
			marginLeft: "-4px",
			marginRight: "2px"
		});
		upper = Dom.createElement("span", {
			position: "absolute",
			top: "0px",
			left: "0px",
			width: "15px",
			height: "9px",
			backgroundImage: _getAsset("cal_up.png"),
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		div.appendChild(upper);
		upper.onclick = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_hover.png")
			});
			this._currDate.setFullYear(this._currDate.getFullYear() + 1);
			this.$_buildCalendar();
		}.bind(this);
		upper.onmouseover = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_hover.png")
			});
		};
		upper.onmousedown = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_active.png")
			});
		};
		upper.onmouseout = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up.png")
			});
		};
		lower = Dom.createElement("span", {
			position: "absolute",
			top: "7px",
			left: "0px",
			width: "15px",
			height: "9px",
			backgroundImage: _getAsset("cal_down.png"),
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		div.appendChild(lower);
		lower.onclick = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_hover.png")
			});
			this._currDate.setFullYear(this._currDate.getFullYear() - 1);
			this.$_buildCalendar();
		}.bind(this);
		lower.onmouseover = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_hover.png")
			});
		};
		lower.onmousedown = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_active.png")
			});
		};
		lower.onmouseout = function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down.png")
			});
		};
		return div;
	},
	$_createCalendar: function () {
		var elt, head, tr, td, i, cells, th, span, r, body, rows,
			loc = Locale._default;
		elt = Dom.createElement("table", {
			margin: "2px",
            borderCollapse: "separate",
            borderSpacing: "3px"
		});
		elt.cellSpacing = 3;
		head = this._headElement = Dom.createElement("thead", {
		});
		elt.appendChild(elt.$_head = head);
		tr = Dom.createElement("tr");
		head.appendChild(tr);
		cells = [];
		for (i = 0; i < 7; i++) {
			th = Dom.createElement("th", {
				minWidth: "20px",
				textAlign: "center"
			});
			head.appendChild(th);
			span = Dom.createElement("span", {
                fontFamily: "Verdana",
                fontSize: "11px",
                fontStyle: "normal",
                fontVariant: "normal",
                fontWeight: "normal"
			});
			span.innerHTML = Dom.htmlEncode(loc.shortWeekDays[i]);//this._weekDays[i]);
			th.appendChild(span);
			cells.push(span);
		}
		head.$_cells = cells;
		body = Dom.createElement("tbody", {
			fontSize: "10px"
		});
		elt.appendChild(elt.$_body = body);
		rows = body.$_rows = [];
		for (r = 0; r < 6; r++) {
			tr = Dom.createElement("tr", {
			});
			body.appendChild(tr);
			rows.push(tr);
			tr.$_cells = cells = [];
			for (i = 0; i < 7; i++) {
				td = Dom.createElement("td", {
					padding: "1px",
					textAlign: "right",
					color: this._cellColor,
					background: "#f0f0f0",
					borderRadius: "1px"
				});
				tr.appendChild(td);
				cells.push(td);
				td.onmouseover = this._mouseoverHandler;
				td.onmouseout = this._mouseoutHandler;
				td.onclick = this._clickHandler;
				span = Dom.createElement("span", {
                    fontFamily: "Verdana",
                    fontSize: "11px",
                    fontStyle: "normal",
                    fontVariant: "normal",
                    fontWeight: "normal"
				});
				td.appendChild(td.$_span = span);
			}
		}
		return elt;
	},
	$_show: function (x, y, cellWidth, editBounds) {
		var d, container, br, pr, cr, w, h, r, sx, sy,
			body = document.documentElement;
		this.setFocused(false);
		this._selected = false;
		this._header.$_title.$_yearSpin.style.visibility = this._yearNavigation ? "visible" : "hidden";
        this._todayElement.style.display = this._showToday ? "initial" : "none";
        this._header.$_title.style.marginRight = this._showToday ? "50px" : "20px";
		d = this._date;
		if (!(d instanceof Date) || d == "Invalid Date") {
			d = null;
		}
		this._currDate = d ? new Date(d) : new Date();
		this._today = new Date();
		this.$_buildCalendar();
		this._dom.disableSelection();
		this._containerElement.appendChild(this._dom.element());
		container = this._container._container;
        br = _getBrowserSize();
        pr = Dom.getBounds(this._containerElement);
		cr = Dom.getBounds(container);
        w = br.width; // this._container.width(); // _container: grid container
        h = br.height; //this._container.height();
		r = this._dom.getBounds();
        sx = window.pageXOffset || body.scrollLeft;
        sy = window.pageYOffset || body.scrollTop;
        if (body.scrollWidth > body.clientWidth) {
            h -= 18;
        }
        if (body.scrollHeight > body.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += body.scrollLeft;
			y += body.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
	$_isFocusedDay: function (date, day) {
		var t = _asDate(this._date);
		return t && date.getFullYear() == t.getFullYear() &&
				date.getMonth() == t.getMonth() &&
				day == t.getDate();
	},
	$_isToday: function (date, day) {
		var t = _asDate(this._today);
		return t && date.getFullYear() == t.getFullYear() &&
			date.getMonth() == t.getMonth() &&
			day == t.getDate();
	},
	$_isOutedDay: function (date) {
		return date && this._minDate && this._maxDate && (date < this._minDate || date > this._maxDate);
	},
	$_buildCalendar: function () {
		var i, cells, body, rows, mdays, d, dow, c, md, h, y2, m2, mdays2, h, r, j,
			loc = Locale._default,
			header = this._header,
			date = this._currDate,
			prev = header.$_prev,
			next = header.$_next,
			title = header.$_title,
			y = date.getFullYear(),
			m = date.getMonth();
		title.$_year.innerHTML = y + loc.year + "&nbsp;";
		title.$_month.innerHTML = loc.shortMonths[m];
		if (m == 0) {
			prev.title = (y - 1) + "/12";
		} else {
			prev.title = y + "/" + _pad(m);
		}
		if (m == 11) {
			next.title = (y + 1) + "/01";
		} else {
			next.title = y + "/" + _pad(m + 2);
		}
		cells = this._calendar.$_head.$_cells;
		for (i = 0; i < 7; i++) {
			var elt = cells[i];
			elt.innerHTML = Dom.htmlEncode(loc.shortWeekDays[i]);//this._weekDays[i]);
		}
		body = this._calendar.$_body;
		rows = body.$_rows;
		mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
		d = new Date(date);
		d.setDate(1);
		dow = d.getDay();
		if (mdays == 30 && dow == 6 || mdays == 31 && dow >= 5) {
			Dom.addChild(body, rows[5]);
		} else {
			Dom.removeChild(body, rows[5]);
		}
		if (mdays == 28 && dow == 0) {
			Dom.removeChild(body, rows[4]);
		} else {
			Dom.addChild(body, rows[4]);
		}
		md = 0;
		cells = rows[0].$_cells;
		if (dow > 0) {
			y2 = y;
			m2 = m - 1;
			if (m2 < 0) {
				y2--;
				m2 = 11;
			}
			var mdays2 = $$_month_days[_isLeapYear(y2) ? 1 : 0][m2];
			for (i = 0; i < dow; i++) {
				c = cells[i];
				h = this._holidays.contains(d, md);
				c.$_holiday = h;
				c.$_outed = this.$_isOutedDay(d);
				c.$_day = i - dow;
				c.$_span.innerHTML = (mdays2 - dow + i + 1);
				if (h && h.description()) {
					c.title = h.description();
				}
				Dom.setStyles(c, {
					background: "",
					border: this._nullBorder,
					color: this._nullColor
				});
			}
		}
		for (i = dow; i < 7; i++) {
			c = cells[i];
			h = this._holidays.contains(d, md);
			c.$_holiday = h;
			c.$_outed = this.$_isOutedDay(d);
			c.$_day = md++;
			c.$_span.innerHTML = md;
			if (h && h.description()) {
				c.title = h.description();
			}
			if (this.$_isFocusedDay(date, md)) {
				Dom.setStyles(c, {
					background: this._focusedBackground,
					border: this._focusedBorder,
					color: this._cellColor
				});
			} else if (this.$_isToday(date, md)) {
				Dom.setStyles(c, {
					background: this._todayBackground,
					border: this._todayBorder,
					color: this._cellColor
				});
			} else if (h) {
				Dom.setStyles(c, {
					background: h._background && h._background.css(),
					border: h._boarder && h._border.css(),
					color: h._color && h._color.css()
				});
			} else if (c.$_outed) {
				Dom.setStyles(c, {
					background: "",
					border: this._nullBorder,
					color: this._nullColor
				});
			} else {
				Dom.setStyles(c, {
					background: this._cellBackground,
					border: this._cellBorder,
					color: this._cellColor
				});
			}
		}
		for (r = 1; r < 6 && md < mdays; r++) {
			cells = rows[r].$_cells;
			for (i = 0; i < 7; i++) {
				if (md < mdays) {
					c = cells[i];
					h = this._holidays.contains(d, md);
					c.$_holiday = h;
					c.$_outed = this.$_isOutedDay(d);
					c.$_day = md++;
					c.$_span.innerHTML = md;
					if (h && h.description()) {
						c.title = h.description();
					}
					if (this.$_isFocusedDay(date, md)) {
						Dom.setStyles(c, {
							background: this._focusedBackground,
							border: this._focusedBorder,
							color: this._cellColor
						});
					} else if (this.$_isToday(date, md)) {
						Dom.setStyles(c, {
							background: this._todayBackground,
							border: this._todayBorder,
							color: this._cellColor
						});
					} else if (h) {
						Dom.setStyles(c, {
							background: h._background && h._background.css(),
							border: h._border && h._border.css(),
							color: h._color && h._color.css()
						});
					} else if (c.$_outed) {
						Dom.setStyles(c, {
							background: "",
							border: this._nullBorder,
							color: this._nullColor
						});
					} else {
						Dom.setStyles(c, {
							background: this._cellBackground,
							border: this._cellBorder,
							color: this._cellColor
						});
					}
				} else {
					j = 1;
					for (; i < 7; i++) {
						c = cells[i];
						c.$_day = md++;
						c.$_span.innerHTML = j++;
						Dom.setStyles(c, {
							background: "",
							border: this._nullBorder,
							color: this._nullColor
						});
					}
				}
			}
		}
	},
	$_refreshItems: function () {
	},
	$_search: function (text) {
	}
});
DatePicker.CLOSE_UP = "onDatePickerCloseUp";
var MonthPicker = defineClass("DatePicker", EventAware, {
	init: function () {
		this._super();
		this._mouseoverHandler = function (e) {
			var div = e.currentTarget;
			div.style.background = "rgba(0, 0, 0, 0.9)";
			div.style.color = "#fff";
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var div = e.currentTarget;
			div.style.background = "";
			div.style.color = "";
		}.bind(this);
		this._clickHandler = function (e) {
            _stopEvent(e);
			var div = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			if (idx >= 0) {
				this._month = idx;
				this.fireEvent(MonthPicker.CLOSE_UP, this._month);
			}
			this.hide();
		}.bind(this);
		this._dom = new Dom(this.$_createPicker());
		this._container = null;
	},
	month: -1,
	show: function (containerElement, x, y) {
		var elt, r, s;
		this._container = containerElement;
		if (containerElement) {
			elt = this._dom._element;
			r = this._dom.getBounds();
			s = Dom.getScrolled();
			x = Math.max(s.sx, x - r.width - 2);
			y = Math.max(s.sy, y - r.height / 2 + 13);
			Dom.visitChildren(elt, function (parent, child) {
				child.style.background = "";
				child.style.color = "";
			});
			containerElement.appendChild(elt);
			this._dom.move(x, y);
		}
	},
	hide: function () {
		this._dom.detach();
		this._container = null;
	},
	isListing: function () {
		return this._container && this._container.contains(this._dom._element);
	},
	$_createPicker: function () {
		var element, i, div, span;
		element = Dom.createElement("div", {
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			margin: "0px",
			cursor: "default",
			zIndex: 3001,
			background: "#fff",
			border: "1px solid rgba(50, 50, 50, 0.5)",
			boxShadow: "rgba(0, 0, 0, 0.5) 1px 2px 5px",
			fontFamily: "Verdana",
			fontSize: "11px",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal"
		});
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		for (i = 1; i <= 12; i++) {
			div = Dom.createElement("div", {
				position: "relative",
				float: "none",
				paddingTop: "1px",
				paddingBottom: "1px",
				paddingLeft: "4px",
				paddingRight: "4px",
				fontFamily: "Verdana",
				fontSize: "11px",
				textAlign: "center",
				cursor: "default"
			});
			Dom.disableSelection(div);
			element.appendChild(div);
			div.onclick = this._clickHandler;
			div.onmouseup = this._clickHandler;
			div.onmouseover = this._mouseoverHandler;
			div.onmouseout = this._mouseoutHandler;
			span = Dom.createElement("span", {
                fontSize: "11px"
            });
			span.innerHTML = Dom.htmlEncode(i + " ");
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
		}
		return element;
	}
});
MonthPicker.CLOSE_UP = "onMonthPickerCloseUp";
var GridEditController = defineClass("GridEditController", null, {
    init: function (grid) {
        this._super();
        this._grid = grid;
        this._editIndex = new CellIndex();
        this._editor = null;
        this._editable = false;
        this._readOnly = false;
        this._dirty = false;
        this._starting = false;
        this._modified = false;
        this._commiting = false;
        this._canceling = false;
        this._resetting = false;
        this._defaultEditor = grid.delegate().getDefaultCellEditor();
        this._defaultEditor.setController(this);
        this._internalHideEditor(this._defaultEditor);
    },
    editIndex: function () {
        return this._editIndex.clone();
    },
    isEditing: function () {
        return this._editor && this._editor.isEditing();
    },
    reactivate: function (index) {
        if (this._grid.isValidCell(index)) {
            this._prepareEditor(index);
        }
    },
    deactivate: function () {
        this._grid.delegate().deleteCellEditors();
    },
    setFocus: function (force) {
        this.$_focusToEditor(force);
    },
    getEditable: function (index) {
        if (CellIndex.areEqual(index, this._editIndex)) {
            return this._editable;
        } else {
            return this.$_getEditable(index);
        }
        return false;
    },
    closeList: function (accept) {
        if (this._editor) {
            this._editor.closeList(accept);
        }
    },
    reprepareEditor: function (index) {
        if (CellIndex.areEqual(index, this._editIndex)) {
            if (this.isEditing()) {
                this._editor.selectAll();
            } else {
                this._prepareEditor(index);
            }
        }
    },
    invalidateEditor: function () {
        this._dirty = true;
    },
    focusedIndexChanging: function () {
        if (this.isEditing()) {
            this.closeList(true);
            return this.commitEditor();
        }
        return true;
    },
    focusedIndexChanged: function (oldIndex, newIndex, noCommit) {
        this.resetIndex();
        if (!noCommit && !CellIndex.areEqual(newIndex, this._editIndex)) {
            this._unprepareEditor();
            if (this._grid.isValidCell(newIndex)) {
                this._prepareEditor(newIndex);
            }
        }
    },
    editColumnChanged: function (column) {
        if (column && this._editor && this._editIndex && this._editIndex.dataColumn() === column) {
            var readOnly = this.$_getReadOnly(this._grid, this._editIndex);
            if (readOnly != this._readOnly) {
                if (this.isEditing()) {
                    this._editor.setReadOnly(readOnly);
                } else {
                    this._prepareEditor(this._editIndex);
                }
            }
        }
    },
    fillSearchItems: function (column, searchKey, values, labels) {
        if (this.isEditing() && this._editIndex.column === column && this._editor instanceof SearchCellEditor) {
            this._editor.fillItems(searchKey, values, labels);
        }
    },
    showEditList: function (force) {
        this.isEditing() && this._editor.showList(force);
    },
    resetIndex: function (editRow) {
        if (this.isEditing()) {
            editRow = editRow || this._grid.getEditingRow();
            this._editIndex.rowIndex = editRow.index();
            this._resetBounds();
        }
    },
    resetEditor: function (resetValue) {
        var v, index;
        if (this.isEditing()) {
            if (!this._grid.isValidCell(this._editIndex)) {
                this.hideEditor();
            } else {
                this._resetBounds();
                if (resetValue && this.isEditing()) {
                    index = this._editIndex;
                    v = this.getData(index);
                    this._resetting = true;
                    try {
                        v = grid.setEditValue(this._editor, index, v);
                        this._editor.setEditValue(v);
                        this._editor.beginEdit(false, true);
                    } finally {
                        this._resetting = false;
                    }
                }
            }
        }
    },
    showEditor: function (index) {
        var grid = this._grid;
        if (grid && grid.isValidCell(index)) {
            if (this._editor && this._editor.isEditing()) {
                grid.makeCellVisible(index);
                return true;
            }
            this._prepareEditor(index, true);
            if (this._editor && this._editable) {
                grid.makeCellVisible(index);
                return this._activateEditor(false, true);
            }
        }
        return false;
    },
    hideEditor: function () {
        if (this.isEditing()) {
            this._modified = false;
            this._resetting = true;
            try {
                this._internalHideEditor(this._editor);
                this._prepareEditor(this._editIndex);
            } finally {
                this._resetting = false;
            }
        }
        else {
            this._prepareEditor(this._editIndex);
        }
    },
    commitEditor: function (hideEditor, throwError, noAlert) {
        if (!this.isEditing() || this._commiting) {
            return true;
        }
        var v, err, editResult,
            grid = this._grid,
            options = grid.editOptions(),
            index = this._editIndex,
            column = index.dataColumn(),
            editor = this._editor,
            commit = true;
        this._commiting = true;
        try {
            editor.commit();
            if (this._modified || editor.isEdited()) {
                if (column && column.dataIndex() >= 0) {
                    try {
                        try {
                            v = editor.getEditValue(true, true);
                            if (v === CellEditor.InvalidFormat) {
                                commit = false;
                                err = options.invalidFormatMessage() || GridLocale._default.invalidInputFormat;
                                if (!noAlert && options.aletInvalidFormatError()) {
                                    _alert(err);
                                    err = null;
                                }
                            } else if (v === CellEditor.ShortLength) {
                                commit = false;
                                err = options.minLengthMessage() || GridLocale._default.minLengthRequired;
                                err = err.replace('${length}', editor.minLength());
                                if (!noAlert && options.alertMinLengthError()) {
                                    _alert(err);
                                    err = null;
                                }
                            } else if (v === CellEditor.Unselected) {
                                commit = false;
                            } else {
                                editResult = { text: editor.getEditText(), value: v };
                                grid.getEditValue(editor, index, editResult);
                                v = editResult.value;
                                commit = grid.editorCommit(editor, index, this._getData(index), v);
                            }
                        } catch (e) {
                            err = e;
                            _dtrace(e.message || e);
                            commit = false;
                        }
                        if (grid.isRowEditing()) {
                            index.rowIndex = grid.getEditingRow().index();
                            if (grid.isRowEditing(index.getRow(grid)) && commit) {
                                this.$_setData(index, v, this.$_cellEditing());
                                if (grid.isRowEditing()) {
                                    index.rowIndex = grid.getEditingRow().index();
                                    if (this._grid.isRowEditing(index.getRow(grid))) {
                                        v = this._getData(index);
                                        grid.validateCellCommit(index, v);
                                    }
                                } else {
                                    commit = false;
                                }
                            }
                        } else {
                            commit = false;
                        }
                        this._modified = false;
                    } catch (e) {
                        err = e;
                        commit = false;
                    }
                }
            }
            if (hideEditor || options.hideEditorOnFailed() || commit) {
                this._resetting = true;
                try {
                    this._internalHideEditor(editor);
                        this._prepareEditor(index);
                } finally {
                    this._resetting = false;
                }
            }
            if (err) {
                _dtrace(err.message || err);
                if (throwError) {
                    throw err;
                } else if (!noAlert) {
                    _alert((err.message || err) + ' during commit editing.');
                }
                _throwDebug(err);
            }
        } finally {
            this._commiting = false;
        }
        if (commit && this.$_cellEditing()) {
            if (!grid.itemSource().commit(index.dataField())) {
                grid.itemSource().cancel();
                return true;
            }
        }
        return commit;
    },
    cancelEditor: function (hideEditor) {
        if (!this.isEditing()) {
            return;
        }
        this._canceling = true;
        try {
            try {
                this._grid.editorCancel(this._editor, this._editIndex, this._modified);
            } catch (err) {
                throw err;
            } finally {
                this._modified = false;
            }
            this._resetting = true;
            try {
                this._internalHideEditor(this._editor);
                this._prepareEditor(this._editIndex);
            } finally {
                this._resetting = false;
            }
        } finally {
            this._canceling = false;
            this._grid.editorCanceled();
        }
        if (this._grid.editOptions().updateByCell()) {
            this._grid.itemSource().cancel();
        }
    },
    caretToLast: function () {
        this._editor && this._editor.caretToLast();
    },
    buttonClicked: function (index) {
        if (this._editor && CellIndex.areEqual(this._editIndex, index) && this._editor.hasButton()) {
            this._editor.buttonClicked(this._editIndex);
        }
    },
    getEditText: function () {
        return this.isEditing() ? this._editor.getEditText() : undefined;
    },
    _needPrepare: function (index) {
        return true;
    },
    _getData: function (index) {
        var row = index.getRow(this._grid);
        if (row) {
            if (index.column instanceof CalculatedColumn) {
                return index.column.getValue(row);
            } else if (index.column instanceof SeriesColumn) {
                return index.column.getValue(row);
            } else {
                var fld = index.column.dataIndex();
                if (fld >= 0) {
                    return row.getValue(fld);
                }
            }
        }
        return undefined;
    },
    $_setData: function (index, value, noCalc) {
        var row = index.getRow(this._grid);
        if (row) {
            var fld = index.column.dataIndex();
            if (fld >= 0) {
                this._grid.execute(new SetValueCommand(row, fld, value, index.column, noCalc));
            }
        }
    },
    $_getCellEditor: function (index) {
        var editor = this._grid.delegate().getCellEditor(index);
        editor && editor.setController(this);
        return editor;
    },
    $_getEditorOptions: function (index) {
        return this._grid.delegate().getCellEditorOptions(index);
    },
    $_focusToEditor: function (force) {
        if (force || this._grid.$_editFocused) {
            this._grid._container._setFocusAndScroll(this._editor || this._defaultEditor);
            if (!this.isEditing()) {
                this._editor && this._editor.selectAll();
            }
        }
    },
    $_focusToContainer: function () {
    },
    $_freezeEdit: function (index, editor) {
        if (editor) {
            editor.setReadOnly(this._readOnly = true);
            editor.setEditIndex(index);
            editor.setVisible(false);
            this._editorActivated(null);
            this.$_focusToEditor();
        }
    },
    $_getReadOnly: function (grid, index, style) {
        return grid.getReadOnlyAt(index.rowIndex, index.column, style);
    },
    $_getEditable: function (index) {
        var callback, v, row, rowIndex, cs,
            grid = this._grid,
            options = grid.editOptions(),
            col = index.column,
            dcol = _cast(col, DataColumn);
        if (grid.readMode() || !options.editable()) {
            return false;
        }
        row = index.getRow(grid);
        if (!row || !row.canEdit()) {
            return false;
        }
        rowIndex = row.dataIndex();
        if (rowIndex < 0 && !row.isEditing()) {
            return false;
        }
        if (!col.canEditable()) {
            return false;
        }
        if (dcol && (callback = dcol.editableCallback())) {
            if (_isBoolean(v = callback(index))) {
                return v;
            }
        }
        if (callback = options.editableCallback()) {
            if (_isBoolean(v = callback(index))) {
                return v;
            }
        }
        if (dcol && rowIndex >= 0) {
            cs = grid.getCellStyle(rowIndex, col.dataIndex());
            if (cs && _isBoolean(v = cs.editable())) {
                return v;
            }
        }
        if (!col.canEdit()) {
            return false;
        }
        if (DataRowState.isDeleted(row.dataState()) && !options.deletedRowEditable()) {
            return false;
        }
        if (grid.isFixedRowIndex(row.index()) && !options.fixedRowEditable()) {
            return false;
        }
        if (grid.isFixedColumn(col) && !options.fixedColumnEditable()) {
            return false;
        }
        return true;
    },
    $_cellEditing: function () {
        var grid = this._grid,
            options = grid.editOptions(),
            items = grid.itemSource();
        return options.updateByCell() && items.isUpdating() ||
            options.insertByCell() && (items.isInserting() || items.isAppending());
    },
    _editorActivated: function (editor) {
        this._grid.editorActivated(null);
    },
    _unprepareEditor: function () {
        if (this._editor) {
            try {
                this._editor.clear();
                this._editor.setVisible(false);
                this._editorActivated(null);
            } finally {
                this._editor.endEdit();
                this._editor = null;
                this._editable = false;
                this._readOnly = true;
                this.$_focusToEditor();
            }
        }
    },
    _prepareEditor: function (index, force) {
        var editor, column, item, itemState, rowIndex, editable, v,
            grid = this._grid,
            options = grid.editOptions();
        if (!force && !this._needPrepare(index)) {
            return;
        }
        this._dirty = false;
        if (!grid.isValidCell(index)) {
            return;
        }
        this._editIndex.assign(index);
        this._unprepareEditor();
        if (grid.readMode() && grid.isEmpty()) {
            return;
        }
        editor = this._editor = this.$_getCellEditor(index);
        if (!editor) {
            return;
        }
        this._editable = this.$_getEditable(index);
        if (!this._editable) {
            this.$_freezeEdit(index, editor);
            return;
        }
        this._readOnly = this.$_getReadOnly(grid, index);
        editor.setReadOnly(this._readOnly);
        editor.initOptions();
        editor.applyOptions(this.$_getEditorOptions(index));
        editor.setEditIndex(index);
        editor.clear();
        v = this._getData(index);
        v = grid.setEditValue(editor, index, v);
        editor.setEditValue(v);
        editor.selectAll();
        if (options.editWhenFocused()) {
            editor.setVisible(true);
            this._resetBounds();
        } else {
            editor.setVisible(false);
        }
        this.$_focusToEditor(false, true);
    },
    _resetBounds: function () {
        var r, h,
            grid = this._grid,
            editor = this._editor,
            index = this._editIndex;
        if (editor) {
            r = grid.getEditBounds(index);
            r.x--;
            r.y--;
            r.width++;
            r.height++;
            h = _int(grid.editOptions().minEditorHeight());
            if (isNaN(h)) h = 0;
            h = Math.max(r.height, h);
            if (_isIE && r.right() > grid.width() + 3) {
                editor.setBounds(r.x + 10000, r.y, 0, 0, r.scrolled);
            } else {
                editor.setBounds(r.x, r.y, r.width, h, r.scrolled);
            }
            r = grid.getEditCellBounds(index);
            editor.setCellBounds(r.x, r. y, r.width, h);
        }
    },
    _initEditor: function (bClear, bSelect) {
        if (this._dirty) {
            this._dirty = false;
            if (!this._starting) {
                this._prepareEditor(this._editIndex, true);
            }
        }
        var editor = this._editor;
        if (editor) {
            editor.endEdit();
            this._resetBounds();
            editor.setVisible(true);
            editor.beginEdit(bClear, bSelect);
            bClear && editor.clear();
            bSelect && editor.selectAll();
            editor.setFocus();
        }
    },
    $_canShowEditor: function (index) {
        /*
         if (!this.readMode() && this.isValidCell(index)) {
         index = this._tmpIndex.assign(index);
         if (index.column instanceof DataColumn) {
         var callback = index.column.editableCallback() || this._editOptions.editableCallback();
         if (callback && callback(index) === false) {
         return false;
         }
         }
         return this._fireShowEditor(index);
         }
         return false;
         */
        return this._grid.isValidCell(index) && this._grid._fireShowEditor(index);
    },
    _activateEditor: function (bClear, bSelect) {
        var grid = this._grid,
            editor = this._editor,
            index = this._editIndex,
            row = index.getRow(grid);
        if (this._editable && editor && !editor.isEditing() && this.$_canShowEditor(index)) {
            this._initEditor(bClear, bSelect);
            if (!GridRowState.isEditing(row.rowState()) && !grid.$_canUpdate(row, true)) {
                this._editor.setReadOnly(this._readOnly = true);
            }
            this._modified = false;
            this._editorActivated(this._editor);
            return true;
        }
        return false;
    },
    _internalHideEditor: function (editor) {
        this.closeList(false);
        editor.setVisible(false);
        editor.endEdit();
        this._editorActivated(null);
    },
    onEditorStart: function (editor) {
        if (!editor.visible() && !this._commiting && !this._canceling) {
            this._activateEditor(false, false);
        }
    },
    onEditorKeyDown: function (editor, keyCode, ctrl, shift, alt) {
        return this._grid.activeTool().keyDown(keyCode, ctrl, shift, alt);
    },
    onEditorKeyUp: function (editor, keyCode, ctrl, shift, alt) {
        return this._grid.activeTool().keyUp(keyCode, ctrl, shift, alt);
    },
    onEditorChange: function (editor) {
        if (!this._modified) {
            this._modified = true;
            this._grid._editorStarted(this._editor, this._editIndex);
        }
        if (this.isEditing()) {
            this._grid.makeCellVisible(this._editIndex);
            this._grid._editorChange(this._editor, this._editIndex, this._editor.getEditValue(false, false));//, this._editor.getEditText());
        }
    },
    onEditorSearch: function (editor, text) {
        this._grid._editorSearch(this._editor, this._editIndex, text);
    },
    onEditorCommit: function (editor) {
        this.commitEditor();
    }
});
var DefaultEditController = defineClass("DefaultEditController", GridEditController, {
	init: function (grid) {
		this._super(grid);
	}
});
/** @internal */
var DummyEditController = defineClass("DummyEditController", null, {
    init: function (grid) {
        this._super();
        this._grid = grid;
        this._editIndex = new CellIndex();
    },
    editIndex: function () {
        return this._editIndex.clone();
    },
    isEditing: function () {
        return false;
    },
	getEditable: function (index) {
		return false;
	},
    reactivate: function (index) {
    },
    deactivate: function () {
    },
    setFocus: function () {
        this._grid.container().setFocus();
    },
    resetEditor: function (resetValue) {
    },
    reprepareEditor: function (index) {
    },
    invalidateEditor: function () {
    },
    closeList: function () {
    },
    focusedIndexChanging: function () {
        return true;
    },
    focusedIndexChanged: function (oldIndex, newIndex) {
    },
    showEditor: function (index) {
    },
    hideEditor: function () {
    },
    commitEditor: function (hideEditor, throwError) {
        return true;
    },
    cancelEditor: function (hideEditor) {
    },
    fillSearchItems: function (column, searchKey, values, labels) {
    },
    buttonClicked: function (index) {
    },
    editColumnChanged: function (column) {
    },
    onEditorStart: function (editor) {
    },
    onEditorKeyDown: function (editor, keyCode, ctrl, shift) {
    },
    onEditorChange: function (editor) {
    },
    onEditorSearch: function (editor, text) {
    }
});
var EditRowCommand = defineClass("EditRowCommand", EditCommand, {
	init: function (grid, row) {
		this._super();
		this._grid = grid;
		this._row = row;
	},
	undo: function () {
		this._grid.cancel();
	},
	redo: function () {
	}
});
var SetValueCommand = defineClass("SetValueCommand", EditCommand, {
	init: function (row, field, value, column, noCalc) {
		this._super();
		this._row = row;
		this._field = field;
		this._value = value;
		this._column = column;
        this._noCalc = noCalc;
		this._oldValue = row.getValue(field);
	},
	undo: function () {
		this._row.setValue(this._field, this._oldValue, this._noCalc);
		this.$_focus();
	},
	redo: function () {
		this._row.setValue(this._field, this._value, this._noCalc);
		this.$_focus();
	},
	$_focus: function () {
		var col = this._column;
		var grid = col.grid();
		col && grid && grid.setFocusedColumn(col).makeColumnVisible(col);
	}
});
var GridTool = defineClass("GridTool", VisualTool, {
	init: function (owner, name) {
		this._super(owner, name);
		this._grid = owner.gridView();
		this._focusView = this._createFocusView(this._grid._dom, this._grid);
		this._innerFocusView = null;
	},
    focused: null,
	grid: function () {
        return this._grid;
    },
	focused_: function () {
		return this._grid.$_focusedIndex();
	},
	setFocused: function (value, select) {
		if (this._grid.isValidCell(value)) {
			return this._grid.setFocusedIndex(value, true, select);
		}
		return false;
	},
	layoutChanged: function () {
		this._doLayoutChanged && this._doLayoutChanged();
	},
	resetFocus: function () {
		this._resetFocusView();
	},
	focusedIndexChanged: function (oldIndex, newIndex) {
		this._doFocusedIndexChanged && this._doFocusedIndexChanged(oldIndex, newIndex); 
	},
	columnHeaderDblClicked: function (column) {
		this._grid._fireColumnHeaderDblClicked(column);
	},
    headerHeadDblClicked: function () {
        this._grid._fireHeaderHeadDblClicked();
    },
	footerCellDblClicked: function (column) {
		this._grid._fireFooterCellDblClicked(column);
	},
    footerHeadDblClicked: function () {
        this._grid._fireFooterHeadDblClicked();
    },
    headerSummaryCellDblClicked: function (column) {
        this._grid._fireHeaderSummaryCellDblClicked(column);
    },
    headerSummaryHeadDblClicked: function () {
        this._grid._fireHeaderSummaryHeadDblClicked();
    },
	checkBarFootDblClicked: function () {
		this._grid._fireCheckBarFootDblClicked();
	},
	rowIndicatorCellClick: function (index) {
		this._grid._fireRowIndicatorCellClick(index);
	},
    rowIndicatorCellClicked: function (index) {
        this._grid._fireRowIndicatorCellClicked(index);
    },
	rowIndicatorCellDblClicked: function (index) {
		this._grid._fireRowIndicatorCellDblClicked(index);
	},
	stateBarCellDblClicked: function (rowIndex) {
		this._grid._fireStateCellDblClicked(rowIndex);
	},
    checkBarCellDblClicked: function (rowIndex) {
        this._grid._fireCheckCellDblClicked(rowIndex);
    },
    checkBarHeadDblClicked: function () {
        this._grid._fireCheckBarHeadDblClicked();
    },
	rowGroupHeadCellDblClicked: function (level) {
		this._grid._fireRowGroupHeadCellDblClicked(level);
	},
	rowGroupHeaderDblClicked: function (rowIndex) {
		this._grid._fireRowGroupHeaderDblClicked(rowIndex);
	},
    rowGroupFooterCellDblClicked: function (index) {
        this._grid._fireRowGroupFooterCellDblClicked(index);
    },
	rowGroupBarDblClicked: function (index) {
		this._grid._fireRowGroupBarDblClicked(index);
	},
	panelDblClicked: function () {
		this._grid._firePanelDblClicked();
	},
	rowGroupPanelDblClicked: function (column) {
		this._grid._fireRowGroupPanelDblClicked(column);
	},
	dataCellClick: function (index) {
		this._grid._fireDataCellClick(index);
	},
	dataCellClicked: function (index) {
		this._grid._fireDataCellClicked(index);
	},
	dataCellDblClicked: function (index) {
		this._grid._fireDataCellDblClicked(index);
	},
	cellButtonClicked: function (index) {
        var menu, view, mergeView, r,
			grid = this._grid,
		    column = index.dataColumn();
		if (column) {
			switch (column.button()) {
				case CellButton.POPUP:
					menu = column.$_getMenu(index);
					if (menu) {
						view = _cast(grid.getCellView(null, index), CellElement);
						if (view) {
							grid.showPopupMenu(index.clone(), menu, view);
						} else {
							mergeView = column.fixed() ? grid.fixedMergeView() : grid.mergeView();
							view = mergeView && mergeView.getCellView(index);
							if (view) {
								r = view.boundsByContainer();
								r.y = grid.lm().itemBounds(index.rowIndex - grid.topIndex()).bottom() + grid.bodyView().y();
								grid.showPopupMenuAt(index.clone(), menu, r.x, r.y, r.width);
							}
						}
					}
					break;
				case CellButton.ACTION:
					grid._doCellButtonClicked(index, -1);
					break;
			}
		}
	},
    customCellButtonClicked: function (index, button) {
        if (!index.column.$_buttonClicked(index, button)) {
            this._grid._doCellButtonClicked(index, button);
        }
    },
	editorButtonClicked: function (index) {
		this._grid._fireEditorButtonClicked(index);
	},
	dataButtonClicked: function (index) {
		this._grid._fireDataButtonClicked(index);
	},
    getFocusRect: function () {
        return this._focusView.visible() ? this._focusView.bounds() : null;
    },
	rowEditStarted: function (row) {
	},
	rowEditEnded: function (row, canceled) {
	},
    _createFocusView: function (dom, grid) {
        return new FocusView(dom, grid);
    },
    _doSetFocus: function () {
        this._grid.editController().setFocus(true);
    },
	_resetFocusView: function () {
		var cell, cell2, r1, r2, lm, fixed, editing, r,
            grid = this._grid,
			root = grid._rootElement,
		    index = this.focused(),
		    vis = false,
		    inner = false;
		if (grid.displayOptions().focusVisible() && grid.isValidCell(index)) {
			cell = grid.getFocusedCellView(index);
			if (cell) {
                lm = grid.lm();
                fixed = lm.fixedColCount();
                editing = grid.isEditing();
                r = cell.boundsBy(root);
				if (cell instanceof RowGroupFooterElement) {
                    if (!cell.fixed() && fixed) {
                        /*if (grid._rowGroupView.visible()) {
                            cell2 = grid.getCellView(grid._rowGroupView, index, true);
                        } else*/ if (grid._bandedGroupView.visible()) {
                            cell2 = grid.getCellView(grid._bandedGroupView, index, true);
                        }
                        if (cell2) {
                            r2 = cell2.boundsBy(root);
                            r.setLeft(r2.x);
                        } else {
                            if ($_debug) debugger;
                        }
                    } else if (cell.fixed()) {
                        /*if (grid._rowGroupView.visible()) {
                            cell2 = grid.getCellView(grid._rowGroupView, index, false);
                        } else*/ if (grid._bandedGroupView.visible()) {
                            cell2 = grid.getCellView(grid._bandedGroupView, index, false);
                        }
                        if (cell2) {
                            r2 = cell2.boundsBy(root);
                            r.setRight(r2.right());
                        } else {
                            if ($_debug) debugger;
                        }
                    }
                }
                if (cell instanceof MergedFooterElement && fixed) {
                    r.setRight(lm.bodyBounds().right());
                    if (!cell.fixed()) {
                        r.x = lm.fixedBounds().right();
                    }
                }
				if (r.width > 0 && r.height > 0) {
					if (grid._container.$_rich) {
						r.x++;
						r.y++;
					}
					this._focusView.setRect(r);
					vis = true;
					if (cell instanceof MergedDataCellElement || cell instanceof MergedSeriesCellElement) {
                        cell.setInnerIndex(index.rowIndex - cell.mergeRoom().headItem());
                        if (cell.canEditable()) {
                            if (!this._innerFocusView) {
                                this._innerFocusView = new InnerFocusView(grid._dom, grid);
                                grid.addFocusElement(this._innerFocusView);
                            }
                            r1 = lm.itemBounds(cell._topIndex);
                            r2 = lm.itemBounds(index.rowIndex - grid.topIndex());
                            r.y += r2.y - r1.y;
                            r.height = r2.height;
                            !editing && r.setBy(2, 2, -5, -5);
                            this._innerFocusView.setRect(r);
                            this._innerFocusView.setEditing(editing, cell.getButtonWidth ? cell.getButtonWidth() : 0);
                            inner = true;
                        }
					}
					if (inner) {
						this._focusView.setEditing(false, 0);
					} else {
						this._focusView.setEditing(editing, cell.getButtonWidth ? cell.getButtonWidth() : 0);
					}
                    grid._resetFocusMask();
				}
			}
		}
		this._focusView.setVisible(vis);
		this._innerFocusView && this._innerFocusView.setVisible(inner);
	},
	$_updateHoverView: function (grid, rowView, cellView) {
		var r, lm, ms, tr,
			root = grid._rootElement,
            model = grid.displayOptions().rowHoverMask(),
		    hv = this._rowHoverView;
		this._rowHoverPos = rowView.y();
		hv.updateElement(model);
		hv.$_cellView = cellView;
		if (hv.visible()) {
			r = rowView.boundsBy(root);
            lm = grid.lm();
            ms = lm.checkBarBounds().x;
			switch (model.extent()) {
				case RowHoverMaskExtent.CHECK_AND_FILL:
					r.x = lm.checkBarBounds().x;
					r.setRight(lm.nonfixedBounds().right());
					break;
				case RowHoverMaskExtent.DATA:
					r.x = lm.checkBarBounds().right();
					r.setRight(Math.min(lm.nonfixedBounds().right(), lm.bodyBounds().right()));
					break;
				case RowHoverMaskExtent.FILL:
					r.x = lm.checkBarBounds().right();
					r.setRight(lm.nonfixedBounds().right());
					break;
				case RowHoverMaskExtent.INDICATOR_AND_DATA:
					r.x = lm.rowIndicatorBounds().x;
					r.setRight(Math.min(lm.nonfixedBounds().right(), lm.bodyBounds().right()));
					ms = lm.rowIndicatorBounds().x;
					break;
				case RowHoverMaskExtent.INDICATOR_AND_FILL:
					r.x = lm.rowIndicatorBounds().x;
					r.setRight(lm.nonfixedBounds().right());
					ms = lm.rowIndicatorBounds().x;
					break;
				case RowHoverMaskExtent.CELL:
					if (cellView instanceof DataCellElement) {
						r = cellView.boundsBy(root);
						break;
					}
				default:
					r.x = lm.checkBarBounds().x;
					r.setRight(Math.min(lm.nonfixedBounds().right(), lm.bodyBounds().right()));
					break;
			}
			hv.setRectI(r);
			tr = grid._bodyView.getBounds();
			tr.x = 0;
			tr.width = Math.min(r.width, lm.gridBounds().right() - ms);
			tr.y = 0;
			tr.height = Math.min(r.height, grid.lm().gridBounds().bottom() - hv.y());
			if (grid._dom) {
				hv._css.clip = Dom.getClipRect(tr);
			} else {
				hv._mask = tr;
			}
			hv.invalidate();
		}
	},
	_resetHoverView: function () {
		var y, rowView, hv = this._rowHoverView;
		if (hv && hv.visible()) {
			y = this._rowHoverPos;
			rowView = this._grid.bodyView().findRowViewAt(this._rowHoverPos);
            if (rowView) {
				this.$_updateHoverView(this._grid, rowView, hv.$_cellView);
				this._rowHoverPos = y;
			} else {
				hv.setVisible(false);
			}
		}
	},
	_checkCellClicked: function (cell, x, y) {
        var checkBar, p,
		    grid = this._grid,
		    row = cell.item();
		if (grid.editOptions().checkable()) {
			checkBar = grid.checkBar();
			if ((grid.isCheckable(row) || !checkBar.checkableOnly()) && (checkBar.showGroup() || row.dataIndex() >= 0)) {
				p = cell.containerToElement(x, y);
				if (cell.checkableAt(p.x, p.y)) {
					grid.makeRowVisible(row.index());
					grid.setChecked(row, !grid.isChecked(row), checkBar.exclusive());
				}
			}
		}
		grid._fireCheckCellClicked(row.index());
	},
	_checkAllClicked: function (cell, x, y) {
		var p,
            grid = this._grid,
			options = grid.editOptions(),
		    cb = grid.checkBar();
		if (!grid.isEmpty() && options.checkable() && cb.showAll() && !cb.exclusive()) {
			p = cell.containerToElement(x, y);
			if (cell.checkableAt(p.x, p.y) && grid._fireAllCheck(!cell.checked())) {
				cell.setChecked(!cell.checked());
				grid.checkAll(cell.checked(), cb.visibleOnly(), cb.checkableOnly(), cb.$_getCheckAllCallback(), options.rowEventsWhenCheckAll());
			}
		}
		grid._fireCheckBarHeadClicked();
	}
});
var GridRowHoverElement = defineClass("GridRowHoverElement", LayerElement, {
    init: function (dom) {
        this._super(dom, "rowHoverView");
    },
    background: null,
    border: null,
    updateElement: function (model) {
        this.setVisible(model.visible());
        this.setBackground(model.styles().background());
        this.setBorder(model.styles().border());
    },
    _doDraw: function(g, needOpaque) {
        g.drawBoundsI(this._background, this._border, 0, 0, this.width(), this.height());
    },
    _doDrawHtml: function () {
        this._dom.style.background = this._background ? this._background.css() : '';
    }
});
var GridEditTool = defineClass("GridEditTool", GridTool, {
    init: function (owner, name) {
        this._super(owner, name);
        this._clickElement = null;
        this._clickHandle = null;
        this._clickCell = null;
    },
    _doEnter: function (grid, options, focused, ctrl, shift) {
        var index, skp, noSelect, sel,
            editing = grid.isEditing();
        if (editing && !options.enterToTab()) {
            return grid.commitEditor();
        } else {
            index = focused.clone();
            skip = options.skipReadOnly();
            noSelect = false;
            if (options.enterToEdit()) {
                if (grid.isValidCell(index) && (!editing && index && index.column.canEditable()/* && !this.$_checkReadOnly(index)*/)) {
                    grid.$_showEditor(focused);
                }
            } else {
                if (!grid.isValidCell(index)) {
                    index.normalize(grid);
                } else if (options.enterToNextRow()) {
                    if (index.rowIndex < grid.rowCount() - 1) {
                        index.down();
                    } else if (index.rowIndex == grid.rowCount() - 1 && index.isBottomColumn()) {
                        switch (index.getRow(grid).rowState()) {
                            case GridRowState.INSERTING:
                                if (!grid.commit(options.forceInsert())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.APPENDING:
                                if (!grid.commit(options.forceAppend())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.UPDATING:
                                if (!grid.commit(options.commitWhenNoEdit())) {
                                    grid.cancel(true);
                                }
                                return true;
                        }
                        grid.append();
                    }
                } else if (options.enterToTab()) {
                    sel = grid.getSelection();
                    if (shift) {
                        if (options.moveInSelection() && sel && !sel.isSingleCell() && sel.contains(index)) {
                            index = sel.getBounds().moveToPrev(index);
                            noSelect = true;
                        } else {
                            if (options.crossWhenExitFirst() && index.isFirstColumn() && index.rowIndex > 0) {
                                index.up();
                                index.end();
                            } else {
                                index.prev();
                            }
                        }
                        if (options.skipReadOnly() && !this.$_skipReadOnly(index, -1)) {
                            index.assign(focused);
                        }
                    } else if (options.moveInSelection() && sel && !sel.isSingleCell() && sel.contains(index)) {
                        index = sel.getBounds().moveToNext(index);
                        noSelect = true;
                        if (skip && !this.$_skipReadOnly(index, 1)) {
                            index.assign(focused);
                        }
                    } else {
                        if (index.isLastColumn()) {
                            if (options.commitOnLastCell() && grid.isRowEditing()) {
                                grid.commit(options.commitWhenNoEdit());
                            } else if (index.rowIndex == grid.rowCount() - 1) {
                                if (options.appendWhenExitLast()) {
                                    grid.append(true);
                                    if (grid.isRowEditing()) {
                                        index.down();
                                        index.home();
                                    }
                                } else if (options.hideOnLastCell()) {
                                    return grid.commitEditor();
                                }
                            } else if (options.crossWhenExitLast()) {
                                index.down();
                                index.home();
                                skip && this.$_skipReadOnly(index, 1);
                            } else if (options.hideOnLastCell()) {
                                return grid.commitEditor();
                            }
                        } else {//if (editing || this.$_checkReadOnly(index)) {
                            if (editing) {
                                if (!grid.commitEditor()) {
                                    return false;
                                }
                            }
                            index.next();
                            if (skip && !this.$_skipReadOnly(index, 1)) {
                                index.assign(focused);
                            }
                        } /*else {
                            index.next();
                            if (skip && !this.$_skipReadOnly(index, 1)) {
                                index.assign(focused);
                            }
                        }*/
                    }
                    /*
                     if (options.crossWhenExitLast() && index.isLastColumn() && index.rowIndex < grid.rowCount() - 1) {
                     index.down();
                     index.home();
                     skip && this.$_skipReadOnly(index, 1);
                     } else if (options.commitWhenExitLast() && index.isLastColumn()) {
                     grid.commit(options.commitWhenNoEdit());
                     if (options.appendWhenExitLast()) {
                     grid.append();
                     if (grid.isRowEditing()) {
                     index.down();
                     index.home();
                     }
                     }
                     } else if (editing || this.$_checkReadOnly(index)) {
                     if (editing) {
                     grid.commitEditor();
                     }
                     index.next();
                     if (skip && !this.$_skipReadOnly(index, 1)) {
                     index.assign(focused);
                     }
                     } else {
                     index.next();
                     if (skip && !this.$_skipReadOnly(index, 1)) {
                     index.assign(focused);
                     }
                     }
                     */
                }
            }
            if (!CellIndex.areEqual(index, focused)) {
                this.setFocused(index, !noSelect);
            }
        }
        return true;
    },
    $_checkReadOnly: function (index) {
        return this.grid().isReadOnlyCell(index);
    },
    $_skipReadOnly: function (index, dx) {
        var idx, s, start,
            moved = false,
            grid = this._grid,
            selection = grid.getSelection();
        if (grid.editOptions().skipReadOnly()) {
            idx = this._skipIndex;
            idx.assign(index);
            moved = !this.$_checkReadOnly(idx);
            if (!moved) {
                s = selection && !selection.isSingleCell() && selection.contains(idx);
                start = idx.clone();
                if (s) {
                    if (dx > 0) {
                        while (selection.getBounds().moveToNext(idx) && !CellIndex.areEqual(idx, start)) {
                            if (!this.$_checkReadOnly(idx)) {
                                index.assign(idx);
                                moved = true;
                                break;
                            }
                        }
                    } else {
                        while (selection.getBounds().moveToPrev(idx) && !CellIndex.areEqual(idx, start)) {
                            if (!this.$_checkReadOnly(idx)) {
                                index.assign(idx);
                                moved = true;
                                break;
                            }
                        }
                    }
                } else {
                    if (dx > 0) {
                        while (idx.next()) {
                            if (!this.$_checkReadOnly(idx)) {
                                index.assign(idx);
                                moved = true;
                                break;
                            }
                        }
                    } else {
                        while (idx.prev()) {
                            if (!this.$_checkReadOnly(idx)) {
                                index.assign(idx);
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return moved;
    },
    $_skipReadOnlyCell: function (index, dx) {
    }
});
var GridSelectionTool = defineClass("GridSelectionTool", GridEditTool, {
	init: function (owner, name) {
		this._super(owner, name || "selectionTool");
		this._clickPos = Point.empty();
		this._tmpIndex = new CellIndex();
		this._skipIndex = new CellIndex();
		this._tipCell = null;
		this._tipOptions = new ToolTipOptions();
        this._scrollTool = new GridScrollTool();
		this._rightClicked = null;
        this._keySelecting = false;
        this._rowHoverView = new GridRowHoverElement(this._grid._dom);
        this._rowHoverPos = -1;
        this._tipCloseCallback = function () {
            this._tipCell = null;
        }.bind(this);
	},
	hoveredCell: null,
	setHoveredCell: function (value) {
        var index, dcol, renderer, s, cb, cr,
            grid = this._grid,
			options = grid.displayOptions(),
			tips = this._tipOptions,
            cell = value;
        if (value != this._hoveredCell) {
            if (this._hoveredCell) {
				this._hoveredCell.setMouseEntered(false);
            }
            this._hoveredCell = value;
            if (this._hoveredCell) {
                this._hoveredCell.setMouseEntered(true);
            }
            /*
                var r = this._hoveredCell.parent().boundsBy(this._grid);
                this._rowHoverView.setRectI(r);
                this._grid.addFeedbackElement(this._rowHoverView);
                this._rowHoverView.invalidate();
                console.log('@@@@@@@@@@@@@ ADD');
			} else {
                this._grid.removeFeedbackElement(this._rowHoverView);
                console.log('@@@@@@@@@@@@@ REM');
            }
            */
		}
        if (cell && grid.canHovering()) {
            index = cell.index();
            if (cell instanceof DataCellElement) {
                dcol = index.valueColumn();
                if (dcol) {
                    if (cb = options._cursorCallback) {
                        cr = cb(index);
                    }
                    if (!cr) {
                        cr = dcol.cursor();
                    }
                    cr && grid.container().setCursor(cr);
                }
            }
            if (options.showTooltip()) {
                if (cell instanceof HeaderCellElement) {
                    cb = grid.header().tooltipCallback();
                    if (_isFunction(cb)) {
                        s = cb(index.column);
                    }
                } else if (cell instanceof FooterCellElement) {
                    cb = grid.footer().tooltipCallback();
                    if (_isFunction(cb)) {
                        s = cb(index.column, cell.value());
                    }
                } else if (cell instanceof SummaryCellElement) {
                    cb = grid.header().summary().tooltipCallback();
                    if (_isFunction(cb)) {
                        s = cb(index.column, cell.value());
                    }
                }
                if (!s && cell instanceof ValueCellElement) {
                    if (cell instanceof DataCellElement) {
                        dcol = index.dataColumn();
                        if (dcol && grid.isRowEditing(index.getRow(grid)) && grid.editOptions().hintOnError() && dcol.error()) {
                            s = dcol.error().message || dcol.error();
                        } else {
                            renderer = cell.renderer();
                            if (renderer) {
                                s = renderer.getTooltip(cell);
                            }
                        }
                    }
                    if (!s) {
                        dcol = index.valueColumn();
                        cb = dcol && (dcol.tooltipCallback() || grid.body().tooltipCallback());
                        if (_isFunction(cb)) {
                            s = cb(index);
                        }
                    }
                }
                if (s) {
                    tips.setLineBreak(options.tooltipLineBreak())
                        .setMaxWidth(options.tooltipMaxWidth())
                        .setMinWidth(options.tooltipMinWidth())
                        .setDelay(options.tooltipDelay())
                        .setDuration(options.tooltipDuration())
                        .setStyles(options.tooltipStyles())
                        .setAnimation(options.tooltipAnimation())
                        .setMessage(_toStr(s));
                    this._showTooltip(cell, tips);
                }
            }
            if (!s) {
                this._hideTooltip();
            }
        } else {
            !options.tooltipAnimation() && this._hideTooltip();
        }
	},
    isEditing: function () {
        return this._grid.isEditing();
    },
	_doActivate: function () {
		this._super();
		this._grid.addFocusElement(this._focusView);
        this._innerFocusView && this._grid.addFocusElement(this._innerFocusView);
        this._grid.addFeedbackElement(this._rowHoverView);
	},
	_doDeactivate: function () {
        this._grid.removeFeedbackElement(this._rowHoverView);
		this._grid.removeFocusElement(this._focusView);
        this._innerFocusView && this._grid.removeFocusElement(this._innerFocusView);
		this._super();
	},
	_doCancel: function (grid) {
        if (this._dragTracker && this._dragTracker.cancelable()) {
            this._dragTracker.cancel();
            grid.refreshView();
        } else {
            grid.closeFilterSelector();
            if (grid.isEditing()) {
                grid.cancelEditor(true);
            } else {
                grid.cancel();
            }
        }
	},
	_doTab: function (grid, options, focused, ctrl, shift) {
		var sel, noSelect,
            index = focused.clone(),
            editing = grid.isEditing(),
            skip = options.skipReadOnly();
		if (!grid.isValidCell(index)) {
			index.normalize(grid);
			this.$_skipReadOnly(index, 1);
		} else if (options.useTabKey()) {
			sel = grid.getSelection();
			noSelect = false;
			if (shift) {
				if (options.moveInSelection() && sel && !sel.isSingleCell() && sel.contains(index)) {
					index = sel.getBounds().moveToPrev(index);
					noSelect = true;
				} else {
					if (options.crossWhenExitFirst() && index.isFirstColumn() && index.rowIndex > 0) {
                        index.up();
                        index.end();
					} else {
						index.prev();
					}
				}
                if (options.skipReadOnly() && !this.$_skipReadOnly(index, -1)) {
                    index.assign(focused);
                }
            } else if (options.moveInSelection() && sel && !sel.isSingleCell() && sel.contains(index)) {
				index = sel.getBounds().moveToNext(index);
				noSelect = true;
				if (skip && !this.$_skipReadOnly(index, 1)) {
					index.assign(focused);
				}
			} else {
                if (index.isLastColumn()) {
					if (options.commitOnLastCell() && grid.isRowEditing()) {
						grid.commit(options.commitWhenNoEdit());
					} else if (index.rowIndex == grid.rowCount() - 1) {
                        if (options.appendWhenExitLast()) {
                            grid.append(true);
                            if (grid.isRowEditing()) {
                                index.down();
                                index.home();
                            }
                        } else if (options.hideOnLastCell()) {
                            return grid.commitEditor();
                        }
                    } else if (options.crossWhenExitLast()) {
                        index.down();
                        index.home();
                        skip && this.$_skipReadOnly(index, 1);
                    } else if (options.hideOnLastCell()) {
                        return grid.commitEditor();
                    }
                } else {//if (editing || this.$_checkReadOnly(index)) {
                    if (editing) {
                        if (!grid.commitEditor()) {
                            return false;
                        }
                    }
                    index.next();
                    if (skip && !this.$_skipReadOnly(index, 1)) {
                        index.assign(focused);
                    }
                }/* else {
                    index.next();
                    if (skip && !this.$_skipReadOnly(index, 1)) {
                        index.assign(focused);
                    }
                }*/
                /*
                if (options.crossWhenExitLast() && index.isLastColumn() && index.rowIndex < grid.rowCount() - 1) {
                    index.down();
                    index.home();
                } else if (options.commitWhenExitLast() && index.isLastColumn()) {
                    grid.commit(options.commitWhenNoEdit());
                    if (options.appendWhenExitLast()) {
                        grid.append();
                        if (grid.isRowEditing()) {
                            index.down();
                            index.home();
                        }
                    }
                } else {
                    index.next();
                }
                if (options.skipReadOnly() && !this.$_skipReadOnly(index, 1)) {
                    index.assign(focused);
                }
                */
            }
			if (!CellIndex.areEqual(index, focused)) {
				this.setFocused(index, !noSelect);
			}
			return true;
		}
		return false;
	},
	_doKeyDown: function (key, ctrl, shift, alt) {
		var grid = this.grid();
		if (grid.popupShowing()) {
			return false;
		}
		var item, itemCount, rowView, editing, selecting, keep, col, row, mergeCell, room,
			lm = grid.lm(),
			options = grid.editOptions(),
        	sm = grid.selections(),
			skip = options.skipReadOnly(),
			focused = this.focused(),
			index = focused.clone(),
            editing = grid.isEditing(),
			isMac = false,
        	appending = false;
		if (!grid._fireKeyDown(key, ctrl, shift, alt)) {
            return true;
        }
        this._keySelecting = false;
		if (DataCellRenderer.consumeKey(index, key, ctrl, shift)) {
			return true;
		}
        grid.closeFilterSelector();
		mergeCell = grid.$_getMergeCell(index);
		room = mergeCell && mergeCell.mergeRoom ? mergeCell.mergeRoom() : null;
		if (key == Keys.ESCAPE) {
			grid.closePopups();
			this._doCancel(grid);
		} else if (key == Keys.ENTER) {
			return this._doEnter(grid, options, index, ctrl, shift);
		} else if (key == Keys.TAB) {
			return this._doTab(grid, options, index, ctrl, shift);
		} else if (key == Keys.F2) {
			if (!grid.isEditing() && index && index.column.canEditable()) {
				grid.$_showEditor(index, shift);
			}
		} else if (key == Keys.QUOT && options.useCopyKey() && !grid.isEditing() && grid.isRowEditing()) {
			if (!this.$_checkReadOnly(index) && grid.copyCellValue(index)) {
				index.next();
				skip && !this.$_skipReadOnly(index, 1);
				this.setFocused(index, true);
			}
		} else if (key == Keys.Z && ctrl && options.undoable()) {
			return grid.undo();
		} else if (key == Keys.Y && ctrl && options.undoable()) {
			return grid.redo();
		} else if (key == Keys.INSERT || (_isMac && ctrl && alt && key == Keys.I)) {
            if (options.appendWhenInsertKey() || grid.rowCount() == 0) {
                grid.append();
            } else {
                grid.insert(shift, ctrl);
            }
		} else if (key == Keys.DELETE || (_isMac && ctrl && alt && key == Keys.D)) {
            if (ctrl && shift) {
                grid.revertSelection();
                return true;
            } else if (ctrl) {
				grid.deleteSelection();
				return true;
			} else if (options.erasable()) {
                grid.eraseSelection();
                return true;
            }
			return false;
		} else if (key == Keys.BACK) {
			return false;
		} else if (_included(key, Keys.HOME, Keys.END, Keys.RIGHT, Keys.LEFT, Keys.DOWN, Keys.UP, Keys.PAGEDOWN, Keys.PAGEUP)) {
			itemCount = grid.rowCount();
			if (key == Keys.DOWN && itemCount == 0) {
				grid.append();
				return;
			}
			if (!grid.isValidCell(index)) {
				index.normalize(grid);
				this.setFocused(index, true);
				return true;
			}
			if ((_included(key, Keys.DOWN, Keys.PAGEDOWN) || (key == Keys.END && ctrl)) && index.isBottomColumn() && this.$_checkAppending(index, true)) {
				return true;
			}
			if ((_included(key, Keys.UP, Keys.PAGEUP) || (key == Keys.HOME && ctrl)) && index.isTopColumn() && this.$_checkAppending(index, true)) {
				return true;
			}
            rowView = grid.bodyView().findRowView(index.rowIndex);
            editing = grid.isEditing();
            selecting = shift && grid.selections().count() > 0;
            keep = options.keepFocusedWhenSelecting();
			switch (key) {
                case Keys.HOME:
                    if (!editing && selecting && keep) {
                        if (ctrl) {
                            sm.getItem(0).getAnchor(index).firstRow(grid);
                        } else {
                            sm.getItem(0).getAnchor(index).home();
                        }
                    } else if (ctrl) {
                        index.firstRow(grid);
                    } else {
                        index.home();
                        this.$_skipReadOnly(index, 1);
                    }
                    break;
                case Keys.END:
                    if (!editing && selecting && keep) {
                        if (ctrl) {
                            sm.getItem(0).getAnchor(index).lastRow(grid);
                        } else {
                            sm.getItem(0).getAnchor(index).end();
                        }
                    } else if (ctrl) {
                        index.lastRow(grid);
                    } else {
                        index.end();
                        this.$_skipReadOnly(index, -1);
                    }
                    break;
                case Keys.RIGHT:
                    row = grid.getRow(index.rowIndex);
                    if (!editing && selecting && keep) {
                        sm.getItem(0).getAnchor(index).right();
                    } else if (row instanceof MergedGroupHeader) {
                        index.down();
                    } else if (!row.isEditing() && row instanceof GroupRow && row.dataIndex() < 0) { // treeRow가 해당되지 않도록
                        if (/*ctrl &&*/ row.collapsed()) {
                            grid.expand(row, false, false);
                        } else {
                            index.down();
                        }
                    } else if (!row.isEditing() && row.dataIndex() < 0) { // !(row instanceof DataRow)) { // footer
                        index.down();
                    } else {
                        index.right();
                        if (skip && this.$_checkReadOnly(index)) {
                            if (!this.$_skipReadOnly(index, 1)) {
                                index.assign(focused);
                                break;
                            }
                        }
                    }
                    break;
                case Keys.LEFT:
                    row = grid.getRow(index.rowIndex);
                    if (!editing && selecting && keep) {
                        sm.getItem(0).getAnchor(index).left();
                    } else if (row instanceof MergedGroupHeader) {
                        col = row.level() - 1;
                        if (col >= 0 && col < grid.visibleColumnCount()) {
                            index.column = grid.getVisibleColumn(col);
                        } else {
                            index.up();
                        }
                    } else if (!row.isEditing() && row instanceof GroupRow && row.dataIndex() < 0) {
                        if (row.expanded()) {
                            grid.collapse(row, false);
                        } else {
                            index.up();
                        }
                    } else if (!row.isEditing() && index.isFirstColumn()) {
                        if (!(row.parent() instanceof RootRow)) {
                            index.setRow(row.parent());
                        }
                    } else if (!row.isEditing() && row.dataIndex() < 0) { // !(row instanceof DataRow)) { // footer
                        index.up();
                    } else {
                        index.left();
                        if (skip && this.$_checkReadOnly(index)) {
                            if (!this.$_skipReadOnly(index, -1)) {
                                index.assign(focused);
                                break;
                            }
                        }
                    }
                    break;
                case Keys.DOWN:
                    if (!editing && selecting && keep) {
						if (alt && room) {
							sm.getItem(0).getAnchor(index).rowIndex += Math.min(grid.rowCount() - 1, room.tailItem() + 1);
						} else if (ctrl && isMac) {
							sm.getItem(0).getAnchor(index).last();
						} else {
							sm.getItem(0).getAnchor(index).down();
						}
					} else if (ctrl) {
						grid.setTopIndex(grid.topIndex() + 1);
						return true;
                    } else if (index.rowIndex == grid.rowCount() - 1 && index.isBottomColumn()) {
                        switch (index.getRow(grid).rowState()) {
                            case GridRowState.INSERTING:
                                if (!grid.commit(options.forceInsert())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.APPENDING:
                                if (!grid.commit(options.forceAppend())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.UPDATING:
                                if (!grid.commit(options.commitWhenNoEdit())) {
                                    grid.cancel(true);
                                }
                                return true;
                        }
                        grid.append();
                        appending = true;
                        if (ctrl && isMac) {
                            index.last();
                        } else {
                            index.down();
                        }
                    } else {
						if (alt && room) {
							index.rowIndex = Math.min(grid.rowCount() - 1, room.tailItem() + 1);
						} else if (ctrl && isMac) {
                            index.last();
                        } else {
                            index.down();
                        }
                    }
                    break;
                case Keys.UP:
                    if (!editing && selecting && keep) {
                        if (ctrl && isMac) {
                            sm.getItem(0).getAnchor(index).first();
                        } else {
                            sm.getItem(0).getAnchor(index).up();
                        }
					} else if (ctrl) {
						grid.setTopIndex(grid.topIndex() - 1);
						return true;
                    } else if (index.rowIndex == 0 && index.isTopColumn()) {
                        switch (index.getRow(grid).rowState()) {
                            case GridRowState.INSERTING:
                                if (!grid.commit(options.forceInsert())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.APPENDING:
                                if (!grid.commit(options.forceAppend())) {
                                    grid.cancel(true);
                                }
                                return true;
                            case GridRowState.UPDATING:
                                if (!grid.commit(options.commitWhenNoEdit())) {
                                    grid.cancel(true);
                                }
                                return true;
                        }
                        if (ctrl && isMac) {
                            index.first();
                        } else {
                            index.up();
                        }
                    } else {
						if (alt && room) {
							index.rowIndex = Math.max(0, room.headItem() - 1);
						} else if (ctrl && isMac) {
                            index.first();
                        } else {
                            index.up();
                        }
                    }
                    break;
                case Keys.PAGEUP:
                    if (!editing && selecting && keep) {
                        sm.getItem(0).getAnchor(index).incRow(grid, -lm.fullItemCount());
                    } else {
                        index.incRow(grid, -lm.fullItemCount());
                    }
                    break;
                case Keys.PAGEDOWN:
                    if (!editing && selecting && keep) {
                        sm.getItem(0).getAnchor(index).incRow(grid, lm.fullItemCount());
                    } else if (index.rowIndex == grid.rowCount() - 1 && index.isBottomColumn()) {
                        if (GridRowState.isInserting(index.getRow(grid).rowState())) {
                            if (grid.commit(options.forceAppend())) {
                            }
                            return true;
                        }
                    } else {
                        index.incRow(grid, lm.fullItemCount());
                    }
                    break;
            }
            if (selecting) {
                if (!SelectionStyle.isSingle(grid.displayOptions().selectStyle())) {
                    if (keep) {
                        grid.makeCellVisible(index);
                    } else {
                        this.setFocused(index, false);
                    }
                    sm.getItem(0).resizeTo(index);
                    this._keySelecting = true;
                }
            } else {
                this.setFocused(index, true);
            }
			return true;
		} else if (key == Keys["0"] && ctrl) {
			if (grid.$_restoreEditValue()) {
				return true;
			}
		}
		return false;
	},
    _doKeyUp: function (key, ctrl, shift) {
        var item, grid = this._grid;
        this._super(key, ctrl, shift);
        if (this._keySelecting) {
            this._keySelecting = false;
            item = grid.getSelection();
            item && grid._fireSelectionEnded(item);
        }
    },
    _doClick: function (x, y) {
		if (this.isDragging()) { // || isScrollBar(event)) {
			return false;
		}
		var elt, cellView,
            grid = this._grid,
		    index = this.focused();
		if (index) {
			elt = this.findElementAt(x, y, true);
			if (elt) {
				cellView = _cast(elt, CellElement) || elt.getParentAs(CellElement);
			}
			if (this._clickElement === elt) {
                if (cellView && cellView.isDataCell()) {
                    if (elt instanceof DataCellElement) {
                        index = elt.innerCellIndex();
                    }
					this.dataCellClicked(index);
					if (!grid.isEditing()) {
						if (this._reclickCell) {
							this._performRendererClick(index, this._reclickCell, x, y, false, false);
						} else {
							this._performRendererClick(index, elt, x, y, false, true);
						}
					}
				} else if (elt instanceof IndicatorCellElement) {
					this.rowIndicatorCellClicked(elt.index().rowIndex);
				} else if (elt instanceof CellMenuElement) {
                    var owner = elt.owner();
                    if (owner instanceof HeaderHeadElement) {
                        grid.showPopupMenu(grid.header().head(), grid.header().head().popupMenuName(), owner, 4, -4);
                    } else if (owner instanceof FooterHeadElement) {
                        grid.showPopupMenu(grid.footer().head(), grid.footer().head().popupMenuName(), owner, 4, -4);
                    } else if (owner instanceof HeaderSummaryHeadElement) {
                        grid.showPopupMenu(grid.header().summary().head(), grid.header().summary().head().popupMenuName(), owner, 4, -4);
                    } else if (owner instanceof GroupPanelHeadElement) {
						grid.showPopupMenu(grid.rowGroup(), grid.rowGroup().getPopupMenu(), elt, 4, -4);
					}
                } else if (elt instanceof ColumnMenuHandle) {
                    grid.showPopupMenu(elt.column().header(), elt.column().header().popupMenuName(), elt, 4, -4);
                }
			}
		}
	},
    $_calcInnerIndex: function (cell, index, x, y) {
        if (cell instanceof MergedDataCellElement || cell instanceof MergedSeriesCellElement) {
            var r = cell.$_calcInnerIndex(this._grid, x, y);
            if (r >= 0) {
                index.rowIndex = r;
            }
        }
    },
	_doDblClick: function (x, y) {
		if (this.isDragging()) {
			return false;
		}
		var cellView, request, groupItem,
            grid = this._grid,
			index = this.focused(),
			clickCell = this._clickCell,
			clickIndex = clickCell ? clickCell.index() : null,
			elt = this.findElementAt(x, y, true);
		if (elt && elt === this._clickElement) {
			cellView = _cast(elt, CellElement) || elt.getParentAs(CellElement);
			request = this._getEditRequest(elt, x, y, false, false);
			if (request instanceof RowResizeRequest) {
				grid.fitRowHeight(request.rowIndex());
			} else if (request instanceof ColumnResizeRequest) {
				grid.lm().fitColumnWidth(request.cell().index().column, 0, 0, false, grid.displayOptions().includeHeaderWhenFitColumn());
			} else if (cellView && cellView.isDataCell()) {
				this.dataCellDblClicked(elt instanceof DataCellElement ? elt.innerCellIndex() : elt.index());
			}
			if (elt instanceof RowGroupHeaderCellElement || elt instanceof BandedRowGroupHeaderCellElement) {
				groupItem = _cast(elt.item(), GroupRow);
				if (groupItem) {
                    if (_checkAbort(this.rowGroupHeaderDblClicked, this, groupItem.index())) {
                        groupItem.setExpanded(!groupItem.expanded());
                    }
				}
			} else if (elt instanceof HeaderCellElement) {
				clickIndex.column && this.columnHeaderDblClicked(clickIndex.column);
            } else if (clickCell instanceof HeaderHeadElement) {
                this.headerHeadDblClicked();
			} else if (grid.isValidCell(index) && !grid.isEditing() && clickCell && clickCell.canEditable()) {
				this._performRendererClick(index, this._reclickCell, x, y, true, false);
				if (clickCell instanceof MergedDataCellElement) {
					clickIndex = clickIndex.clone();
					this.$_calcInnerIndex(clickCell, clickIndex, x, y);
				}
				if (grid.editOptions().showEditorWhenDblClicked() && CellIndex.areEqual(clickIndex, index)) {
					if (clickCell.canEditableAt(clickCell.containerToElement(x, y))) {
						grid.$_showEditor(clickIndex);
					}
				}
			} else if (clickCell instanceof FooterCellElement) {
				if (clickCell.error() || clickCell.errorDetail()) {
					grid.alertCellError(clickCell, clickCell.errorDetail() || clickCell.error());
				} else {
					this.footerCellDblClicked(clickIndex.column);
				}
            } else if (clickCell instanceof FooterHeadElement) {
                this.footerHeadDblClicked();
            } else if (clickCell instanceof SummaryCellElement) {
                if (clickCell.error()) {
                    grid.alertCellError(clickCell, clickCell.errorDetail() || clickCell.error());
                } else {
                    this.headerSummaryCellDblClicked(clickIndex.column);
                }
            } else if (clickCell instanceof HeaderSummaryHeadElement) {
                this.headerSummaryHeadDblClicked();
			} else if (clickCell instanceof GroupFooterCellElement) {
                if (_checkAbort(this.rowGroupFooterCellDblClicked, this, clickIndex)) {
                    if (clickCell.error() || clickCell.errorDetail()) {
                        grid.alertCellError(clickCell, clickCell.errorDetail() || clickCell.error());
                    }
                }
			} else if (clickCell instanceof IndicatorCellElement) {
				this.rowIndicatorCellDblClicked(index.rowIndex);
			} else if (clickCell instanceof StateCellElement) {
				this.stateBarCellDblClicked(elt.index().rowIndex);
            } else if (clickCell instanceof CheckBarCellElement) {
                this.checkBarCellDblClicked(elt.index().rowIndex);
            } else if (clickCell instanceof CheckBarHeadElement) {
                this.checkBarHeadDblClicked();
			} else if (clickCell instanceof RowGroupHeadCellElement) {
				this.rowGroupHeadCellDblClicked(clickCell.level());
            } else if (clickCell instanceof BandedRowGroupHeaderCellElement) {
                this.rowGroupHeaderDblClicked(clickIndex.rowIndex);
			} else if (clickCell instanceof RowGroupHeaderCellElement) {
				this.rowGroupHeaderDblClicked(clickIndex.rowIndex);
			} else if (clickCell instanceof RowGroupExpandHandle) {
				this.rowGroupBarDblClicked(-1);
			} else if (clickCell instanceof RowGroupExpanderElement) {
				this.rowGroupBarDblClicked(-2);
			}
		}
	},
	_doMouseDown: function (x, y, ctrlKey, shiftKey, button, metaKey) {
        var clickElement, clickCell, clickRow, request, tracker, sels, needFocus,
            footerView, mergedFooter, index, selItem, idx, extSel, clearable, resizeSel,
            grid = this._grid,
            options = grid.displayOptions();
		this._hideTooltip();
		grid.closePopups();
		grid.setFocus();
		grid.autoFill().stop();
        this._scrollTool.stop();
		clickElement = this._clickElement = null;
		clickCell = this._clickCell = null;
        clickRow = null;
		this._reclickCell = null;
		this._clickHandle = null;
		this._rightClicked = button > 1 ? true : false;
        if (button == 0 || options.rightClickable()) {
            clickElement = this._clickElement = this.findElementAt(x, y, false);
            if (clickElement) {
                if (this._scrollTool.start(clickElement, x, y)) {
                    return;
                }
                this._clickHandle = _cast(clickElement, HandleElement);
                clickCell = this._clickCell = _cast(clickElement, CellElement);
                if (!clickCell) clickCell = clickElement && clickElement.getParentAs(DataCellElement);
                if (!clickCell) clickRow = clickElement.getParentAs(GroupRowElement);
            }
            this._clickPos.set(x, y);
            if (this._clickHandle) {
                if (this._clickHandle.clickable()) {
                    this.$_handleClicked(this._clickHandle);
                    return;
                }
            }
        }
        if (clickElement instanceof CellElement && clickElement.isDataCell()) {
			this.dataCellClick(clickElement.index());
		} else if (clickElement instanceof IndicatorCellElement) {
			this.rowIndicatorCellClick(clickElement.index().rowIndex);
		}
		if (clickCell instanceof DataCellElement && this.$_checkAppending(grid.$_focusedIndex(), true, clickCell)) {
			return;
		}
		if (clickCell || clickRow) {
            sels = grid._selections;
			needFocus = false;
			footerView = null;
			mergedFooter = null;
			index = clickCell ? clickCell.index().clone() : new CellIndex(clickRow.rowIndex());
            request = this._getEditRequest(clickCell, x, y, ctrlKey, shiftKey);
			if (!request || request.isSelectable()) {
				if (!shiftKey) {
                    extSel = options.selectMode() == SelectionMode.EXTENDED && (ctrlKey || metaKey);
                    clearable = !extSel &&
                        ((!this._rightClicked || !sels.contains(clickCell.index())) || (!grid.getContextMenu() && options.preventSystemMenu()));
                    if (clickCell instanceof ValueCellElement && index.getRow(grid) && clearable) {
                        grid._selections.clear();
                    } else if (clickCell instanceof IndicatorCellElement && clearable && grid.rowIndicator().selectable()) {
                        grid._selections.clear();
                    } else if (clickCell instanceof RowGroupHeaderCellElement && clearable) {
                        grid._selections.clear();
                    } else if (clickCell instanceof BandedRowGroupHeaderCellElement && clearable) {
						grid._selections.clear();
					} else if (clickCell instanceof CheckBarCellElement && grid.checkBar().draggable() && clearable) {
						grid._selections.clear();
                    } else if (clickRow) {
                        grid._selections.clear();
                    } else if ((footerView = this.$_getGroupFooterView(clickCell)) != null && clearable) {
                        grid._selections.clear();
                    } else if ((mergedFooter = this.$_getMergedFooterView(clickCell)) != null && clearable) {
                        grid._selections.clear();
                    }
                } else if (clickCell instanceof HeaderCellElement) {
				} else if (selItem = sels.lastItem()) {
					resizeSel = !SelectionStyle.isSingle(options.selectStyle());
                    if ((clickCell instanceof DataCellElement || clickCell instanceof IndicatorCellElement) && resizeSel) {
						selItem.resizeTo(clickCell.index());
					}
                    return;
                }
                if (clickCell instanceof MergedDataCellElement || clickCell instanceof MergedSeriesCellElement) {
                    this.$_calcInnerIndex(clickCell, index, x, y);
                }
				if (clickCell && clickCell.canEditable()) {
					if (CellIndex.areEqual(index, this.focused())) {
                        this._reclickCell = this._clickCell;
                    }
                    if (!(request instanceof CellButtonRequest) && this._reclickCell && grid.editOptions().editWhenClickFocused()) {
                        grid.$_showEditor(index);
                    } else {
						needFocus = true;
                    }
                } else if (clickCell instanceof ValueCellElement || clickCell instanceof DataGroupCellElement) {
					needFocus = clickCell.index().getRow(grid) != null
				} else if (clickCell instanceof IndicatorCellElement) {
					if (grid.rowIndicator().selectable()) {
						idx = this._tmpIndex;
						idx.assign(grid.$_focusedIndex());
						idx.rowIndex = index.rowIndex;
						if (idx.column == null && idx.getRow(grid) instanceof DataRow) {
							idx.column = grid.getFirstColumn();
						}
						index = idx;
						needFocus = true;
					}
				} else if (clickCell instanceof RowGroupHeaderCellElement || clickCell instanceof BandedRowGroupHeaderCellElement) {
                    index.column = grid.getVisibleColumn(index.getRow(grid).level());
					needFocus = true;
				} else if (footerView) {
					idx = this.focused().clone();
					idx.rowIndex = footerView.item().index();
					index = idx;
					needFocus = true;
				} else if (mergedFooter) {
					needFocus = true;
                } else if (clickRow) {
                    idx = this.focused().clone();
                    idx.rowIndex = clickRow.item().index();
                    index = idx;
					needFocus = true;
				}
				if (needFocus) {
                    this.setFocused(index.normalize(grid), clearable);
                    /*
                    if (grid.isValidCell(grid.$_focusedIndex())) { // button == 0 이면, 아래 selectionTracker에서 clear할 것이다.
						if (SelectionStyle.isSingle(grid.displayOptions().selectStyle()) && grid._selections.count() < 1) {
							grid.clearSelection();
						} 
					} else {
						return;
					}
					*/
				}
			}
            if (button == 0) {
                tracker = this._getDragTracker(request, x, y, ctrlKey, shiftKey, metaKey);
                this.setDragTracker(tracker);
                /*
                if (grid._selections.count() < 1) {
					if (grid.displayOptions().selectStyle() == SelectionStyle.ROWS && !(tracker instanceof RowsSelectTracker) ||
					    grid.displayOptions().selectStyle() == SelectionStyle.COLUMNS && !(tracker instanceof ColumnsSelectTracker)) {
                        grid.clearSelection();
                    }
                }
                */
            }
		} else if (clickElement) { // for scrollbar or auto fill handle
			request = this._getEditRequest(clickElement, x, y, false, false);
			if (request) {
				this.setDragTracker(this._getDragTracker(request, x, y, ctrlKey, shiftKey));
			}
		}
		tracker = this.dragTracker();
		if (tracker && tracker.isStartWhenCreated()) {
			this._startDragTracker(x, y);
		}
	},
	_doMouseMove: function (x, y, ctrl, shift) {
		var elt, rowView, hm, hv, request,
            grid = this._grid;
		if (this._scrollTool.isScrolling()) {
			this._scrollTool.move(x, y);
		} else if (this.dragTracker()) {
			this._hideTooltip();
		} else {
            grid.container().restoreCursor();
			elt = this.findElementAt(x, y, true);
			grid.toolTipManager().setTarget(elt);
			if (grid.canHovering()) {
                this.setHoveredCell(_cast(elt, CellElement));
                this._hoveredCell && this._hoveredCell.$_setHoverIndex(grid, x, y);
			} else {
				this._hideTooltip();
			}
            if (elt) {
				hm = grid.displayOptions().rowHoverMask();
				hv = this._rowHoverView;
				if (hm.visible()) {
					rowView = elt.getParentAs(DataRowElement);
					if (rowView) {
						if (hm.extent() == RowHoverMaskExtent.CELL && elt !== hv.$_cellView || rowView.y() != this._rowHoverPos) {
							this.$_updateHoverView(grid, rowView, elt);
						}
					}
				} else {
					hv.setVisible(false);
				}
            }
			request = this._getEditRequest(elt, x, y, ctrl, shift);
			if (request && request.cursor()) {
                grid.container().setCursor(request.cursor());
			}
		}
	},
	_doMouseUp: function (x, y) {
		var request,
            elt = this.findElementAt(x, y, true);
        if (this._scrollTool.isScrolling()) {
            this._scrollTool.stop(x, y);
		} else if ((!this.dragTracker() || !this.dragTracker().isCompleted()) && elt && elt == this._clickElement) {
			if (elt instanceof HeaderCellElement && elt.clickable()) {
				request = this._getEditRequest(this._clickElement, x, y, false, false);
				if (!request || !request.isDblClickable()) {
					if (elt.parent() instanceof HeaderElement || elt.parent() instanceof HeaderGroupCellElement) {
						this.$_columnHeaderClicked(elt.index().column, this._rightClicked);
					}
				}
			} else if (elt instanceof HeaderCheckHandle) {
                elt.cellView().column().setChecked(!elt.cellView().column().checked());
            } else if (elt instanceof HeaderHeadElement) {
                this._headerHeadClicked();
            } else if (elt instanceof CheckBarCellElement) {
				this._checkCellClicked(elt, this._clickX, this._clickY);
			} else if (elt instanceof CheckBarHeadElement) {
				this._checkAllClicked(elt, this._clickX, this._clickY);
			} else if (elt instanceof IndicatorCellElement) {
			} else if (elt instanceof StateCellElement) {
				this._stateBarCellClicked(elt.index().rowIndex);
            } else if (elt instanceof FooterCellElement) {
                this._footerCellClicked(elt.index().column);
            } else if (elt instanceof FooterHeadElement) {
                this._footerHeadClicked();
            } else if (elt instanceof SummaryCellElement) {
                this._headerSummaryCellClicked(elt.index().column);
            } else if (elt instanceof HeaderSummaryHeadElement) {
                this._headerSummaryHeadClicked();
			} else if (elt instanceof RowGroupHeadCellElement) {
				this._rowGroupHeadCellClicked(elt.level());
			} else if (elt instanceof RowGroupHeaderCellElement || elt instanceof BandedRowGroupHeaderCellElement) {
				this._rowGroupHeaderClicked(elt.index().rowIndex);
			} else if (elt instanceof GroupFooterCellElement) {
				this._rowGroupFooterCellClicked(elt.index());
			} else if (elt instanceof RowGroupExpandHandle) {
				this._rowGroupBarClicked(-1);
			} else if (elt instanceof RowGroupExpanderElement) {
				this._rowGroupBarClicked(-2);
			} else if (elt === this._clickHandle && !elt.clickable()) {
				this.$_handleClicked(elt);
			} else if (elt.clickable()) {
				this.$_elementClicked(elt);
			}
		}
		this.setDragTracker(null);
	},
	_doMouseOutside: function () {
		this.setHoveredCell(null);
		this._grid._validateScrollBars();
	},
	_doMouseWheel: function (x, y, deltaX, deltaY) {
        var delta, p,
		    grid = this._grid,
		    options = grid.displayOptions(),
		    lm = grid.lm();
        this._scrollTool.stop();
		if ((delta = options.wheelDelta()) && grid.rowCount() > lm.fullItemCount()) {
			p = grid.topIndex();
			delta = (_isMac && deltaY == 0) ? 0 : deltaY >= 0 ? -delta : delta;
			if (delta < 0 && p > 0 || delta > 0 && lm.itemCount() > lm.fullItemCount()) {
				grid.setTopIndex(p + delta);
				return true;
			}
		} else if ((delta = options.horzWheelDelta()) && grid.maxHorzPos() > 0) {
			p = grid.leftPos();
            delta = (_isMac && deltaY == 0) ? 0 : deltaY >= 0 ? -delta : delta;
			if (delta < 0 && p > 0 || delta > 0 && grid.maxHorzPos() > 0) {
				grid.setLeftPos(p + delta);
				return true;
			}
		}
		return !options.bubbleWheelEvents() ? true : this._super(x, y, deltaX, deltaY);
	},
	_doMouseEnter: function (x, y) {
	},
	_doMouseLeave: function () {
		!this._grid.displayOptions().tooltipAnimation() && this._hideTooltip();
	},
	_doMouseOver: function (x, y) {
	},
	_doLayoutChanged: function (x, y) {
		this._resetFocusView();
		this._resetHoverView();
	},
	_doFocusedIndexChanged: function (oldIndex, newIndex) {
		this._resetFocusView();
	},
	editorButtonClicked: function (index) {
		var grid = this._grid;
        grid.makeCellVisible();
        if (grid.$_showEditor(index)) {
            grid.$_editorButtonClick(index);
        }
		this._super(index);
	},
	$_checkAppending: function (index, cancel, clickCell) {
		var appending, rowIndex,
            grid = this._grid;
		if (!grid.isValidCell(index)) {
			return false;
		}
		if (index.rowIndex == grid.rowCount() - 1 && GridRowState.isInserting(index.getRow(grid).rowState())) {
			appending = GridRowState.isInserting(index.getRow(grid).rowState()) && index.rowIndex == grid.rowCount() - 1;
			rowIndex = index.rowIndex;
			if (!clickCell || clickCell.index().rowIndex !== rowIndex) {
                try {
                    if (grid.commit(grid.editOptions().forceAppend(), true)) {
                        index = index.clone();
                        index.rowIndex = rowIndex;
                        if (!grid.isValidCell(index)) {
                            index.rowIndex = grid.getRowIndexOfDataIndex(grid.dataSource().rowCount() - 1);
                        }
                        this.setFocused(index, true);
                    } else if (cancel && grid.itemSource() && !grid.itemSource().isEdited()) {
                        grid.cancel(true);
                    }
                } catch (err) {
                    if (err instanceof ValidationError) {
                        _alert(err);
						_throwDebug(err);
                        return true
                    }
                    if (err instanceof AbortError) {
						_throwDebug(err);
						return true;
                    }
                    throw err;
                }
				return appending;
			}
		}
		return false;
	},
	$_getGroupFooterView: function (element)/* RowGroupFooterElement */ {
		var p = element.parent();
		while (p) {
			if (p instanceof RowGroupFooterElement) {
				return p;
			}
			p = p.parent();
		}
		return null;
	},
	$_getMergedFooterView: function (element)/* MergedFooterElement */ {
		var p = element.parent();
		while (p) {
			if (p instanceof MergedFooterElement) {
				return p;
			}
			p = p.parent();
		}
		return null;
	},
	_getEditRequest: function (source, x, y, ctrlKey, shiftKey) {
        var index, column, resizable, b,
            grid = this._grid,
            sm = grid.selections(), mode, style,
            cell, lm, options, request;
        /*if (source instanceof ScrollThumb) {
			return new ScrollThumbRequest(source);
		} else*/ if (source instanceof AutoFillHandle) {
            return new AutoFillRequest();
        }
		if (grid.visibleColumnCount() < 1) {
			return null;
		}
		if (!(source instanceof CellElement)) { 
			return null;
		}
        cell = source;
        lm = grid.lm();
        options = grid.displayOptions();
        request = this.$_getRowResizeRequest(grid, lm, options, cell, x, y, ctrlKey, shiftKey);
		if (request) {
			return request;
		}
		if (grid.header().resizable()) {
			request = this.$_getHeaderResizeRequest(x, y);
			if (request) {
				return request;
			}
		}
		if (grid.footer().resizable()) {
			request = this.$_getFooterResizeRequest(x, y);
			if (request) {
				return request;
			}
		}
        if (grid.header().summary().resizable()) {
            request = this.$_getHeaderSummaryResizeRequest(x, y);
            if (request) {
                return request;
            }
        }
        mode = options.selectMode(),
        style = options.selectStyle();
        if (cell instanceof IndicatorCellElement) {
			if (grid.rowIndicator().selectable() && mode != SelectionMode.NONE && style != SelectionStyle.NONE && style != SelectionStyle.SINGLE_ROW) {
				return new SelectRequest(sm, cell, SelectionStyle.ROWS);
			}
		} else if (cell instanceof CheckBarCellElement) {
			if (grid.checkBar().draggable() && grid.editOptions().checkable()) {
				return new CheckCellRequest(cell);
			}
		} else if (cell instanceof HeaderCellElement) {
			if (shiftKey || ctrlKey) {
				if (grid.header().selectable() && mode != SelectionMode.NONE && style != SelectionStyle.NONE && style != SelectionStyle.SINGLE_COLUMN) {
					return new SelectRequest(sm, cell, SelectionStyle.COLUMNS);
				}
			} else {
                request = this.$_getColumnResizeRequest(grid, lm, options, cell, x, y);
                if (request) return request;
				index = cell.getDelegateParent().index();
				column = index.column;
				if (options.columnMovable() && column.movable() &&
					(!column.isRoot() || grid.canMoveIndex(column.root().displayIndex()))) {
					return new ColumnMoveRequest(cell);
				}
			}
		} else if (cell instanceof RowGroupHeaderCellElement || cell instanceof BandedRowGroupHeaderCellElement || this.$_getGroupFooterView(cell) || this.$_getMergedFooterView(cell)) {
			if (mode != SelectionMode.NONE && style != SelectionStyle.NONE && !SelectionStyle.isSingle(style)) {
				if (sm.count() > 0 && shiftKey) {
					return new SelectRequest(sm, cell, sm.itemStyle());
				} else if (style != SelectionStyle.NONE) {
					return new SelectRequest(sm, cell,  style);
				}
			}
		} else if (cell instanceof DataCellElement) {
			x = cell.mouseX();
			y = cell.mouseY();
			cell.setButtonState(-1, -1);
			cell.setEditorButtonState(false, false);
			if (cell.ptInButton(x, y)) {
				cell.setButtonState(0, -1);
				return new CellButtonRequest(cell, 0);
			}
            if ((b = cell.ptInCustomButton(x, y)) >= 0) {
                return new CellButtonRequest(cell, b + 1);
            }
			if (cell.ptInEditorButton(x, y)) {
				cell.setEditorButtonState(true, false);
				return new EditorButtonRequest(cell);
			}
            if (cell.ptInDataButton(x, y)) {
                return new DataButtonRequest(cell);
            }
			if (mode != SelectionMode.NONE && style != SelectionStyle.NONE) {// && !SelectionStyle.isSingle(style)) {
				if (sm.count() > 0 && shiftKey) {
					return new SelectRequest(sm, cell, sm.itemStyle());
				} else if (style != SelectionStyle.NONE) {
					return new SelectRequest(sm, cell,  style);
				}
			}
		} else if (/*cell instanceof ValueCellElement && */cell.index().getRow(grid) != null) {
            if (mode != SelectionMode.NONE && style != SelectionStyle.NONE) {// && !SelectionStyle.isSingle(style)) {
                if (sm.count() > 0 && shiftKey) {
                    return new SelectRequest(sm, cell, sm.itemStyle());
                } else if (style != SelectionStyle.NONE) {
                    return new SelectRequest(sm, cell,  style);
                }
            }
        }
		return this._super(source, x, y, ctrlKey, shiftKey);
	},
	$_getHeaderResizeRequest: function (x, y) {
		var r,
            lm = this._grid.lm(),
		    w = lm.rowIndicatorBounds().width;
		if (w <= 0) {
			w = lm.stateBarBounds().width;
		}
		if (w <= 0) {
			w = lm.checkBarBounds().width;
		}
		if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
			w = 20;
		}
		if (w <= 0 || x >= w) {
            return null;
        }
		r = lm.headerBounds();
		if (y > r.bottom() - 3 && y <= r.bottom()) {
			return new HeaderResizeRequest();
		}
		return null;
	},
    $_getHeaderSummaryResizeRequest: function (x, y) {
        var r,
            lm = this._grid.lm(),
            w = lm.rowIndicatorBounds().width;
        if (w <= 0) {
            w = lm.stateBarBounds().width;
        }
        if (w <= 0) {
            w = lm.checkBarBounds().width;
        }
        if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
            w = 20;
        }
        if (w <= 0 || x >= w) {
            return null;
        }
        r = lm.summaryBounds();
        if (y > r.bottom() - 3 && y <= r.bottom()) {
            return new HeaderSummaryResizeRequest();
        }
        return null;
    },
	$_getFooterResizeRequest: function (x, y) {
		var r,
            lm = this._grid.lm(),
		    w = lm.rowIndicatorBounds().width;
		if (w <= 0) {
			w = lm.stateBarBounds().width;
		}
		if (w <= 0) {
			w = lm.checkBarBounds().width;
		}
		if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
			w = 20;
		}
		if (w <= 0 || x >= w) {
			return null;
		}
		r = lm.footerBounds();
		if (y >= r.y && y <= r.y + 3) {
			return new FooterResizeRequest();
		}
		return null;
	},
    $_isResizable: function (column, grid, lm, options) {
        var resizable = true;
        if (options.checkChildColumnResizable() && column.group()) {
            resizable = column.group().resizable();
        }
        if (resizable && options.columnResizable() && column.resizable() &&
            (grid.displayOptions().fixedColumnResizable() || column.root().displayIndex() >= lm.fixedColCount())) {
            return true;
        }
    },
    $_getColumnResizeRequest: function (grid, lm, options, cell, x, y) {
        if (grid.visibleColumnCount() < 1) {
            return null;
        }
        var saveCell,
            index = cell.getDelegateParent().index(),
            column = index.column,
            resizable = this.$_isResizable(column, grid, lm, options),
            p = cell.localToContainer(Point.EMPTY);
        if (resizable && x >= p.x + cell.width() - 3) {
            return new ColumnResizeRequest(cell);
        }
        if (x < p.x + 3) {
            saveCell = cell;
            cell = this.findElementAt(p.x - 1, y);
            if (cell instanceof HeaderCellElement && cell !== saveCell) {
                column = cell.getDelegateParent().index().column;
                if (this.$_isResizable(column, grid, lm, options)) {
                    return new ColumnResizeRequest(cell);
                }
            }
        }
    },
	$_getRowResizeRequest: function (grid, lm, options, cell, x, y, ctrl, shift) {
		if (grid.rowCount() < 1) {
            return null;
        }
        var i, r, r2, cnt, variable, nFixed, p, w, row, itemCount, topIndex,
            idx = -1;
		if (cell instanceof IndicatorCellElement || cell instanceof  StateBarElement) {
			idx = cell.index().rowIndex;
		} else if (cell instanceof  CheckBarCellElement) {
			if (!grid.rowIndicator().visible()) {
				idx = cell.index().rowIndex;
			}
		} else if (cell instanceof DataCellElement) {
			if (!grid.rowIndicator().visible() && !grid.checkBar().visible() && x < 50) {
				idx = cell.index().rowIndex;
			}
		}
		if (idx < 0) {
			return null;
		}
        variable = options.variableRowHeight() && !grid._verticalColumnGrouped && !ctrl;
        nFixed = lm.fixedItemCount();
        p = cell.localToContainer(Point.EMPTY);
        w = cell.width();
		if (w <= 0 || x < p.x || x >= p.x + w) {
			return null;
		}
        y -= grid.y(); // container 경계선이 1 이상일 수 있다.
		if (variable && options.fixedRowResizable() || !variable && options.rowResizable()) {
			for (i = 0; i < (variable ? nFixed : 1); i++) {
				if (grid.getRow(i).isResizable()) {
					if (idx == i) {
						r = lm.getItemRect(i);
						if (y >= r.bottom() - 3) {
							return new RowResizeRequest(i, variable);
						} else if (row > 0 && y <= r.y + 2) {
							row--;
							if (grid.getRow(row).isResizable()) {
								return new RowResizeRequest(row, variable);
							}
							break;
						} else {
							r2 = lm.footerBounds();
							if (r.bottom() >= r2.y && y >= r2.y - 2 && y <= r2.y + 2) {
								return new RowResizeRequest(i, variable);
							}
						}
					}
				}
			}
		}
		if (nFixed > 0 && !variable) {
            return null;
        }
		if (options.rowResizable()) {
            itemCount = lm.itemCount();
            topIndex = grid.topIndex();
			if (itemCount == 0 && nFixed > 0 || itemCount == 1 && lm.fullItemCount() == 0 && grid.getRow(0).isResizable()) {
				r = lm.getItemRect(0);
				r2 = lm.footerBounds();
				if (r.bottom() >= r2.y && y >= r2.y - 5 && y <= r2.y + 2) {
					return new RowResizeRequest(0, variable);
				}
			}
			cnt = 0;
			for (i = 0; i < itemCount; i++) {
                row = i + topIndex + nFixed;
				if (grid.getRow(row) && grid.getRow(row).isResizable()) {
					cnt++;
					if (idx === row) {
						r = lm.getItemRect(i + nFixed);
						if (y >= r.bottom() - 3) {
							return new RowResizeRequest(row, variable);
						} else if (row > 0 && y <= r.y + 2) {
							row--;
							if (grid.getRow(row).isResizable()) {
								if (row >= nFixed || options.fixedRowResizable()) {
									return new RowResizeRequest(row, variable);
								}
							}
							break;
						} else {
							r2 = lm.footerBounds();
							if (r.bottom() >= r2.y && y >= r2.y - 2 && y <= r2.y + 2) {
								return new RowResizeRequest(row, variable);
							}
						}
					}
				}
				if (cnt > 0 && !variable) break;
			}
		}
		return null;
	},
	_getDragTracker: function (request, x, y, ctrlKey, shiftKey, metaKey) {
        var grid = this._grid;
        if (request instanceof AutoFillRequest) {
            return new AutoFillTracker(grid, request);
        } else if (request instanceof ColumnResizeRequest) {
			return new ColumnResizeTracker(request, x, y);
		} else if (request instanceof ColumnMoveRequest) {
			if (this._grid.displayOptions().parentChangable()) {
				return new ColumnMoveTracker3(request, x, y);
			} else {
				return new ColumnMoveTracker2(request, x, y);
			}
		} else if (request instanceof HeaderResizeRequest) {
			return new HeaderResizeTracker(grid, request, x, y);
        } else if (request instanceof HeaderSummaryResizeRequest) {
            return new HeaderSummaryResizeTracker(grid, request, x, y);
		} else if (request instanceof FooterResizeRequest) {
			return new FooterResizeTracker(grid, request, x, y);
		} else if (request instanceof RowResizeRequest) {
			return new RowResizeTracker(grid, request, x, y);
        } else if (request instanceof ColumnExcludeRequest) {
            return new ColumnExcludeTracker(grid, request, x, y);
		} else if (request instanceof CheckCellRequest) {
			return new CheckCellTracker(request, x, y, ctrlKey)
		} else if (request instanceof SelectRequest) {
			var ext = (ctrlKey || metaKey) && grid.displayOptions().selectMode() == SelectionMode.EXTENDED;
            switch (request.selectStyle()) {
                case SelectionStyle.SINGLE_ROW:
                case SelectionStyle.ROWS:
                    return new RowsSelectTracker(request, ext);
                case SelectionStyle.SINGLE_COLUMN:
                case SelectionStyle.COLUMNS:
                    return new ColumnsSelectTracker(request, ext);
                case SelectionStyle.SINGLE:
                case SelectionStyle.BLOCK:
                    return new BlockSelectTracker(request, ext);
            }
        } else if (request instanceof DataButtonRequest) {
            return new DataButtonTracker(request);
		} else if (request instanceof EditorButtonRequest) {
			return new EditorButtonTracker(request);
		} else if (request instanceof CellButtonRequest) {
			return new CellButtonTracker(request);
		}
		return null;
	},
	editorActivated: function (editor) {
		this._resetFocusView();
	},
	$_columnHeaderClicked: function (column, rightClicked) {
		rightClicked = arguments.length > 1 ? rightClicked : false;
		this._grid._fireColumnHeaderClicked(column, rightClicked);
		this._doColumnHeaderClicked(column, rightClicked);
	},
	_doColumnHeaderClicked: function (column) {
	},
    _headerHeadClicked: function () {
        this._grid._fireHeaderHeadClicked();
    },
	_footerCellClicked: function (column) {
		this._grid._fireFooterCellClicked(column);
	},
    _footerHeadClicked: function () {
        this._grid._fireFooterHeadClicked();
    },
    _headerSummaryCellClicked: function (column) {
        this._grid._fireHeaderSummaryCellClicked(column);
    },
    _headerSummaryHeadClicked: function () {
        this._grid._fireHeaderSummaryHeadClicked();
    },
	_stateBarCellClicked: function (rowIndex) {
		this._grid._fireStateCellClicked(rowIndex);
	},
	_rowGroupHeadCellClicked: function (level) {
		this._grid._fireRowGroupHeadCellClicked(level);
	},
	_rowGroupHeaderClicked: function (rowIndex) {
		this._grid._fireRowGroupHeaderClicked(rowIndex);
	},
    _rowGroupFooterCellClicked: function (index) {
        this._grid._fireRowGroupFooterCellClicked(index);
    },
	_rowGroupBarClicked: function (index) {
		this._grid._fireRowGroupBarClicked(index);
	},
	_panelClicked: function () {
		this._grid._firePanelClicked();
	},
	_rowGroupPanelClicked: function (cell) {
		this._grid._fireRowGroupPanelClicked(cell);
	},
	$_elementClicked: function (element) {
		this._doElementClicked(element);
	},
	_doElementClicked: function (element) {
	},
	$_handleClicked: function (handle) {
		this._doHandleClicked(handle);
	},
	_doHandleClicked: function (handle) {
		var grid = this._grid,
            col = handle.cellView().index().dataColumn();
		if (handle instanceof ColumnFilterHandle) {
			grid.selectColumnFilters(col);
		}
	},
	_showTooltip: function (cellView, options) {
		var grid = this._grid,
		    tm = grid.toolTipManager();
		if (/*tm.visible() &&*/ this._tipCell === cellView) {
			return;
		}
        if (!options.animation()) {
            this._hideTooltip();
        }
		if (cellView && options) {
			tm.show(options, cellView, this._tipCloseCallback);
			this._tipCell = cellView;
		}
	},
	_hideTooltip: function () {
		this._grid.toolTipManager().close();
		this._tipCell = null;
	},
	_performRendererClick: function (index, cell, x, y, dblClick, firstClick) {
		var column, renderer,
            grid = this._grid;
		if (!grid.isEditing() && grid.isValidCell(index) && cell) {
			column = index.dataColumn();
			if (column) {
				renderer = cell.renderer(); // column.renderer;
				if (cell.ptInClick(cell.mouseX(), cell.mouseY())) {
					if (renderer.editable() && (!dblClick && !renderer.dblClickEditable() || dblClick && renderer.dblClickEditable()) && (!firstClick || renderer.editOnClick())) {
						if (!grid.getReadOnlyAt(index.rowIndex, column)) {
							if (grid.edit()) {
								renderer.performEdit(index);
							}
						}
					} else if (!dblClick && renderer.isClickable(cell)) {
						renderer.performClick(cell, x, y);
					}
				}
			}
		}
	}
});
var FocusView = defineClass("FocusView", LayerElement, {
	init: function (dom, grid, name) {
		this._super(dom, name || "focusView");
        this._grid = grid;
		this._border = new SolidPen(0xff333333, 2);
		this._editBorder = new SolidPen(0xff000000 + (82 << 16) + (146 << 8) + 247, 2);
		this._editing = false;
	},
    setEditing: function (editing, buttonWidth) {
            this._editing = editing;
            this._buttonWidth = buttonWidth;
            this.invalidate();
    },
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0),
            d = this._editing ? 0 : 1;
		g.drawBoundsI(null, this._editing ? this._editBorder : (this._getGridBorder() || this._border), -1, -1, w - d, this.height() - 1);
	},
	_doDrawHtml: function () {
		var stroke = this._editing ? this._editBorder : this._border;
		this._css.background = "";
		this._css.border = stroke.css();
	},
    _getGridBorder: function () {
        return this._grid.displayOptions().focusBorder();
    }
});
var InnerFocusView = defineClass("InnerFocusView", FocusView, {
    init: function (dom, grid) {
        this._super(dom, grid, "innerFocusView");
        this._border = new SolidPen(0x80333333, 1, [1, 1]);
    },
    _getGridBorder: function () {
        return this._grid.displayOptions().innerFocusBorder();
    }
});
var RowController = defineClass("RowController", EventAware, {
	init: function() {
		this._super();
	},
	currentIndex: -1
});
var CellRequest = defineClass("CellRequest", EditRequest, {
	init : function(cell) {
		this._super();
		this._cell = cell;
	},
	cell: function () {
		return this._cell;
	},
	cursor : function() {
		return null;
	},
	source : function() {
		return this._cell;
	},
	isSelectable : function() {
		return true;
	},
	isDblClickable : function() {
		return false;
	}
});
var GridEditRequest = defineClass("GridEditRequest", EditRequest, {
	init: function() {
		this._super();
	},
	cursor: function() {
		return null;
	},
	source: function() {
		return null;
	},
	isSelectable: function() {
		return true;
	},
	isDblClickable: function() {
		return false;
	}
});
var GridDragTracker = defineClass("GridDragTracker", DragTracker, {
	init: function(grid, name) {
		this._super(grid.container(), name);
		this._grid = grid;
	},
	grid: function () {
		return this._grid;
	}
});
var ColumnResizeRequest = defineClass("ColumnResizeRequest", CellRequest, {
	init: function(headerCell) {
		this._super(headerCell);
	},
	delta: 0,
	headerCell: function () {
		return this._cell;
	},
	cursor: function() {
		return Cursor.HORZ_RESIZE;
	},
	isSelectable : function() {
		return false;
	},
	isDblClickable : function() {
		return true;
	}
});
var ColumnMoveRequest = defineClass("ColumnMoveRequest", CellRequest, {
	init: function(cell) {
		this._super(cell);
	}
});
var CheckCellRequest = defineClass("CheckCellRequest", CellRequest, {
	init: function(cell, ctrlKey) {
		this._super(cell);
	}
});
var DataCellRequest = defineClass("DataCellRequest", EditRequest, {
	init: function (index) {
		this._super();
		this._index = index;
	},
	cursor: function () {
		return null;
	},
	source: function () {
		return null;
	},
	isSelectable: function () {
		return true;
	},
	isDblClickable: function () {
		return false;
	}
});
var CellButtonRequest = defineClass("CellButtonRequest", DataCellRequest, {
	init : function(dataCell, button) {
		this._super(dataCell.index());
		this._cell = dataCell;
		this._button = button;
	},
	cell : function() {
		return this._cell;
	}
});
var EditorButtonRequest = defineClass("EditorButtonRequest", CellButtonRequest, {
	init: function(dataCellView) {
		this._super(dataCellView);
	}
});
var DataButtonRequest = defineClass("EditorButtonRequest", CellButtonRequest, {
    init: function(dataCellView) {
        this._super(dataCellView);
    }
});
var HeaderResizeRequest = defineClass("HeaderResizeRequest", GridEditRequest, {
	init: function() {
		this._super();
	},
	cursor: function() {
		return Cursor.VERT_RESIZE;
	}
});
var HeaderSummaryResizeRequest = defineClass("HeaderSummaryResizeRequest", GridEditRequest, {
    init: function() {
        this._super();
    },
    cursor: function() {
        return Cursor.VERT_RESIZE;
    }
});
var FooterResizeRequest = defineClass("FooterResizeRequest", GridEditRequest, {
	init: function() {
		this._super();
	},
	cursor: function() {
		return Cursor.VERT_RESIZE;
	}
});
var RowResizeRequest = defineClass("RowResizeRequest", GridEditRequest, {
	init: function(itemIndex, variable) {
		this._super();
		this._itemIndex = itemIndex;
		this._variable = variable;
	},
	rowIndex: function () { return this._itemIndex; },
	cursor: function() {
		return Cursor.VERT_RESIZE;
	},
	isSelectable: function() {
		return false;
	}
});
var ColumnExcludeRequest = defineClass("ColumnExcludeRequest", GridEditRequest, {
    init: function(column) {
        this._super();
        this._column = column;
    },
    column: function () { return this._column; },
    cursor: function() {
        return Cursor.NOT_ALLOWED;
    },
    isSelectable: function() {
        return false;
    }
});
var ColumnResizeTracker = defineClass("ColumnResizeTracker", GridDragTracker, {
	init: function(request) {
		this._super(request.cell().grid(), "columnResizeTracker");
		this._request = request;
        var cell = this._request.headerCell().getDelegateParent();
        this._column = cell.index().column;
		this._startWidth = cell.width();
		this._offset = this.container().mouseX() - this._startWidth;
        this._oldWidth = this._column.displayWidth();
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		return true;
	},
	_doDrag: function (x, y) {
		var w, dx,
		    column = this._column,//cell.index().column,
		    x = this.container().mouseX() - this._offset;
		if (x >= 2) {
            dx = x - this._startWidth;
            w = column.displayWidth();
            if (!this.grid()._columnResizing(column, w + dx, w)) {
                return false;
            }
			ColumnGroup.changeWidth(column, dx, false, 2);
            this._startWidth = x;
		}
		return true;
	},
    _doCompleted: function () {
        var w = this._column.displayWidth();
        if (w != this._oldWidth) {
            this.grid()._columnResized(this._column, w, this._oldWidth);
        }
    }
});
var RowResizeTracker = defineClass("RowResizeTracker", GridDragTracker, {
	init: function(grid, request, x, y) {
		this._super(grid, "rowResizeTracker");
		this._request = request;
        this._rowIndex = request._itemIndex;
		var r = grid.lm().itemBounds(this._rowIndex - grid.topIndex());
		r.x += grid.x();
		r.y += grid.y();
		this._rowTop = r.y;
		this._rowBottom = r.bottom();
		this._offset = y - r.bottom();
        this._oldHeight = grid.getRowHeight(this._rowIndex);
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function(x, y) {
		return true;
	},
	_doDrag: function(x, y) {
		var grid = this._grid,
            hOld = grid.getRowHeight(this._rowIndex),
            h = y - this._offset - this._rowTop;
		if (h >= 2) {
            if (!grid._rowResizing(this._rowIndex, h, hOld)) {
                return false;
            }
			if (this._request._variable) {
				this._grid.setRowHeight(this._rowIndex, h)
			} else {
				this._grid.displayOptions().setRowHeight(h);
			}
		}
		return true;
	},
    _doCompleted: function () {
        var h = this._grid.getRowHeight(this._rowIndex);
        if (h != this._oldHeight) {
            this._grid._rowResized(this._rowIndex, h, this._oldHeight);
        }
    }
});
var HeaderResizeTracker = defineClass("HeaderResizeTracker", GridDragTracker, {
	init : function(grid, request, x, y) {
		this._super(grid, "headerResizeTracker");
		this._request = request;
		var r = grid.lm().headerBounds();
		this._headerTop = r.y;
		this._headerBottom = r.bottom();
		this._offset = y - r.bottom();
	},
	_doStart : function(x, y) {
		return true;
	},
	_doDrag : function(x, y) {
		if (this._grid.footer().visible() && y >= this._grid.lm().footerBounds().y) {
			return false;
		}
		if (y >= this._grid.lm().gridBounds().bottom()) {
			return false;
		}
		var h = y - this._offset - this._headerTop;
		if (h >= 2) {
			this._grid.header().setHeight(h);
		}
		return true;
	}
});
var HeaderSummaryResizeTracker = defineClass("HeaderSummaryResizeTracker", GridDragTracker, {
    init : function(grid, request, x, y) {
        this._super(grid, "headerResizeTracker");
        this._request = request;
        var r = grid.lm().summaryBounds();
        this._summaryTop = r.y;
        this._summaryBottom = r.bottom();
        this._offset = y - r.bottom();
    },
    _doStart : function(x, y) {
        return true;
    },
    _doDrag : function(x, y) {
        if (this._grid.footer().visible() && y >= this._grid.layoutManager().footerBounds().y) {
            return false;
        }
        if (y >= this._grid.lm().gridBounds().bottom()) {
            return false;
        }
        var h = y - this._offset - this._summaryTop;
        if (h >= 2) {
            this._grid.header().summary().setHeight(h);
        }
        return true;
    }
});
var FooterResizeTracker = defineClass("FooterResizeTracker", GridDragTracker, {
	init : function(grid, request, x, y) {
		this._super(grid, "footerResizeTracker");
		this._request = request;
		var r = grid.lm().footerBounds();
		this._footerTop = r.y;
		this._footerBottom = r.bottom();
		this._offset = y - r.y;
	},
	_doStart : function(x, y) {
		return true;
	},
	_doDrag : function(x, y) {
		if (this._grid.header().visible() && y < this._grid.lm().headerBounds().bottom()) {
			return false;
		}
		if (this._grid.panel() && this._grid.panel().visible() && y < this._grid.lm().panelBounds().bottom()) {
			return false;
		}
		if (y < 0) {
			return false;
		}
		var h = this._footerBottom - y + this._offset;
		if (h >= 2) {
			this._grid.footer().setHeight(h);
		}
		return true;
	}
});
/** @abstract */
var ColumnMoveTracker = defineClass("ColumnMoveTracker", GridDragTracker, {
    init: function (request, name) {
        this._super(request.cell().grid(), name);
        this._request = request;
        this._sourceFeedback = new HeaderCellElement(this._grid._dom, "columnMoveFeedback");
        this._sourceFeedback.setAlpha(0.7);
        this._targetFeedback = new ColumnMoveFeedback(this._grid._dom, "columnMoveTargetFeedback");
        this._targetFeedback.setAlpha(0.9);
        this.setNeedRedraw(true);
        this.setCancelable(true);
    },
    _doStart: function(x, y) {
        var cell = this._request.cell(),
        	grid = this.grid(),
			root = grid._rootElement,
        	r = cell.boundsBy(root);
        grid.addFeedbackElement(this._sourceFeedback);
        grid.addFeedbackElement(this._targetFeedback);
        this._sourceFeedback.setBounds(r.x, r.y, cell.width(), cell.height());
        this._sourceFeedback.updateCell(grid.header().getCell(cell.index()));
        this.$_setTarget(null);
        return true;
    },
    _doEnded: function () {
        var grid = this.grid();
        grid.removeFeedbackElement(this._targetFeedback);
        grid.removeFeedbackElement(this._sourceFeedback);
    },
    getNextRequest: function (x, y) {
        var grid = this.grid(),
			lm = grid.lm(),
            cell = this._request.cell(),
        	index = cell.index(),
			col = index.column;
		lm = grid.lm();
		y -= grid.y();
		if (y > lm.headerBounds().bottom() && grid.displayOptions().checkColumnExcludable(col)) {
			return new ColumnExcludeRequest(col);
		} else if (grid.operateOptions().groupingEnabled() && !grid.isRowEditing() && grid.groupPanel().visible()) {
            if (col instanceof DataColumn && col.groupable()) {
                if (y < lm.headerBounds().y && y >= lm.groupPanelBounds().y) {
                    return new RowGroupingRequest(cell);
                }
            }
        }
        return null;
    }
});
var ColumnMoveTracker2 = defineClass("ColumnMoveTracker2", ColumnMoveTracker, {
	init: function(request, x, y) {
		this._super(request, "columnMoveTracker2");
		var p = request.cell().index().column.parent();
		if (p.horizontal()) {
			this._startPos = x;
			this._orgPos = request.cell().boundsByContainer().x;
		} else {
			this._startPos = y;
			this._orgPos = request.cell().boundsByContainer().y;
		}
	},
	_doDrag: function (x, y) {
		var group, r, headerView, column2,
			cell = this._request.cell(),
			column = cell.getDelegateParent().index().column,
			target = null,
			grid = this.grid(),
			lm = grid.lm();
		y -= grid.y();
		if (y > lm.headerBounds().bottom() && grid.displayOptions().checkColumnExcludable(cell.index().column)) {
			return false;
		}
		if (grid.groupPanel().visible() && y >= lm.groupPanelBounds().y && y < lm.groupPanelBounds().bottom()) {
			return false;
		}
		if (column.group()) {
			target = cell;
			if (column instanceof ColumnGroup) {
				target = target.parent();
			}
			if (column.parent().horizontal()) {
				this._sourceFeedback.setX(this._orgPos + (this._currentX - this._startPos));
			} else {
				this._sourceFeedback.setY(this._orgPos + (this._currentY - this._startPos));
			}
			group = _cast(target.parent(), HeaderGroupCellElement);
			r = group.boundsByContainer();
			x -= r.x;
			y -= r.y;
			target = group.getCellAt(x, y);
		} else { // 최상위 셀들.
			if (column.parent().horizontal()) {
				this._sourceFeedback.setX(this._orgPos + (x - this._startPos));
			} else {
				this._sourceFeedback.setY(this._orgPos + (y - this._startPos));
			}
			headerView = grid.headerView();
			r = headerView.boundsByContainer();
			x -= r.x;
			y -= r.y;
			target = headerView.getCellAt(x, y);
			if (target == null && lm.fixedColCount() > 0 && grid.displayOptions().fixedColumnMovable()) {
				x += r.x;
				y += r.y;
				headerView = grid.fixedHeaderView();
				r = headerView.boundsByContainer();
				x -= r.x;
				y -= r.y;
				target = headerView.getCellAt(x, y);
			}
		}
		column2 = target ? target.index().column : null;
		if (target && column2.isRoot() && !grid.canMoveToIndex(column2.root().displayIndex())) {
			target = null;
		}
		if (!target || column2.group() == column.group()) {
			this.$_setTarget(target);
		}
		return true;
	},
	_doCompleted: function () {
		if (this._target) {
			var source = this._request.cell().getDelegateParent(),
				column = source.index().column;
			column.setDisplayIndex(this._target.index().column.displayIndex());
		}
	},
	$_setTarget: function (cell) {
		if (cell == this._target) {
			return;
		}
		var x1, x2, y1, y2, grid, lm, oldPos, r, root,
			source = this._request.cell().getDelegateParent(),
			column = source.index().column,
			group = _cast(column, ColumnGroup),
			target = this._target = cell;
		if (target) {
			grid = this.grid();
			root = grid._rootElement;
			lm = grid.lm();
			oldPos = grid.leftPos();
			grid.makeCellVisible(target.index());
			if (grid.leftPos() != oldPos) {
				grid.refreshView();
				grid.container().updateNow();
			}
			r = target.boundsBy(root);
			if (target === source) {
				this._targetFeedback._direction = "none";
			} else if (group && group === target.index().column) {
				this._targetFeedback.direction = "none";
			} else if (!column.group() || column.group().horizontal()) {
				if (lm.fixedColCount() > 0 && grid.displayOptions().fixedColumnMovable()) {
					x1 = target.boundsBy(root).x;
					x2 = group ? source.parent().boundsBy(root).x : source.boundsBy(root).x;
				} else {
					x1 = target.x();
					x2 = group ? source.parent().x() : source.x();
				}
				this._targetFeedback._direction = "horz";
				this._targetFeedback._reversed = x1 > x2;
			} else {
				y1 = target.y();
				y2 = group ? source.parent().y() : source.y();
				this._targetFeedback._direction = "vert";
				this._targetFeedback._reversed = y1 > y2;
			}
			this._targetFeedback.setBounds(r.x, r.y, target.width(), target.height());
			this._targetFeedback.setVisible(true);
			this._targetFeedback.invalidate();
		} else {
			this._targetFeedback.setVisible(false);
		}
	}
});
var ColumnMoveTracker3 = defineClass("ColumnMoveTracker3", ColumnMoveTracker, {
	init: function(request, x, y) {
		this._super(request, "columnMoveTracker3");
		var r = request.cell().boundsByContainer();
		this._startX = y;
		this._startY = y;
		this._orgX = r.x;
		this._orgY = r.y;
		this._target = null;
		this._dir = null;
	},
	_doDrag: function(x, y) {
		var header, r, target, column,
			cell = this._request.cell(),
			grid = this.grid(),
			lm = grid.lm();
		if (y > lm.headerBounds().bottom() && grid.displayOptions().checkColumnExcludable(cell.index().column)) {
			return false;
		}
        if (grid.groupPanel().visible() && y >= lm.groupPanelBounds().y && y < lm.groupPanelBounds().bottom()) {
            return false;
        }
		if (cell.index().column.parent().count() < 2) {
			return true;
		}
		this._sourceFeedback.setX(x);
		this._sourceFeedback.setY(y);
		header = grid.headerView();
		r = header.boundsByContainer();
		x -= r.x;
		y -= r.y;
		target = header.getCellAt(x, y, true);
		if (target == null && lm.fixedColCount() > 0 && grid.displayOptions().fixedColumnMovable()) {
			x += r.x;
			y += r.y;
			header = grid.fixedHeaderView();
			r = header.boundsByContainer();
			x -= r.x;
			y -= r.y;
			target = header.getCellAt(x, y);
		}
		column = target ? target.index().column : null;
		if (target && column.isRoot() && !grid.canMoveToIndex(column.root().displayIndex())) {
			target = null;
		}
		this.$_setTarget(target);
		return true;
	},
	_doCompleted: function() {
		if (this._target) {
			var source = this._request.cell().getDelegateParent(),
				colSource = source.index().column,
				colTarget = this._target.index().column;
			if (colTarget.parent() === colSource.parent()) {
				colSource.setDisplayIndex(colTarget.displayIndex());
			} else {
				colSource.setParent(colTarget.parent());
				colSource.setDisplayIndex(colTarget.displayIndex() + (this._dir == "r" ? 1 : 0));
			}
		}
	},
	$_setTarget: function(cell) {
		var equals, target, grid, root, lm, oldPos, dir, r, x1, x2, y1, y2,
			x = this.currentX(),
			y = this.currentY(),
			source = this._request.cell().getDelegateParent(),
			sourceColumn = source.index().column,
			column = cell ? cell.index().column : null;
		if (sourceColumn instanceof ColumnGroup && sourceColumn.isAncestorOf(column)) {
			return;
		}
		equals = cell == this._target;
		target = this._target = cell;
		if (target) {
			grid = this.grid();
			root = grid._rootElement;
			lm = grid.layoutManager();
			oldPos = grid.leftPos();
			if (!equals) {
				grid.makeCellVisible(target.index());
				if (grid.leftPos != oldPos) {
					grid.refreshView();
					grid.updateNow();
				}
			}
			r = target.boundsBy(root);
			if (target === source) {
				this._targetFeedback._direction = "none";
			} else if (!column.group() || column.group().horizontal()) {
				this._targetFeedback._direction = "horz";
				if (column.parent() == sourceColumn.parent() && !(column instanceof ColumnGroup)) {
					if (!equals) {
						if (lm.fixedColCount() > 0 && grid.displayOptions().fixedColumnMovable()) {
							x1 = target.boundsBy(root).x;
							x2 = (sourceColumn instanceof ColumnGroup) ? source.parent().boundsBy(root).x : source.boundsBy(root).x;
						} else {
							x1 = target.x();
							x2 = (sourceColumn instanceof ColumnGroup) ? source.parent().x() : source.x();
						}
						this._targetFeedback._reversed = x1 > x2;
					} 
				} else {
					x1 = target.width() / 2;
					x2 = x - r.x;
					dir = x2 > x1 ? "r" : "n";
					if (!equals || dir != this._dir) {
						this._dir = dir;
						if (column instanceof ColumnGroup) {
							r.height = target.parent().height();
						}
						this._targetFeedback._reversed = dir == "r";
					}
				}
			} else {
				this._targetFeedback._direction = "vert";
				if (column.parent() == sourceColumn.parent() && !(column instanceof ColumnGroup)) {
					y1 = target.y();
					y2 = (sourceColumn instanceof ColumnGroup) ? source.parent().y() : source.y();
					this._targetFeedback._reversed = y1 > y2;
				} else {
					y1 = target.height() / 2;
					y2 = y - r.y;
					dir = y2 > y1 ? "r" : "n";
					if (!equals || dir != this._dir) {
						this._dir = dir;
						if (column instanceof ColumnGroup) {
							r.width = target.parent().width();
							r.height = target.parent().height();
						}
						this._targetFeedback._reversed = dir == "r";
					}
				}
			}
			this._targetFeedback.setRect(r);
			this._targetFeedback.setVisible(true);
		} else {
			this._targetFeedback.setVisible(false);
		}
	}
});
var ColumnMoveFeedback = defineClass("ColumnMoveFeedback", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._direction = "none";	// "horz", "vert"
		this._reversed = false;
		this._lineNone = new SolidPen("rgba(0, 0, 0, 0.7)", 2);
		this._fillNone = new SolidBrush("rgba(0, 0, 0, 0.2)");
		this._line = new SolidPen(0xff000000, 2);
		this._fill = new SolidBrush(0xff000000);
	},
	_doDraw: function (g) {
		var x, y,
			r = this.getClientRect(this._drawRect);
		switch (this._direction) {
            case "horz":
                if (!this._reversed) {
                    y = r.height - 2;
                    g.drawBoundsI(this._fill, null, 0, 1, 3, y)
                     .drawLineI(this._line, 1, 1, 7, 1)
                     .drawLineI(this._line, 1, y, 7, y);
                } else {
                    x = r.width;
                    y = r.height - 2;
                    g.drawBoundsI(this._fill, null, x - 3, 1, 3, y)
                     .drawLineI(this._line, x - 1, 1, x - 7, 1)
                     .drawLineI(this._line, x - 1, y, x - 7, y);
                }
                break;
            case "vert":
                if (!this._reversed) {
                    w = r.width - 2;
                    g.drawBoundsI(this._fill, null, 1, 0, w, 3)
                     .drawLineI(this._line, 1, 1, 1, 7)
                     .drawLineI(this._line, w, 1, w, 7);
                } else {
                    x = r.width - 2;
                    y = r.height;
                    g.drawBoundsI(this._fill, null, 1, y - 3, x, 3)
                     .drawLineI(this._line, 1, y - 1, 1, y - 7)
                     .drawLineI(this._line, x, y - 1, x, y - 7);
                }
                break;
            default:
                g.drawRectI(this._fillNone, this._lineNone, r);
                break;
		}
	},
	_doDrawHtml: function () {
		this._doDraw(this.$_getGraphics(true));
	}
});
var ColumnExcludeTracker = defineClass("ColumnExcludeTracker", GridDragTracker, {
    init: function (grid, request) {
        this._super(grid, "columnExcludeTracker");
        this._request = request;
        this._columnView = null;
        this._border = new SolidPen(0xff999999, 1, [2, 2]);
        this._border2 = new SolidPen(0xff880000, 3, [2, 2]);
        this.setNeedRedraw(true);
        this.setCancelable(true);
    },
    request: function () {
        return this._request;
    },
    _doStart: function (x, y) {
        return true;
    },
    _canAccept: function (x, y) {
        var grid = this.grid(),
            lm = grid.lm();
        y -= grid.y();
        return y > lm.headerBounds().bottom();
    },
    _doCompleted: function () {
        var grid = this.grid(),
            col = this._request.column();
        grid.excludeColumn(col);
    },
    _showFeedback: function (x, y) {
        var can,
            grid = this.grid(),
            lm = grid.lm(),
            cv = this._columnView,
            index = CellIndex.temp(-1, this._request.column());
        if (!cv) {
            cv = this._columnView = new ColumnView(grid._dom, grid);
        }
        cv.updateCell(grid.header().getCell(index));
        cv.setBorder(this._border2);
        cv.setBounds(0, 0, 110, 22);
        cv.invalidate();
        grid.addFeedbackElement(this._columnView);
        cv.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
    },
    _moveFeedback: function (x, y) {
        var grid = this.grid(),
            lm = grid.lm(),
            cv = this._columnView;
        y -= grid.y();
        cv.setBorder(this._canAccept(x, y) ? this._border2 : this._border);
        cv.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
    },
    _hideFeedback: function () {
        this.grid().removeFeedbackElement(this._columnView);
    }
});
var CheckCellTracker = defineClass("CheckBarCellTracker", GridDragTracker, {
	init: function (request, x, y, ctrlKey) {
		this._super(request.cell().grid(), "checkCellTracker");
		this._request = request;
		this._prevRow = null;
		this._ctrlKey = ctrlKey;
	},
	_doStart: function (x, y) {
		this._super();
		return Boolean(this._request.cell().index().getRow(this.grid()));
	},
	_doDrag: function (x, y) {
		var index, row, exclusive,
			grid = this.grid(),
			lm = grid.layoutManager();
		this._currX = x = grid.containerToGridX(x);
		this._currY = y = grid.containerToGridY(y);
		if (x > lm.checkBarBounds().x && x < lm.checkBarBounds().right()
			&& y > lm.checkBarBounds().y && y < lm.checkBarBounds().bottom()) {
			index = grid.pointToIndex(x, y, false)
			row = index.getRow(grid);
			exclusive = grid.checkBar().exclusive();
			if (row != this._prevRow) {
				if (this._ctrlKey) {
					grid.isChecked(row) ? grid.setChecked(row, false, exclusive) : grid.setChecked(row, true, exclusive);
				} else {
					grid.setChecked(row, true, exclusive);
				}
				this._prevRow = row;
			}
			return true;
		}
		return false;
	}
})
var CellButtonTracker = defineClass("CellButtonTracker", GridDragTracker, {
	init: function (request) {
		this._super(request.cell().grid(), "cellButtonTracker");
		this._request = request;
		this._button = request._button;
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._request.cell().setButtonState(this._button, this._button);
		return true;
	},
	_doDrag: function (x, y) {
		var cell = this._request.cell(),
            hit = -1;
        if (this._button == 0) {
            if (cell.ptInButton(cell.mouseX(), cell.mouseY())) {
                hit = 0;
            }
        } else if (cell.ptInCustomButton(cell.mouseX(), cell.mouseY()) == this._button - 1) {
            hit = this._button;
        }
		cell.setButtonState(hit, hit);
		return true;
	},
	_canAccept: function (x, y) {
		var cell = this._request.cell(),
			p = cell.containerToElement(x, y);
		return cell.ptInButton(p.x, p.y) || cell.ptInCustomButton(p.x, p.y) >= 0;
	},
	_doCompleted: function () {
        var tool = this.grid().activeTool(),
            idx = this._request.cell().innerCellIndex();
        if (this._button == 0) {
            tool.cellButtonClicked(idx);
        } else {
            tool.customCellButtonClicked(idx, this._button - 1);
        }
	},
	_doEnded: function () {
		this._request.cell().setButtonState(-1, -1);
	}
});
var EditorButtonTracker = defineClass("EditorButtonTracker", GridDragTracker, {
	init: function (request) {
		this._super(request.cell().grid(), "editorButtonTracker");
		this._request = request;
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._request.cell().setEditorButtonState(true, true);
		return true;
	},
	_doDrag: function (x, y) {
		var cell = this._request.cell(),
			hit = cell.ptInButton(cell.mouseX(), cell.mouseY());
		cell.setEditorButtonState(hit, hit);
		return true;
	},
	_canAccept: function (x, y) {
		var cell = this._request.cell(),
			p = cell.containerToElement(x, y);
		return cell.ptInEditorButton(p.x, p.y);
	},
	_doCompleted: function () {
        this.grid().activeTool().editorButtonClicked(this._request.cell().innerCellIndex());
	},
	_doEnded: function () {
		this._request.cell().setEditorButtonState(false, false);
	}
});
var DataButtonTracker = defineClass("DataButtonTracker", GridDragTracker, {
    init: function (request) {
        this._super(request.cell().grid(), "dataButtonTracker");
        this._request = request;
    },
    isStartWhenCreated: function () {
        return true;
    },
    _doStart: function (x, y) {
        this._request.cell().setPressed(true);
        return true;
    },
    _doDrag: function (x, y) {
        var cell = this._request.cell(),
        	hit = cell.ptInDataButton(cell.mouseX(), cell.mouseY());
        cell.setPressed(hit);
        return true;
    },
    _canAccept: function (x, y) {
        var cell = this._request.cell(),
        	p = cell.containerToElement(x, y);
        return cell.ptInDataButton(p.x, p.y);
    },
    _doCompleted: function () {
		if (this._request.cell().clickable()) {
			this.grid().activeTool().dataButtonClicked(this._request.cell().index());
		}
    },
    _doEnded: function () {
        this._request.cell().setPressed(false);
    }
});
var AutoFill = defineClass("AutoFillOptions", GridBaseOptions, {
	init: function (grid, config) {
		this._super(grid);
	},
	enabled: false,
    checkReadOnly: false,
    /** 시리즈컬럼을 수정할 것인가? */
    includeSeries: false,
	stop: function () {
		this.grid().stopAutoFill();
	},
    assignSimple: function (value) {
        this.setEnabled(value);
    }
});
var AutoFillHandle = defineClass("AutoFillHandle", HandleElement, {
    init: function (dom, grid) {
        AutoFillHandle.Base.init.call(this, dom, grid, 'autoFillhandle');
        this._fill = new SolidBrush(0xff333333);
        this._stroke = new SolidPen(0xffffffff, 2);
        if (dom) {
            this._css.background = this._fill.css();
            this._css.borderLeft = this._css.borderTop = this._stroke.css();
        }
        this._clientRect = new Rectangle();
        this.setSize(8, 8);
    },
    grid: function () {
        return this._owner;
    },
    _hoveredChanged: function () {
    },
    _doDraw: function (g) {
        var r = this.getClientRect(this._clientRect);
        g.drawRect(this._fill, null, r);
        g.drawVLineI(this._stroke, r.x + 1, r.bottom(), r.y);
        g.drawHLineI(this._stroke, r.y + 1, r.x, r.right());
    }
});
var AutoFillView = defineClass("AutoFillView", LayerElement, {
	init: function (dom) {
		this._super(dom, "autoFillView");
        this._fill = new SolidBrush(0x080088ff);
		this._border = new SolidPen(0xff000000, 1, [3, 3]);
		this._direction = undefined;
		this._drawRect = new Rectangle()
	},
	refresh: function (direction, bounds) {
		if (direction != this._direction) {
			this._direction = direction;
			this.invalidate();
		}
		this.setRect(bounds);
	},
	_doDraw: function (g) {
		var x2, y2,
            r = this.getClientRect(this._drawRect);
        if (r.height <= 0) {
            return;
        }
        g.drawRectI(this._fill, null, r);
		x2 = r.right() - 1;
		y2 = r.bottom() - 1;
		switch (this._direction) {
			case "up":
				g.drawLinesI(this._border, r.x, y2, r.x, r.y, x2, r.y, x2, y2);
				break;
            case "down":
            default:
                g.drawLinesI(this._border, r.x, r.y, r.x, y2, x2, y2, x2, r.y);
                break;
        }
	},
    _doDrawHtml: function () {
        var css = this._css;
        css.background = this._fill.css();
        switch (this._direction) {
            case "up":
                css.borderBottom = null;
                css.borderLeft = css.borderRight = css.borderTop = this._border.css();
                break;
            case "down":
            default:
                css.borderTop = null;
                css.borderLeft = css.borderRight = css.borderBottom = this._border.css();
                break;
        }
    }
});
var AutoFillRequest = defineClass("AutoFillRequest", GridEditRequest, {
	init: function() {
		this._super();
	},
	cursor: function() {
		return Cursor.CROSSHAIR;
	},
	isSelectable: function() {
		return false;
	}
});
var AutoFillTracker = defineClass("AutoFillTracker", GridDragTracker, {
	init: function (grid, request) {
		this._super(grid, request, "autoFillTracker");
		this._direction = undefined;
		this._startIndex = new CellIndex();
		this._endIndex = new CellIndex();
		this._feedback = undefined;
		this._rect = new Rectangle();
        this._eltIndex = new CellIndex();
        this._selStart = null;
        this._selEnd = null;
        this._timer = null;
        this._currx = NaN;
        this._curry = NaN;
        this._rowPrevLoop = 0;
        this._rowLoop = 0;
        this._colPrevLoop = 0;
        this._colLoop = 0;
        this._interval = 0;
        this.setCancelable(true);
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		var grid = this._grid,
            sel = this.$_getSelection(grid);
		grid._autoFillHandle.setMouseEnabled(false);
		this._feedback = new AutoFillView(grid._dom);
		grid.addAutoFillElement(this._feedback);
        this._selStart = sel.startIndex().clone();
        this._selEnd = sel.endIndex().clone();
        this._startIndex.assign(this._selStart);
		return true;
	},
	_doDrag: function (x, y) {
		var elt, index, r, index,
            grid = this._grid,
            lm = grid.lm();
        this._currx = x = grid.containerToGridX(x);
        this._curry = y = grid.containerToGridY(y);
        if (y > lm.footerBounds().y || y < lm.gridBounds().y ||	x < lm.gridBounds().x || x > lm.clientRect().right()) {
            this.$_startTimer();
        } else {
            this.$_stopTimer();
            elt = this._findElementAt(x, y);
            if (elt instanceof CellElement) {
                index = this._eltIndex.assign(elt.index());
                if (elt instanceof DataCellElement && elt.mergeRoom()) {
                    r = elt.$_calcInnerIndex(grid, x, y);
                    if (r >= 0) {
                        index.rowIndex = r;
                    }
                }
                this.$_resizeTo(index);
            } else {
                index = grid.pointToIndex(this._currx, this._curry, false);
                if (index.column && index.rowIndex >= 0) {
                    index.rowIndex = Math.min(Math.max(index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
                    this.$_resizeTo(this._eltIndex.assign(index));
                }
            }
        }
        return true;
	},
	_canAccept: function (x, y) {
		return true;
	},
	_doCanceled: function () {
	},
	_doCompleted: function () {
        if (this._direction) {
            var result,
                idx1 = this._startIndex,
                idx2 = this._endIndex,
                grid = this._grid,
                ds = grid.dataSource(),
                sel = this.$_getSelection(grid);
            if (grid.$_autoFillComplete(sel, this._direction, idx1, idx2) === false) {
                return;
            }
            ds.beginUpdate();
            try {
                ds.beginActions();
                try {
                    if (sel.isSingleCell()) {
                        result = this.$_copySingleCell(grid, this._direction, idx1, idx2);
                    } else {
                        result = this.$_copyRows(grid, this._direction, idx1, idx2);
                    }
                } catch (e) {
                    ds.endActions(true);
                    throw e;
                } finally {
                    ds.endActions();
                }
            } finally {
                ds.endUpdate();
            }
            idx1.rowIndex = result.row1;
            idx2.rowIndex = result.row2;
            grid.$_autoFillCompleted(sel, this._direction, idx1, idx2);
        }
	},
	_doEnded: function () {
        var grid = this._grid;
        this.$_stopTimer();
		grid.removeAutoFillElement(this._feedback);
		grid._autoFillHandle.setMouseEnabled(true);
	},
    $_startTimer: function () {
        if (!this._timer) {
            this._rowLoop = this._rowPrevLoop = this._colLoop = this._colPrevLoop = 0;
            this._timer = setInterval(this.$_timerHandler.bind(this), 30);
        }
    },
    $_stopTimer: function () {
        if (this._timer) {
            clearInterval(this._timer);
            this._timer = null;
        }
    },
    $_timerHandler: function () {
        var cnt, index,
            grid = this._grid,
            lm = grid.lm(),
            x = this._currx,
            y = this._curry,
            cx = 0,
            cy = 0,
            scrolled = false;
        if (y > lm.footerBounds().y) {
            cy = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
            this._interval = 4 - cy;
            this._rowLoop++;
        } else if (y < lm.gridBounds().y) {
            cy = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
            this._interval = 4 - cy;
            this._rowLoop++;
        }
        if (x > lm.clientRect().right()) {
            cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
            this._interval = 4 - cx;
            this._colLoop++;
        } else if (x < lm.gridBounds().x) {
            cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
            this._interval = 4 - cx;
            this._colLoop++;
        }
        cnt = Math.max(cx, cy);
        if (cnt > 0) {
            this._interval = 4 - Math.max(cx, cy);
        }
        if (this._rowLoop - this._rowPrevLoop >= this._interval) {
            this._rowPrevLoop = this._rowLoop;
            if (y > lm.footerBounds().y) {
                if (grid.topRow() + lm.fullItemCount() < grid.rowCount()) {
                    grid.setTopIndex(grid.topIndex() + 1);
                    scrolled = true;
                }
            } else if (y < lm.gridBounds().y) {
                if (grid.topRow() > lm.fixedItemCount()) {
                    grid.setTopIndex(grid.topIndex() - 1);
                    scrolled = true;
                }
            }
        }
        if (!scrolled) {
            if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
                this._colPrevLoop = this._colLoop;
                if (x > lm.clientRect().right()) {
                    grid.setLeftCol(grid.leftCol() + 1);
                    scrolled = true;
                } else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
                    grid.setLeftCol(grid.leftCol() - 1);
                    scrolled = true;
                }
            }
        }
        if (scrolled) {
            index = grid.pointToIndex(this._currx, this._curry, false);
            if (index.column) {
                index.rowIndex = Math.min(Math.max(0, index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
                this.$_resizeTo(index);
            }
        }
    },
    $_getSelection: function (grid) {
        return grid.selections().lastItem();
    },
	$_calcDirection: function (index) {
        var dir,
		    grid = this._grid,
		    sel = this.$_getSelection(grid),
		    idx = this._startIndex;
        index = this._endIndex.assign(index);
		if (sel.isSingleCell()) {
			if (index.rowIndex > idx.rowIndex) {
				dir = "down";
			} else if (index.rowIndex < idx.rowIndex) {
                if (index.rowIndex >= 0 || idx.rowIndex >= grid.topIndex()) {
                    dir = "up";
                }
			}
            index.column = idx.column;
		} else {
            if (index.rowIndex > this._selEnd.rowIndex) {
                dir = "down";
            } else if (index.rowIndex < this._selStart.rowIndex) {
                dir = "up";
            }
            index.column = this._selEnd.column;
		}
		this._direction = dir;
	},
    $_rowIsVisible: function (index) {
        var grid = this._grid,
            lm = grid.lm(),
            t = grid.topIndex(),
            i = index.rowIndex,
            fixed = lm.fixedRowCount(),
            fulls = lm.fullItemCount();
        if (i >= fixed) {
            if (i < t + fixed) {
                return false;
            }
            if (fulls == 0 && i == t + fixed) {
                return true;
            }
            if (i >= t + fixed + fulls) {
                return false;
            }
        }
        return true;
    },
    $_resizeTo: function (index) {
        index = index.clone();
        this.$_calcDirection(index);
        if (this._direction) {
            var r2,
                grid = this._grid,
                lm = grid.layoutManager(),
                sel = this.$_getSelection(grid),
                single = sel.isSingleCell(),
                r = this._rect,
                idx = this._eltIndex;
            this._feedback.setVisible(true);
            switch (this._direction) {
                case "up":
                    idx.assign(this._selStart);
                    idx.rowIndex--;
                    grid.$_getSelectionRangeRect(lm, CellRange.temp(idx, this._endIndex), r, false);//single);
                    if (single) {
                        idx = grid.focusedIndex();
                        if (this.$_rowIsVisible(idx)) {
                            r.setBottom(lm.dataCellRect(idx).y);
                        } else {
                            r.setBottom(lm.gridBounds().bottom());
                        }
                        /*
                        idx = this._endIndex;
                        if (idx.rowIndex < grid.topIndex()) {
                            r.setTop(lm.bodyBounds().y);
                        }
                        if (idx.rowIndex >= grid.topIndex + lm.itemCount()) {
                            r.setBottom(lm.bodyBounds().bottom());
                        }
                        if (grid.focusedIndex() < grid.topIndex()) {
                            if (r.isEmpty()) debugger;
                        } else if (idx.rowIndex - grid.topIndex() > lm.itemCount()) {
                            r.setBottom(1000);
                            if (r.isEmpty()) debugger;
                        } else {
                            r2 = lm.dataCellRect(grid.focusedIndex());
                            r.setBottom(r2.y);
                            if (r.isEmpty()) debugger;
                        }
                        */
                        /*
                        if (this._endIndex.rowIndex < grid.topIndex()) {
                            r2 = lm.dataCellRect(grid.focusedIndex());
                            r.y = lm.itemBounds(0).y + lm.bodyBounds().y;
                            r.x = r2.x;
                            r.width = r2.width;
                        } else if (idx.rowIndex - this._endIndex.rowIndex >= lm.itemCount()) {
                            var bottomIdx = grid.getCellIndex(this._endIndex.rowIndex + lm.itemCount() - 1, idx.column);
                            r2 = lm.dataCellRect(bottomIdx);
                            if (r2.isEmpty()) { // focusedIndex가 그리드 아래가 될 때
                                r2.y = lm.gridBounds().bottom();
                            }
                        } else {
                            r2 = lm.dataCellRect(grid.focusedIndex());
                            if (r2.isEmpty()) { // focusedIndex가 그리드 아래가 될 때
                                r2.y = lm.gridBounds().bottom();
                            }
                        }
                        r.setBottom(r2.y);
                        if (r.isEmpty()) debugger;
                        */
                    }
                    break;
                case "down":
                default:
                    idx.assign(this._selStart);
                    idx.rowIndex = sel.endIndex().rowIndex + 1;
                    grid.$_getSelectionRangeRect(lm, CellRange.temp(idx, this._endIndex), r, false);//single);
                    if (single) {
                        idx = grid.focusedIndex();
                        if (this.$_rowIsVisible(idx)) {
                            r.setTop(lm.dataCellRect(idx).bottom());
                        } else {
                            r.setTop(lm.gridBounds().y);
                        }
                    }
                    break;
            }
            if (!this._direction) r.width = 0;
            this._feedback.refresh(this._direction, r);
        } else {
            this._feedback.setVisible(false);
        }
    },
    $_canCopy: function (grid, row, col) {
        return !grid.getReadOnlyAt(row, col);
    },
	$_copySingleCell: function (grid, dir, idx1, idx2) {
        var i,
            check = grid.autoFill().checkReadOnly(),
            col = idx1.column,
            res = { row1: -1, row2: -1 },
            v = idx1.getValue();
		switch (dir) {
			case "up":
				i = CellIndex.temp(idx2);
                res.row2 = i.rowIndex;
				while (i.rowIndex < idx1.rowIndex) {
                    if (!check || this.$_canCopy(grid, i.getDataIndex(grid), col)) {
                        i.setValue(v);
                    }
                    res.row1 = i.rowIndex;
					i.rowIndex++;
				}
				break;
            case "down":
            default:
                i = CellIndex.temp(idx1);
                res.row1 = i.rowIndex + 1;
                while (i.rowIndex < idx2.rowIndex) {
                    i.rowIndex++;
                    if (!check || this.$_canCopy(grid, i.getDataIndex(grid), col)) {
                        i.setValue(v);
                    }
                }
                res.row2 = i.rowIndex;
                break;
        }
        grid.setSelection(idx1, idx2, SelectionStyle.BLOCK);
        return res;
	},
    $_getCopyVals: function (ds, grid, row, columns, vals) {
        var j, col, prop,
            obj = {};
        for (j = columns.length; j--;) {
            col = columns[j];
            if (this.$_canCopy(grid, row.dataIndex(), col)) {
                prop = ds.getFieldName(col.dataIndex());
                obj[prop] = vals[prop]
            }
        }
        return obj;
    },
	$_copyRows: function (grid, dir, idx1, idx2) {
        var i, j, idx, diff, r, row, col, vals, prop, obj,
            check = grid.autoFill().checkReadOnly(),
            sel = this.$_getSelection(grid),
		    range = sel.getBounds(),
            selRows = [],
            targets = [],
            columns = grid.collectDataColumns(range.C1(), range.C2()),
            ds = grid.dataSource(),
            res = { row1: -1, row2: -1},
            fields = [];
        for (i = columns.length; i--;) {
            idx = columns[i].dataIndex();
            if (idx >= 0) {
                idx = ds.getFieldName(idx);
                if (fields.indexOf(idx) < 0) {
                    fields.push(idx);
                }
            }
        }
        if (dir == "up") {
            for (r = idx2.rowIndex; r < range.R1(); r++) {
                row = grid.getRow(r);
                if (row.dataIndex() >= 0) {
                    targets.push(row);
                }
            }
            if (targets.length > 0) {
                res.row2 = targets[0].index();
                res.row1 = targets[targets.length - 1].index();
            }
            for (r = range.R1(); r <= range.R2(); r++) {
                row = grid.getRow(r);
                if (row.dataIndex() >= 0) {
                    selRows.push(row.getRowProps(fields));
                }
            }
            for (r = targets.length - 1; r >= 0; r -= selRows.length) {
                for (i = 0; i < selRows.length && r - i >= 0; i++) {
                    row = targets[r - i];
                    vals = selRows[selRows.length - i - 1];
                    if (check) {
                        obj = this.$_getCopyVals(ds, grid, row, columns, vals);
                        row.setRowProps(obj);
                    } else {
                        row.setRowProps(vals);
                    }
                }
            }
            idx1.rowIndex = range.R2();
            grid.setSelection(idx2, idx1, SelectionStyle.BLOCK);
        } else {
            for (r = range.R2() + 1; r <= idx2.rowIndex; r++) {
                row = grid.getRow(r);
                if (row.dataIndex() >= 0) {
                    targets.push(row);
                }
            }
            if (targets.length > 0) {
                res.row1 = targets[0].index();
                res.row2 = targets[targets.length - 1].index();
            }
            for (r = range.R1(); r <= range.R2() && selRows.length < targets.length; r++) {
                row = grid.getRow(r);
                if (row.dataIndex() >= 0) {
                    selRows.push(row.getRowProps(fields));
                }
            }
            for (r = 0; r < targets.length; r += selRows.length) {
                for (i = 0; i < selRows.length && r + i < targets.length; i++) {
                    row = targets[r + i];
                    vals = selRows[i]
                    if (check) {
                        obj = this.$_getCopyVals(ds, grid, row, columns, vals);
                        row.setRowProps(obj);
                    } else {
                        row.setRowProps(vals);
                    }
                }
            }
            grid.setSelection(idx1, idx2, SelectionStyle.BLOCK);
        }
        return res;
	}
});
var SelectRequest = defineClass("SelectRequest", CellRequest, {
	init: function(manager, cell, style) {
		this._super(cell);
		this._manager = manager;
		this._style = style;
	},
	manager: function () {
		return this._manager;
	},
	selectStyle: function () {
		return this._style;
	}
});
var SelectTracker = defineClass("SelectTracker", GridDragTracker, {
	init: function(request, name, extended) {
		this._super(request.cell().grid(), name);
		this._request = request;
        this._single = SelectionStyle.isSingle(request.selectStyle());
		this._extended = extended;
	},
	isStartWhenCreated: function () {
        var cell = this._request.cell();
		if (cell instanceof StateCellElement ||
            cell instanceof GroupFooterCellElement ||
			cell instanceof RowGroupHeaderCellElement || // for merged grouping
            cell instanceof BandedRowGroupHeaderCellElement) {
            return false;
        }
        return true;
	},
    _doStart: function () {
    },
	_doEnded: function() {
		var item = this._getItem();
        item && this.grid().selections()._itemEnded(item);
	},
	_getItem: function () {
		return null;
	},
	$_calcInnerIndex: function (cell, index, x, y) {
		if (cell instanceof MergedDataCellElement || cell instanceof MergedSeriesCellElement) {
			var r = cell.$_calcInnerIndex(this._grid, x, y);
			if (r >= 0) {
				index = index.clone();
				index.rowIndex = r;
			}
		}
		return index;
	}
});
var BlockSelectTracker = defineClass("BlockSelectTracker", SelectTracker, {
	init : function(request, extended) {
		this._super(request, "blockSelectTracker", extended);
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._rowPrevLoop = 0;
		this._rowLoop = 0;
		this._colPrevLoop = 0;
		this._colLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
        this._super();
		var item, idx,
			cell = this._request.cell(),
			manager = this._request.manager();
		idx = cell.index().clone();
		if (cell instanceof MergedDataCellElement || cell instanceof MergedSeriesCellElement) {
			idx.rowIndex += cell._innerIndex;
		}
		manager.setItemStyle(SelectionStyle.BLOCK, !this._extended);
        /*
		if (shift) {
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.BLOCK);
		}
		*/
		if (this._extended) {
			this._item = manager.add(idx, idx, SelectionStyle.BLOCK);
		} else if (manager.isSingleCell() && (item = manager.getItem(0)) instanceof BlockSelection && item.contains(idx)) {
            this._item = item;
        } else {
            manager.clear();
            this._item = manager.add(idx, idx, SelectionStyle.BLOCK);
        }
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
        if (this._single) {
            return true;
        }
        var elt, index,
            grid = this.grid(),
            lm = grid.layoutManager(),
            item = this._item;
        if (item) {
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (y > lm.footerBounds().y || y < lm.gridBounds().y ||	x < lm.gridBounds().x || x > lm.clientRect().right()) {
				this._startTimer();
			} else {
				this._stopTimer();
                elt = this._findElementAt(x, y);
                if (elt) {
                    elt = elt.getParentAs(CellElement);
                    if (elt) {
                        index = elt.index();
                        if (index.column && index.rowIndex >= 0) {
                            index = this.$_calcInnerIndex(elt, index, x, y);
                            item.resizeTo(index);
                        }
                    } else {
                        index = grid.pointToIndex(this._currx, this._curry, false);
                        if (index.column && index.rowIndex >= 0) {
                            index.rowIndex = Math.min(Math.max(index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
                            this._item.resizeTo(index);
                        }
                    }
                }
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._rowLoop = this._rowPrevLoop = this._colLoop = this._colPrevLoop = 0;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var scrolled, cnt, index,
			grid = this._grid,
        	lm = grid.layoutManager(),
			x = this._currx,
			y = this._curry,
			cx = 0,
			cy = 0;
		if (y > lm.footerBounds().y) {
			cy = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		} else if (y < lm.gridBounds().y) {
			cy = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		}
		if (x > lm.clientRect().right()) {
			cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		} else if (x < lm.gridBounds().x) {
			cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		}
		scrolled = false;
		cnt = Math.max(cx, cy);
		if (cnt > 0) {
			this._interval = 4 - Math.max(cx, cy);
		}
		if (this._rowLoop - this._rowPrevLoop >= this._interval) {
			this._rowPrevLoop = this._rowLoop;
			if (y > lm.footerBounds().y) {
				if (grid.topRow() + lm.fullItemCount() < grid.rowCount()) {
					grid.setTopIndex(grid.topIndex() + 1);
					scrolled = true;
				}
			} else if (y < lm.gridBounds().y) {
				if (grid.topRow() > lm.fixedItemCount()) {
					grid.setTopIndex(grid.topIndex() - 1);
					scrolled = true;
				}
			}
		}
		if (!scrolled) {
			if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
				this._colPrevLoop = this._colLoop;
				if (x > lm.clientRect().right()) {
					grid.setLeftCol(grid.leftCol() + 1);
					scrolled = true;
				} else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
					grid.setLeftCol(grid.leftCol() - 1);
					scrolled = true;
				}
			}
		}
		if (scrolled) {
			index = grid.pointToIndex(this._currx, this._curry, false);
			if (index.column) {
				index.rowIndex = Math.min(Math.max(0, index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
				this._item.resizeTo(index);
			}
		}
	}
});
var RowsSelectTracker = defineClass("RowsSelectTracker", SelectTracker, {
	init: function (request, extended) {
		this._super(request, "rowsSelectTracker", extended);
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._prevLoop = 0;
		this._loop = 0;
		this._colPrevLoop = 0;
		this._colLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
        this._super();
		var item, idx,
			cell = this._request.cell(),
			manager = this._request.manager();
		idx = cell.index().clone();
		if (cell instanceof MergedDataCellElement) {
			idx.rowIndex += cell._innerIndex;
		}
		manager.setItemStyle(SelectionStyle.ROWS, !this._extended);
        /*
		if (shift) {
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.ROWS);
		}
		*/
		if (this._extended) {
			this._item = manager.add(idx, idx, SelectionStyle.ROWS, this._single);
		} else if (manager.count() == 1 && (item = manager.getItem(0)) instanceof RowSelection && item._single == this._single && item.contains(idx)) {
            this._item = item;
        } else {
            manager.clear();
            this._item = manager.add(idx, idx, SelectionStyle.ROWS, this._single);
        }
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
        if (this._single) {
            return true;
        }
		if (this._item) {
			var index,
				grid = this.grid(),
				lm = grid.layoutManager();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (y > lm.footerBounds().y || y < lm.gridBounds().y || x < 0 || x > lm.clientRect().right()) {
				this._startTimer();
			} else {
				this._stopTimer();
				index = grid.pointToIndex(x, y, false);
				if (index.getRow(grid)) {
					this._item.resizeTo(index);
				}
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._loop = this._prevLoop = this._colLoop = this._colPrevLoop = 0;
			this._interval = 1;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var cnt, index,
			grid = this._grid,
			x = this._currx,
			y = this._curry,
			lm = grid.layoutManager();
		if (y > lm.footerBounds().y) {
			cnt = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		} else if (y < lm.gridBounds().y) {
			cnt = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		}
		if (this._loop - this._prevLoop >= this._interval) {
			this._prevLoop = this._loop;
			if (y > lm.footerBounds().y) {
				grid.setTopIndex(grid.topIndex() + 1);
			} else if (y < lm.gridBounds().y) {
				grid.setTopIndex(grid.topIndex() - 1);
			}
			index = grid.pointToIndex(this._currx, this._curry, false); // 이 함수가 한 칸씩 밀어준다.
				index.rowIndex = Math.min(Math.max(0, index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
				this._item.resizeTo(index);
		} else {
			if (x > lm.clientRect().right()) {
				cnt = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
				this._interval = 4 - cnt;
				this._colLoop++;
			} else if (x < 0) {
				cnt = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
				this._interval = 4 - cnt;
				this._colLoop++;
			}
			if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
				this._colPrevLoop = this._colLoop;
				if (x > lm.clientRect().right()) {
					grid.setLeftCol(grid.leftCol() + 1);
				} else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
					grid.setLeftCol(grid.leftCol() - 1);
				}
				index = grid.pointToIndex(this._currx, this._curry, false);
				if (index.rowIndex >= 0) {
					index.rowIndex = Math.min(Math.max(0, index.rowIndex, grid.topIndex()), grid.rowCount() - 1);
					this._item.resizeTo(index);
				}
			}
		}
	}
});
var ColumnsSelectTracker = defineClass("ColumnsSelectTracker", SelectTracker, {
	init: function (request, extended) {
		this._super(request, "columnsSelectTracker", extended);
        this._single = SelectionStyle.isSingle(request.selectStyle());
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._prevLoop = 0;
		this._loop = 0;
		this._rowPrevLoop = 0;
		this._rowLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
        this._super();
		var item,
        	idx = this._request.cell().index(),
			manager = this._request.manager();
		manager.setItemStyle(SelectionStyle.COLUMNS, !this._extended);
        /*
		if (shift) {
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.COLUMNS);
		}
		*/
		if (this._extended) {
			this._item = manager.add(idx, idx, SelectionStyle.COLUMNS);
		} else if (manager.count() == 1 && (item = manager.getItem(0)) instanceof ColumnSelection && item.contains(idx)) {
            this._item = item;
        } else {
            manager.clear();
            this._item = manager.add(idx, idx, SelectionStyle.COLUMNS);
        }
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
        if (this._single) {
            return true;
        }
		if (this._item) {
			var grid = this.grid(),
				lm = grid.layoutManager();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (x < lm.gridBounds().x || x > lm.clientRect().right() || y > lm.footerBounds().y || y < 0) {
				this._startTimer();
			} else {
				this._stopTimer();
				var index = grid.pointToIndex(x, y, false);
				if (index.column) {
					this._item.resizeTo(index);
				}
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._loop = this._prevLoop = this._rowLoop = this._rowPrevLoop = 0;
			this._interval = 1;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var index, cnt,
			grid = this._grid,
			x = this._currx,
			y = this._curry,
			lm = grid.layoutManager();
		if (x > lm.clientRect().right()) {
			cnt = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		} else if (x < lm.gridBounds().x) {
			cnt = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		}
		if (this._loop - this._prevLoop >= this._interval * 2) {
			this._prevLoop = this._loop;
			if (x > lm.clientRect().right()) {
				grid.setLeftCol(grid.leftCol() + 1);
			} else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
				grid.setLeftCol(grid.leftCol() - 1);
			}
			index = grid.pointToIndex(this._currx, this._curry, false);
			if (index.column) {
				this._item.resizeTo(index);
			}
		} else {
			if (y > lm.footerBounds().y) {
				cnt = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
				this._interval = 4 - cnt;
				this._rowLoop++;
			} else if (y < 0) {
				cnt = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
				this._interval = 4 - cnt;
				this._rowLoop++;
			}
			if (this._rowLoop - this._rowPrevLoop >= this._interval) {
				this._rowPrevLoop = this._rowLoop;
				if (y > lm.footerBounds().y) {
					grid.setTopIndex(grid.topIndex() + 1);
				} else if (y < lm.gridBounds().y) {
					grid.setTopIndex(grid.topIndex() - 1);
				}
				index = grid.pointToIndex(this._currx, this._curry, false);
				if (index.column) {
					this._item.resizeTo(index);
				}
			}
		}
	}
});
var SelectionItem = defineClass("SelectionItem", null, {
	init: function(manager) {
		this._super();
		this._manager = manager;
        this._grid = manager.grid();
	},
    manager: function () {
        return this._manager;
    },
    grid: function () {
        return this._grid;
    },
	style: function () {
		_throwAbstractError();
	},
	isSingleCell: function () {
		return false;
	},
	getBounds: function () {
		return null;
	},
	contains: function (index) {
		return false;
	},
	intersects: function (index1, index2) {
		return false;
	},
	containedInFixedColumns: function (fixedCols) {
		return false;
	},
	containedInFixedRows: function (fixedRows) {
		return false;
	},
	resizeTo: function (endIndex) {
	},
    getAnchor: function (index) {
        return index;
    },
	intersectsWith: function (item) {
        return this.getBounds().intersectsWith(item.getBounds());
	},
	mergeWith: function (item) {
		_throwAbstractError();
	},
	getData: function (maxRows) {
		_throwAbstractError();
	},
    getRows: function (all) {
        var r, row,
            grid = this.grid(),
            rows = [],
            range = this.getBounds(),
            r1 = Math.min(range.R1(), range.R2()),
            r2 = Math.max(range.R1(), range.R2());
        for (r = r1; r <= r2; r++) {
            row = grid.getRow(r);
            if (row && (all || row.dataIndex() >= 0 || row.isEditing())) {
                rows.push(row);
            }
        }
        return rows;
    },
    getRowIndices: function (all) {
        var i, cnt, row,
            rows = this.getRows(all),
            indices = [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = rows[i];
            row && indices.push(row.index());
        }
        return indices;
    },
    getDataIndices: function (all) {
        var i, cnt, row,
            rows = this.getRows(all);
            indices = [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = rows[i];
            if (row) {
                r = row.dataIndex();
                if (r >= 0 || all) {
                    indices.push(r);
                }
            }
        }
        return indices;
    },
    /** 영역에 포함된 모든 셀의 값을 동시에 같은 값으로 변경한다 */
    setValue: function (value) {
    },
	_mergedSel: function () {
		return this.grid()._displayOptions.mergedSelection();
	},
	_resized: function () {
		this._manager && this._manager._itemResized(this);
	},
    _getRoom: function (col, row) {
        return col.stateFor(ColumnMergeManager.MERGE_ROOMS).getRoomAtRow(row, true);
    }
}, {
	$_index: new CellIndex()
});
var SelectionManager = defineClass("SelectionManager", EventAware, {
	init: function(grid) {
		this._super();
		this._grid = grid;
		this._items = [];
		this._locked = false;
	},
	itemStyle: EnumProp(SelectionStyle, SelectionStyle.BLOCK),
	setItemStyle: function (value, clear) {
        clear = arguments.length > 0 ? clear : true;
		if (value != this._itemStyle) {
			this._itemStyle = value;
			clear && this.clear();
		}
	},
	grid: function () {
		return this._grid;
	},
	count: function () {
		return this._items.length;
	},
    items: function () {
        return this._items.concat();
    },
	lastItem: function () {
		var len = this._items.length;
		return len ? this._items[len - 1] : null;
	},
	isSingleCell: function () {
		return this._items.length == 1 && this._items[0].isSingleCell();
	},
	lock: function () {
		this._locked = true;
	},
	unlock: function () {
		this._locked = false;
	},
	getItem: function (index) {
		return this._items[index];
	},
	indexOf: function (item) {
		return this._items.indexOf(item);
	},
	add: function (start, end, style, single) {
		if (this._locked) return null;
		if (style == SelectionStyle.NONE) {
			this.clear();
			return null;
		}
		var item = null;
		switch (style) {
			case SelectionStyle.COLUMNS:
				if (start.column) {
					item = new ColumnSelection(this, start.column, end ? end.column : start.column);
				}
				break;
			case SelectionStyle.SINGLE_COLUMN:
				if (start.column) {
					item = new ColumnSelection(this, start.column, start.column);
				}
				break;
			case SelectionStyle.ROWS:
				item = new RowSelection(this, start.rowIndex, end.rowIndex, single);
				break;
			case SelectionStyle.SINGLE_ROW:
				item = new RowSelection(this, start.rowIndex, start.rowIndex, true);
				break;
			case SelectionStyle.BLOCK:
				item = new BlockSelection(this, start, end);
				break;
			case SelectionStyle.SINGLE:
				item = new BlockSelection(this, start, start);
				break;
		}
		return this._addItem(item);
	},
	remove: function (item) {
		if (this._locked) return;
        var index = parseInt(item);
        if (isNaN(index)) {
            index = this._items.indexOf(item);
        }
		if (index >= 0 && index < this._items.length) {
            item = this._items[index];
			this._items.splice(index, 1);
			this.fireEvent(SelectionManager.REMOVED, item);
            this.fireEvent(SelectionManager.CHANGED, item);
		}
	},
	clear: function () {
		if (this._locked) return;
		if (this._items.length > 0) {
			this._items.length = 0;
			this.fireEvent(SelectionManager.CLEARED);
            this.fireEvent(SelectionManager.CHANGED);
		}
	},
	contains: function (index) {
		return this._items.length > 0 && this._items[0].contains(index);
	},
	containsItem: function (itemIndex) {
		return false;
	},
	containsColumn: function (column) {
		return false;
	},
	normalize: function () {
	},
	getFirstCell: function () {
		if (this._items.length > 0) {
			return this._items[0].getBounds().firstCell();
		}
		return null;
	},
	_addItem: function (item) {
		if (item && this._items.indexOf(item) < 0) {
			this._items.push(item);
			this.fireEvent(SelectionManager.ADDED, item);
            this.fireEvent(SelectionManager.CHANGED, item);
		}
		return item;
	},
	_itemResized: function (item) {
		this.fireEvent(SelectionManager.RESIZED, item);
        this.fireEvent(SelectionManager.CHANGED, item);
	},
    _itemEnded: function (item) {
        this.fireEvent(SelectionManager.ENDED, item);
    },
});
SelectionManager.CHANGED = "onSelectionManagerChanged";
SelectionManager.ADDED = "onSelectionManagerAdded";
SelectionManager.REMOVED = "onSelectionManagerRemoved";
SelectionManager.CLEARED = "onSelectionManagerCleared";
SelectionManager.RESIZED = "onSelectionManagerResized";
SelectionManager.ENDED = "onSelectionManagerEnded";
var BlockSelection = defineClass("BlockSelection", SelectionItem, {
	init: function(manager, startIndex, endIndex) {
		this._super(manager);
		this._startIndex = startIndex.clone();
		this._endIndex = endIndex.clone();
        this.$_fitMerged();
	},
	startIndex: function () {
		return this._startIndex;
	},
	endIndex: function () {
		return this._endIndex;
	},
	rowCount: function () {
		return Math.abs(this._startIndex.rowIndex - this._endIndex.rowIndex) + 1;
	},
	style: function () {
		return SelectionStyle.BLOCK;
	},
	isSingleCell: function () {
		return CellIndex.areEqual(this._startIndex, this._endIndex);
	},
	getBounds: function () {
		var view, room, c1, c2, r,
			idx1 = this._startIndex,
			idx2 = this._endIndex,
			grid = this.grid();
		idx1.normalize(grid);
		idx2.normalize(grid);
		/*if (CellIndex.areEqual(idx1, idx2)) {
			view = grid.$_getMergeCell(idx1);
			if (view) {
				room = view.mergeRoom();
				c1 = idx1.column ? idx1.column.dataRoot() : null;
				return CellRange.createRange(room.headItem(), c1, room.tailItem(), c1);
			} else {
				return CellRange.create(idx1);
			}
		} else*/ {
			c1 = idx1.column ? idx1.column.dataRoot() : null;
			c2 = idx2.column ? idx2.column.dataRoot() : null;
			return CellRange.createRange(idx1.rowIndex, c1, idx2.rowIndex, c2);
		}
	},
	contains: function (index) {
		return this.getBounds().containsIndex(index);
	},
	intersects: function (index1, index2) {
		return this.getBounds().intersects(index1, index2);
	},
	containedInFixedColumns: function (fixedCols) {
		return this._startIndex.column.root().displayIndex() < fixedCols || this._endIndex.column.root().displayIndex() < fixedCols;
	},
	containedInFixedRows: function (fixedRows) {
		return this._startIndex.rowIndex < fixedRows || this._endIndex.rowIndex < fixedRows;
	},
    getAnchor: function (index) {
        index = index || new CellIndex();
        index.assign(this._endIndex);
        return index;
    },
	resizeTo: function (newEnd) {
		var oldIndex, grid = this.grid();
		if (grid.isValidCell(newEnd) && !CellIndex.areEqual(newEnd, this._endIndex)) {
			if (this._mergedSel()) {
				oldIndex = this._endIndex.copyTo(SelectionItem.$_index);
				this._endIndex.assign(newEnd);
				this.$_fitMerged();
				if (!CellIndex.areEqual(oldIndex, this._endIndex)) {
					this._resized();
				}
			} else {
				this._endIndex.assign(newEnd);
				this._resized();
			}
		}
	},
	mergeWith: function (item) {
	},
	getData: function (maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
        var cnt, r1, r2, rows, r, item, row, c, col, p,
            grid = this.grid(),
		    columns = grid.collectDataColumns(this._startIndex.column, this._endIndex.column);
		if (!columns || (cnt = columns.length) < 1) {
			return null;
		}
		r1 = Math.min(this._startIndex.rowIndex, this._endIndex.rowIndex);
		r2 = Math.max(this._startIndex.rowIndex, this._endIndex.rowIndex);
		rows = [];
		for (r = r1; r <= r2; r++) {
			item = grid.getRow(r);
			if (item && item.dataIndex() >= 0) {
				row = {};
				for (c = 0; c < cnt; c++) {
					col = columns[c];
					p = col.dataFieldName();
					p && (row[p] = item.getValue(col.dataIndex()));
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	},
    toString: function () {
        var	r1 = Math.min(this._startIndex.rowIndex, this._endIndex.rowIndex),
            r2 = Math.max(this._startIndex.rowIndex, this._endIndex.rowIndex);
		if (this._startIndex.column && this._endIndex.column) {
			return '(' + r1 + ', ' + this._startIndex.column.name() + ') ~ (' + r2 + ', ' + this._endIndex.column.name() + ')';
		} else {
			return "";
		}
    },
    $_fitMerged: function () {
        var c, i, j, c1, c2, c3, r1, r2, d1, d2, room1, room2, reversed,
            grid = this.grid(),
            idx1 = this._startIndex,
            idx2 = this._endIndex;
		if (!this._mergedSel()) return;
        d1 = idx1.column.distance();
        d2 = idx2.column.distance();
		c1 = idx1.column.root().displayIndex();
        c2 = idx2.column.root().displayIndex();
        if (c1 > c2) {
            c = c1;
            c1 = c2;
            c2 = c;
            d = d1;
            d1 = d2;
            d2 = d;
        }
		r1 = idx1.rowIndex;
		r2 = idx2.rowIndex;
		reversed = r1 > r2;
		for (i = c1; i <= c2; i++) {
			c = grid.getVisibleColumn(i);
			if (c instanceof ValueColumn && c.canMerge()) {
                room1 = this._getRoom(c, idx1.rowIndex);
                room2 = this._getRoom(c, idx2.rowIndex);
				if (reversed) {
					room1 && (r1 = Math.max(r1, room1.tailItem()));
					room2 && (r2 = Math.min(r2, room2.headItem()));
				} else {
					room1 && (r1 = Math.min(r1, room1.headItem()));
					room2 && (r2 = Math.max(r2, room2.tailItem()));
				}
			}
            else if (c instanceof ColumnGroup) {
                for (j = c.visibleCount(); j--;) {
                    c3 = c.getVisibleItem(j);
                    if (c3 instanceof ValueColumn && c3.canMerge() && c3.distance() >= d1 && c3.distance() <= d2) {
                        room1 = this._getRoom(c3, idx1.rowIndex);
                        room2 = this._getRoom(c3, idx2.rowIndex);
                        if (reversed) {
                            room1 && (r1 = Math.max(r1, room1.tailItem()));
                            room2 && (r2 = Math.min(r2, room2.headItem()));
                        } else {
                            room1 && (r1 = Math.min(r1, room1.headItem()));
                            room2 && (r2 = Math.max(r2, room2.tailItem()));
                        }
                    }
                }
            }
		}
		idx1.rowIndex = r1;
		idx2.rowIndex = r2;
    }
});
var RowSelection = defineClass("RowSelection", SelectionItem, {
	init : function(manager, startRow, endRow, single) {
		this._super(manager);
		this._single = single;
		this._startRow = Math.min(startRow, endRow);
		this._endRow = Math.max(startRow, endRow);
        this._mergedSel() && this.$_fitMerged();
	},
	startRow: function() {
		return this._startRow;
	},
	endRow: function() {
		return this._endRow;
	},
	topRow: function () {
		return Math.min(this._startRow, this._endRow);
	},
	bottomRow: function () {
		return Math.max(this._startRow, this._endRow);
	},
    startIndex: function () {
        return CellIndex.create(this._startRow, this.grid().getFirstColumn());
    },
    endIndex: function () {
        return CellIndex.create(this._endRow, this.grid().getLastColumn());
    },
	style : function() {
		return SelectionStyle.ROWS;
	},
	getBounds: function () {
        var grid = this.grid();
		var itemCount = grid.rowCount();
		this._startRow = Math.max(0, Math.min(itemCount - 1, this._startRow));
		this._endRow = Math.max(0, Math.min(itemCount - 1, this._endRow));
		if (this._startRow <= this._endRow) {
			return CellRange.createRange(this._startRow, grid.getVisibleColumn(0), this._endRow, grid.getVisibleColumn(grid.visibleColumnCount() - 1));
		} else {
			return CellRange.createRange(this._endRow, grid.getVisibleColumn(0), this._startRow, grid.getVisibleColumn(grid.visibleColumnCount() - 1));
		}
	},
	contains: function (index) {
		var r1 = Math.min(this._startRow, this._endRow);
		var r2 = Math.max(this._startRow, this._endRow);
		return (index.rowIndex >= r1) && (index.rowIndex <= r2);
	},
	intersects: function (index1, index2) {
		var r1 = Math.min(index1.rowIndex, index2.rowIndex),
		    r2 = Math.max(index1.rowIndex, index2.rowIndex),
            row1 = Math.min(this._startRow, this._endRow),
            row2 = Math.max(this._startRow, this._endRow);
        return (r1 <= row2) && (row1 <= r2);
	},
	containedInFixedColumns: function (fixedCols) {
		return true;
	},
	containedInFixedRows: function (fixedRows) {
		return this._startRow < fixedRows || this._endRow < fixedRows;
	},
    getAnchor: function (index) {
        index = index || new CellIndex();
        index.rowIndex = this._endRow;
        return index;
    },
	resizeTo: function (endIndex) {
		var oldRow, row = Math.max(0, endIndex.rowIndex);
		if (row != this._endRow) {
			oldRow = this._endRow;
			this._endRow = Math.max(0, Math.min(this.grid().rowCount() - 1, row));
			if (this._mergedSel()) {
				this.$_fitMerged();
				if (this._endRow != oldRow) {
					this._resized();
				}
			} else {
				this._resized();
			}
		}
	},
	mergeWith: function (item) {
	},
	getData: function (maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
		var cnt, r1, r2, rows, r, item, row, c, col, p,
        	grid = this.grid(),
			columns = grid.collectDataColumns(grid.getVisibleColumn(0), grid.getVisibleColumn(grid.visibleColumnCount() - 1));
		if (!columns) {
			return null;
		}
		cnt = columns.length;
		if (cnt < 1) {
			return null;
		}
		r1 = Math.max(0, Math.min(this._startRow, this._endRow));
		r2 = Math.min(this.grid().rowCount() - 1, Math.max(this._startRow, this._endRow));
		rows = [];
		for (r = r1; r <= r2; r++) {
			item = grid.getRow(r);
			if (item && item.dataIndex() >= 0) {
				row = {};
				for (c = 0; c < cnt; c++) {
					col = columns[c];
					p = col.dataFieldName();
					p && (row[p] = item.getValue(col.dataIndex()));
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	},
    toString: function () {
        var r1 = Math.max(0, Math.min(this._startRow, this._endRow));
        var r2 = Math.min(this.grid().rowCount() - 1, Math.max(this._startRow, this._endRow));
        return '(' + r1 + ' ~ ' + r2 + ')';
    },
    $_fitMerged: function () {
		if (this._single || !this._mergedSel()) {
            return;
        }
		var i, j, cnt, c, c2, r1, r2, room1, room2, reversed,
			grid = this.grid(),
			row1 = this._startRow,
			row2 = this._endRow;
		r1 = row1;
		r2 = row2;
		reversed = r1 > r2;
		for (i = 0, cnt = grid.visibleColumnCount(); i < cnt;  i++) {
			c = grid.getVisibleColumn(i);
			if (c instanceof ValueColumn && c.canMerge()) {
				room1 = this._getRoom(c, row1);
                room2 = this._getRoom(c, row2);
				if (reversed) {
					room1 && (r1 = Math.max(r1, room1.tailItem()));
					room2 && (r2 = Math.min(r2, room2.headItem()));
				} else {
					room1 && (r1 = Math.min(r1, room1.headItem()));
					room2 && (r2 = Math.max(r2, room2.tailItem()));
				}
			} else if (c instanceof ColumnGroup) {
                for (j = c.visibleCount(); j--;) {
                    c2 = c.getVisibleItem(j);
                    if (c2 instanceof ValueColumn && c2.canMerge()) {
                        room1 = this._getRoom(c2, row1);
                        room2 = this._getRoom(c2, row2);
                        if (reversed) {
                            room1 && (r1 = Math.max(r1, room1.tailItem()));
                            room2 && (r2 = Math.min(r2, room2.headItem()));
                        } else {
                            room1 && (r1 = Math.min(r1, room1.headItem()));
                            room2 && (r2 = Math.max(r2, room2.tailItem()));
                        }
                    }
                }
            }
		}
		this._startRow = r1;
		this._endRow = r2;
    }
});
var ColumnSelection = defineClass("ColumnSelection", SelectionItem, {
	init: function(manager, startColumn, endColumn) {
		this._super(manager);
		if (GridColumn.compareLoc(startColumn, endColumn) <= 0) {
			this._startColumn = startColumn;
			this._endColumn = endColumn;
		} else {
			this._startColumn = endColumn;
			this._endColumn = startColumn;
		}
	},
	startColumn: function() {
		return this._startColumn;
	},
	endColumn: function() {
		return this._endColumn;
	},
	leftColumn: function () {
		return this._startColumn.distance() <= this._endColumn.distance() ? this._startColumn : this._endColumn;
	},
	rightColumn: function () {
		return this._startColumn.distance() > this._endColumn.distance() ? this._startColumn : this._endColumn;
	},
	style: function() {
		return SelectionStyle.COLUMNS;
	},
	getBounds: function() {
		if (this._startColumn.distance() <= this._endColumn.distance()) {
			return CellRange.createRange(0, this._startColumn, this._startColumn.grid().rowCount() - 1, this._endColumn);
		} else {
			return CellRange.createRange(0, this._endColumn, this._endColumn.grid().rowCount() - 1, this._startColumn);
		}
	},
	contains: function(index) {
		var column = index.column;
		if (this._startColumn.distance() <= this._endColumn.distance()) {
			return _compCL(column, this._startColumn) >= 0 && _compCL(column, this._endColumn) <= 0;
		} else {
			return _compCL(column, this._endColumn) >= 0 && _compCL(column, this._startColumn) <= 0;
		}
	},
	intersects: function (index1, index2) {
		var c,
			c1 = index1.column,
			c2 = index2.column,
			col1 = this._startColumn,
			col2 = this._endColumn;
		if (_compCL(c1, c2) > 0) {
			c = c1;
			c1 = c2;
			c2 = c;
		}
		if (_compCL(col1, col2) > 0) {
			c = col1;
			col1 = col2;
			col2 = c;
		}
		return _compCL(col1, c2) <= 0 && _compCL(c1,  col2) <= 0;
	},
	containedInFixedColumns: function (fixedCols) {
		return this._startColumn.root().displayIndex() < fixedCols || this._endColumn.root().displayIndex() < fixedCols;
	},
	containedInFixedRows: function (fixedRows) {
		return true;
	},
    getAnchor: function (index) {
        index = index || new CellIndex();
        index.column = this._endColumn;
        return index;
    },
	resizeTo: function(newEnd) {
		if (newEnd.column !== this._endColumn) {
			this._endColumn = newEnd.column;
			this._resized();
		}
	},
	mergeWith: function(item) {
	},
	getData: function(maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
		var cnt, row, r, item, row, c, cols, col, p,
			grid = this.grid(),
			columns = grid.collectDataColumns(this._startColumn, this._endColumn);
		if (!columns) {
			return null;
		}
		cnt = grid.rowCount();
		rows = [];
		for (r = 0; r < cnt; r++) {
			item = grid.getRow(r);
			if (item && item.dataIndex() >= 0) {
				row = {};
				for (c = 0, cols = columns.length; c < cols; c++) {
					col = columns[c];
					p = col.dataFieldName();
					p && (row[p] = item.getValue(col.dataIndex()));
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	},
    toString: function () {
        return '(' + this._startColumn.name() + ' ~ ' + this._endColumn.name() + ')';
    }
});
var SelectionView = defineClass("SelectionView", LayerElement, {
	init : function(dom) {
		this._super(dom, "selectionView");
		this._item = null;
		this._background = SelectionView.$$_defBackground;
		this._border = SelectionView.$$_defBorder;
	},
	background: null,
    border: null,
	setBackground: function (value) {
		if (value !== this._background) {
			this._background = value;
			this.invalidate();
		}
	},
	setBorder: function (value) {
		if (value != this._border) {
			this._border = value;
			this.invalidate();
		}
	},
	updateElement: function (item, styles) {
		this._item = item;
		this.setBackground(styles.background());
		this.setBorder(styles.border());
	},
	_doDraw: function (g) {
        if (this.width() > 0 && this.height() > 0) {
			var grid = this.container().gridView(),
				stroke = this.$_isTracking(grid) ? null : this._border,
				w = stroke ? stroke.width() : 0,
				p = _floor(w / 2);
			w = stroke ? _floor((w + 1) / 2) : 0;
            g.clipRectEx(this.$_calcClipRect(grid));
            g.drawBoundsI(this._borderOnly ? null : this._background, stroke, p, p, this.width() - w, this.height() - w);
        }
	},
	_doDrawHtml: function (g) {
        if (this.width() > 0 && this.height() > 0) {
			var grid = this.container().gridView(),
            	stroke = this.$_isTracking(grid) ? null : this._border,
            	fill = this._borderOnly ? null : this._background;
            this._css.clip = Dom.getClipRect(this.$_calcClipRect(grid));
            _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
            this._css.border = stroke ? stroke.css() : "none"
        }
	},
    $_isTracking: function (grid) {
		if (grid.selections().lastItem() === this._item) {
			var tracker = grid.activeTool().dragTracker();
			return tracker instanceof SelectTracker;
		}
		return false;
    },
	$_calcClipRect: function (grid) {
		var lm = grid.layoutManager(),
			r = lm.gridBounds(),
			item = this._item,
			n = lm.fixedColCount();
		if (n > 0 && !item.containedInFixedColumns(n)) {
			r.setLeft(lm.fixedBounds().right());
		}
		if ((n = lm.fixedRowCount()) > 0 && !item.containedInFixedRows(n)) {
			r.setTop(lm.bodyBounds().y + lm.fixedHeight());
		}
		r = grid._selectionLayer.translateBy(this, r);
		return r;
	}
});
SelectionView.$$_defBackground = new SolidBrush(0x2F1E90FF);
SelectionView.$$_defBorder = new SolidPen(0xaa1E90FF, 1);
/** @abstract */
var ClipboardData = defineClass("ClipboardData", null, {
	init: function() {
		this._super();
	},
	lastColumn: function () { _throwAbstractError(); },
	getText: function (scope, range, format) { _throwAbstractError(); },
	getCellText: function (scope, index, format) { _throwAbstractError(); },
	getRows: function (scope, data, index) { _throwAbstractError(); },
	getCell: function (scope, data, index) { _throwAbstractError(); }
});
var ClipboardSource = defineClass("ClipboardSource", null, {
	init: function(data) {
		this._super();
		this._lines = [];
		this._colCount = 0;
		this.$_parse(data);
	},
	rowCount: function () {
		return this._lines.length;
	},
	colCount: function () {
		return this._colCount;
	},
	isEmpty: function () {
		return this._lines.length == 0 || this._colCount == 0;
	},
	isSingle: function () {
		return this._lines.length == 1 && this._colCount == 1;
	},
	get: function (row) {
		return this._lines[row];
	},
	$_parse: function (data) {
		var c, quoted, escaped, s,
			lines = this._lines,
			line = [],
			len = data.length,
			p = 0,
			i = 0,
			quoting = false;
		while (i < len) {
			c = data.charAt(i);
			if (quoting) {
				if (c == '"') {
					quoting = false;
				}
			} else if (c == '"') {
				quoting = true;
			} else if (c == "\t") {
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				p = i + 1;
			} else if (c == "\r" && (i + 1) < len && data.charAt(i + 1) == "\n") {
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				lines.push(line);
				line = [];
				i++;
				p = i + 1;
			} else if (c == "\n" || c == "\r") { // mac excel 에서는 '\r' 을 보낸다.
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				lines.push(line);
				line = [];
				p = i + 1;
			}
			i++;
		}
		if (p < len) {
			s = data.substring(p, len);
			line.push(s);
			lines.push(line);
		}
		for (i = lines.length - 1; i >= 0; i--) {
			line = lines[i];
			this._colCount = Math.max(this._colCount, line.length);
			for (p = line.length - 1; p >= 0; p--) {
				s = line[p];
				if (s && (len = s.length) > 1 && s.charAt(0) == '"' && s.charAt(len - 1) == '"') {
					line[p] = s.substring(1, len - 1);
				}
			}
		}
	}
});
var DefaultClipboardData = defineClass("DefaultClipboardData", ClipboardData, {
	init: function() {
		this._super();
		this._columns = null;
	},
	lastColumn: function () {
		return this._columns ? this._columns[this._columns.length - 1] : null;
	},
    $_getText: function (scope, col, row, format) {
        var s = "";
        if (col && !col._blankWhenCopy) {
            if (col instanceof DataColumn) {
                s = scope.getData(row.index(), col, format);
            } else if (col instanceof SeriesColumn) {
                s = col.getValue(row);
            } else if (col instanceof CalculatedColumn) {
                s = col.getValue(row);
            } else if (col instanceof LabelColumn) {
                s = col.text();
            }
        }
        return s;
    },
	getText: function (scope, range, format) {
        var r, item, f, cols, row, c, col, v, s,
		    grid = scope.grid(),
            cells = this.$_rangeToCells(scope, null, range),
            rows = [],
            rt = this._calcedRuntime;
		for (r = range.R1(); r <= range.R2(); r++) {
			item = grid.getRow(r);
			if (item.dataIndex() >= 0 || GridRowState.isInserting(item.rowState())) {
				for (f = 0; f < cells.length; f++) {
					cols = cells[f];
					row = [];
					for (c = 0; c < cols.length; c++) {
						v = this.$_getText(scope, cols[c], item, format);
                        row.push(v);
					}
					s = row.join("\t") + "\r\n";
					rows.push(s);
				}
			}
		}
		return rows.join("");
	},
	getCellText: function (scope, index, format) {
        return this.$_getText(scope, index.column, scope.grid().getRow(index.rowIndex), format);
	},
	getRows: function (scope, data, index) {
		if (!data) {
			return null;
		}
		var source = new ClipboardSource(data);
		if (source.isEmpty()) {
			return null;
		}
		if (source.isSingle()) {
			return source.get(0)[0];
		} else {
            var row, j, c, line, cols, cnt, r,
			    roots = scope.getDataRoots(),
			    idx1 = new CellIndex(index.rowIndex, index.column.dataRoot()),
			    idx2 = new CellIndex(index.rowIndex, roots[roots.length - 1]),
			    range = CellRange.create(idx1, idx2),
			    cells = this.$_rangeToCells(scope, source, range),
                rows = [],
                i = 0,
                len = source.rowCount();
            while (i < len) {
                row = {};
                row.columns = [];
                row.values = [];
                for (j = 0; j < cells.length && i < len; j++, i++) {
                    cols = cells[j];
                    line = source.get(i);
                    row.columns.push(cols);
                    row.values.push(r = []);
                    cnt = Math.min(line.length, cols.length);// colCount);
                    for (c = 0; c < cnt; c++) {
                        if (cols[c]) {
                            r.push(line[c]);
                        } else {
                            r.push("");
                        }
                    }
                }
                rows.push(row);
            }
			return rows;
		}
	},
	getCell: function (scope, data, index) {
        if (data) {
            var source = new ClipboardSource(data);
            return source.isEmpty() ? null : source.get(0)[0];
        }
        return null;
	},
    setValue: function (scope, range, value, checkErasable) {
        var r, item, f, cols, c, col,
            grid = scope.grid(),
            cells = this.$_rangeToCells(scope, null, range);
        for (r = range.R1(); r <= range.R2(); r++) {
            item = grid.getRow(r);
            if (item.dataIndex() >= 0 || GridRowState.isInserting(item.rowState())) {
                for (f = 0; f < cells.length; f++) {
                    cols = cells[f];
                    for (c = 0; c < cols.length; c++) {
                        col = cols[c];
                        if (col instanceof DataColumn && (!checkErasable || grid.$_isErasable(r, col))) {
                            grid.setValueAt(r, col, value);
                        }
                    }
                }
            }
        }
    },
	$_rangeToCells: function (scope/*ClipboardManager*/, source/*ClipboardSource*/, range) {
		range.normalizeData();
		var fld, r, c, g, col, i, colCount, width, height, w,
			col1 = range.C1(),
			col2 = range.C2(),
			cells = [],
			roots = scope.getDataRoots(),
			columns = this._columns = [],
			c1 = roots.indexOf(col1),
			c2 = roots.indexOf(col2);
		if (c1 < 0) {
			throw col1.name + " is not data root column.";
		}
		if (c2 < 0) {
			throw col2.name + " is not data root column.";
		}
		for (c = c1; c <= c2; c++) {
			columns.push(roots[c]);
		}
		colCount = columns.length;
		for (width = 0, c = 0; c < columns.length; c++) {
			width += this.$_calcWidth(columns[c]);
			if (source && width >= source.colCount()) {
				width = Math.min(width, source.colCount());
				colCount = c + 1;
				columns.length = colCount;
				break;
			}
		}
		w = 0;
		for (height = 1, c = 0; c < colCount; c++) {
			col = columns[c];
			height = Math.max(height, this.$_calcHeight(col, width - w));
			w += col instanceof ColumnGroup ? col.$_dataWidth : 1;
		}
		for (r = 0; r < height; r++) {
			cells.push([]);
		}
		for (r = 0; r < height; r++) {
			for (i = 0; i < width; i++) {
				cells[r].push(null);
			}
		}
		w = 0;
		for (c = 0; c < colCount; c++) {
			col = columns[c];
			this.$_setFields(col, cells, w, 0);
			w += col instanceof ColumnGroup ? col.$_dataWidth : 1;
		}
		return cells;
	},
	$_calcHeight: function (column, maxWidth) {
		if (maxWidth < 1) {
			return 0;
		}
		var i, cnt, c,
			h = 1,
			g = _cast(column, ColumnGroup);
		if (g && (cnt = g.count()) > 0) {
			if (g.vertical()) {
				h = 0;
				for (i = 0; i < cnt; i++) {
					h += this.$_calcHeight(g.getItem(i), maxWidth);
				}
			} else {
				for (i = 0; i < cnt && maxWidth > 0; i++) {
					c = g.getItem(i);
					h = Math.max(h, this.$_calcHeight(c, maxWidth));
					maxWidth -= c instanceof ColumnGroup ? c.$_dataWidth : 1;
				}
			}
			g.$_dataHeight = h;
		} else if (g) {
			g.$_dataHeight = 1;
		}
		return h;
	},
	$_calcWidth: function (column) {
		var i, cnt,
			w = 1,
			g = _cast(column, ColumnGroup);
		if (g && (cnt = g.count()) > 0) {
			if (g.horizontal()) {
				w = 0;
				for (i = 0; i < cnt; i++) {
					w += this.$_calcWidth(g.getItem(i));
				}
			} else {
				for (i = 0; i < cnt; i++) {
					w = Math.max(w, this.$_calcWidth(g.getItem(i)));
				}
			}
			g.$_dataWidth = w;
		} else if (g) {
			g.$_dataWidth = 1;
		}
		return w;
	},
	$_setFields: function (column, cells, x, y) {
		var r, c, i, fld, col,
			g = _cast(column, ColumnGroup);
		if (!g) {
			if (cells[y].length > x) {
                cells[y][x] = (column instanceof ValueColumn) ? column : null;// _cast(column, DataColumn);
			}
		} else if (g.vertical()) {
			r = y;
			for (i = 0; i < g.count(); i++) {
				col = g.getItem(i);
				this.$_setFields(col, cells, x, r);
				r += (col instanceof ColumnGroup) ? col.$_dataHeight : 1;
			}
		} else {
			c = x;
			for (i = 0; i < g.count(); i++) {
				col = g.getItem(i);
				this.$_setFields(col, cells, c, y);
				c += (col instanceof ColumnGroup) ? col.$_dataWidth : 1;
			}
		}
	}
});
var ClipboardItem = defineClass("ClipboardItem", GridRow, {
	init: function() {
		this._super();
		this._dataSource = null;
		this._values = null;
	},
	setValues: function (values) {
		this._values = values;
	},
	id: function () {
		return NaN;
	},
	index: function () {
		return -1;
	},
	parent: function () {
		return null;
	},
	root: function () {
		return this;
	},
	childIndex: function () {
		return -1;
	},
	level: function () {
		return 1;
	},
    leaf: function () {
        return true;
    },
	isLeaf: function () {
		return true;
	},
    visible: function () {
        return true;
    },
	isVisible: function () {
		return true;
	},
	provider: function () {
		return null;
	},
	dataSource: function () {
		return this._dataSource;
	},
	setDataSource: function (value) {
		this._dataSource = value;
	},
	dataRow: function () {
		return -1;
	},
	rowState: function () {
		return DataRowState.NONE;
	},
	itemState: function () {
		return GridRowState.NORMAL;
	},
    checked: function () {
        return false;
    },
	isChecked: function () {
		return false;
	},
	setChecked: function (value) {
	},
    checkable: function () {
        return true;
    },
	isCheckable: function () {
		return true;
	},
	setCheckable: function (value) {
	},
	isEditable: function () {
		return false;
	},
    readOnly: function () {
        return false;
    },
	isReadOnly: function () {
		return false;
	},
	setReadOnly: function (value) {
	},
    resizable: function () {
        return false;
    },
	isResizable: function () {
		return false;
	},
	getRowData: function () {
		return null;
	},
	getRowObject: function () {
		return null;
	},
	canEdit: function () {
		return false;
	},
	makeVisible: function () {
	},
	getValue: function (field) {
		return this._values[field];
	}
});
var ClipboardIndex = defineClass("ClipboardIndex", CellIndex, {
	init: function (row) {
		this._super();
		this._row = row;
	},
	getRow: function (grid) {
		return this._row;
	}
});
var ClipboardManager = defineClass("ClipboardManager", null, {
	init: function(grid) {
		this._super();
		this._grid = grid;
		this._data = new DefaultClipboardData();
		this._appendingItem = new ClipboardItem();
		this._appendingIndex = new ClipboardIndex(this._appendingItem);
	},
	grid: function () {
		return this._grid;
	},
	dataSource: function () {
		return this._dataSource;
	},
	copyEmptyToClipboard: function () {
		return "";
	},
	copyToClipboard: function (range) {
		return this._data.getText(this, range, true);
	},
	copyCellToClipboard: function (index) {
		return this._data.getCellText(this, index, true);
	},
	getPasteRows: function (index, data) {
		if (data) {
			return this._data.getRows(this, data, index);
		}
	},
	pasteFromClipboard: function (index, data, rows, dataLock) {
		var saveIndex = index.clone();
		this._dataLock = dataLock;
		index = this.$_checkIndex(index);
		if (!index || !this._grid.isValidCell(index)) {
			return;
		}
		/*
		 var data = null;
		 var inner = Clipboard.generalClipboard.hasFormat(DEFAULT_FORMAT);
		 if (inner) {
		 data = Clipboard.generalClipboard.getData(DEFAULT_FORMAT) as String;
		 } else if (Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)) {
		 data = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
		 }
		 */
		if (!rows && data) {
			rows = this._data.getRows(this, data, index);
		}
		if (rows) {
			if (typeof rows == "string") {
				this.$_pasteSingleCell(index, rows);
			} else if (rows.length == 1) {
				this.$_pasteSingleLine(index, rows[0], true);
			} else if (rows.length > 1) {
				this._grid.dataSource().beginActions();
				try {
					this.$_pasteMultiLines(index, rows, true);
				} finally {
					this._grid.dataSource().endActions();
				}
			}
		}
		if (!CellIndex.areEqual(index, saveIndex)) {
			this._grid.setFocusedIndex(saveIndex, false, false);
		}
	},
	pasteCellFromClipboard: function (index, data) {
		index = this.$_checkIndex(index);
		if (!index || !this._grid.isValidCell(index)) {
			return;
		}
		/*
		 var data = null;
		 var inner = Clipboard.generalClipboard.hasFormat(DEFAULT_FORMAT);
		 if (inner) {
		 data = Clipboard.generalClipboard.getData(DEFAULT_FORMAT) as String;
		 } else if (Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)) {
		 data = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
		 }
		 */
		if (data) {
			var s = this._data.getCell(this, data, index);
			this.$_pasteSingleCell(index, s);
		}
	},
	getDataRoots: function () {
		return this._grid.getDataRootColumns();
	},
	getData: function (itemIndex, column, format) {
        var fld, s, writer, v, options, callback,
		    grid = this._grid,
		    row = grid.getRow(itemIndex);
		if (!row || !(GridRowState.isInserting(row.rowState()) || row.dataIndex() >= 0)) {
			return "";
		}
		if (column && (fld = grid.dataSource().getField(column.dataIndex())) != null) {
			v = row.getValue(column.dataIndex());
			if (format) {
                options = this._grid.editOptions();
                callback = column.copyCallback();
                if (callback) {
                    s = callback(row, fld, v);
                } else {
                    callback = options.copyCallback();
                    if (callback) {
                        s = callback(row, column, fld, v);
                    } else {
                        switch (fld.dataType()) {
                            case ValueType.DATETIME:
                                if (v) {
                                    writer = options.$_getDateWriter(column);
                                    s = writer ? writer.getText(v) : v;
                                } else {
                                    s = "";
                                }
                                break;
                            case ValueType.BOOLEAN:
                                if (v !== undefined) {
                                    writer = options.$_getBoolWriter(column);
                                    s = writer ? writer.formatValue(v) : v;
                                } else {
                                    s = "";
                                }
                                break;
                            case ValueType.NUMBER:
                                if (v !== undefined && !isNaN(v)) {
                                    writer = options.$_getNumberWriter(column);
                                    s = writer ? writer.format(v) : v;
                                } else {
                                    s = "";
                                }
                                break;
                            case ValueType.OBJECT:
                                s = _isObject(v) ? JSON.stringify(v) : v;
                                break;
                            default:
                                s = v;
                                break;
                        }
                    }
                }
			} else {
				switch (fld.dataType()) {
					case ValueType.DATETIME:
						s = v ? v : "";
						break;
					case ValueType.BOOLEAN:
						s = (v !== undefined) ? v : "";
						break;
					case ValueType.NUMBER:
						s = (v !== undefined && !isNaN(v)) ? v : "";
						break;
					default:
						s = v;
						break;
				}
			}
			s = s ? String(s) : s;
			if (s && (s.indexOf("\n") >= 0 || s.indexOf("\r\n") >= 0)) {
				s = '"' + s + '"';
			}
			return s;
		} else {
			return "";
		}
	},
	$_checkIndex: function (index) {
		if (index) {
			index.normalize(this._grid);
			if (this._grid.isValidCell(index)) {
				if (this._grid.editOptions().selectionBasePaste()) {
					if (this._grid.selections().count() > 0) {
						var range = this._grid.selections().getItem(0).getBounds();
						var idx = range.firstCell();
						index.column = idx.column;
						index.rowIndex = idx.rowIndex;
					}
				}
			}
		}
		return index;
	},
	$_createDate: function () {
		return new DefaultClipboardData();
	},
	$_readValue: function (ds, column, s) {
		var v = UNDEFINED,
		    fld = ds.getField(column.dataIndex());
		switch (fld.dataType) {
			case ValueType.NUMBER:
				v = Number(s);
				break;
			case ValueType.DATETIME:
				v = new Date(s);
				break;
			case ValueType.BOOLEAN:
				v = Boolean(s);
				break;
			default:
				v = s;
				break;
		}
		return v;
	},
	$_convertText: function (ds, grid, options, row, column, s) {
        var callback, v, exp, readers, i, boolReader, editor,
		    idx = column.dataIndex(),
		    fld = ds.getField(idx);
        callback = column.pasteCallback();
        if (callback) {
            v = callback(row, fld, s);
        } else {
            callback = options.pasteCallback();
            if (callback) {
                v = callback(row, column, fld, s);
            } else {
                switch (fld.dataType()) {
                    case ValueType.NUMBER:
                        v = NaN;
                        if (s) {
                            exp = options.pasteNumberCharExp();
                            if (exp) {
                                s = s.replace(exp, "");
                            }
                            v = fld.readValue(s);
                        }
                        break;
                    case ValueType.DATETIME:
                        v = null;
                        readers = options.dateReaders();
                        if (s && readers) {
                            for (i = 0; i < readers.length; i++) {
                                v = readers[i].toDate(s);
                                if (v) {
                                    break;
                                }
                            }
                        }
                        if (v === null) {
                            v = new Date(s);
                            if (isNaN(v.getTime())) {
                                v = null;
                            }
                        }
                        if (v === null) {
                            v = fld.readValue(s);
                        }
                        break;
                    case ValueType.BOOLEAN:
                        v = undefined;
                        boolReader = options.boolReader();
                        if (s && boolReader) {
                            v = boolReader.toBoolStrict(s);
                        }
                        if (v === undefined) {
                            v = fld.readValue(s);
                        }
                        break;
                    default:
                        s = String(s);
                        /*
                         if (s) {
                         if (column.textInputCase() == TextInputCase.LOWER) {
                         s = s.toLocaleLowerCase();
                         } else if (column.textInputCase() == TextInputCase.UPPER) {
                         s = s.toLocaleUpperCase();
                         }
                         }
                         */
                        v = s;
                }
            }
        }
		if (v !== undefined && v && options._maskWhenPaste) {
			editor = grid.delegate().getCellEditor(CellIndex.temp(row.index(), column));
			if (editor.maskable()) {
				v = editor.seiveText(v);
			}
		}
		return v;
	},
	$_removeChars: function (s, c) {
		if (c) {
			while (true) {
				var s2 = s.replace(c, "");
				if (s2.length == s.length)
					break;
				s = s2;
			}
		}
		return s;
	},
	$_isPastable: function (grid, options, rowIndex, col) {
        var dcol = col instanceof DataColumn ? col : null;
		var v = (!options._checkReadOnlyWhenPaste && dcol) ||
		   		!grid.getReadOnlyAt(rowIndex, col, undefined, undefined, true);
        if (v && dcol && dcol._valueType == ValueType.OBJECT) {
            v = !!dcol._pasteCallback;
        }
        return v;
	},
	$_pasteSingleCell: function (index, s) {
        var v, oldValue, vals, validations, rowValidation, colValidation,
		    grid = this._grid,
		    options = grid.editOptions(),
		    ds = grid.dataSource(),
		    col = index.dataColumn(),
            row = index.getRow(grid),
		    can = s && ds && this.$_isPastable(grid, options, row.index(), col);
		if (can) {
			if (s.lastIndexOf("\r\n") == s.length - 1) {
				s = s.substr(0, s.length - 2);
			}
			if (s.lastIndexOf("\n") == s.length - 1) {
				s = s.substr(0, s.length - 1);
			}
			v = this.$_convertText(ds, grid, options, row, col, s);
			if (grid.isRowEditing() || !options.updateByCell() && options.startEditWhenPaste() && grid.edit()) {
				row = index.getRow(grid);
				oldValue = row.getValue(index.dataField());
				grid.setCellUpdateEventLock(options.noEditEventWhenPaste());
				try {
					row.setValue(col.dataIndex(), v);
				} finally {
					grid.setCellUpdateEventLock(false);
				}
				grid.validateCellCommit(index, row.getValue(index.dataField()));
				grid.$_editRowPasted(row, [index.dataField()], [oldValue], [v]);
                grid.$_pasted(row, 0, 0);
				grid.refreshView();
			} else {
				validations = grid.validationManager();
				rowValidation = options.forceRowValidationWhenPaste() && grid.validationManager().hasRowValidation();
				colValidation = options.forceColumnValidationWhenPaste();
				vals = rowValidation ? row.getRowData() : [];
				vals[col.dataIndex()] = v;
				this._appendingItem.setValues(vals);
				if (rowValidation) {
					grid.validationManager().validateRow(this._appendingItem, false, true);
				}
				if (colValidation) {
					this._appendingIndex.column = col;
					validations.validateCell(this._appendingIndex, false);
				}
                grid.updatePastedCell(row, col.dataIndex(), v);
                grid.$_pasted(row, 1, 0);
			}
			grid.selections().clear();
			grid.selections().add(index, new CellIndex(index.rowIndex, index.column), SelectionStyle.BLOCK);
		}
	},
	$_pasteSingleLine: function (index, row) {
		var v, col, item, val, vals, cols, values, cnt, r, i, fld, fields, oldValues, saveCol,
            validations, rowValidation, colValidation,
			grid = this._grid,
			ds = grid.dataSource(),
			rs = grid.rowSource(),
			options = grid.editOptions(),
			n = 0;
		if (!ds || !rs) {
			return;
		}
		item = index.getRow(grid);
		cnt = Math.min(row.columns.length, row.values.length);
		if (grid.isRowEditing() || options.startEditWhenPaste() && grid.edit()) {
			fields = [];
			oldValues = [];
			saveCol = index.column;
			item = index.getRow(grid);
			values = [];
			for (r = 0; r < cnt; r++) {
				cols = row.columns[r];
				vals = row.values[r];
				for (i = 0; i < vals.length; i++) {
					col = cols[i];
					if (this.$_isPastable(grid, options, index.rowIndex, col)) {
						val = vals[i];
                        fld = col.dataIndex();
						oldValues.push(item.getValue(fld));
						v = this.$_convertText(ds, grid, options, item, col, val);
						grid.setCellUpdateEventLock(options.noEditEventWhenPaste());
						try {
							item.setValue(fld, v);
						} finally {
							grid.setCellUpdateEventLock(false);
						}
						index.column = col;
						grid.validateCellCommit(index, item.getValue(fld));
						fields.push(fld);
						values.push(v);
                        n++;
					}
				}
			}
            if (n > 0) {
                grid.$_editRowPasted(item, fields, oldValues, values);
                grid.$_pasted(item, 0, 0);
                index.column = saveCol;
                grid.refreshView();
            }
		} else {
			validations = grid.validationManager();
			rowValidation = options.forceRowValidationWhenPaste() && validations.hasRowValidation();
			colValidation = options.forceColumnValidationWhenPaste();
            fields = [];
			item = index.getRow(grid);
			values = rowValidation ? item.getRowData() : [];
			for (r = 0; r < cnt; r++) {
				cols = row.columns[r];
				vals = row.values[r];
				for (i = 0; i < vals.length; i++) {
					col = cols[i];
                    if (this.$_isPastable(grid, options, index.rowIndex, col)) {
                        fld = col.dataIndex();
						v = this.$_convertText(ds, grid, options, item, col, vals[i]);
						values[fld] = v;
                        fields.push(fld);
                        n++;
					}
				}
			}
            if (n > 0) {
                this._appendingItem.setValues(values);
                if (rowValidation) {
                    validations.validateRow(this._appendingItem, false, true);
                }
                if (colValidation) {
                    for (i = 0; i < values.length; i++) {
                        this._appendingIndex.column = cols[i];
                        validations.validateCell(this._appendingIndex, false);
                    }
                }
                if (options.pasteByCell()) {
                    for (i = 0; i < fields.length; i++) {
                        fld = fields[i];
                        grid.updatePastedCell(item, fld, values[fld]);
                    }
                } else {
                    grid.updatePastedRow(item, values, true);//!rowValidation);
                }
                grid.$_pasted(item, 1, 0);
            }
		}
        if (n > 0) {
            grid.selections().clear();
            grid.selections().add(index, new CellIndex(index.rowIndex, this._data.lastColumn()), SelectionStyle.BLOCK);
        }
	},
	$_pasteMultiLines: function (index, rows) {
		var grid = this._grid,
		    ds = grid.dataSource();
		if (!ds) return;
		var r, r2, cnt, i, v, item, lastItem, row, vals, fld, fields, col, itemCount, values, columns, pasteFlag, cs, can, canFlds,
			len = rows.length,
			idx = index.rowIndex,
			options = grid.editOptions(),
            byCell = options.pasteByCell(),
			flds = ds.fieldCount(),
			allColumns = grid.getDataColumns(false),
			cols = allColumns.length,
			validations = grid.validationManager(),
			rowValidation = options.forceRowValidationWhenPaste() && validations.hasRowValidation(),
			colValidation = options.forceColumnValidationWhenPaste(),
			fillColDefaults = options.fillColumnDefaultsWhenPaste(),
			fillFldDefaults = options.fillFieldDefaultsWhenPaste(),
			appendingItem = this._appendingItem,
			appendingIndex = this._appendingIndex,
			ucount = 0,
			acount = 0;
		if (options.commitWhenPaste()) {
			if (!grid.commit(false)) {
				grid.cancel();
			}
		} else {
			grid.cancel();
		}
		itemCount = grid.rowCount();
		appendingItem.setDataSource(ds);
		for (r = 0; r < len && idx < itemCount; r++) {
			try {
				lastItem = item = grid.getRow(idx);
				if (item.rowState() == GridRowState.APPENDING) {
					break;
				}
				while (item && item.dataIndex() < 0) {
					idx++;
					item = grid.getRow(idx);
					if (item) lastItem = item;
				}
				if (item == null) {
					break;
				}
                fields = [];
				row = rows[r];
				vals = rowValidation ? item.getRowData() : [];
				cnt = Math.min(row.columns.length, row.values.length);
				for (r2 = 0; r2 < cnt; r2++) {
					columns = row.columns[r2];
					values = row.values[r2];
					for (i = 0; i < values.length; i++) {
						col = columns[i];
						if (this.$_isPastable(grid, options, idx, col)) {
							v = this.$_convertText(ds, grid, options, item, col, values[i]);
                            fld = col.dataIndex();
							vals[fld] = v;
                            fields.push(fld);
						}
					}
				}
				try {
					appendingItem.setValues(vals);
					if (rowValidation) {
						validations.validateRow(appendingItem, false, true);
					}
					if (colValidation) {
						for (r2 = 0; r2 < cnt; r2++) {
							columns = row.columns[r2];
							for (i = 0; i < values.length; i++) {
								appendingIndex.column = columns[i];
								validations.validateCell(appendingIndex, false);
							}
						}
					}
                    if (byCell) {
                        for (i = 0; i < fields.length; i++) {
                            fld = fields[i];
                            grid.updatePastedCell(item, fld, vals[fld]);
                        }
                    } else {
                        grid.updatePastedRow(item, vals, true);// !rowValidation);
                    }
					ucount++;
				} catch (err) {
					if (options.stopPasteOnError()) {
						throw err;
					}
				}
				idx++;
			} catch (err) {
				idx = Math.max(index.rowIndex, idx - 1);
				grid.setFocusedIndex(index, false, false);
				grid.selections().clear();
				grid.selections().add(index, new CellIndex(idx, this._data.lastColumn()), SelectionStyle.BLOCK);
				throw err;
			}
		}
		if (r < len && options.enableAppendWhenPaste()) {
			for (; r < len; r++) {
				row = rows[r];
				cnt = Math.min(row.columns.length, row.values.length);
				vals = [];
                fields = [];
                canFlds = [];
				try {
					for (r2 = 0; r2 < cnt; r2++) {
						columns = row.columns[r2];
						values = row.values[r2];
						for (i = 0; i < values.length; i++) {
							col = columns[i];
							if (lastItem && this.$_isPastable(grid, options, lastItem.index(), col)) {
                                fld = col.dataIndex();
                                v = this.$_convertText(ds, grid, options, lastItem, col, values[i]);
                                vals[fld] = v;
                                canFlds[fld] = canFlds[fld] && true;
							} else if (col) {
                                canFlds[col.dataIndex()] = false;
                            }
						}
						if (fillColDefaults) {
							for (i = 0; i < cols; i++) {
								col = allColumns[i];
								if (columns.indexOf(col) < 0 && col.defaultValue() !== undefined) {
                                    fld = col.dataIndex();
									if (canFlds[fld] && vals[fld] === undefined) {
										vals[fld] = col.defaultValue();
									}
								}
							}
						}
						if (fillFldDefaults) {
							for (i = 0; i < flds; i++) {
								if (vals[i] === undefined) {
									fld = ds.getField(i);
									if (canFlds[fld] && fld.defaultValue() !== undefined) {
										vals[i] = fld.defaultValue();
									}
								}
							}
						}
					}
					try {
						appendingItem.setValues(vals);
						if (rowValidation) {
							validations.validateRow(appendingItem, true, true);
						}
						if (colValidation) {
							for (i = 0; i < cols; i++) {
								col = allColumns[i];
								this._appendingIndex.column = col;
								validations.validateCell(this._appendingIndex, true);
							}
						}
						grid.appendPastedRow(vals);
						acount++
					} catch (err) {
						if (options.stopPasteOnError()) {
							throw err;
						}
					}
				} catch (err) {
					idx = Math.max(index.rowIndex, grid.rowCount() - 1);
					grid.setFocusedIndex(index, false, false);
					grid.selections().clear();
					grid.selections().add(index, new CellIndex(idx, this._data.lastColumn()), SelectionStyle.BLOCK);
					throw err;
				}
			}
			idx = this._dataLock ? -1 : grid.rowCount();
		}
		if (this._dataLock) {
			ds.endUpdate();
			this._dataLock = false;
			if (idx < 0) idx = grid.rowCount();
		}
		grid.setFocusedIndex(index, false, false);
		grid.selections().clear();
		grid.selections().add(index, new CellIndex(idx - 1, this._data.lastColumn()), SelectionStyle.BLOCK);
		grid.$_pasted(index.getRow(grid), ucount, acount);//idx - index.rowIndex);
	}
});
var MobileSelectionTool = defineClass("MobileSelectionTool", GridEditTool, {
	init: function (owner) {
		this._super(owner, "mobileSelectionTool");
		this._editCommandBar = new MobileEditCommandBar(this._grid, [{
            name: 'Submit',
			callback: function (grid, row) {
                grid.commit();
			}
		}, {
            name: 'Cancel',
			callback: function (grid, row) {
                grid.cancel();
			}
		}]);
		this._swipeTimer = null;
		this._swipeDistance = 0;
		this._swipeDuration = 0;
		this._swipeStarted = null;
		this._swipePrev = undefined;
		this._swipeAmount = 0;
		this._tapX = this._tapY = NaN;
        this._tapTracker = null;
        var tm = this._touchManager = new SingleTouchManager(owner);
		tm.setTouchHandler(function (x, y) {
			return this.onTouch(x, y);
		}.bind(this));
		tm.setTapHandler(function (x, y) {
			return this.onTap(x, y);
		}.bind(this));
		tm.setDoubleTapHandler(function (x, y) {
			return this.onDoubleTap(x, y);
		}.bind(this));
		tm.setLongTapHandler(function (x, y) {
			return this.onLongTap(x, y);
		}.bind(this));
		tm.setDragStartHandler(function (startX, startY, x, y) {
			return this.onDragStart(startX, startY, x, y);
		}.bind(this));
		tm.setDragHandler(function (prevX, prevY, x, y) {
			return this.onDrag(prevX, prevY, x, y);
		}.bind(this));
        tm.setDragEndHandler(function (x, y) {
            return this.onDragEnd(x, y);
        }.bind(this));
		tm.setSwipeHandler(function (duration, distance, dir) {
			return this.onSwipe(duration, distance, dir);
		}.bind(this));
	},
	touchManager: function () {
		return this._touchManager;
	},
    _doKeyDown: function (key, ctrl, shift, alt) {
        var item,
            grid = this.grid(),
            lm = grid.lm(),
            options = grid.editOptions(),
            index = this.focused().clone();
        if (!grid._fireKeyDown(key, ctrl, shift, alt)) {
            return true;
        }
        if (key == Keys.ENTER) {
            return this._doEnter(grid, options, index, ctrl, shift);
        }
    },
	_doMouseDown: function (x, y, ctrlKey, shiftKey) {
	},
	_doMouseMove: function (x, y) {
	},
	_doMouseUp: function (x, y) {
	},
	_doLayoutChanged: function (x, y) {
	},
	_doFocusedIndexChanging: function (newIndex) {
	},
	_doFocusedIndexChanged: function (oldIndex, newIndex) {
        this._grid.hideEditor();
	},
	_doDblClick: function (x, y) {
		this.onDoubleTap(x, y);
	},
    editorActivated: function (editor) {
        this._resetFocusView();
        this._grid._layoutSelectionViews();
		!editor && this._grid.isRowEditing() && this._showEditCommander(this._grid.focusedRow());
        this._grid.invalidate();
    },
	rowEditStarted: function (row) {
        if (row && !this._grid.isEditing()) {
            this._showEditCommander(row);
        }
	},
	rowEditEnded: function (row, canceled) {
		this._hideEditCommander();
	},
	_resetFocusView: function () {
        var cell, r,
		    grid = this._grid,
			root = grid._rootElement,
		    index = this.focused();
		if (!grid.isEditing() && grid.displayOptions().focusVisible() && grid.isValidCell(index)) {
			cell = grid.getFocusedCellView();
			if (cell) {
				r = cell.boundsBy(root);
				if (r.width > 0 && r.height > 0) {
					if (grid._container.$_rich) {
						r.x++;
						r.y++;
					}
					this._focusView.setRect(r);
					this._focusView.setEditing(grid.isEditing(), cell.getButtonWidth ? cell.getButtonWidth() : 0);
					this._focusView.setVisible(true);
				} else {
					this._focusView.setVisible(false);
				}
			} else {
				this._focusView.setVisible(false);
			}
		} else {
			this._focusView.setVisible(false);
		}
	},
	_stopTapTracker: function (accept) {
		if (this._tapTracker) {
			try {
				accept ? this._tapTracker.drop(x, y) : this._tapTracker.cancel();
			} finally {
				this._tapTracker = null;
			}
		}
	},
	_showEditCommander: function (row) {
        var c = this._editCommandBar,
            upper = false,
            r = new Rectangle();
            grid = this._grid,
            lm = grid.lm(),
            view = grid.bodyView().findRowView(row.index());
        if (view) {
            r.y = view.height();
            r = view.boundsByContainer(r);
        } else {
            r.y = grid.height() - c.offsetHeight;
        }
        r.x = lm.checkBarBounds().right();
        r.width = Math.min(grid.width() - r.x, lm.bodyBounds().width);
        r = grid.container().toScreen(r);
        c.show(r.x, r.y + 1, r.width, upper);
	},
	_hideEditCommander: function () {
        this._editCommandBar.hide();
	},
	onTouch: function (x, y) {
		var clickElement,
			grid = this._grid;
        grid.setFocus();
        clearInterval(this._swipeTimer);
		this._stopTapTracker(false);
        this._clickCell = this._clickHandle = null;
		clickElement = this._clickElement = this.findElementAt(x, y, false);
		this._clickHandle = _cast(clickElement, HandleElement);
		this._clickCell = _cast(clickElement, CellElement);
		if (clickElement instanceof ScrollThumb) {
			return new TabScrollThumbTracker(grid, clickElement);
		} else if (clickElement instanceof ScrollButton) {
			return new ScrollButtonTimer(clickElement);
		} else if (clickElement instanceof ScrollBarElement) {
			/*
			if (clickElement.ptInTrack(x, y, true)) {
				return new ScrollTrackTimer(clickElement, true);
			} else if (clickElement.ptInTrack(x, y, false)) {
				return new ScrollTrackTimer(clickElement, false);
			}
			*/
		}
	},
	onTap: function (x, y) {
		var grid = this._grid,
			selections = grid._selections,
			clickCell = this._clickCell,
			clickElement = this._clickElement,
            clickHandle = this._clickHandle,
			index = clickCell ? clickCell.index() : null,
			col = clickCell ? index.column : null;
        if (clickElement instanceof MobileEditCommandView) {
            clickElement.model().run(grid, index);
        } else if (clickCell instanceof DataCellElement) {
			index.normalize(grid);
			this.setFocused(index, true);
            this.dataCellClicked(index);
		} else if (clickCell instanceof HeaderCellElement && clickCell.clickable()) {
			if (!grid.isEmpty() && col instanceof DataColumn && col.sortable() && grid.operateOptions().sortingEnabled()) {
				grid.sortColumn(col);
			}
		} else if (clickElement instanceof IndicatorCellElement) {
			selections.add(index, index, SelectionStyle.ROWS);
		} else if (clickElement instanceof CheckBarCellElement) {
			this._checkCellClicked(clickCell, x, y);
		} else if (clickElement instanceof CheckBarHeadElement) {
			this._checkAllClicked(clickCell, x, y);
		}/* else if (clickElement instanceof StateCellElement) {
			this._stateBarCellClicked(clickCell.index().rowIndex);
		} else if (clickElement instanceof RowGroupHeadCellElement) {
			this._rowGroupHeadFootClicked(-1);
		} else if (clickElement instanceof RowGroupFootCellElement) {
			this._rowGroupHeadFootClicked(-2);
		} else if (clickElement instanceof RowGroupHeaderCellElement) {
			this._rowGroupHeaderFooterClicked(-1);
        } else if (clickElement instanceof BandedRowGroupHeaderCellElement) {
            this._rowGroupHeaderFooterClicked(-1);
		} else if (clickElement instanceof GroupFooterCellElement) {
			this._rowGroupHeaderFooterClicked(-2);
		} else if (clickElement instanceof RowGroupBarCellElement) {
			this._rowGroupBarClicked(elt.level());
		} else if (clickElement instanceof RowGroupExpandHandle) {
			this._rowGroupBarClicked(-1);
		} else if (clickElement instanceof RowGroupExpanderElement) {
			this._rowGroupBarClicked(-2);
		} else if (clickElement instanceof FooterCellElement) {
			this._footerCellClicked(clickElement.index().column);
		} else if (clickElement instanceof MobileSelectionHandle) {
		}
		*/
        else if (clickHandle && clickHandle.clickable()) {
            this._handleClicked(clickHandle);
        }
	},
	onLongTap: function (x, y) {
		return true;
	},
	onDoubleTap: function (x, y) {
        var grid = this._grid,
            index = this.focused(),
            clickIndex = this._clickCell ? this._clickCell.index() : null,
            elt = this.findElementAt(x, y, true);
		if (this._clickCell instanceof DataCellElement) {
            this.dataCellDblClicked(this._clickElement.index());
		} else if (this._clickElement instanceof RowGroupHeaderCellElement || this._clickElement instanceof BandedRowGroupHeaderCellElement) {
			var groupItem = _cast(this._clickElement.item(), GroupRow);
			if (groupItem) {
				groupItem.setExpanded(!groupItem.expanded());
			}
		}/* else if (this._clickElement instanceof HeaderCellElement) {
			if (this._clickElement.parent() instanceof HeaderElement) {
				this._grid._fireColumnHeaderDblClicked(this._clickElement.index().column);
			} else {
				this._grid._fireRowGroupPanelDblClicked(this._clickElement.index().column);
			}
		} else if (this._clickCell instanceof FooterCellElement) {
			if (this._clickCell.error()) {
				this._grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
			} else {
				this._grid._fireFooterCellDblClicked(this._clickCell.index().column);
			}
		} else if (this._clickCell instanceof GroupFooterCellElement && this._clickCell.error()) {
			this._grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
		} else if (this._clickCell instanceof StateCellElement) {
			this._grid._fireStateBarCellDblClicked(this._clickCell.index().rowIndex());
		} else if (this._clickCell instanceof RowGroupHeadCellElement) {
			this._grid._fireRowGroupHeadFootDblClicked(-1);
		} else if (this._clickCell instanceof RowGroupFootCellElement) {
			this._grid._fireRowGroupHeadFootDblClicked(-2);
		} else if (this._clickCell instanceof RowGroupHeaderCellElement) {
			this._grid._fireRowGroupHeaderFooterDblClicked(-1);
		} else if (this._clickCell instanceof GroupFooterCellElement) {
			this._grid._fireRowGroupHeaderFooterDblClicked(-2);
		} else if (this._clickCell instanceof RowGroupBarCellElement) {
			this._grid._fireRowGroupBarDblClicked(this._clickCell.level());
		} else if (this._clickCell instanceof RowGroupExpandHandle) {
			this._grid._fireRowGroupBarDblClicked(-1);
		} else if (this._clickCell instanceof RowGroupExpanderElement) {
			this._grid._fireRowGroupBarDblClicked(-2);
		} else if (this._clickElement instanceof GroupByView) {
			this._grid._firePanelDblClicked(0);
		}
		*/
        if (grid.isValidCell(index) && !grid.isEditing() && this._clickCell && this._clickCell.canEditable()) {
            if (CellIndex.areEqual(clickIndex, index)) {
                grid.$_showEditor(clickIndex);
            }
        }
	},
	onDragStart: function (startX, startY, currX, currY) {
		var elt = this._clickElement,
			tracker = null;
		if (elt instanceof DataCellElement) {
			tracker = new MobileScrollTracker(this._grid);
		} else if (elt instanceof IndicatorCellElement) {
			tracker = new MobileRowSelectTracker(this._grid, elt);
		} else if (elt instanceof HeaderCellElement) {
		} else if (elt instanceof MobileSelectionHandle) {
			tracker = new MobileSelectHandleTracker(this._grid, elt);
		} else if (elt instanceof ScrollThumb) {
		}
		if (tracker && tracker.start(startX, startY, currX, currY)) {
			this._tapTracker = tracker;
		}
	},
	onDrag: function (prevX, prevY, currX, currY) {
		var tracker = this._tapTracker;
		if (tracker) {
			if (!tracker.drag(prevX, prevY, currX, currY)) {
				tracker.cancel();
                this._tapTracker = null;
			}
		}
	},
    onDragEnd: function (currX, currY) {
        var tracker = this._tapTracker;
        if (tracker) {
            try {
                if (!tracker.drop(currX, currY)) {
                    tracker.cancel();
                }
            } finally {
                this._tapTracker = null;
            }
        }
    },
	onSwipe: function (duration, distance, dir) {
		if (!(this._clickElement instanceof DataCellElement)) {
			return;
		}
		var grid = this._grid,
		    delta = 1;
		switch (dir) {
			case "right":
				grid.setLeftPos(grid.leftPos() - distance / 20);
				break;
			case "left":
				grid.setLeftPos(grid.leftPos() + distance / 20);
				break;
			case "bottom":
				delta = -1;
			case "top":
				this._swipeDistance = delta * distance / 20;
				this._swipeDuration = duration;
				this._swipePrev = this._swipeStarted = getTimer();
				this._swipeAmount = 0;
				this._swipeTimer = setInterval(this.$_scrollRow.bind(this), 50);
				break;
		}
	},
	_footerCellClicked: function (cell) {
		this._grid._fireFooterCellClicked(cell);
	},
	_checkBarFootClicked: function (cell) {
		this._grid._fireCheckBarFootClicked(cell);
	},
	_indicatorCellClicked: function (index) {
		this._grid._fireIndicatorCellClicked(index);
	},
	_stateBarCellClicked: function (index) {
		this._grid._fireStateBarCellClicked(index);
	},
	_rowGroupHeadFootClicked: function (index) {
		this._grid._fireRowGroupHeadFootClicked(index);
	},
	_rowGroupHeaderFooterClicked: function (index) {
		this._grid._fireRowGroupHeaderFooterClicked(index);
	},
	_rowGroupBarClicked: function (index) {
		this._grid._fireRowGroupBarClicked(index);
	},
	_panelClicked: function (index) {
		this._grid._firePanelClicked(index);
	},
	_rowGroupPanelClicked: function (cell) {
		this._grid._fireRowGroupPanelClicked(cell);
	},
	$_scrollRow: function () {
		var dt, rows, t = getTimer();
		if (t - this._swipeStarted < this._swipeDuration) {
			dt = getTimer() - this._swipePrev;
			rows = (this._swipeDistance - this._swipeAmount) * dt / this._swipeDuration;
			this._swipeAmount -= rows;
			this._swipePrev = t;
			this._grid.setTopIndex(this._grid.topIndex() + rows);
		} else {
			clearInterval(this._swipeTimer);
		}
	},
    _handleClicked: function (handle) {
        var row, group,
            grid = this._grid;
        if (handle instanceof TreeExpandHandle) {
            row = handle.cellView().row();
            row && row.setExpanded(!row.expanded());
        } if (handle instanceof RowGroupExpandHandle) {
            group = _cast(handle.cellView().item(), GroupRowImpl);
            if (group) {
                if (group.expanded()) {
                    grid.collapse(group);
                } else {
                    grid.expand(group, false, false)
                }
            }
        } else if (handle instanceof DataCellExpandHandle) {
            group = handle.group();
            if (group) {
                if (group.expanded()) {
                    grid.collapse(group);
                } else {
                    grid.expand(group, false, false)
                }
                if (!group.expanded()) {
                    row = group.index() >= 0 ? group : group.firstLeaf();
                    if ((!row || row.index() < 0) && group.footer()) {
                        row = group.footer();
                    }
                    if (row) {
                        grid.makeRowVisible(row.index());
                    }
                }
            }
        }
    }
});
var MobileSelectionHandle = defineClass("MobileSelectionHandle", UIElement, {
	init: function (selectionView, dir) {
		this._super(selectionView._dom, "mobileSelectionHandle");
		this._view = selectionView;
		this._dir = dir;
		this._background = new SolidBrush(0xff333333);
		if (this._dom) {
			this._border = null;
			this.setWidth(11);
			this.setHeight(11);
		} else {
			this._border = this._dom ? new SolidPen(0xffffffff, 5) : new SolidPen(0xffdddddd, 1);
			this.setWidth(21);
			this.setHeight(21);
		}
	},
	view: function () {
		return this._view;
	},
	dir: function () {
		return this._dir;
	},
	propertyChanged: function (/*prop, value*/) {
		this.invalidate();
	},
	_doDraw: function (g) {
		g.drawBounds(this._background, this._border, 5, 5, 11, 11);
	},
	_doDrawHtml: function (g) {
		this._css.background = this._background.css();
		this._css.border = this._border ? this._border.css() : "";
		this._css.padding = this._css.margin = 0;
	}
});
var MobileSelectionView = defineClass("MobileSelectionView", LayerElement, {
	init : function(dom) {
		this._super(dom, "mobileSelectionView");
		this._item = null;
		this._background = MobileSelectionView.$$_defBackground;
		this._border = MobileSelectionView.$$_defBorder;
		this.addElement(this._leftHandle = new MobileSelectionHandle(this, "left"));
		this.addElement(this._rightHandle = new MobileSelectionHandle(this, "right"));
		this.addElement(this._topHandle = new MobileSelectionHandle(this, "top"));
		this.addElement(this._bottomHandle = new MobileSelectionHandle(this, "bottom"));
	},
	background: null,
	border: null,
	item: function () {
		return this._item;
	},
	setBackground: function (value) {
		if (value !== this._background) {
			this._background = value;
			this.invalidate();
		}
	},
	setBorder: function (value) {
		if (value != this._border) {
			this._border = value;
			this.invalidate();
		}
	},
	updateElement: function (item, styles) {
        var x, y, st, isBlock,
			grid = this.container().gridView(),
            editing = grid.isEditing() || grid.isRowEditing(),
            cw = this.width(),
            ch = this.height(),
            w = this._leftHandle.width(),
            h = this._leftHandle.height();
		this._item = item;
		this.setBackground(styles.background());
		this.setBorder(styles.border());
		w += this._dom ? 3 : 0;
		h += this._dom ? 3 : 0;
		x = (cw - w) / 2;
		y = (ch - h) / 2;
		st = item.style();
		isBlock = st == SelectionStyle.BLOCK || st == SelectionStyle.SINGLE;
		this._leftHandle._context = this._context;
		this._rightHandle._context = this._context;
		this._topHandle._context = this._context;
		this._bottomHandle._context = this._context;
		this._leftHandle.setVisible(!editing && (isBlock || SelectionStyle.isColumn(st)));
		this._rightHandle.setVisible(!editing && this._leftHandle.visible());
		this._topHandle.setVisible(!editing && (isBlock || SelectionStyle.isRow(st)));
		this._bottomHandle.setVisible(!editing && this._topHandle.visible());
		this._leftHandle.visible() && this._leftHandle.move(-w / 2, y);
		this._rightHandle.visible() && this._rightHandle.move(cw - w / 2, y);
		this._topHandle.visible() && this._topHandle.move(x, -h / 2);
		this._bottomHandle.visible() && this._bottomHandle.move(x, ch - h / 2);
		this._leftHandle.invalidate();
		this._rightHandle.invalidate();
		this._topHandle.invalidate();
		this._bottomHandle.invalidate();
	},
	_doDraw: function (g) {
		var grid = this.container().gridView(),
		    lm = grid.layoutManager(),
		    r = lm.gridBounds();
		r = grid._selectionLayer.translateBy(this, r);
		g.clipRectEx(r);
		g.drawBoundsI(this._background, this._border, 0, 0, this.width(), this.height());
	},
	_doDrawHtml: function () {
		/*
		var grid = this.container().gridView();
		var lm = grid.layoutManager();
		var r = lm.gridBounds();
		r = grid._selectionLayer.translateBy(this, r);
		g.clipRectEx(r);
		*/
		this._css.background = this._background.css();
		this._css.border = this._border.css();
	}
});
MobileSelectionView.$$_defBackground = new SolidBrush(0x10000000);
MobileSelectionView.$$_defBorder = new SolidPen(0xff333333, 2);
var MobileEditCommand = defineClass("MobileEditCommand", null, {
    init: function (owner, name, config) {
        this._super();
        this._owner = owner;
        this._name = name;
        this._label = config.label;
        this._styles = new GridStyles(owner, 'mobileEditCommand', {
            line: SolidPen.WHITE,
            paddingLeft: 11,
            paddingRight: 11,
            paddingTop: 9,
            paddingBottom: 9
        });
        if (config) {
            this._callback = config.callback;
            this._renderer = config.renderer;
            config.styles && this._styles.extend(config.styles);
        }
    },
    run: function (grid, index) {
        var cb = this._callback;
        if (cb) {
            cb(grid, index);
        } else {
            this._doRun(grid, index);
        }
    },
    _doRun: function (grid, index) {
    }
});
var MobileEditCommandView = defineClass("MobileEditCommandView", GridElement, {
    init: function (dom, model) {
        this._super(dom, 'mobileEditCommandView');
        this._model = model;
    },
    model: function () {
        return this._model;
    },
    _doRender: function(g, r) {
        var m = this._model,
            styles = m._styles,
            fill = styles.background(),
            stroke = styles.line() || SolidPen.WHITE,
            rd = m._renderer;
        g.drawRectI(fill, SolidPen.WHITE, r);
        styles.deflatePaddings(r);
        if (rd) {
            rd(g, r, stroke);
        }
        styles.inflatePaddings(r);
    },
    _doRenderHtml: function (r) {
        this._doRender(this.$_getGraphics(true), r);
    }
});
var MobileEditCommander = defineClass("MobileEditCommander", LayerElement, {
    init: function (grid, commands) {
        this._super(grid._dom, 'mobileEditCommander');
        this._grid = grid;
        this._commands = [];
        this._views = {};
        commands && this.addCommands(commands);
    },
    itemWidth: 41,
    itemHeight: 35,
    addCommands: function (commands) {
        var cnt, i, cfg, cmd;
        if (_isArray(commands) && (cnt = commands.length) > 0) {
            for (i = 0; i < cnt; i++) {
                cfg = commands[i];
                if (cfg && cfg.name && _isFunction(cfg.callback) && _isFunction(cfg.renderer)) {
                    cmd = new MobileEditCommand(this._grid, cfg.name, cfg);
                    this._commands.push(cmd);
                }
            }
            this.updateElement();
        }
    },
    updateElement: function () {
        var i, cmd, view, w, h, x,
            map = this._views,
            cnt = this._commands.length;
        this.setVisible(cnt > 0);
        if (this.visible()) {
            this.clear();
            w = this._itemWidth;
            h = this._itemHeight;
            x = 0;
            for (i = 0; i < cnt; i++) {
                cmd = this._commands[i];
                view = map[cmd.$_hash];
                if (!view) {
                    view = new MobileEditCommandView(this._dom, cmd);
                    map[cmd.$_hash] = view;
                }
                this.addChild(view);
                view.setBounds(x, 0, w, h);
                x += w;
            }
            this.resize(x, h);
        }
    }
});
var MobileEditCommandBar = defineClass("MobileEditCommandBar", EventAware, {
    init: function (grid, commands) {
        this._super(grid._dom, 'mobileEditCommander');
        this._grid = grid;
        this._commands = [];
        this._element = this._createElement();
        this._upper = false;
        commands && this.addCommands(commands);
    },
    addCommands: function (commands) {
        var cnt, i, cfg, cmd;
        if (_isArray(commands) && (cnt = commands.length) > 0) {
            for (i = 0; i < cnt; i++) {
                cfg = commands[i];
                if (cfg && cfg.name && _isFunction(cfg.callback)) {
                    cmd = new MobileEditCommand(this._grid, cfg.name, cfg);
                    this._commands.push(cmd);
                }
            }
            this._updateElement();
        }
    },
    show: function (x, y, width, upper) {
        var elt = this._element,
            css = elt.style;
        this._updateElement(upper);
        css.left = x + 'px';
        css.top = y + 'px';
        css.width = width + 'px';
        document.documentElement.appendChild(elt);
    },
    hide: function () {
        var elt = this._element;
        if (elt && elt.parentNode) {
            document.documentElement.removeChild(elt);
        }
    },
    _createElement: function () {
        var doc = document;
        var div = Dom.createElement('div', {
            position: 'absolute',
            textAlign: 'center',
            zIndex: 3002
        });
        var anchor = Dom.createElement('div', {
            width: '100%',
            height: '5px',
            background: '#e5edf4',
            boxShadow: '2px 1px grey'
        });
        var panel = Dom.createElement('div', {
            display: 'inline-block',
            background: '#e5edf4',
            marginTop: '-1px',
            padding: '6px 20px',
            borderBottomLeftRadius: '6px',
            borderBottomRightRadius: '6px',
            boxShadow: '2px 2px grey'
        });
        panel.$_buttons = [];
        div.appendChild(anchor);
        div.appendChild(panel);
        div.$_anchor = anchor;
        div.$_panel = panel;
        return div;
    },
    _updateElement: function (upper) {
        var cmd, btn, t, i,
            grid = this._grid,
            panel = this._element.$_panel,
            buttons = panel.$_buttons,
            cmds = this._commands;
        while (buttons.length < cmds.length) {
            btn = Dom.createElement('button', {
                marginLeft: '4px',
                marginRight: '4px',
                padding: '2px 5px'
            });
            t = document.createTextNode('');
            btn.appendChild(t);
            btn.$_text = t;
            buttons.push(btn);
        }
        while (buttons.length > cmds.length) {
            panel.removeChild(buttons[buttons.length - 1]);
        }
        for (i = 0; i < cmds.length; i++) {
            cmd = cmds[i];
            btn = buttons[i];
            btn.onclick = (function (cmd) {
                return function () {
                    cmd.run(grid);
                }
            })(cmd);
            btn.$_text.textContent = cmd._label || cmd._name;
            if (btn.parentNode !== panel) {
                panel.appendChild(btn);
            }
        }
    }
});
var TapDragTracker = defineClass("TapDragTracker", null, {
	init: function(grid, name) {
		this._super();
		this._grid = grid;
		this._name = name;
	},
    needRedraw: false,
	grid: function () {
		return this._grid;
	},
	name: function () {
		return this._name;
	},
	start: function(startX, startY, currX, currY) {
		return this._doStart(startX, startY, currX, currY);
	},
	drag: function(startX, startY, currX, currY) {
		return this._doDrag(startX, startY, currX, currY);
	},
	drop: function (x, y) {
        this.needRedraw() && this._grid.container().invalidate();
		return this._doDrop(x, y);
	},
	cancel: function () {
		this._doCancel();
	},
	_doStart: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrag: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrop: function (x, y) {
        return true;
	},
	_doCancel: function () {
	}
});
var MobileScrollTracker = defineClass("MobileScrollTracker", TapDragTracker, {
	init: function(grid) {
		this._super(grid, "mobileScrollTracker");
		this._tapX = this._tapY = NaN;
		this._vertical = true;
	},
	_doStart: function(startX, startY, currX, currY) {
		var dx = currX - startX;
		var dy = currY - startY;
		this._vertical = Math.abs(dy) >= Math.abs(dx);
		if (this._vertical) {
			this._grid.setTopIndex(this._grid.topIndex() + (dy > 0 ? -1 : 1));
		} else {
			this._grid.setLeftPos(this._grid.leftPos() - dx);
		}
		this._tapX = currX;
		this._tapY = currY;
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var dx = currX - this._tapX;
		var dy = currY - this._tapY;
		var vertical = Math.abs(dy) >= Math.abs(dx);
		if (vertical != this._vertical) {
			if (vertical && Math.abs(dy) > Math.abs(dx) * 2 || !vertical && Math.abs(dx) > Math.abs(dy) * 2) {
				this._vertical = vertical;
			}
		}
		if (this._vertical) {
			if (Math.abs(dy) > 5) {
				this._grid.setTopIndex(this._grid.topIndex() + (dy > 0 ? -1 : 1));
				this._tapY = currY;
			}
		} else {
			this._grid.setLeftPos(this._grid.leftPos() - dx);
			this._tapX = currX;
		}
		return true;
	}
});
var MobileRowSelectTracker = defineClass("MobileRowSelectTracker", TapDragTracker, {
	init: function(grid, cell) {
		this._super(grid, "mobileRowSelectTracker");
		this._cell = cell;
		this._item = null;
	},
	_doStart: function(startX, startY, currX, currY) {
		var grid = this._grid;
		var selections = grid._selections;
		var index = this._cell.index();
		selections.clear();
		this._item = selections.add(index, index, SelectionStyle.ROWS);
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (index.rowIndex >= 0) {
			this._item.resizeTo(index);
		}
		return true;
	}
});
var MobileColumnSelectTracker = defineClass("MobileColumnSelectTracker", TapDragTracker, {
	init: function(grid, cell) {
		this._super(grid, "mobileColumnSelectTracker");
		this._cell = cell;
		this._item = null;
	},
	_doStart: function(startX, startY, currX, currY) {
		var grid = this._grid;
		var selections = grid._selections;
		var index = this._cell.index();
		selections.clear();
		this._item = selections.add(index, index, SelectionStyle.COLUMNS);
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (index.column) {
			this._item.inflate(currX > prevX ? "right" : "left", index);
		}
		return true;
	}
});
var MobileSelectHandleTracker = defineClass("MobileSelectHandleTracker", TapDragTracker, {
	init: function(grid, handle) {
		this._super(grid, "mobileSelectHandleTracker");
		this._handle = handle;
	},
	_doStart: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (index.rowIndex >= 0) {
			var item = this._handle.view().item();
			item.inflate(this._handle.dir(), index);
		}
		return true;
	},
});
/** @abstract */
var MobileColumnMoveTracker = defineClass("MobileColumnMoveTracker", TapDragTracker, {
    init: function (cell, name) {
        this._super(cell.grid(), name);
        this._cell = cell;
        this._sourceFeedback = new HeaderCellElement(this._grid._dom, "columnMoveFeedback");
        this._sourceFeedback.setAlpha(0.7);
        this._targetFeedback = new ColumnMoveFeedback(this._grid._dom, "columnMoveTargetFeedback");
        this._targetFeedback.setAlpha(0.9);
        this.setNeedRedraw(true);
    },
    _doStart: function(startX, startY, currX, currY) {
        return true;
    },
    _doDrag: function(prevX, prevY, currX, currY) {
        var grid = this._grid;
        var index = grid.pointToIndex(currX, currY, false);
        if (index.rowIndex >= 0) {
            var item = this._handle.view().item();
            item.inflate(this._handle.dir(), index);
        }
        return true;
    }
});
/** @internal */
var TabScrollThumbTracker = defineClass("TabScrollThumbTracker", null, {
	init: function (grid, thumbView) {
		this._super();
		this._grid = grid;
		this._thumb = thumbView;
	},
	start: function (x, y) {
		this._thumb.setPressed(true);
		var bar = this._thumb.scrollBar();
		var p = bar.containerToElement(x, y);
		if (bar.vertical()) {
			this._offset = p.y - this._thumb.y();
		} else {
			this._offset = p.x - this._thumb.x();
		}
	},
	move: function (x, y) {
		this.$_doScroll(x, y, ScrollEventType.THUMB_TRACK);
	},
	stop: function (x, y) {
		this._thumb.setPressed(false);
		this.$_doScroll(x, y, ScrollEventType.THUMB_END);
	},
	$_doScroll: function (x, y, eventType) {
		var bar = this._thumb.scrollBar();
		var len = bar._maxPosition - bar._min + 1;
		var szBtn = bar._buttonSize;
		var p = bar.containerToElement(x, y);
		if (bar.vertical()) {
			p.y -= this._offset;
			p.y = (p.y - szBtn) * len / (bar.height() - szBtn * 2 - this._thumb.height());
			bar._doScroll(eventType, 0, _int(p.y));
		} else {
			p.x -= this._offset;
			p.x = (p.x - szBtn) * len / (bar.width() - szBtn * 2 - this._thumb.width());
			bar._doScroll(eventType, 0, _int(p.x));
		}
	}
});
/** @internal */
var MobileResizer = defineClass("MobileResizer", LayerElement, {
	init: function () {
		this._super("focusView");
		this._border = new SolidPen(0xff333333, 2);
		this._editBorder = new SolidPen(0xff000000 + (82 << 16) + (146 << 8) + 247, 2);
		this._editing = false;
	},
	setEditing: function (editing, buttonWidth) {
		if (editing != this._editing) {
			this._editing = editing;
			this._buttonWidth = buttonWidth;
			this.invalidate();
		}
	},
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0);
		g.drawBoundsI(null, this._editing ? this._editBorder : this._border, -1, -1, w - 1, this.height() - 1);
	}
});
var MobileEditController = defineClass("MobileEditController", GridEditController, {
	init: function (grid) {
		this._super(grid);
        this._commander = new MobileEditCommander(grid, [{
            name: 'cancel',
            callback: function (grid, index) {
                grid.cancelEditor();
            },
            renderer: function (g, r, stroke) {
                g.drawLine(stroke, r.x, r.y, r.right(), r.bottom());
                g.drawLine(stroke, r.right(), r.y, r.x, r.bottom());
            },
            styles: {
                background: '#f00'
            }
        }, {
            name: 'commit',
            callback: function (grid, index) {
                grid.commitEditor();
            },
            renderer: function (g, r, stroke) {
                g.drawLines(stroke,
                    r.x, r.y + r.height * 2 / 3,
                    r.x + r.width / 3, r.bottom(),
                    r.right(), r.y
                );
            },
            styles: {
                background: '#080'
            }
        }]);
	},
    setFocus: function (force) {
        this.$_focusToEditor(force, this._grid.isRowEditing());
    },
    $_focusToEditor: function (force, preparing) {
        if (preparing || this._needPrepare()) {
            this._super(preparing || force);
        }
    },
    _needPrepare: function (index) {
        return index && this._grid.isRowEditing(index.getRow(this._grid));
    },
	showEditor: function (index) {
        var editing = this.isEditing();
        var ret = this._super(index);
        if (!editing && ret) {
            this.caretToLast();
        }
        return ret;
	},
    _editorActivated: function (editor) {
        this._super(editor);
        var r, w, h, x, y,
            cont = this._grid.container(),
            c = this._commander;
        if (editor) {
            c.updateElement();
            r = this._grid.getEditCellBounds(this._editIndex);
            w = c.width();
            h = c.height();
            x = r.right() - w;
            y = r.y - h - 5;
            if (y < 0) {
                if (cont.width() - w >= r.right()) {
                    x = Math.min(cont.width() - w, r.right() + 2);
                    y = Math.max(0, r.y - 2);
                } else if (r.x >= w) {
                    x = Math.max(0, r.x - w - 2);
                    y = Math.max(0, r.y - 2);
                } else if (cont.height() - h >= r.bottom()) {
                    y = Math.min(cont.height() - h, r.bottom() + 2);
                }
            }
            c.setPosition(x, y);
            cont.addFeedback(c);
        } else {
            cont.removeFeedback(c);
        }
        this._grid.invalidate();
    }
});
var AnimationInfo = defineClass("AnimationInfo", null, {
	init : function(target, source) {
		this._super();
        this.target = target;       // column
        this.property = null;       // value or style properties
        this.startValue = "old";    // old or zero
        this.duration = 1000;
        source && this.assign(source);
	},
    assign: function (source) {
        if (source) {
            if (source.hasOwnProperty("property")) {
                this.property = source.property;
            }
            if (source.hasOwnProperty("startValue")) {
                this.property = source.startValue;
            }
            if (source.hasOwnProperty("duration")) {
                this.duration = source.duration;
            }
        }
        return this;
    }
});
var AnimationInfoCollection = defineClass("AnimationInfoCollection", null, {
    init : function (target) {
        this._super();
        this._target = target;
        this._items = [];
    },
    count: function () {
        return this._items.length;
    },
    getItem: function (index) {
        return this._items[index];
    },
    assign: function (source) {
        if (_isArray(source)) {
            for (var i = 0; i < source.length; i++) {
                var src = source[i];
                src && this._items.push(new AnimationInfo(this._target, src));
            }
        } else if (source) {
            this._items.push(new AnimationInfo(this._target, source));
        }
    }
});
var AnimationRun = defineClass("AnimationRun", null, {
    init : function(info, value, t) {
        this._super();
        this._info = info;
        this._startValue = value;
        this._started = t;
        this._current = 0.0; // 0.0 ~ 1.0
    },
    isActive: function () {
        return this._current <= 1;
    },
    startValue: function () {
        return this._startValue;
    },
    current: function () {
        return this._current;
    },
    check: function (t) {
        var info = this._info;
        if (!info) {
            return false;
        }
        this._current = (t - this._started) / info.duration;
        if (this._current > 1) {
            return false;
        }
        if (info.target instanceof GridColumn && !info.target.visible()) {
            return false;
        }
        return true;
    },
    animate: function (grid, lm) {
        grid.invalidate();
        return true;
    }
});
var ValueAnimation = defineClass("ValueAnimation", AnimationRun, {
    init: function (info, value, t) {
        this._super(info, value, t);
    }
});
var StyleAnimation = defineClass("StyleAnimation", AnimationRun, {
    init: function (info, value, t) {
        this._super(info, value, t);
    }
});
var AnimationManager = defineClass("AnimationManager", null, {
    init : function(grid) {
        this._super();
        this._grid = grid;
        this._runs = {};
        this._interval = 20;
        this._timer = undefined;
        this._timerHandler = this.doRun.bind(this);
        this._startTimer = undefined;
        this._saveRuns = 0;
    },
    active: function () {
        return this._timer !== undefined;
    },
    enabled: function () {
        return this._grid && this._grid.effectOptions().animationEnabled();
    },
    clear: function () {
        this.stop();
        this._runs = {};
    },
    clearTarget: function (target) {
        var runs = this._runs[target.$_hash];
        if (runs) {
            var has = false;
            for (var k in runs) {
                has = true;
                break;
            }
            if (has) {
                delete this._runs[tarkget.$_hash];
                return true;
            }
        }
        return false;
    },
    add: function (target, key, run) {
        if (!this.enabled()) return;
        var runs = this._runs[target.$_hash];
        if (!runs) {
            this._runs[target.$_hash] = runs = {};
        }
        runs[key] = run;
    },
    getRuns: function (target, key) {
        if (this._timer) {
            var runs = this._runs[target.$_hash];
            if (runs) {
                return runs[key];
            }
        }
        return null;
    },
    start: function (restart) {
        var options = this._grid.effectOptions();
        if (!options.animationEnabled()) {
            this.stop();
            return false;
        }
        if (this.active()) {
            if (restart) {
                this.stop();
            } else {
                return false;
            }
        }
        this._timer = setInterval(this._timerHandler, this._interval);
        _trace("Animation started: " + _getTimer());
        return true;
    },
    stop: function () {
        if (this._timer !== undefined) {
            clearInterval(this._timer);
            this._timer = undefined;
            this._runs = {};
            _trace("Animation stopped: " + _getTimer());
            return true;
        }
        return false;
    },
    requestLoad: function (lm) {
        if (!this.enabled()) return;
        this.clear();
        var cols = lm.getDataColumns();
        var top = lm.topIndex();
        var rowCount = lm.itemCount();
        var now = _getTimer();
        for (var i = cols.length; i--;) {
            var col = cols[i];
            var anis = col.animations();
            var cnt = anis.count();
            if (cnt > 0) {
                for (var j = 0; j < cnt; j++) {
                    var info = anis.getItem(j);
                    for (var r = 0; r < rowCount; r++) {
                        var row = lm.grid().getRow(r + top).dataIndex();
                        if (row >= 0) {
                            var run = info.value == "value" ? new ValueAnimation(info, 0, now) : new StyleAnimation(info, 0, now);
                            this.add(col, row, run);
                        }
                    }
                }
            }
        }
        this.start();
    },
    requestNew: function (lm, rowId) {
        if (!this.enabled()) return;
        this.start();
    },
    requestUpdate: function (lm, rowId, field) {
        if (!this.enabled()) return;
        if (!lm.containsDataRow(rowId)) return;
        var cols;
        if (field < 0) {
            cols = lm.getDataColumns();
        } else {
            cols = lm.getDataColumnsOf(field);
        }
        if (cols && cols.length > 0) {
            var cnt = 0;
            var now = _getTimer();
            for (var i = cols.length; i--;) {
                var col = cols[i];
                var anis = col.animations();
                for (var j = anis.count(); j--;) {
                    var info = anis.getItem(j);
                    var oldVal = lm.getCellValue(rowId, col);
                    var run = info.value == "value" ?  new ValueAnimation(info, oldVal, now) : new StyleAnimation(info, oldVal, now);
                    this.add(col, rowId, run);
                    cnt++;
                }
            }
            if (cnt > 0) {
                this.start();
            }
        }
    },
    doRun: function () {
        var grid = this._grid;
        var options = grid.effectOptions();
        if (!options.animationEnabled()) {
            this.stop();
            return;
        }
        var lm = grid.layoutManager();
        var runMap = this._runs;
        var now = _getTimer();
        var runCnt = 0;
        for (var r in runMap) {
            var runs = runMap[r];
            if (runs) {
                var cnt = 0;
                for (var k in runs) {
                    var run = runs[k];
                    if (run.check(now)) {
                        if (run.animate(grid, lm)) {
                            cnt++;
                        } else {
                            delete runs[k];
                        }
                    } else {
                        run.animate(grid, lm);
                        delete runs[k];
                    }
                }
                runCnt += cnt;
                if (cnt < 1) {
                    delete runMap[r];
                }
            }
        }
        this._saveRuns = runCnt;
        if (runCnt > 0) {
            _trace("Animation run: " + runCnt);
        } else {
            this.stop();
        }
    },
});
var _licmod = _licson['module'];
var GridComponent = defineClass("GridComponent", UIComponent, {
    init: function (dom, containerId, readMode) {
        if (_loadLog) {
            _dlog(_loadLog);
            _loadLog = undefined;
        }
        this._super(dom, containerId);
        this._createBackgroundElements(dom);
        this._gridView = this._createGridView(this.$_dom, this, readMode);
        this._addGridView(this._gridView);
        this._prepareLayers(dom);
        this.setDefaultTool(this._createDefaultTool());
    },
    gridView: function () {
        return this._gridView;
    },
    _createChildren: function (containerElement) {
    },
    _layoutChildren: function (bounds) {
        /*
         var r = bounds.clone();
         r.inflate(-1, -1);
         this._vscrollView.setBounds(r.right() - 20, r.y, 20, r.height);
         this._hscrollView.setVisible(false);
         */
    },
    _blockContextMenu: function () {
        return this._gridView.displayOptions().preventSystemMenu();
    },
    _beforeRender: function (bounds) {
        this._gridView._beforeRender(bounds);
    },
    _afterRender: function (bounds) {
        this._gridView._afterRender(bounds);
    },
    _doLayout: function (bounds) {
        var border, w,
            grid = this._gridView,
            r = bounds.clone();
        if (!this.$_dom) {
            border = grid._styles.border();
            if (border) {
                w = border.width();
                w && r.inflate(-w, -w);
            }
        }
        grid.setRect(r);
        r.x = r.y = 0;
        grid._doLayout(r);
    },
    _doDrawBorder: function (g, r) {
        var w, x, y, pen,
            border = this._gridView._styles.border();
        if (border) {
            w = border.width();
            if (w > 0) {
                x = r.x + _int(w / 2);
                y = r.y + _int(w / 2);
                if (!this._invalidated && !border.opaque()) {
                    pen = w > 1 ? new SolidPen(0xffffffff, w) : SolidPen.WHITE;
                    g.drawBoundsI(null, pen, x, y, r.width - w, r.height - w);
                }
                g.drawBoundsI(null, border, x, y, r.width - w, r.height - w);
            }
        }
    },
    _doDrawBorderHtml: function (r) {
        var border = this._gridView._styles.border();
        if (border) {
            this._container.style.border = border.css();
        } else {
            this._container.style.border = '';
            this._container.style.borderStyle = "none";
        }
    },
    _focusHandler: function (event) {
        this._gridView._focusHandler(event);
    },
    onImageLoaded: function (url) {
        this._super(url);
        this._gridView._imageLoaded = true;
    },
    _createBackgroundElements: function (dom) {
    },
    _addGridView: function(grid) {
        this.addElement(grid);
    },
    _createGridView: function (dom, container, readMode) {
        return new GridView(dom, container, readMode);
    },
    _prepareLayers: function (dom) {
    },
    _createDefaultTool: function () {
        return ($_mobileEnabled && _isMobile()) ? new MobileSelectionTool(this) : new GridViewSelectionTool(this);
    }
});
/*
var GridBorderElement = defineClass("GridBorderElement", LayerElement, {
    init: function (dom) {
        this._super(dom, "gridBorderView");
        this._border = new SolidPen(0xffaaaaaa);
        this.setMouseEnabled(false);
    },
    _doDraw: function (g) {
        var w = this._border.width();
        var p = _int(w / 2);
        g.drawBoundsI(null, this._border, p, p, this.width() - w, this.height() - w);
    }
});
*/
var _wmv_ = function (dom) {
    var img = new _egam_();
    var lic = _licson && _licson["toolwm"];
    try {
        img.src = $$_image64 + (lic || _wmv);
        img.onload = function () {
            if (img.width < 30 || img.height < 20) {
                img.src = $$_image64 + _wm_;
            }
        };
    } catch (err) {
        img.src = $$_image64 + _wm_;
    }
    var view = new LayerElement(dom);
    view._doDraw = function (g) {
        g.aL(img, this.width() - img.width - 20, this.height() - img.height - 50, img.width, img.height);
    };
    view._doDrawHtml = function (g) {
        this._dom.appendChild(img);
        img.style.position = 'absolute';
        img.style.left = (this.width() - img.width - 20) + 'px';
        img.style.top = (this.height() - img.height - 50) + 'px';
    };
    return view;
};
var $_INVISIBLE_EDIT_BOUNDS = new Rectangle(-10000, -10000, 100, 100);
var GridBase = defineClass("GridBase", LayerElement, {
    init: function (dom, container, readMode) {
        this._super(dom, "gridView");
        this._container = container;
        this._readMode = readMode;
        this._offsetX = 0;
        this._offsetY = 0;
        this._gridRect = new Rectangle();
        if (container.$_rich) {
            this._context = container._context;
            this._toolContext = new CanvasContext("toolContext");
            container.addContext(this._toolContext);
        }
        this._loading = true;
        this._userMode = false;
        this._userModeError = null;
        this._gridObjects = [];
        this._addGridObject(this._panel = this._createPanelModel());
        this._addGridObject(this._groupPanel = this._createGroupPanelModel());
        this._addGridObject(this._header = new GridHeader(this));
        this._addGridObject(this._editBar = new EditBar(this));
        this._addGridObject(this._footer = this._createFooterModel());
        this._addGridObject(this._rowIndicator = new RowIndicator(this));
        this._addGridObject(this._checkBar = new CheckBar(this));
        this._addGridObject(this._body = new GridBody(this));
        this._addGridObject(this._rowGroup = new RowGroup(this));
        this._addGridObject(this._hscrollBar = new ScrollBar(this));
        this._addGridObject(this._vscrollBar = new ScrollBar(this));
        this._headerItems = new CustomGridItemCollection(this, CustomGridItemType.HEADER);
        this._footerItems = new CustomGridItemCollection(this, CustomGridItemType.FOOTER);
        var view = this._rootElement = new LayerElement(dom, "grid root view", true);
        this.addChild(view);
        this._rootLayer = new LayerElement(dom, "grid layer root view", true);
        this.addChild(this._rootLayer);
        this._bordersLayer = new GridBordersElement(dom, this);
        this.addChild(this._bordersLayer);
        view = this._emptyView = this._createEmptyView(dom);
        view.setVisible(false);
        this.addChild(view);
        this._panelView = this._createPanelView(dom, this._panel);
        this._groupPanelView = this._createGroupPanelView(dom, this._groupPanel);
        this._bodyView = this._createBodyView(dom, this._body, false);
        this._fixedBodyView = this._createBodyView(dom, this._body, true);
        this._mergeView = new GridMergeElement(dom);
        this._fixedMergeView = new GridMergeElement(dom, true);
        this._mergeHeaderLayer = new GridMergeHeaderElement(dom);
        this._headerView = new HeaderElement(dom, this._header);
        this._fixedHeaderView = new HeaderElement(dom, this._header, true);
        this._summaryView = new HeaderSummaryElement(dom, this._header.summary());
        this._fixedSummaryView = new HeaderSummaryElement(dom, this._header.summary(), true);
        this._headerItemsView = new CustomGridItemsLayer(dom, this._headerItems);
        this._rowIndicatorView = new RowIndicatorElement(dom, this._rowIndicator);
        this._stateBarView = new StateBarElement(dom, this._rowIndicator);
        this._checkBarView = new CheckBarElement(dom, this._checkBar);
        this._footerItemsView = new CustomGridItemsLayer(dom, this._footerItems);
        this._footerView = this._createFooterView(dom, this._footer, false);
        this._fixedFooterView = this._createFooterView(dom, this._footer, true);
        this._bandedGroupView = new BandedRowGroupElement(dom, this._rowGroup);
        this._summaryHeadView = new HeaderSummaryHeadElement(dom);
        this._checkBarHeadView = new CheckBarHeadElement(dom);
        this._rowGroupHeadView = new RowGroupHeadElement(dom);
        this._headerHeadView = new HeaderHeadElement(dom);
        this._footerHeadView = new FooterHeadElement(dom);
        this._panelView && this.addElement(this._panelView);
        this._groupPanelView && this.addElement(this._groupPanelView);
        this._linesLayer = new GridLinesElement(dom, this);
        this._rootElement.addChildren([
            this._bodyView,
            this._mergeView,
            this._fixedBodyView,
            this._fixedMergeView,
            this._mergeHeaderLayer,
            this._headerView,
            this._fixedHeaderView,
            this._summaryView,
            this._fixedSummaryView,
            this._headerItemsView
        ]);
        this._addGroupView();
        this._rootElement.addChildren([
            this._rowIndicatorView,
            this._stateBarView,
            this._checkBarView,
            this._linesLayer,
            this._footerItemsView,
            this._footerView,
            this._fixedFooterView,
            this._summaryHeadView,
            this._headerHeadView,
            this._checkBarHeadView,
            this._rowGroupHeadView,
            this._footerHeadView
        ]);
        this._selectionLayer = new LayerElement(dom, "selectionLayer");
        this.addLayer(this._selectionLayer);
        this._focusLayer = new LayerElement(dom, "focusLayer");
        this.addLayer(this._focusLayer);
        if (!$_mobileEnabled || !_isMobile()) {
            this._autoFillLayer = new LayerElement(dom, "autoFillLayer");
            this.addLayer(this._autoFillLayer);
            this._autoFillHandle = new AutoFillHandle(dom, this).setVisible(false);
            this._autoFillLayer.addElement(this._autoFillHandle, this._toolContext);
        }
        this._scrollLayer = new LayerElement(dom, "scrollLayer");
        this.addLayer(this._scrollLayer);
        this._hscrollView = null;
        this._vscrollView = null;
        this._feedbackLayer = new LayerElement(dom, "feedbackLayer");
        this.addLayer(this._feedbackLayer);
        this.addFeedbackElement(this._wmv = _wmv_(dom));
        this._rootColumn = new RootColumn(this);
        this._dataRoots = new DataRootCollection();
        this._columnLayouts = new ColumnLayoutCollection();
        this._columnLayout = null;
        this._orgColumns = [];
        this._orgColumned = true;
        this._columnLayoutChanged = false;
        this._columnsLock = false;
        this._columnWidthsDirty = false;
        this._columnsDirty = false;
        this._columnSpansDirty = false;
        this._rowSource = null;
        this._lookupProvider = null;
        this._dataTags = this._createDataTagManager();
        this._displayOptions = new DisplayOptions(this);
        this._editOptions = new EditOptions(this);
        this._operateOptions = new OperateOptions(this);
        this._effectOptions = new EffectOptions(this);
        this._autoFill = new AutoFill(this);
        this._delegate = this._createDelegate();
        this._eventHandler = this._delegate.createGridEventHandler();
        this._eventHandler && this.addListener(this._eventHandler);
        this._layoutManager = this._createLayoutManager();
        this._heightMeasurer = null;
        this._toolTipManager = new ToolTipManager(this);
        this._clipboardManager = new ClipboardManager(this);
        this._progressManager = new ProgressManager(this._container._container);
        this._selections = new SelectionManager(this);
        this._selections.addListener(this);
        this._selectionViews = new Dictionary();
        this._editController = this._createEditController();
        this._validationManager = new ValidationManager(this);
        this._columnSummaryRuntime = new ColumnSummaryRuntime();
        this._columnDefaultRuntime = new ColumnDefaultRuntime(this);
        this._rowGroupSummaryRuntime = new RowGroupSummaryRuntime(this);
        this._columnValidationRuntime = new DataCellValidationRuntime();
        this._rowValidationRuntime = new DataRowValidationRuntime();
        this._seriesValueRuntime = new SeriesValueRuntime(this);
        this._cellRendererRuntime = new CellRendererExpressionRuntime(this);
        this._defaultStyles = new GridStyles(this, "gridDefault");
        this._styles = new GridStyles(this, "grid", {
            background: null
        });
        this._styles.setParent(this._defaultStyles, false);
        this._stylesDirty = false;
        this._headerItemStyles = new GridStyles(this, "headerItem");
        this._footerItemStyles = new GridStyles(this, "footerItem");
        this._scrollEdgeStyles = new GridStyles(this, "scrollEdge");
        this.initStyles();
        this._styleRegionMap = null;
        this._columnStyles = {};		// style name -> styles
        this._ownedStyleManager = this._styleManager = new CellStyleManager(this);
        this._styleManager.addListener(this);
        this._palettes = new PaletteManager(this);
        this._animations = this._createAnimationManager();
        this._resetting = false;
        this._layouted = false;
        this._focusing = false;
        this._focusedColumn = null;
        this._shadowIndex = new CellIndex();
        this._oldFocusIdx = new CellIndex();
        this._newFocusIdx = new CellIndex();
        this._tmpIndex = new CellIndex();
        this._currentRow = -1;
        this._currentRowId = -1;
        this._currentRowChanged = _getTimer();
        this._vertScroll = 0;
        this._horzScroll = 0;
        this._imageLists = {};
        this._delegate.prepareResources();
        this._filterSelector = new ColumnFilterSelector(this._container._popupOwner || this._container._container);
        this._toastManager = new ToastManager(this);
        this._popupMenuManager = new PopupMenuManager(this.container(), this).addListener(this);
        this._contextMenu = null;
        this._defaultContextMenu = null;
        this.$_prepareContextMenu();
        this._dataCellRenderers = new DataCellRendererCollection(this._delegate);
        this._dataCellEditors = new CellEditorCollection(this._delegate);
        this._topIndex = 0;
        this._prevTopIndex = 0;
        this._prevLeftPos = 0;
        this._prevRowCount = 0;
        this._dataChanged = false;
        this._imageLoaded = false;
        this._cellUpdateEventLock = false;
        this._updateLock = 0;
        this._rowChangeTimer = undefined;
        this._rowChangeTimerCallback = function () {
            this.$_checkCurrentRow(true);
        }.bind(this);
        this.$_fixedColCount = this.$_fixedRowCount = 0;
        this._productName = "DataLudi Grids v1.3, 2014-2017.";
    },
    onPaletteChanged: function (manager) {
        this.refreshView();
    },
    stylesChanged: function (entry) {
        if (!this._stylesDirty) {
            this._stylesDirty = true;
            this.refreshView();
        }
    },
    cellStyleAdded: function (id, needUpdate) {
        if (needUpdate) {
            this.invalidateEditor();
        }
    },
    cellStyleChanged: function (id, needUpdate) {
        if (needUpdate) {
            (id == this.getFocusedCellStyle()) && this.invalidateEditor();
            this.invalidateLayout();
        }
    },
    cellStyleRemoved: function (id, style, needUpdate) {
        this.itemSource().removeCellStyle(style);
        if (needUpdate) {
            (id == this.getFocusedCellStyle()) && this.invalidateEditor();
            this.invalidateLayout();
        }
    },
    cellStylesCleared: function (needUpdate) {
        this.itemSource().clearCellStyles();
        if (needUpdate) {
            this.invalidateEditor();
            this.invalidateLayout();
        }
    },
    onCellStyleManagerStyleChanged: function (manager) {
        this.invalidateEditor();
        this.invalidateLayout();
    },
    onCellStyleManagerCellChanged: function (manager, rows, fields) {
        if (rows !== undefined || fields !== undefined) {
            this.invalidateEditor();
        } else {
            var idx = this.$_focusedIndex();
            var r = idx.dataIndex(this);
            if (r >= 0 && idx.column) {
                var f = idx.column.dataIndex();
                if (r == rows && f == fields) {
                    this.invalidateEditor();
                } else if (r == rows || _isArray(rows) && rows.indexOf(r) >= 0) {
                    if (f == fields || _isArray(fields) && fields.indexOf(f) >= 0) {
                        this.invalidateEditor();
                    }
                }
            }
        }
        this.invalidateLayout();
    },
    viewId: "grid",
    columns: null,
    columnLayout: null,
    rowFilter: {
        get: function () {
            return this._items && this._items.rowFilter();
        },
        set: function (value) {
            this._items && this._items.setRowFilter(value);
            return this;
        }
    },
    maxRowCount: {
        get: function () {
            var rs = this.rowSource();
            return rs ? rs.maxItemCount() : 0;
        },
        set: function (value) {
            var rs = this.rowSource();
            if (rs) {
                value = Math.max(0, parseInt(value));
                if (!isNaN(value) && value != this.maxRowCount()) {
                    rs.setMaxItemCount(value);
                }
            }
            return this;
        }
    },
    body: null,
    panel: null,
    groupPanel: null,
    header: null,
    editBar: null,
    footer: null,
    rowIndicator: null,
    checkBar: null,
    rowGroup: null,
    hscrollBar: null,
    vscrollBar: null,
    headerItems: null,
    footerItems: null,
    displayOptions: null,
    editOptions: null,
    operateOptions: null,
    effectOptions: null,
    autoFill: null,
    defaultStyles: null,
    styles: null,
    headerItemStyles: null,
    footerItemStyles: null,
    scrollEdgeStyles: null,
    styleManager: null,
    topIndex: 0,
    leftPos: 0,
    undoable: false,
    readMode: false,
    userMode: false,
    userModeError: null,
    userData: null, // dataludi는 손대지 않는다. 그리드 개발자들이 임의로 사용할 수 있도록 한다.
    setReadMode: function (value) {
        if (value != this._readMode) {
            this._readMode = value;
            this._editController && this._editController.deactivate();
            this._editController = this._createEditController();
            this._editController && this._editController.reactivate(this.focusedIndex());
        }
        return this;
    },
    setStyleManager: function (value) {
        if (value !== this._styleManager) {
            this._styleManager && this._styleManager.removeListener(this);
            this._styleManager = value;
            value && value.addListener(this);
            this.invalidateLayout();
        }
        return this;
    },
    setUserMode: function (value) {
        this._userMode = value;
        return this;
    },
    setUserModeError: function (value) {
        this._userModeError = value;
        return this;
    },
    setDefaultStyles: function (value) {
        if (value !== this._defaultStyles) {
            this._defaultStyles.extend(value);
        }
        return this;
    },
    setStyles: function (value) {
        if (value !== this._styles) {
            this._styles.extend(value);
        }
        return this;
    },
    setHeaderItemStyles: function (value) {
        if (value !== this._headerItemStyles) {
            this._headerItemStyles.extend(value);
        }
        return this;
    },
    setFooterItemStyles: function (value) {
        if (value !== this._footerItemStyles) {
            this._footerItemStyles.extend(value);
        }
        return this;
    },
    setScrollEdgeStyles: function (value) {
        if (value !== this._scrollEdgeStyles) {
            this._scrollEdgeStyles.extend(value);
        }
        return this;
    },
    rowGrouped: function () {
        return false;
    },
    canShowGroupFooters: function () {
        return this.rowGrouped();
    },
    dataCellRenderers: function () {
        return this._dataCellRenderers;
    },
    rowSource: function () {
        return this._rowSource;
    },
    setRowSource: function (value) {
        if (!value) {
            throw new Error("RowProvider can not be null");
        }
        if (value !== this._rowSource) {
            if (this._rowSource) {
                this._rowSource.removeListener(this);
            }
            this._rowSource = value;
            if (this._rowSource) {
                this._rowSource.addListener(this);
            }
        }
        return this;
    },
    itemSource: function () {
        return this._rowSource;
    },
    setItemSource: function (value) {
        return this.setRowSource(value);
    },
    dataSource: function () {
        return this._rowSource ? this._rowSource.dataSource() : null;
    },
    setDataSource: function (value) {
        var oldDs = this.dataSource();
        this._rowSource && this._rowSource.setDataSource(value);
        var ds = this.dataSource();
        if (ds !== oldDs) {
            if (oldDs) {
                oldDs.removeTag(this._dataTags);
            }
            if (ds) {
                ds.addTag(this._dataTags);
                this.applyFilters();
            }
        }
        return this;
    },
    undoable_: function () {
        var rs = this.rowSource();
        return rs && rs.undoable();
    },
    setUndoable: function (value) {
        var rs = this.rowSource();
        rs && rs.setUndoable(value);
        return this;
    },
    activeTool: function () {
        return this.container().activeTool();
    },
    /** @deprecated Use tooltipManager() instead. */
    toolTipManager: function () {
        return this._toolTipManager;
    },
    tooltipManager: function () {
        return this._toolTipManager;
    },
    validationManager: function () {
        return this._validationManager;
    },
    editController: function () {
        return this._editController;
    },
    /** @internal */
    cellStyles: function () {
        return this._cellStyles;
    },
    setBody: function (value) {
        if (value !== this._body) {
            this._body.assign(value);
        }
        return this;
    },
    setPanel: function (value) {
        if (value !== this._panel) {
            this._panel && this._panel.assign(value);
        }
        return this;
    },
    setGroupPanel: function (value) {
        if (value !== this._groupPanel) {
            this._groupPanel && this._groupPanel.assign(value);
        }
        return this;
    },
    setHeader: function (value) {
        if (value !== this._header) {
            this._header.assign(value);
        }
        return this;
    },
    setEditBar: function (value) {
        if (value !== this._editBar) {
            this._editBar.assign(value);
        }
        return this;
    },
    setFooter: function (value) {
        if (value !== this._footer) {
            this._footer.assign(value);
        }
        return this;
    },
    setRowIndicator: function (value) {
        if (value !== this._rowIndicator) {
            this._rowIndicator.assign(value);
        }
        return this;
    },
    setCheckBar: function (value) {
        if (value !== this._checkBar) {
            this._checkBar.assign(value);
        }
        return this;
    },
    setRowGroup: function (value) {
        if (value !== this._rowGroup) {
            this._rowGroup.assign(value);
        }
        return this;
    },
    setHscrollBar: function (value) {
        if (value !== this._hscrollBar) {
            this._hscrollBar.assign(value);
        }
        return this;
    },
    setVscrollBar: function (value) {
        if (value !== this._vscrollBar) {
            this._vscrollBar.assign(value);
        }
        return this;
    },
    setHeaderItems: function (value) {
        if (value !== this._headerItems) {
            this._headerItems.assign(value);
        }
        return this;
    },
    setFooterItems: function (value) {
        if (value !== this._footerItems) {
            this._footerItems.assign(value);
        }
        return this;
    },
    setDisplayOptions: function (value) {
        if (value !== this._displayOptions) {
            this._displayOptions.assign(value);
        }
        return this;
    },
    setEditOptions: function (value) {
        if (value !== this._editOptions) {
            this._editOptions.assign(value);
        }
        return this;
    },
    setOperateOptions: function (value) {
        if (value !== this._operateOptions) {
            this._operateOptions.assign(value);
        }
        return this;
    },
    setEffectOptions: function (value) {
        if (value !== this._effectOptions) {
            this._effectOptions.assign(value);
        }
        return this;
    },
    setAutoFill: function (value) {
        if (value !== this._autoFill) {
            this._autoFill.assign(value);
        }
        return this;
    },
    panelView: function () {
        return this._panelView;
    },
    groupPanelView: function () {
        return this._groupPanelView;
    },
    mergeView: function () {
        return this._mergeView;
    },
    fixedMergeView: function () {
        return this._fixedMergeView;
    },
    mergeHeaderView: function () {
        return this._mergeHeaderLayer;
    },
    rowIndicatorView: function () {
        return this._rowIndicatorView;
    },
    stateBarView: function () {
        return this._stateBarView;
    },
    checkBarView: function () {
        return this._checkBarView;
    },
    headerView: function () {
        return this._headerView;
    },
    fixedHeaderView: function () {
        return this._fixedHeaderView;
    },
    summaryView: function () {
        return this._summaryView;
    },
    fixedSummaryView: function () {
        return this._fixedSummaryView;
    },
    headerItemsView: function () {
        return this._headerItemsView;
    },
    footerItemsView: function () {
        return this._footerItemsView;
    },
    footerView: function () {
        return this._footerView;
    },
    fixedFooterView: function () {
        return this._fixedFooterView;
    },
    rowGroupHeadView: function () {
        return this._rowGroupHeadView;
    },
    bandedGroupView: function () {
        return this._bandedGroupView;
    },
    summaryHeadView: function () {
        return this._summaryHeadView;
    },
    headerHeadView: function () {
        return this._headerHeadView;
    },
    checkBarHeadView: function () {
        return this._checkBarHeadView;
    },
    footerHeadView: function () {
        return this._footerHeadView;
    },
    bodyView: function () {
        return this._bodyView;
    },
    fixedBodyView: function () {
        return this._fixedBodyView;
    },
    delegate: function () {
        return this._delegate;
    },
    layoutManager: function () {
        return this._layoutManager;
    },
    lm: function () {
        return this._layoutManager;
    },
    popupMenuManager: function () {
        return this._popupMenuManager;
    },
    popupShowing: function () {
        return this._editOptions.allowKeysOnMenu() && this._popupMenuManager.showing();
    },
    selections: function () {
        return this._selections;
    },
    columnSummaryRuntime: function () {
        return this._columnSummaryRuntime;
    },
    columnDefaultRuntime: function () {
        return this._columnDefaultRuntime;
    },
    rowGroupSummaryRuntime: function () {
        return this._rowGroupSummaryRuntime;
    },
    columnValidationRuntime: function () {
        return this._columnValidationRuntime;
    },
    rowValidationRuntime: function () {
        return this._rowValidationRuntime;
    },
    seriesValueRuntime: function () {
        return this._seriesValueRuntime;
    },
    cellRendererRuntime: function () {
        return this._cellRendererRuntime;
    },
    heightMeasurer: function () {
        return this._heightMeasurer || SimpleHeightsMeasurer.Default;
    },
    setHeightMeasurer: function (value) {
        if (value !== this._heightMeasurer) {
            this._heightMeasurer = value;
            this.refreshView();
        }
        return this;
    },
    setTopIndex: function (value) {
        value = isNaN(value) ? 0 : value;
        value = Math.max(0, Math.min(parseInt(value), this.rowCount() - 1, this._vscrollView ? this._vscrollView.maxPosition() : 0));
        if (value != this._topIndex) {
            this._topIndex = value;
            this.refreshView();
            this.closePopups();
        }
        return this;
    },
    topRow: function () {
        return this._topIndex + this.lm().fixedItemCount();
    },
    setTopRow: function (value) {
        return this.setTopIndex(value - this.lm().fixedItemCount());
    },
    maxHorzPos: function () {
        return this._hscrollView ? this._hscrollView.maxPosition() : 0;
    },
    setLeftPos: function (value) {
        value = isNaN(value) ? 0 : value;
        value = Math.max(0, Math.min(parseInt(value), this.maxHorzPos()));
        if (value != this._leftPos) {
            this._leftPos = value;
            this.refreshView();
            this.closePopups();
        }
        return this;
    },
    leftCol: function () {
        var lm = this._layoutManager;
        return lm ? lm.firstCol() : 0;
    },
    setLeftCol: function (value) {
        var lm = this._layoutManager;
        if (lm) {
            value = Math.max(lm.fixedColCount(), Math.min(value, lm.columnCount() - 1));
            return this.setLeftPos(lm.columnBounds(value).x);
        }
        return this;
    },
    isEmptyColumns: function () {
        return this.visibleColumnCount() == 0;
    },
    isEmptyRows: function () {
        return this.rowCount() == 0;
    },
    isEmpty: function () {
        return this.rowCount() == 0 || this.visibleColumnCount() == 0;
    },
    isEmptyData: function () {
        var ds = this.dataSource();
        return !ds || ds.rowCount() == 0;
    },
    lookupProvider: function () {
        return this._lookupProvider;
    },
    setLookupProvider: function (value) {
        if (value != this._lookupProvider) {
            if (this._lookupProvider) {
                this._lookupProvider.removeListener(this);
            }
            if (value && !(value instanceof LookupSourceProvider)) {
                value = new LocalLookupSourceProvider(value);
            }
            this._lookupProvider = value;
            if (this._lookupProvider) {
                this._lookupProvider.addListener(this);
            }
            this.refreshView();
        }
        return this;
    },
    getHeaderLevel: function () {
        return this._rootColumn.headerLevel();
    },
    getDataLevel: function () {
        return this._rootColumn.dataLevel();
    },
    getFooterLevel: function () {
        return this._rootColumn.footerLevel();
    },
    getHeaderSummaryLevel: function () {
        return this._rootColumn.headerSummaryLevel();
    },
    getGroupHeaderLevel: function () {
        return this._rootColumn.groupHeaderLevel();
    },
    getGroupFooterLevel: function () {
        return this._rootColumn.groupFooterLevel();
    },
    dataRowCount: function () {
        var ds = this.dataSource();
        return ds ? ds.rowCount() : 0;
    },
    rowCount: function () {
        return this._rowSource ? this._rowSource.rowCount() : 0;
    },
    /** @deprecated use descendantDataCount instead. */
    descendantCount: function () {
        return this.descendantDataCount();
    },
    /** 자손 데이터행 개수. 편집 행은 제외 */
    descendantDataCount: function () {
        return this._rowSource ? this._rowSource.descendantCount() : 0;
    },
    /** 자손행 개수. 편집 행은 제외 */
    descendantRowCount: function () {
        return this._rowSource ? this._rowSource.descendantRowCount() : 0;
    },
    /** 자손행들을 가져온다. 편집 행은 제외 */
    getDescendantRows: function (visibleOnly, dataOnly) {
        return this._rowSource ? this._rowSource.getDescendantRows(visibleOnly, dataOnly) : [];
    },
    columnCount: function () {
        return this._rootColumn.count();
    },
    visibleColumnCount: function () {
        return this._rootColumn.visibleCount();
    },
    columns_: function () {
        return this._rootColumn.columns();
    },
    setColumns: function (value, attachKey) {
        this._checkEditing();
        this._columnsLock = true;
        try {
            this._rootColumn.setColumns(value, attachKey);
            this._orgColumns = this._rootColumn.columns();
            this._orgColumned = true;
            this._columnLayoutChanged = true;
        } finally {
            this._columnsLock = false;
            this._columnsReset(this._rootColumn);
            this.dataSource() && this.applyFilters();
        }
        return this;
    },
    columnLayouts: function () {
        return this._columnLayouts.items();
    },
    setColumnLayout: function (value) {
        this._checkEditing();
        var layout = _cast(value, ColumnLayout);
        if (!layout) {
            if (typeof value == "string") {
                layout = this._columnLayouts.find(value);
            } else {
                layout = ColumnLayout.create(value);
            }
        }
        if (layout != this._columnLayout) {
            this._columnLayout = layout;
            if (layout) {
                this._columnsLock = true;
                try {
                    if (this._orgColumned) {
                        this._saveOrgWidths();
                        this._orgColumned = false;
                    }
                    this._rootColumn.setColumns(layout.build(this));
                    this._columnLayoutChanged = true;
                } finally {
                    this._columnsLock = false;
                    this._columnsRestore();
                    this._rootColumn._clearSavedWidths();
                }
            } else {
                this.restoreColumns(true);
            }
        }
        return this;
    },
    firstRow: function () {
        var i = this.rowCount();
        return i > 0 ? this._rowSource.getItem(i - 1) : null;
    },
    lastRow: function () {
        var i = this.rowCount();
        return i > 0 ? this._rowSource.getItem(0) : null;
    },
    focusedIndex: function () {
        var items = this.itemSource();
        return items ? CellIndex.create(items.current(), this._focusedColumn) : null;
    },
    $_focusedIndex: function () {
        var items = this.itemSource();
        return this._shadowIndex.set(items ? items.current() : -1, this._focusedColumn);
    },
    focusedRow: function () {
        var items = this.itemSource();
        return items ? items.currentRow() : null;
    },
    focusedRowIndex: function () {
        var items = this.itemSource();
        return items ? items.current() : -1;
    },
    focusedDataRow: function () {
        var items = this.itemSource();
        return items ? items.currentDataRow() : null;
    },
    focusedDataIndex: function () {
        var row = this.focusedRow();
        return row ? row.dataIndex() : -1;
    },
    focusedGroupRow: function () {
        return _cast(this.focusedRow(), GroupRow);
    },
    focusedColumn: function () {
        return this._focusedColumn;
    },
    $_getVisibleRow: function (row) {
        if (row) {
            if (!row.visible()) {
                var dataRow = row.dataIndex();
                if (dataRow >= 0) {
                    row.makeVisible();
                    row = this.getRowOfDataIndex(dataRow);
                }
            }
        }
        return row;
    },
    setFocusedRow: function (rowIndex, focus, select) {
        focus = arguments.length > 1  ? focus : false;
        select = arguments.length > 2 ? select : true;
        if (rowIndex instanceof GridRow) {
            var row = this.$_getVisibleRow(rowIndex);
            rowIndex = row ? row.index() : -1;
        }
        var index = this.$_focusedIndex().clone();
        index.rowIndex = rowIndex;
        return this.setFocusedIndex(index, focus, select);
    },
    setFocusedDataRow: function (dataIndex, focus, select) {
        dataIndex = arguments.length > 0 ? dataIndex : 0;
        focus = arguments.length > 1  ? focus : false;
        select = arguments.length > 2 ? select : true;
        var row = dataIndex.rowId ? dataIndex.rowId() : dataIndex;
        row = this.getRowOfDataIndex(row);
        if (row) {
            this.setFocusedRow(row.index(), focus, select);
        }
        return this;
    },
    requestFocusedDataRow: function (dataIndex) {
        this._requestedFocusedDataRow = dataIndex;
    },
    setFocusedColumn: function (column, focus, select) {
        focus = arguments.length > 1  ? focus : false;
        select = arguments.length > 2 ? select : true;
        var index = this.$_focusedIndex().clone();
        index.column = column;
        return this.setFocusedIndex(index, focus, select);
    },
    setFocusedCell: function (rowIndex, column, focus, select) {
        focus = arguments.length > 2  ? focus : false;
        select = arguments.length > 3 ? select : true;
        if (rowIndex instanceof GridRow) {
            var row = this.$_getVisibleRow(rowIndex);
            rowIndex = row ? row.index() : -1;
        }
        if (typeof column === 'string') {
            column = this.columnByName(column);
        }
        var index = CellIndex.create(rowIndex, column);
        return this.setFocusedIndex(index, focus, select);
    },
    clearFocused: function () {
        if (this.isValidCell(this.$_focusedIndex())) {
            this._focusedColumn = null;
            if (!this._loading && !this._updateLock) {
                this.invalidateLayout();
                this.clearSelection();
                this._layoutSelectionViews();
            }
        }
    },
    setFocusedIndex: function (value, focus, select) {
        focus = arguments.length > 1  ? focus : false;
        select = arguments.length > 2 ? select : true;
        if (!this._focusing && this._displayOptions.focusable()) {
            this._focusing = true;
            try {
                this._doSetFocusedIndex(value, focus, select);
            } finally {
                this._focusing = false;
            }
        }
        return this;
    },
    _doSetFocusedIndex: function (value, focus, select) {
        if (!value) {
            return false;
        }
        var itemSource = this.itemSource();
        if (!itemSource) {
            return false;
        }
        if (value && !this.isValidCell(value)) {
            value = value.clone();
            value.normalize(this);
        }
        if (value.column instanceof ColumnGroup) {
            value.column = (value.column.first());
        }
        if (!this.isValidCell(value)) {
            var ds = this.dataSource();
            if (!ds || ds.rowCount() == 0 || this.rowCount() == 0) {
                this._focusedColumn = this.getFirstColumn();
                itemSource.setCurrent(-1);
            }
            return false;
        }
        var saveIndex = this.$_focusedIndex();
        var oldIndex = this.focusedIndex();
        if (value && CellIndex.areEqual(value, oldIndex)) {
            focus && this.$_makeFocusIndexVisible();
            return true;
        }
        if (!this._fireCurrentChanging(value, oldIndex)) {
            return false;
        }
        if (!this.isValidCell(value)) {
            return false;
        }
        oldIndex.rowIndex = itemSource.current();
        oldIndex.column = this._focusedColumn;
        if (CellIndex.areEqual(value, oldIndex)) {
            focus && this.$_makeFocusIndexVisible();
            return true;
        }
        this.closePopups2();
        if (!this._editController.focusedIndexChanging()) {
            return false;
        }
        oldIndex.rowIndex = itemSource.current();
        oldIndex.column = this._focusedColumn;
        if (CellIndex.areEqual(value, oldIndex)) {
            focus && this.$_makeFocusIndexVisible();
            return true;
        }
        itemSource.setCurrent(value.rowIndex);
        value.rowIndex = itemSource.current();
        this._focusedIndexChanged(saveIndex, value, select, focus);
        this._focusing = false;
        this._fireCurrentChanged(this._shadowIndex.assign(value));
        return true;
    },
    $_checkDiffsChanged: function () {
        var options, rs = this.itemSource();
        if (rs) {
            options = this.editOptions();
            rs.setDiffs(options.checkDiff(), options.checkCellDiff(), options.strictDiff());
        }
    },
    _focusedIndexChanged: function (oldIndex, newIndex, select, focus, noCommit) {
        var cellView, room,
            rs = this.itemSource(),
            options = this.editOptions(),
            tool = this.container().activeTool(),
            lm = this.lm();
        if (this.isValidCell(oldIndex)) {
            room = lm.getMergedCell(oldIndex);
            cellView = this.getCellView(room ? this._mergeView : null, oldIndex);
            if (cellView) {
                cellView.setFocused(false);
            }
        }
        this._focusedColumn = newIndex.column;
        rs.setDiffs(options.checkDiff(), options.checkCellDiff(), options.strictDiff());
        this._editController.focusedIndexChanged(oldIndex, newIndex, noCommit);
        tool && tool.focusedIndexChanged(oldIndex, newIndex, noCommit);
        if (this.isValidCell(newIndex)) {
            room = lm.getMergedCell(newIndex);
            cellView = this.getCellView(room ? this._mergeView : null, newIndex);
            if (cellView && cellView.setFocused) {
                cellView.setFocused(true);
            }
            if (this._rowIndicatorView.visible()) {
                this._rowIndicatorView.refresh();
            }
            if (this._headerView.visible()) {
                this._headerView.refresh();
            }
            if (this._fixedHeaderView.visible()) {
                this._fixedHeaderView.refresh();
            }
        }
        if (select) {
            this.clearSelection();
        }
        if (focus) {
            this.$_makeFocusIndexVisible();
        }
        this._layoutAutoFillHandle();
        if (!this.$_checkCurrentRow()) {
            this.$_checkLastCellCommit(oldIndex);
        }
    },
    $_makeFocusIndexVisible: function () {
        var index = this.$_focusedIndex();
        if (this.isValidCell(index)) {
            this.makeCellVisible(index);
        }
    },
    isScrolling: function () {
        return this._scrolling;
    },
    isHorzScrolling: function () {
        return this._horzScrolling;
    },
    toastManager: function () {
        return this._toastManager;
    },
    setCellUpdateEventLock: function (value) {
        this._cellUpdateEventLock = value;
    },
    displayRowCount: function () {
        return this._layoutManager.itemCount();
    },
    fullDisplayRowCount: function (fullRowsOnly) {
        return this._layoutManager.fullItemCount();
    },
    sorted: function () {
        return this.rowSource().isSorted();
    },
    filtered: function () {
        return this.rowSource().isFiltered();
    },
    onRowCountChanged: DLCallback,
    onDisplayRowCountChanged: DLCallback,
    onDescendantRowCountChanged: DLCallback,
    onDescendantDataCountChanged: DLCallback,
    onCurrentChanging: DLCallback,
    onCurrentChanged: DLCallback,
    onCurrentRowChanged: DLCallback,
    onValidateCell: DLCallback,
    onValidateRow: DLCallback,
    onTopIndexChanged: DLCallback,
    onScrollToBottom: DLCallback,
    onScrollToTop: DLCallback,
    onSelectionChanged: DLCallback,
    onSelectionAdded: DLCallback,
    onSelectionRemoved: DLCallback,
    onSelectionCleared: DLCallback,
    onSelectionResized: DLCallback,
    onSelectionEnded: DLCallback,
    onUpdating: DLCallback,
    onUpdateStarted: DLCallback,
    onInserting: DLCallback,
    onInsertStarted: DLCallback,
    onDeleting: DLCallback,
    onKeyDown: DLCallback,
    onShowEditor: DLCallback,
    onEditChanged: DLCallback,
    onEditCommitted: DLCallback,
    onEditCanceled: DLCallback,
    onEditSearch: DLCallback,
    onEditCellUpdated: DLCallback,
    onEditRowCommitted: DLCallback,
    onEditRowCanceled: DLCallback,
    onCopy: DLCallback,
    onPaste: DLCallback,
    onEditRowPasted: DLCallback,
    onPasted: DLCallback,
    onRowChecked: DLCallback,
    onRowsChecked: DLCallback,
    onCheckedChanged: DLCallback,
    onAllChecked: DLCallback,
    onAllCheck: DLCallback,
    onErrorClicked: DLCallback,
    onSorting: DLCallback,
    onSorted: DLCallback,
    onFiltering: DLCallback,
    onFiltered: DLCallback,
    onAutoFilling: DLCallback,
    onAutoFilled: DLCallback,
    onPopupMenuPopup: DLCallback,
    onPopupMenuClicked: DLCallback,
    onContextMenuPopup: DLCallback,
    onContextMenuClicked: DLCallback,
    onUndoStateChanged: DLCallback,
    onColumnHeaderClicked: DLCallback,
    onColumnHeaderDblClicked: DLCallback,
    onColumnChecked: DLCallback,
    onHeaderHeadClicked: DLCallback,
    onHeaderHeadDblClicked: DLCallback,
    onRowIndicatorCellClick: DLCallback,
    onRowIndicatorCellClicked: DLCallback,
    onRowIndicatorCellDblClicked: DLCallback,
    onStateCellClicked: DLCallback,
    onStateCellDblClicked: DLCallback,
    onCheckCellClicked: DLCallback,
    onCheckCellDblClicked: DLCallback,
    onCheckBarHeadClicked: DLCallback,
    onCheckBarHeadDblClicked: DLCallback,
    onFooterCellClicked: DLCallback,
    onFooterCellDblClicked: DLCallback,
    onFooterHeadClicked: DLCallback,
    onFooterHeadDblClicked: DLCallback,
    onHeaderSummaryCellClicked: DLCallback,
    onHeaderSummaryCellDblClicked: DLCallback,
    onHeaderSummaryHeadClicked: DLCallback,
    onHeaderSummaryHeadDblClicked: DLCallback,
    onCellButtonClicked: DLCallback,
    onEditorButtonClicked: DLCallback,
    onDataButtonClicked: DLCallback,
    onClickableCellClicked: DLCallback,
    onDataCellClick: DLCallback,
    onDataCellClicked: DLCallback,
    onDataCellDblClicked: DLCallback,
    onColumnParentChanged: DLCallback,
    onColumnMoved: DLCallback,
    onColumnVisibleChanged: DLCallback,
    onExcludeColumn: DLCallback,
    onColumnResizing: DLCallback,
    onColumnResized: DLCallback,
    onRowResizing: DLCallback,
    onRowResized: DLCallback,
    dispose: function () {
    },
    resetSize: function () {
        this.container().resetSize();
    },
    adjustSize: function (duration) {
        this.container().adjustSize(duration);
    },
    setOptions: function (source) {
        if (source) {
            var v;
            (v = source.display) && this._displayOptions.assign(v);
            (v = source.edit) && this._editOptions.assign(v);
            (v = source.operate) && this._operateOptions.assign(v);
            (v = source.effect) && this._effectOptions.assign(v);
            source.rowGroup && (v = source.rowGroup.panel) && this.setGroupPanel(v);
            if (v = source.scrollBar) {
                this.setVscrollBar(v);
                this.setHscrollBar(v);
            }
            this.setProperties(source);
            /*
             source.body && this.setBody(source.body);
             source.panel && this.setPanel(source.panel);
             source.groupPanel && this.setGroupPanel(source.groupPanel);
             source.checkBar && this.setCheckBar(source.checkBar);
             source.editBar && this.setEditBar(source.editBar);
             source.header && this.setHeader(source.header);
             source.footer && this.setFooter(source.footer);
             source.rowGroup && this.setRowGroup(source.rowGroup);
             */
        }
        return this;
    },
    registerCustomGridItemType: function (type, clazz) {
        this._headerItems.registerType(type, clazz);
        this._footerItems.registerType(type, clazz);
    },
    _createHeightMeasurer: function (type) {
        if (type == "fixed") {
            return new FixedHeightsMeasurer();
        }
        return null;
    },
    loadStyles: function (styles) {
        for (var i = 0; i < arguments.length; i++) {
            StylesArchiver.deserialize(arguments[i], this);
        }
        return this;
    },
    /** @internal */
    containerToGridRect: function (r) {
        r.x -= this._offsetX;
        r.y -= this._offsetY;
        return r;
    },
    /** @internal */
    containerToGridX: function (x) {
        return x - this._offsetX;
    },
    /** @internal */
    containerToGridY: function (y) {
        return y - this._offsetY;
    },
    setCursor: function (cursor) {
        this.container().setDefaultCursor(cursor);
    },
    updateNow: function () {
        this.container().updateNow();
    },
    setColumnsProperty: function (prop, value, visibleOnly) {
        this._rootColumn.setChildrenProperty(prop, value, true, visibleOnly);
    },
    $_columnWidthChanged: function (column, oldWidth, newWidth) {
        this.fireEvent(GridBase.COLUMN_WIDTH_CHANGED, column, newWidth, oldWidth);
    },
    invalidateColumnWidths: function () {
        if (!this._columnWidthsDirty) {
            this._columnWidthsDirty = true;
            this._columnsDirty = true;
            this.refreshView();
        }
    },
    invalidateColumns: function () {
        if (!this._columnsDirty) {
            this._columnsDirty = true;
            this.refreshView();
        }
    },
    getVisibleColumns: function (parent) {
        var p = _cast(parent, ColumnGroup) || this._rootColumn;
        return p.getVisibleColumns();
    },
    getHiddenColumns: function (parent) {
        var p = _cast(parent, ColumnGroup) || this._rootColumn;
        return p.getHiddenColumns();
    },
    getRow: function (rowIndex) {
        return this._rowSource.getItem(rowIndex);
    },
    getRows: function (rowIndices, allowNull) {
        var i, cnt, row,
            items = this._rowSource;
            rows = null,
            all = rowIndices == null || rowIndices === undefined;
        if (all) {
            rows = [];
            for (i = 0, cnt = items.rowCount(); i < cnt; i++) {
                rows.push(items.getItem(i));
            }
        } else if (_isArray(rowIndices)) {
            rows = [];
            for (i = 0, cnt = rowIndices.length; i < cnt; i++) {
                var row = items.getItem(rowIndices[i]);
                (row || allowNull) && rows.push(row);
            }
        }
        return rows;
    },
    getRowIndices: function (rows, all) {
        if (!rows) return null;
        all = arguments.length > 1 ? all : true;
        var i, idx,
            cnt = rows.length,
            ids = new Array(all ? cnt : 0);
        if (all) {
            for (i = 0; i < cnt; i++) {
                ids[i] = rows[i].index();
            }
        } else {
            for (i = 0; i < cnt; i++) {
                idx = rows[i].index();
                idx >= 0 && rows.push(idx);
            }
        }
        return ids;
    },
    getRowIndexOfDataIndex: function (dataIndex) {
        return this._rowSource.getIndexOfRow(dataIndex);
    },
    getRowOfDataIndex: function (dataIndex, visibleOnly) {
        return this._rowSource.getItemOfRow(dataIndex, !visibleOnly);
    },
    getRowIndicesOfDataIndices: function (dataIndices) {
        return this._rowSource.getIndicesOfRows(dataIndices);
    },
    getAllRows: function () {
        return this._rowSource ? this._rowSource.getAllItems() : null;
    },
    getTopRows: function () {
        return this._rowSource ? this._rowSource.getTopItems() : null;
    },
    getLeafRows: function (visibleOnly, dataOnly) {
        return this._rowSource ? this._rowSource.getLeafItems(visibleOnly, dataOnly) : null;
    },
    visitRows: function (visibleOnly, dataOnly, callback) {
        this._rowSource && this._rowSource.visitRows(visibleOnly, dataOnly, callback);
    },
    getCellIndex: function (rowIndex, column) {
        rowIndex = arguments.length > 0 ? rowIndex : 0;
        column = arguments.length > 1 ? (typeof column == "string" ? this.columnByName(column) : column) : this.getFirstColumn();
        return new CellIndex(rowIndex, column);
    },
    isValidCell: function (index) {
        return index && (index.rowIndex >= 0) && (index.rowIndex < this.rowCount()) && index.column && index.column !== this._rootColumn && (index.column.grid() === this);
    },
    isValidColumn: function (index) {
        return index && index.column && (index.column.grid() === this);
    },
    isValidRow: function (index) {
        return index && (index.rowIndex >= 0) && (index.rowIndex < this.rowCount());
    },
    beginUpdate: function () {
        this._updateLock++;
    },
    endUpdate: function (refresh) {
        if (this._updateLock > 0) {
            this._updateLock--;
            refresh = arguments.length > 0 ? refresh : true;
            if (this._updateLock == 0 && refresh) {
                this.refreshView();
            }
        }
    },
    invalidateLayout: function () {
        if (!this._updateLock) {
            this._super();
        }
    },
    refreshView: function () {
        if (!this._loading && !this._updateLock) {
            this.invalidateLayout();
            this.setTopIndex(this.topIndex());
            this.setLeftPos(this.leftPos());
            this.setFocusedIndex(this.$_focusedIndex(), false, true);
        }
    },
    resetGrid: function () {
        if (!this._loading && !this._updateLock) {
            this._resetting = true;
            this.setTopIndex(0);
            this.setLeftPos(0);
            this.setFocusedIndex(new CellIndex(this.rowCount() > 0 ? 0 : -1, this.getFirstColumn()), false, true);
            this.refreshView();
        }
    },
    isFixedRow: function (row) {
        return row && row.index() < this._layoutManager.fixedItemCount();
    },
    isFixedRowIndex: function (rowIndex) {
        return rowIndex >= 0 && rowIndex < this._layoutManager.fixedItemCount();
    },
    isFixedColumn: function (column) {
        return column && column.root().displayIndex() < this._layoutManager.fixedColCount();
    },
    isFixedCell: function (index) {
        return index && (this.isFixedColumn(index.column) || this.isFixedRowIndex(index.rowIndex));
    },
    getFirstCell: function () {
        if (this.rowCount() > 0) {
            var rowIndex = -1;
            for (var i = 0, cnt = this.rowCount(); i < cnt; i++) {
                if (this.getRow(i) instanceof DataRow) {
                    rowIndex = i;
                    break;
                }
            }
            return new CellIndex(rowIndex, this.getFirstColumn());
        }
        return null;
    },
    getFirstColumn: function () {
        return this._rootColumn.first();
    },
    getLastColumn: function () {
        return this._rootColumn.last();
    },
    getColumn: function (index) {
        return this._rootColumn.getItem(index);
    },
    getVisibleColumn: function (index) {
        return this._rootColumn.getVisibleItem(index);
    },
    $_getColumnGroup: function (group) {
        group = group || this._rootColumn;
        if (typeof group === 'string') {
            group = this.columnByName('group');
        }
        return group instanceof ColumnGroup ? group : null;
    },
    $_getColumn: function (column) {
        if (typeof column === 'string') {
            column = this.columnByName(column);
        }
        return column instanceof GridColumn ? column : null;
    },
    addColumn: function (group, column, index) {
        group = this.$_getColumnGroup(group);
        return group.add(column, index);
    },
    removeColumn: function (column) {
        column = this.$_getColumn(column);
        if (column) {
            var g = column.parent();
            if (g) {
                return g.remove(column);
            }
        }
        return false;
    },
    clearColumns: function (group) {
        group = this.$_getColumnGroup(group);
        group.clear();
    },
    changeColumnIndex: function (column, newIndex) {
        column = this.$_getColumn(column);
        if (column) {
            var g = column.parent();
            if (g) {
                return g.setChildIndex(column, newIndex);
            }
        }
        return false;
    },
    changeColumnDisplayIndex: function (column, newIndex) {
        column = this.$_getColumn(column);
        if (column) {
            var g = column.parent();
            if (g) {
                return g.setChildDisplayIndex(column, newIndex);
            }
        }
        return false;
    },
    generateColumns: function (clear) {
        var cols, i, cnt, col, name,
            ds = this.dataSource();
        if (ds) {
            cols = [];
            for (i = 0, cnt = ds.fieldCount(); i < cnt; i++) {
                col = new DataColumn();
                name = ds.getField(i).fieldName();
                col.setName(name);
                col.setFieldName(name);
                cols.push(col);
            }
            if (!clear) {
                cols = this.columns().concat(cols);
            }
            this.setColumns(cols);
        }
    },
    linearizeColumns: function (sortProps, reverse) {
        var i, cnt, d, prop, cols, layout, c,
            columns = this.getLeafColumns(true);
        if (columns && (cnt = columns.length) > 0) {
            if (sortProps && sortProps.length > 0) {
                d = reverse ? -1 : 1;
                for (i = 0; i < sortProps.length; i++) {
                    prop = sortProps[i];
                    columns.sort(function (col1, col2) {
                        var v1 = col1.getProperty(prop);
                        var v2 = col2.getProperty(prop);
                        return (v1 < v2 ? -1 : v1 > v2 ? 1 : 0) * d;
                    });
                }
            } else if (reverse) {
                columns.reverse();
            }
            cols = [];
            layout = new ColumnLayout();
            for (i = 0; i < cnt; i++) {
                c = columns[i];
                c._saveWidth = c.width();
                cols.push(c);
            }
            layout.setItems(cols);
            this.setColumnLayout(layout);
        }
        return this;
    },
    collectColumns: function (columnsOnly) {
        var columns = [];
        this._rootColumn.collectColumns(columns, columnsOnly);
        return columns;
    },
    collectGroups: function () {
        var groups = [];
        this._rootColumn.collectGroups(groups);
        return groups;
    },
    getColumnNames: function (columnsOnly) {
        return this._rootColumn.collectColumnNames([], columnsOnly);
    },
    columnByHash: function (hash) {
        return this._rootColumn._columnMap[hash];
    },
    columnByName: function (name, ignoreCase) {
        return this._rootColumn.columnByName(name, ignoreCase);
    },
    /* @internal */ layoutColumnByName: function (name, ignoreCase) {
        for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
            var c = this._orgColumns[i];
            if (c instanceof ColumnGroup) {
                c = c.valueColumnByName(name, ignoreCase);
                if (c) {
                    return c;
                }
            } else if (_equalTexts(c.name(), name, ignoreCase)) {
                return c;
            }
        }
        return this._rootColumn.valueColumnByName(name);
    },
    columnByField: function (field, ignoreCase, visibleOnly) {
        var fld = parseInt(Number(field));
        if (isNaN(fld)) {
            var ds = this.dataSource();
            if (ds) {
                fld = ds.getFieldIndexEx(field, ignoreCase);
            }
        }
        return (fld >= 0) ? this._rootColumn.columnByField(fld, visibleOnly) : null;
    },
    columnsByField: function (field, ignoreCase) {
        var ds = this.dataSource();
        if (ds) {
            var fld = ds.getFieldIndexEx(field, ignoreCase);
            if (fld >= 0) {
                var columns = [];
                this._rootColumn.collectColumnsByField(fld, columns);
                return columns.length > 0 ? columns : null;
            }
        }
        return null;
    },
    columnByTag: function (tag) {
        return this._rootColumn.columnByTag(tag);
    },
    columnsByTag: function (tag) {
        var columns = [];
        this._rootColumn.collectColumnsByTag(tag, columns);
        return columns.length > 0 ? columns : null;
    },
    setColumnsVisible: function (columns, visible) {
        var map = ColumnGroup.getColumnMap(this, columns);
        if (map) {
            map.each(function (group, columns) {
                group.setChildrenVisible(columns, visible);
            });
        }
    },
    /** @internal */
    getLeafColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        return this._rootColumn.getLeafColumns(visibleOnly);
    },
    getValueColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        return this._rootColumn.getValueColumns(visibleOnly);
    },
    getDataColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        return this._rootColumn.getDataColumns(visibleOnly);
    },
    /** @internal */
    getDataRootColumns: function () {
        return this._dataRoots.roots();
    },
    /** @internal */
    collectDataColumns: function (c1, c2, columns) {
        return this._dataRoots.collectDataColumns(c1, c2, columns);
    },
    visitAllColumns: function (callback) {
        _isFunction(callback) && this._rootColumn.visitAllChildren(callback);
    },
    visitColumns: function (callback) {
        _isFunction(callback) && this._rootColumn.visitChildren(callback);
    },
    clearColumnTags: function (refresh, tag) {
        this._rootColumn.visitAllChildren(function (col) {
            if (!tag || col.tag() == tag) {
                col.setTag(undefined);
            }
        });
        refresh && this.refreshView();
    },
    getLeftColumn: function (column) {
        /*
         var rightColumn = function (group, y) {
         var cnt = this.childCount();
         if (cnt < 1) return this;
         var group = this.group();
         var child;
         if (group.vertical()) {
         for (var i = 0; i < cnt - 1; i++) {
         child = this.getChild(i);
         if (child.visible() && child.y() >= y && y < child.bottom()) {
         break;
         }
         }
         if (!child) {
         child = this.getChild(cnt - 1);
         }
         } else {
         child = this.getVisibleChild(cnt - 1);
         }
         if (child instanceof DataGroupCellElement) {
         y += child.y();
         return child.rightCell(y);
         }
         return child;
         }
         */
        /*
         var cell = this.findCell(column);
         if (!cell) return null;
         var grpCell = _cast(cell.parent(), DataGroupCellElement);
         var y = cell.y();
         var orgY = y;
         var group, index, child;
         while (grpCell) {
         group = grpCell.index().column;
         if (group.horizontal() && (index = grpCell.getDisplayIndex(cell)) > 0) {
         child = grpCell.getVisibleChild(index - 1);
         if (child instanceof DataGroupCellElement) {
         return child.rightCell(y);
         } else if (child instanceof DataCellElement) {
         return child;
         } else {
         throw "Unknown cell element: " + child.className();
         }
         }
         cell = grpCell;
         y += cell.y();
         grpCell = _cast(cell.parent(), DataGroupCellElement);
         }
         column = cell.index().column.root();
         if (column.displayIndex() > 0) {
         var r = this.findCell(column).bounds();
         cell = this.findCell(column = this.grid().getVisibleColumn(column.displayIndex() - 1));
         if (cell instanceof DataCellElement) {
         return cell;
         }
         if (cell instanceof DataGroupCellElement) {
         return cell.rightCell(orgY);
         }
         if ($_debug && cell) throw ("Invalid cell element type: " + cell.className());
         if (!cell) {
         this._cells[column.$_hash] = cell = this._createCell(column);
         cell.setVisible(false);
         this.addElement(cell);
         if (cell instanceof DataGroupCellElement) {
         cell.setBounds(r);
         cell._prepareCells();
         cell._layoutCells();
         return cell.rightCell(orgY);
         } else {
         return cell;
         }
         }
         }
         return null;
         */
    },
    getRightColumn: function (column) {
    },
    excludeColumn: function (column) {
        if (column) {
            if (this._displayOptions.hideColumnWhenExcluded()) {
                column.setVisible(false);
            } else {
                this._fireExcludeColumn(column);
            }
        }
    },
    /** @internal */
    columnLayoutChanged: function () {
        return this._columnLayoutChanged;
    },
    registerColumnLayouts: function (value) {
        if (value != this._columnLayouts) {
            this._columnLayouts.clear();
            this._columnLayouts.load(value);
        }
        return this;
    },
    restoreColumns: function (restoreSize) {
        this._checkEditing();
        this._columnsLock = true;
        try {
            if (restoreSize) {
                this._restoreOrgWidths();
            }
            this._rootColumn.setColumns(this._orgColumns);
            this._orgColumned = true;
            this._columnLayout = null;
            this._columnLayoutChanged = true;
        } finally {
            this._columnsLock = false;
            this._columnsRestore();
        }
    },
    saveColumnLayout: function () {
        function getColumnLayout(column) {
            return {
                name: column.name(),
                saveWidth: column.saveWidth()
            };
        }
        function getGroupLayout(group) {
            var groupLayout = {
                name: group.name(),
                layout: group.layout(),
                childHeadersVisible: group.childHeadersVisible(),
                childFootersVisible: group.childFootersVisible(),
                childGroupFootersVisible: group.childGroupFootersVisible(),
                childSummariesVisible: group.childSummariesVisible(),
                saveWidth: group.saveWidth(),
                columns: []
            };
            if (group.header && group.header()) {
                groupLayout.header = group.header().text();
            }
            for (var i = 0, cnt = group.visibleCount(); i < cnt; i++) {
                var c = group.getVisibleItem(i);
                if (c.visible()) {
                    if (c instanceof ColumnGroup) {
                        groupLayout.columns.push(getGroupLayout(c));
                    } else if (c.name) {
                        groupLayout.columns.push(getColumnLayout(c));
                    }
                }
            }
            return groupLayout;
        }
        var layout = [];
        for (var i = 0, cnt = this.visibleColumnCount(); i < cnt; i++) {
            var c = this.getVisibleColumn(i);
            if (c.visible()) {
                if (c instanceof ColumnGroup) {
                    layout.push(getGroupLayout(c));
                } else if (c.name) {
                    layout.push(getColumnLayout(c));
                }
            }
        }
        return layout;
    },
    registerColumnStyles: function (styles) {
        var dirty = false;
        if (_isObject(styles)) {
            for (var name in styles) {
                var st = styles[name];
                if (_isObject(st)) {
                    this._columnStyles[name] = (st instanceof GridStyles) ? st : new GridStyles(null, null, st);
                    dirty = true;
                }
            }
            if (dirty) {
                this.$_initColumnStylesMap(this._rootColumn);
                this.refreshView();
            }
        }
    },
    unregisterColumnStyles: function (names) {
        var name, dirty = false;
        if (_isArray(names)) {
            for (var i = names.length; i--;) {
                name = names[i];
                if (this._columnStyles.hasOwnProperty(name)) {
                    delete this._columnStyles[name]
                    dirty = true;
                }
            }
        } else if (this._columnStyles.hasOwnProperty(names)) {
            dirty = true;
            delete this._columnStyles[names]
        }
        if (dirty) {
            this.$_initColumnStylesMap(this._rootColumn);
            this.refreshView();
        }
    },
    clearColumnStyles: function () {
        if (!_isEmptyObject(this._columnStyles)) {
            this._columnStyles = {};
            this.$_initColumnStylesMap(this._rootColumn);
            this.refreshView();
        }
    },
    $_initColumnStylesMap: function (column) {
        column = column || this._rootColumn;
        this.$_columnStyleNameChanged(column);
        if (column instanceof ColumnGroup) {
            var self = this;
            column.visitAllChildren(function (col) {
                self.$_columnStyleNameChanged(col);
            });
        }
    },
    editorActivated: function (editor) {
        if (!this._loading) {
            var tool = this.activeTool();
            tool && tool.editorActivated(editor);
            this._layoutAutoFillHandle();
        }
    },
    getFieldValues: function (field, rows) {
        var ds = this.dataSource();
        if (!ds) return null;
        field = field instanceof GridColumn ? field.dataIndex() : ds.getFieldIndexEx(field, true);
        if (field < 0) return null;
        var i, cnt, row, r,
            vals = [];
        if (_isArray(rows)) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                row = rows[i];
                if (!(row instanceof GridRow)) {
                    row = this.getRow(row);
                }
                if (row instanceof GridRow && (r = row.dataIndex()) >= 0) {
                    vals.push(ds.getValue(r, field));
                }
            }
        } else {
            for (i = 0, cnt = this.rowCount(); i < cnt; i++) {
                row = this.getRow(i);
                if (row instanceof GridRow && (r = row.dataIndex()) >= 0) {
                    vals.push(ds.getValue(r, field));
                }
            }
        }
        return vals;
    },
    cancelEditor: function (hideEditor) {
        hideEditor = arguments.length > 0 ? hideEditor : true;
        this._editController.cancelEditor(hideEditor);
    },
    cancel: function (focus) {
        var index = this.$_focusedIndex();
        var items = _cast(this.itemSource(), EditableRowProvider);
        if (items && items.isEditing(index.getRow(this))) {
            if (items.cancel()) {
                index = index.clone();
                index.normalize(this);
                this.setFocusedIndex(index);
                if (focus) {
                    this.$_makeFocusIndexVisible();
                }
                return true;
            }
        }
        return false;
    },
    commitEditor: function (hideEditor, throwError, noAlert) {
        return this.editController().commitEditor(hideEditor, throwError, noAlert);
    },
    commit: function (force, raiseFailError, alertValidation) {
        raiseFailError = arguments.length > 1 ? raiseFailError : true;
        alertValidation = arguments.length > 2 ? alertValidation : true;
        var items, row,
            index = this.$_focusedIndex();
        if (!this.isValidCell(index)) {
            return false;
        }
        items = _cast(this.itemSource(), EditableRowProvider);
        if (!items) {
            return false;
        }
        /*
         var row = index.getRow(this);
         if (items.isEditing(row) && (force || items.isEdited(row))) {
         var inserting = GridRowState.isInserting(row.rowState());
         try {
         this._validationManager.validateRow(row, inserting);
         this.$_validateRow(row, inserting);
         } catch (err) {
         if (err instanceof ValidationError && err.column instanceof DataColumn) {
         err.column.setError(err.message || err);
         err.column.setErrorLevel(err.level || ValidationLevel.ERROR);
         }
         throw err;
         }
         if (!items.commit()) {
         if (raiseFailError) {
         throw new AbortError();
         }
         return false;
         }
         return true;
         }
         return false;
         */
        try {
            row = index.getRow(this);
            if (items.isEditing(row)) {
                if (force) {
                    return items.commit();
                } else {
                    if (this.isEditing()) {
                        if (!this.editController().commitEditor()) {
                            return false;
                        }
                        this.editController().invalidateEditor();
                    }
                    if (items.isEdited(row)) {
                        return items.commit();
                    }
                }
            }
        } catch (err) {
            if (err instanceof ValidationError) {
                alertValidation && _alert(err.message ? err.message : err.toString());
                _throwDebug(err);
                return false;
            }
            if (err instanceof AbortError) {
            } else if (raiseFailError) {
                throw err;
            }
        }
        return false;
    },
    commitOrCancel: function (force) {
        if (this.isRowEditing()) {
            if (!this.commit(force)) {
                this.cancel();
            }
        }
    },
    isCheckable: function (row) {
        row = this._parseRow(row);
        return row && this._checkBar.$_isCheckable(row);
    },
    setCheckable: function (row, checkable, noRefresh) {
        row = this._parseRow(row);
        if (row && row.$_setCheckable(this, checkable)) {
            !noRefresh && this.refreshView();
            return true;
        }
        return false;
    },
    isChecked: function (row) {
        row = this._parseRow(row);
        return row && row.$_isChecked(this);
    },
    $_clearChecked: function () {
        this._rowSource && this._rowSource.visitAll(function (row) {
            row.$_setChecked(this, false);
        }.bind(this))
    },
    setChecked: function (row, checked, exclusive, noEvent) {
        var changed = false;
        row = this._parseRow(row);
        if (row) {
            if (exclusive) {
                this.$_clearChecked();
                if (checked) {
                    changed = row.$_setChecked(this, true);
                }
            } else {
                changed = row.$_setChecked(this, checked);
            }
        }
        if (changed && !noEvent) {
            this.refreshView();
            this._fireRowChecked(row, checked);
        }
        return changed;
    },
    checkRows: function (rows, checked, rowEvents) {
        var i, cnt, row, list = [];
        if (_isArray(rows) && rows.length > 0) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                row = this._parseRow(rows[i]);
                if (row && row.$_setChecked(this, checked)) {
                    list.push(row);
                    rowEvents && this._fireRowChecked(row, checked);
                }
            }
            if (list.length > 0) {
                this.refreshView();
                this._fireRowsChecked(list, checked);
            }
        }
        return list;
    },
    checkAll: function (checked, visibleOnly, checkableOnly, callback, rowEvents) {
        if (this._rowSource && this.rowCount() > 0) {
            var view = this;
            var changed = false;
            this._rowSource.visitAll(function (row) {
                if (!checkableOnly || view._checkBar.$_isCheckable(row)) {
                    if ((row.$_isChecked(view) != checked) && (!callback || callback(row))) {
                        row.$_setChecked(view, checked);
                        rowEvents && view._fireRowChecked(row, checked);
                        changed = true;
                    }
                }
            }, visibleOnly);
            if (changed) {
                this.refreshView();
                this._fireAllChecked(checked);
            }
        }
    },
    toggleChecked: function (rows, visibleOnly, checkableOnly, rowEvents) {
        if (this._rowSource && this.rowCount() > 0) {
            var i, row,
                view = this,
                bar = view._checkBar,
                list = [];
            if (!rows) {
                this._rowSource.visitAll(function (row) {
                    if (!checkableOnly || bar.$_isCheckable(row)) {
                        var checked = !row.$_isChecked(view);
                        row.$_setChecked(view, checked);
                        rowEvents && view._fireRowChecked(row, checked);
                        list.push(row);
                    }
                }, visibleOnly);
            } else {
                for (i = rows.length; i--;) {
                    row = this._parseRow(rows[i]);
                    if (row && (!visibleOnly || row.index() >= 0) && (!checkableOnly || bar.$_isCheckable(row))) {
                        var checked = !row.$_isChecked(view);
                        row.$_setChecked(view, checked);
                        rowEvents && this._fireRowChecked(row, checked);
                        list.push(row);
                    }
                }
            }
            if (list.length > 0) {
                this.refreshView();
                this._fireCheckedChanged(list);
            }
        }
    },
    setAllChecked: function (checked) {
        this._checkBarHeadView.setChecked(checked);
    },
    isAllChecked: function () {
        return this._checkBarHeadView.checked();
    },
    getCheckedRows: function (visibleOnly) {
        var rows = [];
        if (this._rowSource) {
            this._rowSource.visitAll(function (row) {
                row.$_isChecked(this) && rows.push(row);
            }.bind(this), visibleOnly);
        }
        return rows;
    },
    getCheckedRowIndices: function (visibleOnly) {
        var rows = this.getCheckedRows(visibleOnly);
        for (var i = rows.length; i--;) {
            rows[i] = rows[i].index();
        }
        return rows;
    },
    getCheckedDataIndices: function (visibleOnly) {
        var rows = this.getCheckedRows(visibleOnly);
        for (var i = rows.length; i--;) {
            rows[i] = rows[i].dataIndex();
        }
        return rows;
    },
    /*
    resetCheckables: function () {
    },
    applyCheckables: function () {
    },
    */
    getLookupSource: function (sourceId) {
        return this._lookupProvider && this._lookupProvider.getSource(sourceId);
    },
    addLookupSource: function (source, overwrite) {
        if (!source) return;
        var id = source instanceof LookupSource ? source.id() : source.id;
        if (!id) return;
        var provider = this._lookupProvider;
        if (provider && !overwrite && provider.getSource(id)) return;
        if (!provider) {
            provider = this._lookupProvider = new LocalLookupSourceProvider();
            provider.addListener(this);
        }
        source = provider.add(source);
        return source ? source.id() : null;
    },
    removeLookupSource: function (sourceId) {
        return this._lookupProvider ? this._lookupProvider.remove(sourceId) : false;
    },
    existsLookupData: function (sourceId, keys) {
        if (sourceId && keys) {
            var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
            if (!source) {
                throw "Invalid lookup source id: " + sourceId;
            }
            if (!_isArray(keys)) {
                keys = [keys];
            }
            return source.exists(keys);
        }
        return false;
    },
    fillLookupValues: function (sourceId, keys, values) {
        if (sourceId && values) {
            var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
            if (!source) {
                throw "Invalid lookup source id: " + sourceId;
            }
            source.fill(keys, values);
        }
    },
    fillLookupRows: function (sourceId, rows) {
        if (sourceId && rows) {
            var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
            if (!source) {
                throw "Invalid lookup source id: " + sourceId;
            }
            source.fillRows(rows);
        }
    },
    clearLookupData: function (sourceId) {
        if (sourceId) {
            var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
            if (!source) {
                throw "Invalid lookup source id: " + sourceId;
            }
            source.clear();
        }
    },
    /** @internal */
    getIndicatorIndex: function (item) {
        return item.index();
    },
    canHovering: function () {
        return !this.isEditing();
    },
    $_calcGroupLevels: function () {
        this._rootColumn.calcHeaderLevels();
        this._rootColumn.calcDataLevels();
        this._rootColumn.calcFooterLevels();
        this._rootColumn.calcHeaderSummaryLevels();
        this._rootColumn.calcGroupHeaderLevels();
        this._rootColumn.calcGroupFooterLevels();
    },
    showToast: function (options, force, action) {
        this._toastManager.show(options, force, action);
    },
    hideToast: function (callback) {
        this._toastManager.close();
        callback && callback();
    },
    isEditing: function (index) {
        return this._editController.isEditing() && (!index || CellIndex.areEqual(index, this._editController.editIndex()));
    },
    isRowEditing: function (row) {
        row = row || this.$_focusedIndex().getRow(this);
        return row && (this.itemSource() instanceof EditableRowProvider) && this.itemSource().isEditing(row);
    },
    isRowEdited: function (row) {
        row = row || this.$_focusedIndex().getRow(this);
        return row && (this.itemSource() instanceof EditableRowProvider) && this.itemSource().isEdited(row);
    },
    isColumnEdited: function (col) {
        if (col instanceof DataColumn) {
            var fld = col.dataIndex();
            if (fld >= 0) {
                row = this.$_focusedIndex().getRow(this);
                return row && (this.itemSource() instanceof EditableRowProvider) && this.itemSource().isCellEdited(row, fld);
            }
        }
    },
    $_canUpdate: function (row, editor) {
        var can = !this.readMode() && this.editOptions().canUpdate() && (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canUpdate(row);
        if (can) {
            try {
                if (!this._fireUpdating(row.index(), !!editor)) {
                    return false;
                }
            } catch (err) {
                _alertConfirm(err.message || err);
                _throwDebug(err);
                return false;
            }
        }
        return can;
    },
    $_canAppend: function () {
        var can = !this.readMode() && this.editOptions().canAppend() && (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canAppend();
        if (can) {
            try {
                if (!this._fireInserting(this.itemSource().rowCount())) {
                    return false;
                }
            } catch (err) {
                _alertConfirm(err.message || err);
                _throwDebug(err);
                return false;
            }
        }
        return can;
    },
    $_canInsert: function (row, shift, ctrl) {
        var can = !this.readMode() && this._doCanInsert(row, shift, ctrl) && this.editOptions().canInsert() &&
            (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canInsert(row);
        if (can) {
            try {
                if (!this._fireInserting(row.index(), shift, ctrl)) {
                    return false;
                }
            } catch (err) {
                _alertConfirm(err.message || err);
                _throwDebug(err);
                return false;
            }
        }
        return can;
    },
    _doCanInsert: function (item, shift, ctrl) {
        return true;
    },
    canDelete: function (row) {
        return (this.visibleColumnCount() > 0) &&
            this.rowSource() && (this.isRowEditing(row) || this.rowSource().canDelete(row));
    },
    canCommit: function (row) {
        return !this.readMode() && this.isRowEditing(row) && (this.isRowEdited() || this.editOptions().commitWhenNoEdit());
    },
    canCancel: function (row) {
        return this.isRowEditing(row);
    },
    append: function (force) {
        var items = this.itemSource();
        if (!(items instanceof EditableRowProvider)) {
            return false;
        }
        if (items.isAppending()) {
            return true;
        }
        var defaults = this.$_getInsertDefaults(null);
        return items.append(defaults, false);
        /*
         if (this.isRowEditing()) {
         if (!force) return false;
         this.commit(this.editOptions().commitWhenNoEdit());
         }
         var items = this.itemSource();
         if (items instanceof EditableRowProvider && items.dataSource() && this.$_canAppend()) {
         var defaults = this.$_getInsertDefaults(null);
         this.clearSelection();
         return items.append(defaults);
         }
         return false;
         */
    },
    insert: function (shift, ctrl) {
        var items = this.itemSource();
        if (!(items instanceof EditableRowProvider)) {
            return false;
        }
        if (items.isInserting()) {
            return true;
        }
        var defaults = this.$_getInsertDefaults(null);
        return this.itemSource().insert(defaults, false, shift, ctrl);
        /*
         if (this.isRowEditing()) {
         if (!force) return false;
         this.commit(this.editOptions().commitWhenNoEdit());
         }
         return this.$_insert(row);
         */
    },
    /*
     $_insert: function (row, shift, ctrl) {
     if (!row) {
     row = this.$_focusedIndex() ? this.$_focusedIndex().getRow(this) : null;
     }
     if (!row) {
     return false;
     }
     if (!(this.itemSource() instanceof EditableRowProvider) || !this.$_canInsert(row, shift, ctrl)) {
     return false;
     }
     this.clearSelection();
     var defaults = this.$_getInsertDefaults(null);
     return this.itemSource().insert(row, defaults, shift, ctrl);
     },
     */
    update: function () {
        var items = this.itemSource();
        if (!(items instanceof EditableRowProvider)) {
            return false;
        }
        if (items.isUpdating()) {
            return true;
        }
        return items.update();
    },
    edit: function () {
        var items = this.itemSource();
        if (!(items instanceof EditableRowProvider)) {
            return false;
        }
        if (items.isEditing()) {
            return true;
        }
        return items.update();
        /*
         if (!index) {
         index = this.$_focusedIndex();
         }
         if (!this.isValidCell(index) || !(this.itemSource() instanceof EditableRowProvider)) {
         return false;
         }
         var row = index.getRow(this);
         if (DataRowState.isDeleted(row.dataState())) {
         return false;
         }
         if (this.isRowEditing() && row !== this.focusedRow()) {
         if (!force) return false;
         this.commit(this.editOptions().commitWhenNoEdit());
         }
         if (!GridRowState.isEditing(row.rowState()) && !this.$_canUpdate(row)) {
         return false;
         }
         if (index.dataColumn() && !this.canUpdateField(row, index.dataField())) {
         return false;
         }
         if (!CellIndex.areEqual(index, this.$_focusedIndex())) {
         this.setFocusedIndex(index);
         }
         return this.itemSource().edit(index.getRow(this));
         */
    },
    fillEditSearchItems: function (column, searchKey, values, labels) {
        this._editController.fillSearchItems(column, searchKey, values, labels);
    },
    $_showEditor: function (index, append) {
        index = index || this.$_focusedIndex();
        if (this._editController.showEditor(index)) {
            (append || this._editOptions.noSelectWhenEdit()) && this._editController.caretToLast();
            return true;
        }
        return false;
    },
    showEditor: function (index, listing, append) {
        if (this.$_showEditor(index, append)) {
            if (listing) {
                this._editController.showEditList();
            }
            return true;
        }
        return false;
    },
    hideEditor: function () {
        this._editController.closeList(false);
        this._editController.hideEditor();
    },
    reprepareEditor: function () {
        this._editController.reprepareEditor(this.$_focusedIndex());
    },
    prepareEditor: function () {
        this._editController._prepareEditor(this.$_focusedIndex());
    },
    invalidateEditor: function () {
        this._editController.invalidateEditor();
        this._editController.reprepareEditor(this.$_focusedIndex());
    },
    $_editorButtonClick: function (index) {
        this._editController.buttonClicked(index);
    },
    getEditingRow: function () {
        var rows = _cast(this.itemSource(), EditableRowProvider);
        return rows ? rows.editingItem() : null;
    },
    getSortFieldCount: function () {
        return this.rowSource().getSortFieldCount();
    },
    getSortFields: function () {
        return this.rowSource().getSortFields();
    },
    getSortDirections: function () {
        return this.rowSource().getSortDirections();
    },
    getSortCases: function () {
        return this.rowSource().getSortCases();
    },
    addFocusElement: function (element) {
        if (element && !this._focusLayer.contains(element)) {
            this._focusLayer.addElement(element, this._toolContext);
            return true;
        }
        return false;
    },
    removeFocusElement: function (element) {
        if (this._focusLayer.contains(element)) {
            this._focusLayer.removeElement(element);
            return true;
        }
        return false;
    },
    addAutoFillElement: function (element) {
        if (element && !this._autoFillLayer.contains(element)) {
            this._autoFillLayer.addElement(element, this._toolContext);
            return true;
        }
        return false;
    },
    removeAutoFillElement: function (element) {
        if (this._autoFillLayer.contains(element)) {
            this._autoFillLayer.removeElement(element);
            return true;
        }
        return false;
    },
    addFeedbackElement: function (element) {
        if (element && !this._feedbackLayer.contains(element)) {
            this._feedbackLayer.addElement(element, this._toolContext);
            return true;
        }
        return false;
    },
    removeFeedbackElement: function (element) {
        if (this._feedbackLayer.contains(element)) {
            this._feedbackLayer.removeElement(element);
            return true;
        }
        return false;
    },
    getEditCellBounds: function (index) {
        var r, i, r1, r2,
            lm = this.lm(),
            room = lm.getMergedCell(index),
            view = this.getCellView(room ? this._mergeView : null, index);
        if (view) {
            r = view.getBounds();
            r.x = r.y = 0;
            r = view.boundsByContainer(r);
            if (room) {
                i = index.rowIndex;
                if (i >= lm.topIndex() + lm.fixedRowCount() && i < lm.topIndex() + lm.itemCount() + lm.fixedRowCount()) {
                    r1 = lm.itemBounds(view._topIndex);
                    r2 = lm.itemBounds(index.rowIndex - this._topIndex);
                    r.y += r2.y - r1.y;
                    r.height = r2.height;
                } else {
                    r = $_INVISIBLE_EDIT_BOUNDS.clone();
                }
            }
            return r;
        } else {
            return $_INVISIBLE_EDIT_BOUNDS.clone();
        }
    },
    getEditBounds: function (index) {
        var r, i, r1, r2,
            lm = this.lm(),
            room = lm.getMergedCell(index),
            view = this.getCellView(room ? this._mergeView : null, index, index.isFixedCol(this));
        if (view) {
            r = view.getBounds();
            if (view instanceof DataCellElement) {
                r.width -= view.getButtonsWidth();
            }
            r.x = r.y = 0;
            r = view.boundsByContainer(r);
            if (room) {
                i = index.rowIndex;
                if (i >= lm.topIndex() + lm.fixedRowCount() && i < lm.topIndex() + lm.itemCount() + lm.fixedRowCount()) {
                    r1 = lm.itemBounds(view._topIndex);
                    r2 = lm.itemBounds(index.rowIndex - this._topIndex);
                    r.y += r2.y - r1.y;
                    r.height = r2.height;
                } else {
                    r = $_INVISIBLE_EDIT_BOUNDS.clone();
                    r.scrolled = true;
                }
            }
        } else {
            r = $_INVISIBLE_EDIT_BOUNDS.clone();
            r.scrolled = true;
        }
        return r;
    },
    getCellView: function (owner, index, fixed) {
        if (fixed === undefined) {
            fixed = index.column && index.column.fixed();
        }
        if (owner == null || owner instanceof GridBodyElement) {
            var row = index.getRow(this);
            if (row && row.isEditable()) {
                var rowView = fixed ? this._fixedBodyView.findRowView(row.index()) :
                    this._bodyView.findRowView(row.index());
                if (rowView && rowView.visible()) {
                    return rowView.findCell(index.column);
                }
            }
        } else if (owner === this._bandedGroupView) {
            return this._bandedGroupView.getCellView(index, !!fixed);
        } else if (owner instanceof GridMergeElement) {
            var mergeView = fixed ? this._fixedMergeView : this._mergeView;
            return mergeView.getCellView(index);
        } else if (owner === this._mergeHeaderLayer) {
            return this._mergeHeaderLayer.getCellView(index);
        }
        return null;
    },
    getFocusedCellView: function (index) {
        index = index || this.$_focusedIndex();
        var item = index.getRow(this),
            merged = item && item.merged(),
            fixed = index.isFixedCol(this),
            cell = fixed ? this.getCellView(this._fixedMergeView, index, true) : null;
        if (!cell && !fixed) {
            cell = this.getCellView(this._mergeView, index, false);
        }
        if (!cell && merged) {
            cell = this.getCellView(this._mergeHeaderLayer, index);
        }
        if (!cell) {
            cell = this.getCellView(null, index, fixed);
        }
        if (!cell && !merged) {
                if (!cell) {
                    cell = this.getCellView(this._bandedGroupView, index, false);
                }
                if (!cell) {
                    cell = this.getCellView(this._bandedGroupView, index, true);
                }
        }
        return cell;
    },
    pointToIndex: function (x, y, clipped) {
        var index = CellIndex.temp(-1, null);
        if (clipped) {
            this._layoutManager.mouseToIndex(x, y, index);
        } else {
            this._layoutManager.mouseToIndexEx(x, y, index);
        }
        return index;
    },
    getDataCellRect: function (index) {
        if (this.isValidCell(index)) {
            var fixed = this.isFixedColumn(index.column);
            var view = this.getCellView(null, index, fixed) || this.getCellView(this._mergeView, index, fixed);
            return view ? view.boundsByContainer() : null;
        }
        return null;
    },
    $_deleteRows: function (rows, checked) {
        function checkDeleteAll(self, rows) {
            try {
                var cnt, ids, i, row;
                if (rows && (cnt = rows.length) > 0) {
                    ids = [];
                    for (i = 0; i < cnt; i++) {
                        row = rows[i];
                        if (row && row.dataIndex() >= 0) {
                            ids.push(row.dataIndex());
                        }
                    }
                    if (ids.length > 0) {
                        if (!self._fireDeleting(ids)) {
                            return false;
                        }
                    }
                }
            } catch (err) {
                _alertConfirm(err);
                _throwCheckedError(err);
            }
            return true;
        }
        function deleteSingleCell(self, rows) {
            if (rows.length == 1) {
                var row = rows[0];
                if (self.canDelete(row)) {
                    if (checked) {
                        if (!self.editOptions().confirmWhenDelete()) {
                            if (!self._fireDeleting([row.dataIndex()])) {
                                return true;
                            }
                            self.cancel();
                            if (!GridRowState.isInserting(row.rowState())) {
                                self.rowSource().remove(row);
                            }
                        } else {
                            if (confirm(self.editOptions().getDeleteRowsMessage())) {
                                if (!self._fireDeleting([row.dataIndex()])) {
                                    return true;
                                }
                                self.cancel();
                                if (!GridRowState.isInserting(row.rowState())) {
                                    self.rowSource().remove(row);
                                }
                            }
                        }
                    } else {
                        self.cancel();
                        if (!GridRowState.isInserting(row.rowState())) {
                            self.rowSource().remove(row);
                        }
                    }
                }
                return true;
            }
            return false;
        }
        function removeRows(self, rows) {
            var i, row, state, ids,
                editingItem = null;
            for (i = rows.length; i--;) {
                row = rows[i];
                state = row.rowState();
                if (GridRowState.isEditing(state)) {
                    editingItem = row;
                    if (GridRowState.isInserting(state)) {
                        rows.splice(i, 1);
                    }
                    break;
                }
            }
            ids = [];
            if (rows.length > 0) {
                for (i = 0; i < rows.length; i++) {
                    ids.push(rows[i].index());
                }
                ids = self.rowSource().getRemovableRows(ids);
            }
            if (ids && ids.length > 0) {
                if (editingItem) {
                    self.cancel();
                }
                self.rowSource().removeRows(ids);
            }
        }
        var i, r, row,
            options = this.editOptions(),
            rs = this.rowSource();
        if (checked && !options.deletable()) {
            return;
        }
        if (!(rs instanceof EditableRowProvider)) {
            return;
        }
        if (this.isRowEditing(null) && !options.deletableWhenEdit()) {
            var msg = "Commit or cancel editing before deteting.";
            _alertConfirm(msg);
            _throwDebug(msg);
            return;
        }
        this.commitEditor(true, false, true);
        rows = rows.concat();
        if (deleteSingleCell(this, rows)) {
            return;
        }
        rows.sort(function (r1, r2) {
            return r1.index() - r2.index();
        });
        r = -1;
        for (i = rows.length; i--;) {
            row = rows[i];
            if (row.dataIndex() >= 0 || row.isEditing()) {
                if (row.index() == r) {
                    rows.splice(i, 1);
                } else {
                    r = row.index();
                }
            } else {
                rows.splice(i, 1);
            }
        }
        if (rows.length > 0 && this.canDelete(rows[0])) {
            if (!checked || !options.confirmWhenDelete() || confirm(options.getDeleteRowsMessage())) {
                if (!checked || checkDeleteAll(this, rows)) {
                    removeRows(this, rows);
                    this.clearSelection();
                }
            }
        }
    },
    deleteRows: function (rows, force) {
        var rs, i, r;
        if (_isArray(rows) && rows.length > 0) {
            rs = this.rowSource();
            rows = rows.concat();
            for (i = rows.length; i--;) {
                r = rows[i];
                if (!(r instanceof GridRow)) {
                    r = rs.getItem(r);
                    if (r) {
                        rows[i] = r;
                    } else {
                        rows.splice(i, 1);
                    }
                }
            }
            this.$_deleteRows(rows, !force);
        }
    },
    deleteCheckedRows: function (force, visibleOnly) {
        var rows = this.getCheckedRows(visibleOnly);
        if (rows && rows.length > 0) {
            this.$_deleteRows(rows, !force);
        }
    },
    getSelection: function (index) {
        var cnt = this._selections.count();
        if (cnt > 0) {
            index = arguments.length > 0 ? index : -1;
            return index < 0 ? this._selections.lastItem() : this._selections.getItem(index);
        }
        return null;
    },
    getSelectionCount: function () {
        return this._selections.count();
    },
    getSelections: function () {
        return this._selections.items();
    },
    setSelection: function (index1, index2, style, focus) {
        idx1 = this._getValidIndex(index1);
        idx2 = this._getValidIndex(index2);
        style = style || this._displayOptions.selectStyle();
        if (focus && idx1 instanceof CellIndex) {
            if (this.isValidCell(index1)) {
                this.setFocusedIndex(idx1, false, false);
            } else if (SelectionStyle.isRow(style)) {
                this.setFocusedRow(idx1.rowIndex, false, false);
            } else if (SelectionStyle.isColumn(style)) {
                this.setFocusedColumn(idx1.column, false, false);
            } else {
                this.setFocusedIndex(idx1, false, false);
            }
        }
        this._selections.clear();
        return this._selections.add(idx1, idx2, style);
    },
    addSelection: function (index1, index2, style) {
        return this._selections.add(index1, index2, style || this._displayOptions.selectStyle());
    },
    removeSelection: function (item) {
        this._selections.remove(item);
    },
    $_collectSelectedRows: function (rows, rowIndices, dataIndices) {
        var i, cnt, sel,
            selections = this.selections(),
            list = [];
        for (i = 0, cnt = selections.count(); i < cnt; i++) {
            sel = selections.getItem(i);
            if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
                if (rows) {
                    list = list.concat(sel.getRows());
                } else if (rowIndices) {
                    list = list.concat(sel.getRowIndices());
                } else if (dataIndices) {
                    list = list.concat(sel.getDataIndices());
                }
            }
        }
        return list;
    },
    getSelectedRows: function () {
        var rows = this.$_collectSelectedRows(true);
        return rows;
    },
    getSelectedRowIndices: function () {
        var rows = this.$_collectSelectedRows(false, true);
        return rows;
    },
    getSelectedDataIndices: function () {
        var rows = this.$_collectSelectedRows(false, false, true);
        return rows;
    },
    clearSelection: function (selectFocused) {
        selectFocused = arguments.length > 0 ? selectFocused : true;
        var idx = this.$_focusedIndex();
        this._selections.clear();
        if (selectFocused && this.isValidCell(idx) && (this.rowCount() > 0) && (this.visibleColumnCount() > 0)) {
            this._selections.add(idx, idx, this.displayOptions().selectStyle());
        }
    },
    $_isErasable: function (rowIndex, col) {
        return col._erasable && (!this._editOptions._checkReadOnlyWhenErase || !this.getReadOnlyAt(rowIndex, col));
    },
    eraseSelection: function (force) {
        force = arguments.length > 0 ? force : true;
        function eraseSingleCell(self, selections) {
            if ((selections.count() == 0 && force) || (selections.count() == 1 && selections.getItem(0).isSingleCell())) {
                var idx = self.$_focusedIndex();
                if (self.$_isErasable(idx.rowIndex, idx.column)) {
                    self.setCellValue(idx, undefined);
                }
                return true;
            }
        }
        var i, r, sel, msg, cnt, items,
            options = this.editOptions(),
            selections = this.selections(),
            itemSource = this.itemSource();
        if (this.readMode() || options.readOnly() || !options.updatable()) {// || !isValidCell(m_focusedIndex))
            return false;
        }
        if (!(itemSource instanceof EditableRowProvider)) {
            return false;
        }
        if (this.isRowEditing(null) && !options.erasableWhenEdit()) {
            msg = GridLocale._default.completeEditing;
            _alertConfirm(msg);
            _throwDebug(msg);
            return false;
        }
        if (eraseSingleCell(this, selections)) {
            return true;
        }
        cnt = selections.count();
        if (cnt < 1) {
            return false;
        }
        items = [];
        for (i = 0; i < cnt; i++) {
            sel = selections.getItem(i);
            if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
                items = items.concat(sel.getRows());
            }
        }
        if (items.length == 0) {
            return false;
        }
        if (items.length > 1) {
            items.sort(function (v1, v2) {
                return v1.index() - v2.index();
            });
        }
        if (items.length > 1 || !items[0].isEditing()) {
            this.commitEditor(true, false, true);
        }
        for (i = 0; i < cnt; i++) {
            sel = selections.getItem(i);
            this.dataSource().beginActions();
            try {
                new DefaultClipboardData().setValue(this._clipboardManager, sel.getBounds(), undefined, true);
            } finally {
                this.dataSource().endActions();
            }
        }
        return true;
    },
    restoreErase: function () {
    },
    deleteSelection: function (force) {
        force = arguments.length > 0 ? force : true;
        function checkDeleteAll(self, rows) {
            try {
                if (rows && rows.length > 0) {
                    var ids = [];
                    for (var i = 0, cnt = rows.length; i < cnt; i++) {
                        var row = rows[i];
                        if (row && row.dataIndex() >= 0) {
                            ids.push(row.dataIndex());
                        }
                    }
                    if (ids.length > 0) {
                        if (!self._fireDeleting(ids)) {
                            return false;
                        }
                    }
                }
            } catch (err) {
                _alertConfirm(err);
                _throwCheckedError(err);
            }
            return true;
        }
        function deleteSingleCell(self, selections) {
            if ((selections.count() == 0 && force) || (selections.count() == 1 && selections.getItem(0).isSingleCell())) {
                var r = -1;
                var row;
                if (selections.count() == 0) {
                    r = self.$_focusedIndex().rowIndex;
                } else {
                    r = selections.getItem(0).getBounds().R1();
                }
                if (r >= 0 && self.canDelete(row = self.getRow(r))) {
                    if (!self.editOptions().confirmWhenDelete()) {
                        if (!self._fireDeleting([row.dataIndex()])) {
                            return true;
                        }
                        self.cancel();
                        if (!GridRowState.isInserting(row.rowState())) {
                            self.rowSource().remove(row);
                        }
                    } else {
                        if (confirm(self.editOptions().getDeleteRowsMessage())) {
                            if (!self._fireDeleting([row.dataIndex()])) {
                                return true;
                            }
                            self.cancel();
                            if (!GridRowState.isInserting(row.rowState())) {
                                self.rowSource().remove(row);
                            }
                        }
                    }
                }
                return true;
            }
            return false;
        }
        function removeItems(self, rows) {
            var i, row, state, ids,
                editingItem = null;
            for (i = rows.length; i--;) {
                row = rows[i];
                state = row.rowState();
                if (GridRowState.isEditing(state)) {
                    editingItem = row;
                    if (GridRowState.isInserting(state)) {
                        rows.splice(i, 1);
                    }
                    break;
                }
            }
            ids = self.getRowIndices(rows);
            if (ids.length > 0) {
                ids = self.itemSource().getRemovableRows(ids);
            }
            if (editingItem) {
                self.cancel();
            }
            if (ids && ids.length > 0) {
                self.itemSource().removeRows(ids);
            }
        }
        var msg, cnt, i, r, sel, items,
            options = this.editOptions(),
            selections = this.selections(),
            itemSource = this.itemSource();
        if (this.readMode() || options.readOnly() || !options.deletable()) {// || !isValidCell(m_focusedIndex))
            return false;
        }
        if (!(itemSource instanceof EditableRowProvider)) {
            return false;
        }
        if (this.isRowEditing(null) && !options.deletableWhenEdit()) {
            msg = GridLocale._default.completeEditing;
            _alertConfirm(msg);
            _throwDebug(msg);
            return false;
        }
        this.commitEditor(true, false, true);
        if (deleteSingleCell(this, selections)) {
            return true;
        }
        cnt = selections.count();
        if (cnt < 1) {
            return false;
        }
        items = [];
        for (i = 0; i < cnt; i++) {
            sel = selections.getItem(i);
            if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
                items = items.concat(sel.getRows());
            }
        }
        if (items.length == 0) {
            return false;
        }
        if (items.length > 1) {
            items.sort(function (v1, v2) {
                return v1.index() - v2.index();
            });
        }
        r = -1;
        for (i = items.length; i--;) {
            if (items[i].index() == r) {
                items.splice(i, 1);
            } else {
                r = items[i].index();
            }
        }
        if (items.length > 0 && this.canDelete(items[0])) {
            if (!options.confirmWhenDelete() || confirm(options.getDeleteRowsMessage())) {
                if (checkDeleteAll(this, items)) {
                    this.dataSource().beginActions();
                    try {
                        removeItems(this, items);
                    } finally {
                        this.dataSource().endActions();
                        this.clearSelection();
                    }
                }
            }
        }
        return true;
    },
    revertSelection: function (force) {
        function revertSingleCell(self, selections) {
            if (selections.count() == 0 || selections.count() == 1 && selections.getItem(0).isSingleCell()) {
                var r = -1;
                if (selections.count() == 0) {
                    r = self.$_focusedIndex().rowIndex();
                } else {
                    r = selections.getItem(0).getBounds().R1();
                }
                if (r >= 0) {
                    self.itemSource().revert(r);
                }
            }
        }
        var i, sel, range, r1, r2, r, item, cnt, items,
            options = this.editOptions(),
            selections = this.selections(),
            itemSource = this.itemSource();
        if (!force && !options.revertable()) {
            return;
        }
        if (!(itemSource instanceof EditableRowProvider)) {
            return;
        }
        this.commitEditor(true, false, true);
        if (revertSingleCell(this, selections)) {
            return;
        }
        cnt = selections.count();
        items = [];
        for (i = 0; i < cnt; i++) {
            sel = selections.getItem(i);
            if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
                range = sel.getBounds();
                r1 = Math.min(range.R1(), range.R2());
                r2 = Math.max(range.R1(), range.R2());
                for (r = r1; r <= r2; r++) {
                    item = this.getRow(r);
                    if (item.dataIndex() >= 0 || item.isEditing()) {
                        items.push(r);
                    }
                }
            }
        }
        items.sort(function (v1, v2) {
            return v2 - v2;
        });
        r = -1;
        for (i = items.length; i--;) {
            if (items[i] == r) {
                items.splice(i, 1);
            } else {
                r = items[i];
            }
        }
        if (items.length > 0) {
            this.itemSource().revertAll(items);
        }
    },
    registerImageList: function (images) {
        var list = null;
        if (images instanceof ImageList && images.name() && !this._imageLists.hasOwnProperty(images.name())) {
            list = images;
        } else if (images && images.name && !this._imageLists.hasOwnProperty(images.name)) {
            var list = new ImageList(images.name, images.root || images.rootUrl);
            images.items && list.addUrls(images.items || images.images);
        }
        if (list) {
            this._imageLists[list.name()] = list;
            list.addListener(this);
            this._assignImageList(list);
        }
    },
    unregisterImageList: function (name) {
        if (name && this._imageLists.hasOwnProperty(name)) {
            var list = this._imageLists[name];
            delete this._imageLists[name];
            list.removeListener(this);
            this._assignImageList(list, true);
        }
    },
    getImageList: function (imagesName) {
        return imagesName && this._imageLists[imagesName];
    },
    getListImage: function (images, index) {
        if (images instanceof ImageList) {
            return images.getImage(index);
        } else if (images) {
            images = this._imageLists[images];
            return images ? images.getImage(index) : null;
        }
    },
    _assignImageList: function (images, clear) {
        var columns = this.getDataColumns();
        for (var i = 0, cnt = columns.length; i < cnt; i++) {
            var col = columns[i];
            if (col.imageList() == images.name()) {
                col._images = clear ? null : images;
            }
        }
    },
    getImage: function (url) {
        return this._container.getImage(url);
    },
    getAssetImage: function (imageName, ext) {
        return this._container.getImage($$_rootContext + $$_assets + imageName + (ext || ".png"));
    },
    loadPalettes: function (source) {
        if (source) {
            this._palettes.clear(true);
            this._palettes.addPalettes(source);
        }
        return this;
    },
    registerFillPalette: function (name, fills) {
        return this._palettes.addFill(name, fills);
    },
    registerStrokePalette: function (name, strokes) {
        return this._palettes.addStroke(name, strokes);
    },
    unregisterPalette: function (name) {
        return this._palettes.remove(name);
    },
    clearRowSummary: function () {
        var rs = this.rowSource();
        rs && rs.clearSummary();
    },
    /** @internal */ getSummarizer: function () {
        return null;
    },
    getSummary: function (field, value) {
        var ds = this.dataSource();
        if (ds) {
            value = value && value.trim().toLowerCase();
            if (value) {
                var summarizer = this.getSummarizer();
                if (summarizer) {
                    var fld = ds.getFieldIndexEx(field, true);
                    if (fld >= 0 && fld < ds.fieldCount()) {
                        switch (value) {
                            case "count":
                                return summarizer.getCount(fld);
                            case "sum":
                                return summarizer.getSum(fld);
                            case "max":
                                return summarizer.getMax(fld);
                            case "min":
                                return summarizer.getMin(fld);
                            case "avg":
                                return summarizer.getAvg(fld);
                            case "var":
                                return summarizer.getVar(fld);
                            case "varp":
                                return summarizer.getVarp(fld);
                            case "stdev":
                                return summarizer.getStdev(fld);
                            case "stdevp":
                                return summarizer.getStdevp(fld);
                        }
                    }
                }
            }
        }
        return NaN;
    },
    $_canOrderBy: function (fieldNames, directions, textCases) {
        var items = this.itemSource();
        return items && items.canSorting(fieldNames, directions, textCases);
    },
    orderBy: function (columns, directions, textCases) {
        var cnt, i, col,
            flds = [];
        if (columns && (cnt = columns.length) > 0) {
            for (i = 0; i < cnt; i++) {
                col = columns[i];
                if (!(col instanceof GridColumn)) {
                    col = this.columnByName(col);
                }
                col && flds.push(col.dataIndex());
            }
        }
        this.orderByFields(flds, directions, textCases);
    },
    orderByFields: function (fieldNames, directions, textCases) {
        var cnt, ds, flds, dirs, cases, i, fld;
        if (!fieldNames || fieldNames.length < 1) {
            if (this.$_canOrderBy(null, null, null)) {
                this._sortRows([], [], []);
            }
        } else {
            cnt = fieldNames.length;
            ds = this.dataSource();
            flds = [];
            dirs = [];
            cases = [];
            for (i = 0; i < cnt; i++) {
                fld = ds.getFieldIndexEx(fieldNames[i], true);
                if (fld >= 0) {
                    flds.push(fld);
                    directions && dirs.push(directions[i]);
                    textCases && cases.push(textCases[i]);
                }
            }
            if (this.$_canOrderBy(flds, dirs, cases)) {
                this._sortRows(flds, dirs, cases);
            }
        }
    },
    sortColumn: function (column) {
        if (column) {
            this.sortColumnWithStyle(this.operateOptions().sortStyle(), column);
        }
    },
    unsortColumn: function (column) {
        if (column) {
            this.unsortColumnWithStyle(this.operateOptions().sortStyle(), column);
        }
    },
    $$_addSort: function (field, dir, textCase, reverse) {
        var i,
            flds = this.getSortFields(),
            dirs = this.getSortDirections(),
            cases = this.getSortCases(),
            idx = -1,
            cnt = flds.length;
        for (i = 0; i < cnt; i++) {
            if (flds[i] == field) {
                idx = i;
                break;
            }
        }
        if (idx >= 0) {
            dirs[idx] = dir;
            cases[idx] = textCase;
        } else if (reverse) {
            flds.splice(0, 0, field);
            dirs.splice(0, 0, dir);
            cases.splice(0, 0, textCase);
        } else {
            flds.push(field);
            dirs.push(dir);
            cases.push(textCase);
        }
        this._sortRows(flds, dirs);
    },
    sortColumnWithStyle: function (sortStyle, column) {
        if (this.isRowEditing(null)) {
            return;
        }
        if (!(column instanceof GridColumn)) {
            column = this.columnByName(column);
        }
        if (!column) {
            throw new Error("column is null");
        }
        if (column.dataIndex() < 0) {
            return;
        }
        var sortCase = this._operateOptions.sortTextCase();
        if (sortStyle == SortStyle.EXCLUSIVE) {
            if (column.sortOrder() < 0) {
                this.orderBy([column], [SortDirection.ASCENDING], [sortCase]);
            } else if (column.sortDirection() == SortDirection.ASCENDING) {
                this.orderBy([column], [SortDirection.DESCENDING], [sortCase]);
            } else if (this.isGroupedColumn(column, true)) {
                this.orderBy([column], [SortDirection.ASCENDING], [sortCase]);
            } else if (this._operateOptions.triStateSorting()) {
                this.unsortColumnWithStyle(sortStyle, column);
            } else {
                this.orderBy([column], [SortDirection.ASCENDING], [sortCase]);
            }
        } else if (sortStyle == SortStyle.INCLUSIVE || sortStyle == SortStyle.REVERSE) {
            if (column.sortOrder() < 0) {
                this.$$_addSort(column.dataIndex(), SortDirection.ASCENDING, sortCase, sortStyle == SortStyle.REVERSE);
            } else if (column.sortDirection() == SortDirection.ASCENDING) {
                this.$$_addSort(column.dataIndex(), SortDirection.DESCENDING, sortCase, sortStyle == SortStyle.REVERSE);
            } else if (this.isGroupedColumn(column, true)) {
                this.$$_addSort(column.dataIndex(), SortDirection.ASCENDING, sortCase, sortStyle == SortStyle.REVERSE);
            } else if (this._operateOptions.triStateSorting()) {
                this.unsortColumnWithStyle(sortStyle, column);
            } else {
                this.$$_addSort(column.dataIndex(), SortDirection.ASCENDING, sortCase, sortStyle == SortStyle.REVERSE);
            }
        }
    },
    unsortColumnWithStyle: function (sortStyle, column) {
        var flds, dirs, cases, idx, cnt, i;
        if (this.isRowEditing(null)) {
            return;
        }
        if (!(column instanceof GridColumn)) {
            column = this.columnByName(column);
        }
        if (!column || column.dataIndex() < 0) {
            return;
        }
        flds = this.getSortFields();
        dirs = this.getSortDirections();
        cases = this.getSortCases();
        idx = -1;
        cnt = flds.length;
        for (i = 0; i < cnt; i++) {
            if (flds[i] == column.dataIndex()) {
                idx = i;
                break;
            }
        }
        if (idx < 0) {
            return;
        }
        if (sortStyle == SortStyle.EXCLUSIVE) {
            this.orderBy([], [], []);
        } else if (sortStyle == SortStyle.INCLUSIVE || sortStyle == SortStyle.REVERSE) {
            flds.splice(idx, 1);
            dirs.splice(idx, 1);
            cases.splice(idx, 1);
            this._sortRows(flds, dirs, cases);
        }
    },
    /** @internal */
    applyFilters: function () {
        if (this.isRowEditing(null)) {
            return false;
        }
        this._toastManager.show(this.operateOptions().filteringToast(), true, function () {
            this.$_doApplyFilters();
        }.bind(this));
        return true;
    },
    $_doApplyFilters: function () {
        this._items.beginFiltering();
        try {
            this._items.clearAllFilters();
            this.$_addFilters(this._rootColumn);
        } finally {
            this._items.endFiltering();
        }
        this.setTopIndex(this.topIndex());
    },
    $_addFilters: function (group) {
        var c, column, dc, filters, i, n, filter,
            cnt = group.count();
        for (c = 0; c < cnt; c++) {
            column = group.getItem(c);
            if (column instanceof DataColumn) {
                filters = column.filters();
                if (filters) {
                    n = filters.length;
                    for (i = 0; i < n; i++) {
                        filter = filters[i];
                        if (filter.active()) {
                            this._items.addFilter(column.dataIndex(), filter.expression());
                        }
                    }
                }
                filter = column.autoFilter();
                if (filter && filter.active()) {
                    this._items.addFilter(column.dataIndex(), filter);
                }
            } else if (column instanceof ColumnGroup) {
                this.$_addFilters(column);
            }
        }
    },
    isGroupedField: function (field) {
        return false;
    },
    isGroupedColumn: function (column) {
        return false;
    },
    getGroupLevel: function (field) {
        return -1;
    },
    getGroupLevels: function () {
        return 0;
    },
    clearColumnMergeGrouped: function () {
        this._rootColumn.clearMergeGrouped();
    },
    isDeletedRow: function (rowIndex) {
        var st, row = this.getRow(rowIndex);
        if (row instanceof DataRow) {
            st = this.dataSource().getRowState(row.dataIndex());
            return DataRowState.isDeleted(st);
        }
        return false;
    },
    $_makeRowInView: function (row) {
        var r, cnt,
            lm = this.lm();
        if (row >= lm.fixedItemCount()) {
            r = row;
            cnt = lm.fullItemCount();
            if (cnt == 0) {
                if (lm.itemCount() > 0) {
                    this.setTopItem(r);
                } else {
                    this.seTopIndex(0);
                }
            } else {
                if (r >= this.topRow() && r < this.topRow() + cnt) {
                    return;
                }
                if (r >= this.topRow() + cnt) {
                    r = r - cnt + 1;
                }
                this.setTopItem(Math.max(0, r));
            }
        }
    },
    $_makeColumnInView: function (column) {
        var c, x, dx,
            lm = this.lm(),
            root = column.root(),
            col = root.displayIndex();
        if (col >= lm.fixedColCount()) {
            x = lm.columnBounds(col).x;
            c = column;
            while (c != root) {
                x += c.displayOffset();
                c = c.parent();
            }
            if (x < this.leftPos()) {
                this.setLeftPos(x);
            } else if ((dx = (x + column.displayWidth() - this.leftPos()) - lm.nonfixedBounds().width) > 0) {
                this.setLeftPos(Math.min(x, this.leftPos() + dx));
            }
        }
    },
    makeColumnVisible: function (column) {
        var index = new CellIndex(-1, column);
        this.makeCellVisible(index);
    },
    makeRowVisible: function (rowIndex) {
        if (rowIndex instanceof GridRow) {
            rowIndex = rowIndex.index();
        }
        if (rowIndex >= 0) {
            this.lm().makeRowVisible(rowIndex);
            this.invalidateLayout();
        }
    },
    makeCellVisible: function (index) {
        if (this.isValidCell(index)) {
            if (!this.lm().cellIsVisible(index)) {
                this.lm().makeCellVisible(index);
                this.invalidateLayout();
            }
        } else if (index && index.column) {
            this.lm().makeCellVisible(index);
            this.invalidateLayout();
        }
        /*
         if (this._layouted) {
         if (!force && this._layoutNeeded) {
         this._focusNeededIndex.assign(index);
         this._focusNeeded = true;
         return;
         }
         if (this.isValidRow(index)) {
         this.$_makeRowInView(index.R());
         }
         if (this.isValidColumn(index)) {
         this.$_makeColumnInView(index.column());
         }
         }
         */
    },
    revealRow: function (row, focus, display) {
        if (row instanceof GridRow) {
            this._doRevealRow(row);
            if (row.index() >= 0) {
                focus && this.setFocusedRow(row, true);
                display && this.makeRowVisible(row);
            }
        }
    },
    /** @interal */
    copyToClipboard: function () {
        var data, index, range,
            selections = this.selections();
        if (this._editOptions.copyEnabled()) {
            if (this._editOptions.singleCopy() || selections.count() == 0 || selections.isSingleCell()) {
                index = this.$_focusedIndex();
                if (this.isValidCell(index)) {
                    data = this._clipboardManager.copyCellToClipboard(index);
                }
            } else {
                range = selections.lastItem().getBounds();
                if (range) {
                    data = this._clipboardManager.copyToClipboard(range);
                }
            }
        }
        if (data === undefined) {
            data = this._clipboardManager.copyEmptyToClipboard();
        }
        if (this._fireCopy(index || range, data)) {
            return data;
        }
        return null;
    },
    /** @interal */
    pasteFromClipboard: function (data) {
        var lock, v, rows, sel, r,
            cm = this._clipboardManager,
            options = this._editOptions,
            index = this.$_focusedIndex().clone();
        index.normalize(this);
        if (!this.isValidCell(index) || !index.dataColumn()) {
            return;
        }
        if (!options.readOnly() && options.pasteEnabled() && this._firePaste(index.clone(), data)) {
            if (options.singlePaste()) {
                this._clipboardManager.pasteCellFromClipboard(index, data);
            } else {
                rows = cm.getPasteRows(index, data);
                lock = options.noDataEventWhenPaste() && _isArray(rows) && rows.length > 1;
                lock = lock && this.dataSource().beginUpdate();
                try {
                    cm.pasteFromClipboard(index, null, rows, lock);
                } finally {
                    lock && cm._dataLock && this.dataSource().endUpdate();
                }
                if (index.getRow(this) && GridRowState.isEditing(index.getRow(this).rowState())) {
                    v = index.getRow(this).getValue(index.dataField());
                    this.validateCellCommit(index, v);
                    this.refreshView();
                }
            }
            this._editController.reprepareEditor(index);
        }
    },
    $_editRowPasted: function (item, fields, oldValues, newValues) {
        this._fireEditRowPasted(item, fields, newValues, oldValues)
    },
    $_pasted: function (row, updatedCount, appendedCount) {
        this._firePasted(row, updatedCount, appendedCount);
    },
    $_sortColumnByUser: function (column) {
        if (!this.isEmpty() && column instanceof DataColumn && column.sortable() && this.operateOptions().sortingEnabled()) {
            if (this._fireSorting(column)) {
                this.sortColumn(column);
            }
        }
    },
    selectColumnFilters: function (column) {
        if (!this.isRowEditing(null) && column && column.filterable() && this.operateOptions().filteringEnabled()) {
            if (this._fireFiltering(column)) {
                var view = this._headerView.getView(column);
                this._filterSelector.show(view, this.operateOptions().filterSelector());
            }
        }
    },
    closeFilterSelector: function () {
        this._filterSelector.hide();
    },
    closePopups: function () {
        this._filterSelector.hide();
        this._popupMenuManager.close();
        this._editController.closeList();
    },
    closePopups2: function () {
        this._popupMenuManager.close();
        this._editController.closeList();
    },
    isFilterSelecting: function (column) {
        return this._filterSelector.opened() && this._filterSelector.column() === column;
    },
    isReadOnlyCell: function (index, style) {
        return this.getReadOnlyAt(index.rowIndex, index.column, style, true);
    },
    getReadOnlyAt: function (rowIndex, column, style, noCallback, noObject) {
        var options, callback, row, v, ds, field, fld, lm;
        if (this.readMode()) {
            return true;
        }
        if (!(column instanceof DataColumn)) {
            return true;
        }
        if (rowIndex < 0) {
            return true;
        }
        options = this._editOptions;
        if (options.readOnly()) {
            return true;
        }
        field = column.dataIndex();
        ds = this.dataSource();
        if (!ds || field < 0 || (fld = ds.getField(field)).readOnly()) {
            return true;
        }
        if (!noObject && fld.dataType() === ValueType.OBJECT) {
            return true;
        }
        row = this.getRow(rowIndex);
        if (!row || !row.canEdit() || (!GridRowState.isInserting(row.rowState()) && (!options.updatable() || !this._rowSource.canUpdateField(row, field)))) {
            return true;
        }
        if (!noCallback) {
            callback = column.readOnlyCallback();
            if (callback && _isBoolean(v = callback(CellIndex.temp(rowIndex, column)))) {
                return v;
            }
            callback = options.readOnlyCallback();
            if (callback && _isBoolean(v = callback(CellIndex.temp(rowIndex, column)))) {
                return v;
            }
        }
        style = style instanceof CellStyle ? style : this.getCellStyle(row.dataIndex(), field);
        if (style) {
            if (_isBoolean(v = style.readOnly())) {
                return v;
            }
        }
        if (column.readOnly()) {
            return true;
        }
        if (DataRowState.isDeleted(row.dataState()) && options.deletedRowReadOnly()) {
            return true;
        }
        if (this.isFixedRowIndex(row.index()) && options.fixedRowReadOnly()) {
            return true;
        }
        if (this.isFixedColumn(column) && options.fixedColumnReadOnly()) {
            return true;
        }
        return false;
    },
    getValueAt: function (rowIndex, field) {
        var ds = this.dataSource(),
            row = (rowIndex instanceof GridRow) ? rowIndex : this.getRow(rowIndex);
        if (ds && row) {
            field = field instanceof DataColumn ? field.dataIndex() : ds.getFieldIndexEx(field);
            return row.getValue(field);
        }
        return undefined;
    },
    getCellValue: function (index) {
        if (this.isValidCell(index)) {
            return this.getValueAt(index.rowIndex, index.dataField());
        }
        return undefined;
    },
    setValueAt: function (rowIndex, field, newValue) {
        var row = (rowIndex instanceof GridRow) ? rowIndex : this.getRow(rowIndex);
        if (row) {
            if (typeof field == "string") {
                var ds = this.dataSource();
                if (!ds) return;
                field = ds.getFieldIndexEx(field);
            } else if (field instanceof DataColumn) {
                field = field.dataIndex();
            }
            if (row.isEditing()) { // 편집 행이면
                row.setEditValue(field, newValue);
            } else {
                row.setValue(field, newValue);
            }
        }
    },
    setCellValue: function (index, newValue) {
        this.isValidCell(index) && this.setValueAt(index.rowIndex, index.dataField(), newValue);
    },
    copyCellValue: function (index) {
        if (!this.isEditing() && this.isRowEditing(index.getRow(this))) {
            var row = index.rowIndex;
            while (row-- > 0) {
                if (this.getRow(row).dataIndex() >= 0) {
                    var fld = index.dataField();
                    this.setValueAt(index.rowIndex, fld, this.getValueAt(row, fld));
                    return true;
                }
            }
        }
    },
    getDistinctValues: function (field, maxCount) {
        return this.rowSource().getDistinctValues(field, maxCount);
    },
    searchRow: function (fields, values, options/* SearchOptions */, startRow, wrap, select) {
        var result = -1;
        var cnt = fields && values ? Math.min(fields.length, values.length) : 0;
        if (cnt < 1) return result;
        var rs = this.rowSource();
        if (!rs) return result;
        var ds = rs.dataSource();
        if (!ds) return result;
        var c, f,
            vals = [],
            flds = [];
        for (c = 0; c < cnt; c++) {
            f = ds.getFieldIndexEx(fields[c]);
            if (f >= 0) {
                flds.push(f);
                vals.push(values[c]);
            }
        }
        if (flds.length < 1) return result;
        startRow = arguments.length > 3 ? startRow : 0;
        wrap = arguments.length > 4 ? wrap : true;
        select = arguments.length > 5 ? select : false;
        options = options instanceof SearchOptions ? options : options ? new SearchOptions(options) : null;
        cnt = rs.rowCount();
        startRow = Math.max(0, startRow);
        result = startRow < cnt ? rs.findItem(flds, vals, options, startRow, cnt - 1) : -1;
        if (result < 0 && wrap && startRow > 0) {
            result = rs.findItem(flds, vals, options, 0, startRow - 1);
        }
        if (result >= 0 && select) {
            this.setFocusedRow(result, true, true);
        }
        return result;
    },
    searchCell: function (fields, value, options/* SearchCellOptions */, startRowIndex, startFieldIndex, wrap, select) {
        var result = null;
        var cnt = fields ? fields.length : 0;
        if (fields && cnt < 1) return result;
        var rs = this.rowSource();
        if (!rs) return result;
        var ds = rs.dataSource();
        if (!ds) return result;
        if (value === undefined) return result;
        startRowIndex = arguments.length > 3 ? startRowIndex : 0;
        startFieldIndex = arguments.length > 4 ? startFieldIndex : 0;
        wrap = arguments.length > 5 ? wrap : true;
        select = arguments.length > 6 ? select : false;
        options = options instanceof SearchCellOptions ? options : options ? new SearchCellOptions(options) : null;
        var arr, i, c,
            flds = [];
        if (!fields) {
            cnt = ds.fieldCount();
            for (i = 0; i < cnt; i++) {
                flds.push(i);
            }
        } else {
            for (i = 0; i < cnt; i++) {
                c = ds.getFieldIndexEx(fields[i]);
                if (c >= 0) {
                    flds.push(c);
                }
            }
        }
        if (flds.length > 0) {
            cnt = rs.rowCount();
            startRowIndex = Math.max(0, startRowIndex);
            startFieldIndex = Math.max(0, startFieldIndex);
            result = startRowIndex < cnt ? rs.findCell(flds, value, options, startRowIndex, cnt - 1, startFieldIndex) : null;
            if (!result && wrap && startRowIndex > 0) {
                result = rs.findCell(flds, value, options, 0, startRowIndex - 1, 0);
            }
            if (result) {
                result.fieldName = ds.getFieldName(result["fieldIndex"]);
            }
        }
        if (result && select) {
            c = this.columnByField(result.fieldIndex, true);
            this.setFocusedCell(result.rowIndex, c, true, true);
        }
        return result;
    },
    registerCellRenderers: function (renderers) {
        this._dataCellRenderers.addRenderers(renderers);
        this.refreshView();
    },
    unregisterCellRenderers: function (rendererIds) {
        this._dataCellRenderers.removeRenderers(rendererIds);
        this.refreshView();
    },
    registerCellEditors: function (editors) {
        this._dataCellEditors.addEditors(editors);
        this.refreshView();
    },
    unregisterCellEditors: function (editorIds) {
        this._dataCellEditors.removeEditors(editorIds);
        this.refreshView();
    },
    getCellEditor: function (editorId) {
        return this._dataCellEditors.getEditor(editorId);
    },
    createCellStyleMap: function () {
        return new GridCellStyleMap();
    },
    existsCellStyle: function (styleId) {
        return this._styleManager.hasStyle(styleId);
    },
    registerCellStyle: function (styleId, style, overwrite) {
        this._styleManager.registerStyle(styleId, style, overwrite);
    },
    registerCellStyles: function (styles, overwrite) {
        this._styleManager.registerStyles(styles, overwrite);
    },
    unregisterCellStyle: function (styleId) {
        this._styleManager.unregisterStyles(styleId);
    },
    unregisterCellStyles: function (styleIds) {
        this._styleManager.unregisterStyles(styleIds);
    },
    unregisterAllCellStyles: function () {
        this._styleManager.unregisterAll();
    },
    /*
     $_setCellStyle: function (ds, row, field, style) {
     var r = Math.max(-1, row); // TODO: -1이면 추가 중인 행에 적용한다.
     var f = ds.getFieldIndexEx(field);
     this.itemSource().setCellStyle(r, f, style);
     },
     */
    setCellStyle: function (dataRowIndex, field, styleId, updateNow) {
        this._styleManager.setStyleAt(dataRowIndex, field, styleId, updateNow);
    },
    getCellStyle: function (dataRowIndex, field) {
        return this._styleManager.getStyleAt(dataRowIndex, field);
    },
    getCellStyleId: function (dataRowIndex, field) {
        var style = this._styleManager.getStyleAt(dataRowIndex, field);
        return style ? style.id() : null;
    },
    getFocusedCellStyle: function () {
        var idx = this.$_focusedIndex();
        if (idx.column) {
            var style = this._styleManager.getStyleAt(idx.getDataIndex(this), idx.column.dataIndex());
            return style ? style.id() : null;
        }
    },
    setCellStyles: function (dataRowIndices, fields, styleId) {
        this._styleManager.setStylesAt(dataRowIndices, fields, styleId);
    },
    /** @deprecated use loadCellStyleRows */
    setCellStyleRows: function (rows, fieldMap, startRow, count) {
        this._styleManager.loadStyleRows(rows, fieldMap, startRow, count);
    },
    loadCellStyleRows: function (rows, fieldMap, startRow, count) {
        this._styleManager.loadStyleRows(rows, fieldMap, startRow, count);
    },
    clearCellStyles: function () {
        this._styleManager.clear();
    },
/*
    getStylesOf: function (region) {
        var map = this._styleRegionMap;
        if (!map) {
            map = this._styleRegionMap = {};
            map[GridStyleSheet.GRID] = map[GridStyleSheet.DEFAULT] = this.styles();
            map[GridStyleSheet.PANEL] = this._panel.styles();
            map[GridStyleSheet.GROUPPANEL] = this._groupPanel.styles();
            map[GridStyleSheet.GROUPPANEL_HEAD] = this._groupPanel.head().getStyles();
            map[GridStyleSheet.BODY] = this._body.styles();
            map[GridStyleSheet.BODY_EMPTY] = this._body.emptyStyles();
            map[GridStyleSheet.BODY_ROW] = this._body.rowStyles();
            map[GridStyleSheet.BODY_FIXED_ROW] = this._body.fixedRowStyles();
            map[GridStyleSheet.BODY_CELL] = this._body.cellStyles();
            map[GridStyleSheet.BODY_FIXED_CELL] = this._body.fixedCellStyles();
            map[GridStyleSheet.BODY_FIXED_COLBAR] = this._body.fixedColumnBarStyles();
            map[GridStyleSheet.BODY_FIXED_ROWBAR] = this._body.fixedRowBarStyles();
            map[GridStyleSheet.BODY_SELECTION] = this._body.selectionStyles();
            map[GridStyleSheet.BODY_MOBILE_SELECTION] = this._body.mobileSelectionStyles();
            map[GridStyleSheet.HEADER] = this._header.styles();
            map[GridStyleSheet.HEADER_GROUP] = this._header.groupStyles();
            map[GridStyleSheet.FOOTER] = this._footer.styles();
            map[GridStyleSheet.FOOTER_GROUP] = this._footer.groupStyles();
            map[GridStyleSheet.ROWGROUP_HEADER] = this._rowGroup.headerStyles();
            map[GridStyleSheet.ROWGROUP_FOOTER] = this._rowGroup.footerStyles();
            map[GridStyleSheet.ROWGROUP_HEAD] = this._rowGroup.headStyles();
            map[GridStyleSheet.ROWGROUP_BAR] = this._rowGroup.barStyles();
            map[GridStyleSheet.ROWGROUP_HEADER_BAR] = this._rowGroup.headerBarStyles();
            map[GridStyleSheet.ROWGROUP_FOOTER_BAR] = this._rowGroup.footerBarStyles();
            map[GridStyleSheet.ROWGROUP_PANEL] = this._rowGroup.panelStyles();
            map[GridStyleSheet.ROWINDICATOR] = this._rowIndicator.styles();
            map[GridStyleSheet.ROWINDICATOR_STATE] = this._rowIndicator.stateStyles();
            map[GridStyleSheet.CHECKBAR] = this._checkBar.styles();
            map[GridStyleSheet.CHECKBAR_HEAD] = this._checkBar.headStyles();
            map[GridStyleSheet.HEADER_ITEM] = this._headerItemStyles;
            map[GridStyleSheet.FOOTER_ITEM] = this._footerItemStyles;
            if (this._treeOptions) {
                map[GridStyleSheet.TREE_EXPANDER] = this._treeOptions.expanderStyles();
            }
        }
        return map[region];
    },
*/
    clearStyles: function (recursive) {
        this._defaultStyles.clearValues();
        this._styles.clearValues();
        if (recursive) {
            this.body().clearStyles(true);
            this.panel().clearStyles(true);
            this.groupPanel().clearStyles(true);
            this.rowGroup().clearStyles(true);
            this.header().clearStyles(true);
            this.footer().clearStyles(true);
            this.rowIndicator().clearStyles(true);
            this.checkBar().clearStyles(true);
        }
    },
    alertCellError: function (cell, error) {
        if (this.displayOptions().alertCellError()) {
            _alert(error);
        }
        this._fireErrorClicked(cell, error);
    },
    canMoveIndex: function (index) {
        return this.displayOptions().fixedColumnMovable() || index >= this.lm().fixedColCount();
    },
    canMoveToIndex: function (index) {
        return index >= (this.displayOptions().fixedColumnMovable() ? 0 : this.lm().fixedColCount());
    },
    showProgress: function (title, modal, canceler) {
        this._progressManager.show(null, title, modal, canceler);
    },
    setProgress: function (min, max, pos, msg) {
        this._progressManager.setProperties(min, max, pos, msg);
    },
    closeProgress: function () {
        this._progressManager.close();
    },
    measureText: function (font, text) {
        return this._container.measureText(font, text);
    },
    measureTextRect: function (font, text, x, y, w, h, align, valign, wrap) {
        return this._container.measureTextRect(font, text, x, y, w, h, align, valign, wrap);
    },
    $_prepareContextMenu: function () {
        this.$_contextMenuHandler = function (e) {
            var target = e.target || e.srcElement;
            var r = Dom.getBounds(target); //target.getBoundingClientRect();
            var x = e.clientX - r.left;
            var y = e.clientY - r.top;
            if (this._fireContextMenuPopup(x, y)) {
                var menu = this._contextMenu || this._defaultContextMenu;
                if (menu) {
                    e.preventDefault();
                    this._popupMenuManager.showContext(menu, x, y);
                }
            }
        }.bind(this);
        if ($_evl) {
            this._container._canvas.addEventListener("contextmenu", this.$_contextMenuHandler);
        } else {
            this._container._canvas.attachEvent("contextmenu", this.$_contextMenuHandler);
        }
    },
    setDefaultContextMenu: function (menu) {
        if (typeof menu == "string") {
            this._defaultContextMenu = this.getPopupMenu(menu);
        }
        if (menu instanceof PopupMenu) {
            this._defaultContextMenu = menu;
        } else if (menu) {
            this._defaultContextMenu = new PopupMenu("gridContextMenu", this, menu);
        } else {
            this._defaultContextMenu = null;
        }
        return this;
    },
    getContextMenu: function () {
        return this._contextMenu || this._defaultContextMenu;
    },
    setContextMenu: function (menuItems) {
        if (typeof menuItems == "string") {
            this._contextMenu = this._popupMenuManager.getMenu(menuItems);
        } else {
            this._contextMenu = menuItems instanceof PopupMenu ? menuItems : menuItems ? new PopupMenu("gridContextMenu", this, menuItems) : null;
        }
        return this._contextMenu;
    },
    registerPopupMenu: function (name, menuItems, overwrite) {
        if (menuItems instanceof PopupMenu) {
            this._popupMenuManager.addMenu(name || menuItems.name(), menuItems, overwrite);
        } else if (name && menuItems && menuItems.length > 0) {
            this._popupMenuManager.addMenu(name, menuItems, overwrite);
        }
        return this;
    },
    unregisterPopupMenu: function (name) {
        name && this._popupMenuManager.removeMenu(name);
        return this;
    },
    getPopupMenu: function (name) {
        return this._popupMenuManager.getMenu(name);
    },
    showPopupMenu: function (target, menu, element, offsetX, offsetY, cancelCallback) {
        if (menu) {
            var ret = this._fireMenuPopup(target, menu);
            if (ret !== false) {
                this._popupMenuManager.show(menu, element, offsetX, offsetY, cancelCallback);
            }
        }
        return this;
    },
    showPopupMenuAt: function (target, menu, x, y, width, cancelCallback) {
        if (menu) {
            var ret = this._fireMenuPopup(target, menu);
            if (ret !== false) {
                this._popupMenuManager.showAt(menu, x, y, width, cancelCallback);
            }
        }
        return this;
    },
    stopAutoFill: function () {
        this._autoFillHandle.setMouseEnabled(true);
        return this;
    },
    requestLoadAnimation: function (defered) {
        if (defered) {
            this._animationRequests = "*";
        } else {
            this._animations.requestLoad(this.lm());
        }
        return this;
    },
    getRowHeight: function (row) {
        row = this._parseRow(row);
        return row ? row.$_height(this) : NaN;
    },
    setRowHeight: function (row, value, noRedraw) {
        row = this._parseRow(row);
        if (row && row.isResizable()) {
            row.$_setHeight(this, value);
            !noRedraw && this.refreshView();
        }
        return this;
    },
    setRowHeights: function (rows, value) {
        rows = rows ? this._parseRows(rows) : this.getAllRows();
        if (rows && rows.length > 0) {
            for (var i = rows.length; i--;) {
                rows[i].$_setHeight(this, value);
            }
            this.refreshView();
        }
        return this;
    },
    clearRowHeights: function () {
        rows = this.getAllRows();
        if (rows && rows.length > 0) {
            for (var i = rows.length; i--;) {
                rows[i].$_setHeight(this, undefined);
            }
            this.refreshView();
        }
        return this;
    },
    container: function () {
        return this._container;
    },
    addElement: function (element, context) {
        this._rootElement.addChild(element, context);
    },
    addLayer: function (layer, context) {
        this._rootLayer.addChild(layer, context);
    },
    invalidate: function () {
        this._container.invalidate();
    },
    _beforeRender: function (bounds) {
        this._linesLayer.invalidate();
        this._scrollEdge && this._scrollEdge.visible() && this._scrollEdge.invalidate();
        /*
         var items = this._bodyView.children;
         if (items) {
         for (var i = 50; i < items.length; i++) {
         items[i]._nodraw = true;
         }
         }
         */
    },
    _afterRender: function () {
        this._imageLoaded = false;
    },
    $_setEditFocused: function (value) {
        if (value != this.$_editFocused) {
            this.$_editFocused = value;
            if (value) {
                var index = this.$_focusedIndex();
                if (!index || !this.isValidCell(index)) {
                    index = this._selections.getFirstCell() || this.getFirstCell();
                    index && this.setFocusedIndex(index, false, !this._selections.contains(index));
                }
            }
        }
    },
    _resetFocusMask: function () {
        var lm = this._layoutManager;
        var r = lm.gridBounds();
        var idx = this.$_focusedIndex();
        var row = idx.getRow(this);
        if (lm.rowGrouped() && !this.mergedRowGrouped() && !(row instanceof DataRow)) {
            r.setLeft(lm.rowGroupBounds().x);
        } else if (this.isValidCell(idx) && lm.fixedColCount() > 0 && !(row instanceof GroupRow) && !(row instanceof GroupFooter)) {
            if (idx.column.root().displayIndex() < lm.fixedColCount()) {
                r.copyHorz(lm.fixedBounds());
            } else {
                r.copyHorz(lm.nonfixedBounds());
            }
        }
        r.topBy(-1);
        r.leftBy(-1);
        if (this._dom) {
            this._focusLayer._css.clip = Dom.getClipRect(r);
        } else {
            this._focusLayer._mask = r;//lm.fixedBounds();// lm.nonfixedBounds();// lm.gridBounds();
        }
    },
    $_requestFill: function (view, g, r) {
        var fill = this._styles.background();
        g.drawRectI(SolidBrush.WHITE, null, r);
        if (fill instanceof SolidBrush) {
            g.drawRectI(fill, null, r);
        } else if (fill) {
            r = this.clientRectByChild(view, this._drawRect);
            g.drawRectI(fill, null, r);
        }
    },
    _doDraw: function (g) {
        var hbar, vbar, hVis, vVis, w, h, st, fill, s, font, lm, rs,
            ds = this.dataSource(),
            options = this._displayOptions,
            r = this.clientRect();
        g.clipRect(r);
        if (!this.isEmpty()) {
            fill = this._styles.background();
            if (fill) {
                if (!SolidBrush.areEqual(fill, SolidBrush.WHITE)) {
                    g.drawRectI(fill, null, r);
                }
            }
        } else if (this.isEmptyData() && !this.isEmptyColumns() && (!options.checkDataInited() || (ds && ds.dataInited()))) {
            st = this._body._emptyDataStyles;
            fill = st.background();
            if (fill) {
                if (!SolidBrush.areEqual(fill, SolidBrush.WHITE)) {
                    g.drawRectI(fill, null, r);
                }
            }
            s = _pick(options.emptyDataMessage(), GridLocale._default.emptyDataMessage);
            if (s) {
                fill = st.color();
                font = st.font();
                lm = this.lm();
                r.setTop(lm._summaryBounds.bottom());
                r.setBottom(lm._footerBounds.y);
                st.deflatePaddings(r);
                g.drawTextRectExplicit(font, fill, s, r, st.textAlignment(), st.lineAlignment());
            }
        }
    },
    _doDrawHtml: function () {
        var fill, st, font, lm, r;
        if (this._span) {
            this._span.style.display = 'none';
        }
        if (!this.isEmpty()) {
            fill = this._styles.background();
            if (fill) {
                _ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
            }
        } else if (this.isEmptyData() && !this.isEmptyColumns()) {
            st = this._body._emptyDataStyles;
            fill = st.background();
            if (fill) {
                this._dom.style.background = fill.css();
            }
            s = _pick(this._displayOptions.emptyDataMessage(), GridLocale._default.emptyDataMessage);
            if (s) {
                fill = st.color();
                font = st.font();
                lm = this.lm();
                r = this.clientRect(),
                r.setTop(lm._summaryBounds.bottom());
                r.setBottom(lm._footerBounds.y);
                st.deflatePaddings(r);
                if (!this._span) {
                    this._span = Dom.createSimpleSpan(this._dom);
                } else {
                    this._span.style.display = 'inline-block';
                }
                Dom.renderTextRect(this._span, font, fill, s, r, st.textAlignment(), st.lineAlignment(), 'explicit');
            }
        }
    },
    setFocus: function () {
        this._editController.setFocus(true);
    },
    getEditorText: function () {
        return this._editController.getEditText();
    },
    $_columnSpanChanged: function (column) {
        if (!this._columnSpansDirty) {
            this._columnSpansDirty = true;
            this.invalidateLayout();
        }
    },
    $_columnStyleNameChanged: function (column) {
        column._runStyles = column._styleName ? this._columnStyles[column._styleName] : undefined;
        this.invalidateLayout();
    },
    $_setPosition: function (column, y) {
        var i, cnt;
        column._layoutRect.y = y;
        if (column instanceof ColumnGroup && (cnt = column.visibleCount()) > 0) {
            if (column.vertical()) {
                if (cnt > 1) {
                    for (i = 0; i < cnt; i++) {
                        this.$_setPosition(column.getVisibleItem(i), y + 1);
                    }
                } else {
                    this.$_setPosition(column.getVisibleItem(0), y);
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    this.$_setPosition(column.getVisibleItem(i), y);
                }
            }
        }
    },
    $_setRoot: function (column) {
        var i, cnt, group;
        if (column._layoutRect.y == 0) {
            column._dataRoot = column;
        } else {
            group = column.group();
            while (group) {
                if (group._layoutRect.y == 0) {
                    break;
                }
                group = group.group();
            }
            column._dataRoot = group;
        }
        if (column instanceof ColumnGroup) {
            cnt = column.visibleCount();
            for (i = 0; i < cnt; i++) {
                this.$_setRoot(column.getVisibleItem(i));
            }
        }
    },
    $_setDistance: function (column, x) {
        column._distance = x;
        var d = 1;
        var group = _cast(column, ColumnGroup);
        if (group) {
            var cnt = group.visibleCount();
            var i, c, g;
            if (group.vertical()) {
                for (i = 0; i < cnt; i++) {
                    c = group.getVisibleItem(i);
                    d = Math.max(d, this.$_setDistance(c, x));
                }
            } else {
                d = 0;
                for (i = 0; i < cnt; i++) {
                    c = group.getVisibleItem(i);
                    d += this.$_setDistance(c, x + d);
                }
            }
        }
        return d;
    },
    _resetColumnPositions: function () {
        for (var i = 0, cnt = this.visibleColumnCount(); i < cnt; i++) {
            var column = this.getVisibleColumn(i);
            this.$_setPosition(column, 0);
            this.$_setRoot(column);
            this.$_setDistance(column, i * 1000000);
        }
        this._dataRoots.collect(this._rootColumn);
    },
    _resetColumnIndices: function () {
        this._rootColumn.resetIndices(this);
        this._resetVisibleColumns();
        this._resetColumnPositions();
        this._resetColumnStates();
    },
    _resetVisibleColumns: function () {
        this._rootColumn.resetVisibles();
    },
    _resetColumnStates: function () {
        this._rootColumn.resetStates();
    },
    _isColumnsDirty: function () {
        return this._columnsDirty;
    },
    _isStylesDirty: function () {
        return this._stylesDirty;
    },
    _rootGroup: function () {
        return this._rootColumn;
    },
    stopAnimations: function () {
        return this._animations.stop();
    },
    fitColumnWidth: function (column, maxWidth, minWidth, visibleOnly, includeHeader) {
        if (!this._layouted) {
            this.$_fitColumnWidthRequest = function () {
                this.fitColumnWidth(column, maxWidth, minWidth, visibleOnly, includeHeader);
            };
        } else {
            var lm = this.lm();
            if (!column) {
                for (var i = this.visibleColumnCount(); i--;) {
                    lm.fitColumnWidth(this.getVisibleColumn(i), visibleOnly, minWidth, maxWidth, includeHeader);
                }
            } else {
                column = column instanceof GridColumn ? column : this.columnByName(column);
                column && lm.fitColumnWidth(column, visibleOnly, minWidth, maxWidth, includeHeader);
            }
        }
    },
    fitRowHeight: function (row, minHeight, maxHeight) {
        var options = this._displayOptions;
        row = this._parseRow(row);
        if (row && row.isResizable() && !this._columnVerticalGrouped && options.variableRowHeight()) {
            minHeight = isNaN(minHeight) ? options.minRowHeight() : minHeight;
            maxHeight = isNaN(maxHeight) ? options.maxRowHeight() : maxHeight;
            h = this.lm().fitRowHeight(row, minHeight, maxHeight);
            !isNaN(h) && h && this.setRowHeight(row, h);
        }
    },
    execute: function (command) {
        var rs = this.rowSource();
        return rs && rs.execute(command);
    },
    canUndo: function () {
        var rs = this.rowSource();
        return rs && rs.canUndo();
    },
    canRedo: function () {
        var rs = this.rowSource();
        return rs && rs.canRedo();
    },
    undo: function () {
        this._editController.cancelEditor();
        var rs = this.rowSource();
        if (rs) {
            rs.setCancelWhenUndo(this.editOptions().cancelWhenUndo());
            rs.undo();
        }
        return this;
    },
    redo: function () {
        var rs = this.rowSource();
        rs && rs.redo();
        return this;
    },
    clearUndo: function (clearData) {
        var rs = this.rowSource();
        rs && rs.clearUndo(clearData);
        return this;
    },
    _createDataTagManager: function () {
    },
    _checkEditing: function () {
        if (this.itemSource() instanceof EditableRowProvider && this.itemSource().isEditing()) {
            throw "Item is editing";
        }
    },
    _focusHandler: function (event) {
        this._editController.setFocus();
    },
    _validateScrollBars: function () {
        this._hscrollView && this._hscrollView._mouseOut();
        this._vscrollView && this._vscrollView._mouseOut();
    },
    _addGroupView: function () {
        this.addElement(this._bandedGroupView);
    },
    _addGridObject: function (obj) {
        this._gridObjects.push(obj);
    },
    _cleanGridObjects: function () {
        for (var i = 0, cnt = this._gridObjects.length; i < cnt; i++) {
            this._gridObjects[i].clean();
        }
        this._stylesDirty = false;
    },
    _visualObjectChanged: function (obj) {
        if (obj instanceof GridPanel) {
            this._panelView.invalidate();
        } else if (obj instanceof RowGroupPanel) {
            this._groupPanelView && this._groupPanelView.invalidate();
        } else if (obj instanceof GridBody) {
            this._bodyView.invalidate();
        } else if (obj instanceof RowIndicator) {
            this._rowIndicatorView.invalidate();
        } else if (obj instanceof CheckBar) {
            this._checkBarView.invalidate();
        } else if (obj instanceof GridHeader) {
            this._headerView.invalidate();
        } else if (obj instanceof GridFooter) {
            this._footerView.invalidate();
        } else if (obj instanceof EditBar) {
        }
    },
    _doLayout: function (bounds) {
        var itemCount, prev, fn,
            lm = this.lm(),
            tool = this.activeTool(),
            r = this._gridRect;
        r.copy(bounds);
        this._bordersLayer.updateElement();
        this._bordersLayer.setRect(r);
        this._bordersLayer.deflate(r);
        this._rootElement.setRect(r);
        this._rootLayer.setRect(r);
        r.x = r.y = 0;
        if (this._requestedFocusedDataRow !== undefined) {
            try {
                this.setFocusedDataRow(this._requestedFocusedDataRow, true);
            } catch (e) {
                _throwDebug(e);
            } finally {
                this._requestedFocusedDataRow = undefined
            }
        }
        this._resetting = false;
        try {
            this.$_doLayoutWmv(this._wmv, r);
            this.$_doLayout(r);
        } finally {
            if (this._loading) {
                this._loading = false;
                this._animations.requestLoad(lm);
            } else {
                if (this._animationRequests) {
                    this._animations.requestLoad(lm);
                }
            }
            this._animationRequests = undefined;
            this._dataChanged = false;
        }
        this._cleanGridObjects();
        if (this._columnsDirty || this._dirtyEditor) {
            this._columnsDirty = false;
            this._rootColumn.clean();
            if (this._dirtyEditor) {
                this.reprepareEditor();
                this._dirtyEditor = undefined;
            }
        }
        this._columnLayoutChanged = false;
        this._columnSpansDirty = false;
        itemCount = lm.itemCount();
        if (itemCount > 0) {
            prev = lm.topIndex() + itemCount;
            if (prev != this._prevLast && prev == this.rowCount() && !tool.mousePressing()) {
                tool.mousePressed() && tool.setMousePressing(true);
                setTimeout(function () {
                    this._fireScrollToBottom();
                }.bind(this), 0);
            }
            this._prevLast = prev;
        }
        if (this._topIndex != this._prevTopIndex) {
            prev = this._prevTopIndex;
            if (prev != 0 && this._topIndex == 0) {
                this._fireScrollToTop();
            }
            this._prevTopIndex = this._topIndex;
            this._fireTopIndexChanged(this._topIndex, prev);
        }
        if (this._leftPos != this._prevLeftPos) {
            prev = this._prevLeftPos;
            this._prevLeftPos = this._leftPos;
            this._fireLeftPosChanged(this._leftPos, prev);
        }
        if (itemCount != this._prevRowCount) {
            prev = this._prevRowCount;
            this._prevRowCount = itemCount;
            this._fireDisplayRowCountChanged(itemCount, prev);
        }
        this.$_checkCurrentRow();
        fn = this.$_fitColumnWidthRequest;
        if (fn) {
            this.$_fitColumnWidthRequest = null;
            fn.call(this);
            this._doLayout(r);
        }
    },
    $_doLayoutWmv: function (wmv, bounds) {
        !wmv && _iseval && (bounds.width = bounds.height * 0.3);
        !wmv && (bounds.height = bounds.width);
        var w = wmv ? wmv.width() : 0;
        var h = wmv ? wmv.height() : 0;
        var tool;
        if (w < h) { // _wmv_
            tool = this.activeTool();
            tool.mousePressed() && tool.mousePressing();
        } else { // _wmv_
            tool = this.activeTool();
            this.lm() && tool.mousePressing();
        } // _wmv_
    },
    $_prepareColumns: function (group, fixedCols, styles, groupHeaderStyles, headerStyles, headerSubStyles, groupSummaryStyles, summaryStyles, groupFooterStyles, footerStyles) {
        var cnt = group.visibleCount();
        var def = styles.sysDefault();
        var gheaderDef = groupHeaderStyles.sysDefault();
        var headerDef = headerStyles.sysDefault();
        var headerSubDef = headerSubStyles.sysDefault();
        var gsummaryDef = groupSummaryStyles.sysDefault();
        var summaryDef = summaryStyles.sysDefault();
        var gfooterDef = groupFooterStyles.sysDefault();
        var footerDef = footerStyles.sysDefault();
        group.styles().setParent(styles, false);
        group.header().styles().setParentAndDefault(groupHeaderStyles, gheaderDef);
        group.footer().styles().setParentAndDefault(groupFooterStyles, gfooterDef);
        group.header().summary().styles().setParentAndDefault(groupSummaryStyles, gsummaryDef);
        for (var i = 0; i < cnt; i++) {
            var column = group.getVisibleItem(i);
            column.prepareLayout(this, group.$_fixed || i < fixedCols, fixedCols);
            column.styles().setSysDefault(def, false);
            if (column instanceof ValueColumn) {
                var header = column.header();
                column.styles().setParent(styles, false);
                header.styles().setParentAndDefault(headerStyles, headerDef);
                header.subStyles().setParentAndDefault(headerSubStyles, headerSubDef);
                header.summary().styles().setParentAndDefault(summaryStyles, summaryDef);
                column.footer().styles().setParentAndDefault(footerStyles, footerDef);
                column instanceof DataColumn && column.dynamicStyles().prepare();
            } else if (column instanceof ColumnGroup) {
                this.$_prepareColumns(column, 0, styles, groupHeaderStyles, headerStyles, headerSubStyles, groupSummaryStyles, summaryStyles, groupFooterStyles, footerStyles);
            }
        }
    },
    $_doLayout: function (bounds) {
        var c, column, level, cnt, leftPos, tool,
            options = this._displayOptions,
            cols = this._rootColumn.visibleCount(),
            fixedCols = Math.max(0, Math.min(cols, options.fixedColumnCount())),
            d = this._body.cellStyles(),
            h = this._header.styles(),
            gh = this._header.groupStyles(),
            sh = this._header.subStyles(),
            ghs = this._header.summary().groupStyles(),
            hs = this._header.summary().styles(),
            f = this._footer.styles(),
            gf = this._footer.groupStyles(),
        /*
            def = d.sysDefault(),
            hdef = h.sysDefault(),
            shdef = sh.sysDefault(),
            hsdef = hs.sysDefault(),
            fdef = f.sysDefault(),
            gfdef = gf.sysDefault(),
        */
            rowGroup = this._rowGroup,
            lm = this._layoutManager,
            fl = lm.yU(),
            r = bounds.clone();
        this.$_fixedColCount = fixedCols;
        this.$_fixedRowCount = this._displayOptions.fixedRowCount();
        this.$_hideBorders = this._displayOptions.hideBordersWhenFitted();
        this.$_sortFieldCount = this.getSortFieldCount();
        if (this.$_sortFieldCount > 1) {
            var sos = this._header.sortOrderStyles();
            this.$_sortOrderFont = sos.font();
            this.$_sortOrderColor = sos.color();
        }
        this.$_nanText = this._displayOptions._nanText;
        this._header.$_prepareUpdate();
        this._body.$_prepareUpdate();
        this._rowIndicator.$_prepareUpdate();
        this._checkBar.$_prepareUpdate();
        this._rootColumn.prepareLayout(this, false, fixedCols);
        this.$_prepareColumns(this._rootColumn, fixedCols, d, gh, h, sh, ghs, hs, gf, f);
        this.$_buttonRenderer = this._delegate.getCellButtonRenderer();
        this.$_customButtonRenderer = this._delegate.getCustomButtonRenderer();
        if (this.rowGrouped()) {
            for (c = 0, cnt = rowGroup.levelCount(); c < cnt; c++) {
                level = rowGroup.getLevel(c);
                if (level) {
                    level.headerStyles().setParent(rowGroup.headerStyles(), false);
                    level.footerStyles().setParent(rowGroup.footerStyles(), false);
                    level.expanderStyles().setParent(rowGroup.expanderStyles(), false);
                }
            }
        }
        this._linesLayer.invalidate();
        if (this._columnWidthsDirty) {
            this._columnWidthsDirty = false;
            this.$_resetColumnWidths();
        }
        if (__epochlc > _licsond) delete this["_body"];
        if (cols < 1) {
            this._rootElement.setVisible(false);
            this._emptyView.setVisible(true);
            this._emptyView.setSize(r.width, r.height);
            this._emptyView.invalidate();
        } else {
            this._emptyView.setVisible(false);
            this._rootElement.setVisible(true);
        }
        lm.setHeightMeasurer(this.heightMeasurer());
        lm.measure(r, this._leftPos, this._topIndex, this._vscrollBar.displayWidth(), this._hscrollBar.displayWidth());
        this._topIndex = lm.topIndex();
        leftPos = this._leftPos = lm.leftPos();
        lm.layout(r);
        fl.getChild(0).setSize(r.width, r.height);
        tool = this.activeTool();
        if (tool) {
            tool.layoutChanged();
        }
        this._updateScrollBars(lm, r);
        /*
         var x = bounds.x;
         var y = bounds.y;
         var w = bounds.width;
         var h = bounds.height;
         var view = this._emptyView;
         if (view.visible()) {
         view.setBounds(x, y, w, h);
         return;
         }
         view = this._panelView;
         if (view && view.visible()) {
         view.setBounds(x, y, w, this.getPanel().getMinHeight());
         y += view.getHeight();
         }
         view = this._headerView;
         if (view.visible()) {
         view.setBounds(x, y, w, 25);
         view.layoutContent(lm);
         y += view.getHeight();
         }
         view = this._bodyView;
         view.setBounds(x, y, w, h - y);
         for (var i = 0; i < 20; i++) {
         view.addItem(this._rowSource.getItem(i));
         }
         view.layoutContent(lm);
         */
        /*
         var layout = this.getLayout();
         if (layout) {
         layout.layout(this, bounds);
         }
         */
        if (this._footerView.visible()) {
            if (lm.rowGrouped() && leftPos > 0) {
                r = lm.footerBounds();
                r.x = leftPos;
                r.y = 0;
                this._footerView.setMask(r);
            } else {
                this._footerView.setMask(null);
            }
        }
        this._layoutSelectionViews();
        this._layoutAutoFillHandle();
        this._layouted = true;
        var cellView = this.getCellView(null, this.$_focusedIndex());
        if (cellView) {
            cellView.setFocused(true);
        }
        this._editController.resetEditor();
    },
    fixedRowsChanged: function () {
        if (this.rowSource()) {
            this.rowSource().setFixed(this.displayOptions().fixedRowCount(),
                !this.operateOptions().exceptFixedRowsFromSorting(), !this.operateOptions().exceptFixedRowsFromFiltering());
            this.$_invalidateEditor(this.focusedColumn());
        }
    },
    operateOptionsChanged: function () {
        this._doOperateOptionsChanged();
    },
    _doOperateOptionsChanged: function () {
    },
    _createEmptyView: function (dom) {
        return new EmptyGridElement(dom);
    },
    _createPanelModel: function () {
        return new GridPanel(this);
    },
    _createPanelView: function (dom, panel) {
        return new PanelElement(dom, panel);
    },
    _createGroupPanelModel: function () {
        return new RowGroupPanel(this);
    },
    _createGroupPanelView: function (dom, panel) {
        return null;
    },
    _createFooterModel: function () {
        return new GridFooter(this);
    },
    _createFooterView: function (dom, footer, fixed) {
        return new FooterElement(dom, footer, fixed);
    },
    _createBodyView: function (dom, body, fixed) {
        return new GridBodyElement(dom, body, fixed);
    },
    _createDelegate: function () {
        return _licmod.indexOf('grid') >= 0 ? new GridDelegate(this) : null;
    },
    _createLayoutManager: function () {
        return new GridLayoutManager(this);
    },
    _createEditController: function () {
        return this.readMode() ? new DummyEditController(this) : _isMobile() ? new MobileEditController(this) : new DefaultEditController(this);
    },
    _createAnimationManager: function () {
        return new AnimationManager(this);
    },
    _columnIndexChanged: function () {
        this.clearSelection();
        this._resetColumnIndices();
        this.refreshView();
    },
    _columnDisplayIndexChanged: function (column, oldIndex, newIndex) {
        this.clearSelection();
        this._resetVisibleColumns();
        this._resetColumnPositions();
        this.refreshView();
        column && this._fireColumnMoved(column, newIndex, oldIndex);
    },
    _columnParentChanged: function (column, oldParent, newParent) {
        column && this._fireColumnParentChanged(column, newParent, oldParent);
    },
    _columnVisibleChanged: function (column) {
        column && this._fireColumnVisibleChanged(column);
    },
    _columnChecked: function (column, checked) {
        this._fireColumnChecked(column, checked);
    },
    _editColumnChanged: function (column) {
        this.refreshView();
        this._editController && this._editController.editColumnChanged(column);
    },
    _updateScrollBars: function (lm, r) {
        var hbar = this._hscrollBar;
        var vbar = this._vscrollBar;
        var view, hMax, hPage, rowCount, vMax, vPage;
        view = this._hscrollView;
        if (!view) {
            view = this._hscrollView = new ScrollBarElement(this._dom, false);
            this._scrollLayer.addElement(view);
            view.addListener(this);
        }
        view.updateElement(hbar);
        hMax = lm.bodyBounds().width;
        hPage = Math.min(r.width - lm.gridBounds().x - lm.fixedWidth() - (lm._vscrolled ? vbar.displayWidth() : 0), lm.columnsLength() - lm.leftPos());
        view.setProperties(0, hMax, hPage);
        view.setPosition(lm.leftPos());
        view.setVisible(lm._hscrolled && hbar.visible());
        view = this._vscrollView;
        if (!view) {
            view = this._vscrollView = new ScrollBarElement(this._dom, true);
            this._scrollLayer.addElement(view);
            view.addListener(this);
        }
        view.updateElement(vbar);
        rowCount = this.rowCount();
        vMax = rowCount - lm.fixedItemCount();
        vPage = Math.min(lm.fullItemCount(), rowCount - lm.topIndex());
        view.setProperties(0, vMax, vPage);
        view.setPosition(lm.topIndex());
        view.setVisible(lm._vscrolled && vbar.visible());
        this._layoutScrollBars(lm, r);
            if (!this._scrollEdge) {
                this._scrollEdge = new ScrollEdgeElement(true);
                this._scrollLayer.addElement(this._scrollEdge);
            }
            var vis = false;
            if (!this.isEmpty()) {
                hbar = this._hscrollView;
                vbar = this._vscrollView;
                var hVis = hbar && hbar.visible();
                var vVis = vbar && vbar.visible();
                var w, h, indenter;
                if (hVis && vbar && vVis) {
                    w = vbar.width();
                    h = hbar.height();
                    this._scrollEdge.updateElement(this._scrollEdgeStyles);
                    this._scrollEdge.setBounds(r.width - w, r.height - h, w, h);
                    vis = true;
                }
                indenter = this._hscrollIndenter;
                if (hVis && hbar.x() > 0) {
                    h = hbar.height();
                    if (!indenter) {
                        indenter = this._hscrollIndenter = new ScrollEdgeElement(true);
                        this._scrollLayer.addElement(indenter);
                    }
                    indenter.updateElement(this.hscrollBar().indentStyles());
                    indenter.setBounds(0, hbar.y(), hbar.x(), h);
                    indenter.setVisible(true);
                } else if (indenter) {
                    indenter.setVisible(false);
                }
                indenter = this._vscrollIndenter;
                if (vVis && vbar.y() > 0 && this._layoutManager._allScrolled) {
                    w = vbar.width();
                    if (!indenter) {
                        indenter = this._vscrollIndenter = new ScrollEdgeElement(true);
                        this._scrollLayer.addElement(indenter);
                    }
                    indenter.updateElement(this.vscrollBar().indentStyles());
                    indenter.setBounds(vbar.x(), 0,  w, vbar.y());
                    indenter.setVisible(true);
                } else if (indenter) {
                    indenter.setVisible(false);
                }
            }
            this._scrollEdge.setVisible(vis);
    },
    _layoutScrollBars: function (lm, r) {
        this._scrollLayer.setRect(r);
        var p,
            hBar = this._hscrollBar,
            vBar = this._vscrollBar,
            sh = hBar.barWidth(),
            sw = vBar.barWidth(),
            hView = this._hscrollView,
            vView = this._vscrollView;
        if (hView.visible()) {
            p = 0;
            switch (hBar.barIndent()) {
                case ScrollBarIndent.HEADER:
                    p += lm.checkBarBounds().right() - r.x;
                    break;
                case ScrollBarIndent.FIXED:
                    p += lm.nonfixedBounds().x - r.x;
                    break;
            }
            hView.setBounds(p, r.height - sh, r.width - (vView.visible() ? sw : 0) - p, sh);
            hView.layoutContent();
        }
        if (vView.visible()) {
            p = 0;
            switch (vBar.barIndent()) {
                case ScrollBarIndent.HEADER:
                    p += lm.bodyBounds().y - r.y;
                    break;
                case ScrollBarIndent.FIXED:
                    p += lm.nonfixedBounds().y - r.y;
                    break;
            }
            vView.setBounds(r.width - sw, p, sw, r.height - (hView.visible() ? sh : 0) - p, sw);
            vView.layoutContent();
        }
    },
    _addSelectionElement: function (view) {
        if (view && !this._selectionLayer.contains(view)) {
            this._selectionLayer.addElement(view, this._toolContext);
            return true;
        }
        return false;
    },
    _removeSelectionElement: function (view) {
        if (this._selectionLayer.contains(view)) {
            this._selectionLayer.removeElement(view);
            return true;
        }
        return false;
    },
    _addSelectionView: function (item) {
        var view = null;
        if (!this._selectionViews.get(item)) {
            view = this._delegate.borrowSelectionView(item);
            this._selectionViews.set(item, view);
            this._addSelectionElement(view);
        }
        return view;
    },
    _removeSelectionView: function (item, invalidate) {
        var view = this._selectionViews.get(item);
        if (view) {
            this._removeSelectionElement(view);
            this._delegate.returnSelectionView(view);
            this._selectionViews.unset(item);
            invalidate && this._selectionLayer.invalidate(true, true);
        }
    },
    _clearSelectionViews: function (invalidate) {
        if (!this._selectionViews.isEmpty()) {
            this._selectionViews.each(function (key, value) {
                this._removeSelectionElement(value);
                this._delegate.returnSelectionView(value);
            }.bind(this));
            this._selectionViews.clear();
            invalidate && this._selectionLayer.invalidate(true, true);
        }
    },
    _layoutAutoFillHandle: function () {
        if (!this._layouted) return;
        var vis = false,
            handle = this._autoFillHandle;
        if (!handle) return;
        if (this._autoFill.enabled() && !this.isEditing() && !this.isRowEditing()) {
            var r, row, hasRows, range, view,
                sel = this._selections.lastItem(),
                lm = this.lm(),
                tool = this.activeTool(),
                dx = this._dom ? 6 : 7,
                dy = this._dom ? 6 : 7;
            if (!sel || sel.isSingleCell()) {
                if (this.focusedDataIndex() >= 0) {
                    r = tool.getFocusRect();
                    if (r) {
                        if (r.right() >= lm.gridBounds().right()) {
                            dx = 9;
                        }
                        if (r.bottom() >= lm.gridBounds().bottom()) {
                            dy = 9;
                        }
                        handle.setPosition(r.right() - dx, r.bottom() - dy);
                        vis = true;
                    }
                }
            } else {
                hasRows = false;
                range = sel.getBounds();
                for (r = range.R1(); r <= range.R2(); r++) {
                    row = this.getRow(r);
                    if (row && row.dataIndex() >= 0) {
                        hasRows = true;
                        break;
                    }
                }
                if (hasRows) {
                    view = this._selectionViews.get(sel);
                    if (view && view.visible() && sel.getBounds().bottomIsVisible(this)) {
                        r = view.boundsBy(this._selectionLayer);
                        if (lm.fixedColCount() <= 0 || range.firstCell().column.root().displayIndex() < lm.fixedColCount() || r.right() > this.fixedBodyView().boundsByContainer().right()) {
                            if (r.right() >= lm.gridBounds().right()) {
                                dx = 10;
                            }
                            if (r.bottom() >= lm.gridBounds().bottom()) {
                                dy = 10;
                            }
                            handle.setPosition(r.right() - dx + 1, r.bottom() - dy + 1);
                            vis = true;
                        }
                    }
                }
            }
            this._autoFillLayer.setMask(this.lm().gridBounds());
        }
        handle.setVisible(vis);
    },
    _layoutSelectionViews: function () {
        if (!this._layouted || this._resetting) {
            return;
        }
        var sd = this._displayOptions.selectDisplay(),
            borderOnly = false;
        if (sd == SelectionDisplay.CELL || sd == SelectionDisplay.CELL_AND_BORDER) {
            this._selectCellViews();
            if (this._body._selectionStyles.border()) {
                borderOnly = true;
            } else {
                this._clearSelectionViews(true);
                return;
            }
        } else {
            this._clearCellSelections();
        }
        this._selectionViews.each(function (item, view) {
            var visible, r,
                mobile = _isMobile(),
                showSingle = this._displayOptions.showSingleSelection(),
                single = this._selections.isSingleCell(),
                lm = this.lm();
            if (single && !mobile && !showSingle) {
                view.setVisible(false);
                this.$_singleSelected = true;
            } else {
                this.$_singleSelected = false;
                visible = false;
                r = new Rectangle();
                if (item instanceof RowSelection) {
                    visible = this.$_getSelectionRowsRect(lm, item, r);
                } else if (item instanceof ColumnSelection) {
                    visible = this.$_getSelectionColumnsRect(lm, item, r);
                } else {
                    visible = this.$_getSelectionRangeRect(lm, item, r, single);
                }
                if (view._dom && !view.visible()) {
                    view._css.left = r.x + 'px';
                    view._css.top = r.y + 'px';
                    view._css.width = 0;
                    view._css.height = 0;
                }
                view.setVisible(visible);
                view._borderOnly = borderOnly;
                if (view.visible()) {
                    view.setRectI(r);
                    view.updateElement(item, mobile ? this._body.mobileSelectionStyles() : this._body.selectionStyles());
                    view.invalidate();
                }
            }
        }.bind(this));
    },
    _clearCellSelections: function () {
        var body = this._bodyView,
            fbody = this._fixedBodyView.visible() ? this._fixedBodyView : null,
            merge = this._mergeView.visible() ? this._mergeView : null,
            fmerge = this._fixedMergeView.visible() ? this._fixedMergeView : null;
        body && body.$_clearSelections();
        fbody && fbody.$_clearSelections();
        merge && merge.$_clearSelections();
        fmerge && fmerge.$_clearSelections();
    },
    $_setCellSelections: function (single) {
        var i, cnt, item,
            selItems = [],
            body = this._bodyView,
            fbody = this._fixedBodyView.visible() ? this._fixedBodyView : null,
            merge = this._mergeView.visible() ? this._mergeView : null,
            fmerge = this._fixedMergeView.visible() ? this._fixedMergeView : null,
            sels = this._selections,
            cnt = sels.count();
        for (i = 0; i < cnt; i++) {
            item = sels.getItem(i);
            selItems.push(item);
        }
        body && body.$_setSelections(selItems, single);
        fbody && fbody.$_setSelections(selItems, single);
        merge && merge.$_setSelections(selItems);
        fmerge && fmerge.$_setSelections(selItems);
    },
    _selectCellViews: function () {
        if (this._selections.isSingleCell()) {
            if (this.$_singleSelected) {
                this._clearCellSelections();
            }
            this.$_singleSelected = true;
            if (_isMobile() || this._displayOptions.showSingleSelection()) {
                this.$_setCellSelections(true);
            }
        } else {
            this.$_singleSelected = false;
            this.$_setCellSelections();
        }
    },
    $_getSelectionRowsRect: function (lm, item, r) {
        var r1, r2, y,
            itemCount = lm.itemCount(),
            fixed = lm.fixedItemCount(),
            range = item instanceof SelectionItem ? item.getBounds() : item,
            row1 = range.R1(),
            row2 = range.R2(),
            t = this.topIndex();
        if (fixed > 0) {
            if (row1 >= t + fixed + itemCount || row2 < 0 || row1 >= fixed && row2 < t + fixed) {
                return false;
            }
            y = lm.fixedHeight();
            if (row1 < fixed) {
                r1 = lm.itemBounds(Math.max(0, row1));
            } else {
                r1 = lm.itemBounds(Math.max(0, row1 - t));
            }
            if (row2 < fixed) {
                r2 = lm.itemBounds(row2);
            } else if (row2 >= t) {
                r2 = lm.itemBounds(Math.min(itemCount + fixed - 1, row2 - t));
                r2.y = Math.max(r2.y, y);
            } else {
                r2 = r1;
            }
        } else if (itemCount > 0) {
            if (row1 >= t + itemCount || row2 < t) {
                return false;
            }
            r1 = lm.itemBounds(Math.max(0, row1 - t));
            row1 < t && (r1.y -= r1.height);
            r2 = lm.itemBounds(Math.min(itemCount - 1, row2 - t));
        } else {
            return false;
        }
        r.copy(r1.union(r2));
        r.offset(0, lm.bodyBounds().y);
        r.setRight(lm.bodyBounds().right());
        return true;
    },
    $_getSelectionColumnsRect: function (lm, item, r, single) {
        var r1, r2, c1, c2, x2, x,
            range = item instanceof SelectionItem ? item.getBounds() : item,
            fixed = lm.fixedColCount(),
            leftPos = this.leftPos();
        if (single) {
        } else {
            r1 = lm.dataRootRect(range.C1());
            r2 = lm.dataRootRect(range.C2());
            r.setLeft(r1.x);
            if (fixed > 0 && range.C2().root().displayIndex() >= fixed) {
                r.setRight(Math.max(r2.right(), lm.fixedBounds().right()));
            } else {
                r.setRight(r2.right());
            }
        }
        /*
        if (fixed > 0) {
            c1 = range.C1().root().displayIndex();
            c2 = range.C2().root().displayIndex();
            x2 = lm.columnRect(fixed - 1).right();
            x = lm.bodyBounds().x;
            if (single) {
                r.copy(lm.dataCellRect(range.firstCell()));
                if (c1 >= fixed) {
                    r.setRight(Math.max(x, r.right()));
                    r.setLeft(Math.max(x, r.x));
                }
            } else {
                r1 = lm.dataRootRect(range.C1());
                if (c1 >= fixed) {
                    r1.offset(-leftPos, 0);
                    r1.setRight(Math.max(x, r1.right()));
                    r1.setLeft(Math.max(x, r1.x));
                }
                r2 = lm.dataRootRect(range.C2());
                if (c2 >= fixed) {
                    r2.offset(-leftPos, 0);
                    r2.setRight(Math.max(x, r2.right()));
                    r2.setLeft(Math.max(x, r2.x));
                }
                r.setLeft(Math.min(r1.x, r2.x));
                r.setRight(Math.max(r1.right(), r2.right()));
            }
        } else {
            if (single) {
                r.copy(lm.dataCellRect(range.firstCell()));
            } else {
                r1 = lm.dataRootRect(range.C1());
                r2 = lm.dataRootRect(range.C2());
                r.setLeft(Math.min(r1.x, r2.x));
                r.setRight(Math.max(r1.right(), r2.right()));
            }
        }
        */
        if (!single) {
            r2.setBottom(lm.itemRect(lm.itemCount() - 1).bottom());
            r.setTop(lm.headerBounds().y);
            r.setBottom(r2.bottom());
        }
        return true;
    },
    $_getSelectionRangeRect: function (lm, item, r, single) {
        var tr = new Rectangle();
        if (!this.$_getSelectionRowsRect(lm, item, tr)) {
            return false;
        }
        if (single) {
            r.copy(lm.dataCellRect(item._startIndex));
        } else {
            r.setTop(tr.y);
            r.setBottom(tr.bottom());
            this.$_getSelectionColumnsRect(lm, item, tr);
            r.setLeft(tr.x);
            r.setRight(tr.right());
        }
        return true;
    },
    initStyles: function () {
        var panel = this.panel(),
            gpanel = this.groupPanel(),
            indicator = this.rowIndicator(),
            checkbar = this.checkBar(),
            header = this.header(),
            footer = this.footer(),
            body = this.body(),
            rowGroup = this.rowGroup(),
            headerItems = this.headerItems(),
            footerItems = this.footerItems(),
            vscroll = this.vscrollBar(),
            hscroll = this.hscrollBar(),
            d = this.defaultStyles(),
            g = this.styles(),
            ps = gpanel.styles(),
            b = body.styles(),
            h = header.styles(),
            hs = header.summary().styles(),
            f = footer.styles(),
            rh = rowGroup.headerStyles(),
            s = GridStyleSheet.Default,
            sb = s.scrollBar();
        panel.styles().$_spd(d, s.panel());
        ps.$_spd(d, s.groupPanel());
        gpanel.itemStyles().$_spd(ps, s.groupPanelItem());
        gpanel.itemInnerStyles().$_spd(ps, s.groupPanelItemInner());
        gpanel.head().styles().$_spd(ps, s.groupPanelHead());
        gpanel.head().innerStyles().$_spd(ps, s.groupPanelHeadInner());
        body.styles().$_spd(d, s.body());
        body.emptyStyles().$_spd(d, s.bodyEmpty());
        body.emptyDataStyles().$_spd(d, s.bodyEmptyData());
        body.rowStyles().$_spd(d, s.bodyRow());
        body.fixedRowStyles().$_spd(d, s.bodyFixedRow());
        body.cellStyles().$_spd(d, s.bodyCell());
        body.fixedCellStyles().$_spd(body.cellStyles(), s.bodyFixedCell());
        body.mergedStyles().$_spd(body.cellStyles(), s.bodyMerged());
        body.fixedMergedStyles().$_spd(body.fixedCellStyles(), s.bodyFixedMerged());
        body.fixedColumnBarStyles().$_spd(d, s.bodyFixedColumnBar());
        body.fixedRowBarStyles().$_spd(d, s.bodyFixedRowBar());
        header.styles().$_spd(d, s.header());
        header.head().styles().$_spd(h, s.headerHead());
        header.groupStyles().$_spd(d, s.headerGroup());
        header.subStyles().$_spd(h, s.headerSub());
        header.menuHandleStyles().$_spd(d, s.headerMenuHandle());
        header.filterHandleStyles().$_spd(d, s.headerFilterHandle());
        header.sortHandleStyles().$_spd(d, s.headerSortHandle());
        header.sortOrderStyles().$_spd(d, s.headerSortOrder());
        header.summary().styles().$_spd(d, s.headerSummary());
        header.summary().head().styles().$_spd(hs, s.headerSummaryHead());
        header.summary().groupStyles().$_spd(d, s.headerSummaryGroup());
        footer.styles().$_spd(d, s.footer());
        footer.groupStyles().$_spd(d, s.footerGroup());
        footer.head().styles().$_spd(f, s.footerHead());
        indicator.styles().$_spd(d, s.rowIndicator());
        indicator.stateStyles().$_spd(d, s.rowIndicatorState());
        checkbar.styles().$_spd(d, s.checkBar());
        checkbar.headStyles().$_spd(h, s.checkBarHead());
        rowGroup.headStyles().$_spd(h, s.rowGroupHead());
        rh.$_spd(d, s.rowGroupHeader());
        rowGroup.expanderStyles().$_spd(rh, s.rowGroupExpander());
        rowGroup.footerStyles().$_spd(d, s.rowGroupFooter());
        rowGroup.indentStyles().$_spd(d, s.rowGroupIndent());
        rowGroup.barStyles().$_spd(rh, s.rowGroupBar());
        rowGroup.headerBarStyles().$_spd(rh, s.rowGroupHeaderBar());
        rowGroup.footerBarStyles().$_spd(rowGroup.footerStyles(), s.rowGroupFooterBar());
        this._headerItemStyles.$_spd(d, s.headerItem());
        this._footerItemStyles.$_spd(d, s.footerItem());
        vscroll.styles().$_spd(sb);
        vscroll.buttonStyles().$_spd(s.scrollBarButton(), sb);
        vscroll.thumbStyles().$_spd(s.scrollBarThumb(), sb);
        vscroll.indentStyles().$_spd(s.scrollBarIndent(), sb);
        hscroll.styles().$_spd(s.scrollBar());
        hscroll.buttonStyles().$_spd(s.scrollBarButton(), sb);
        hscroll.thumbStyles().$_spd(s.scrollBarThumb(), sb);
        hscroll.indentStyles().$_spd(s.scrollBarIndent(), sb);
        this._scrollEdgeStyles.$_spd(s.scrollEdge(), sb);
        d.$_ssd(s.default(), false);
        g.$_ssd(s.grid(), false);
        body.selectionStyles().$_ssd(s.bodySelection(), false);
        body.mobileSelectionStyles().$_ssd(s.bodyMobileSelection(), false);
        this._displayOptions.rowHoverMask().styles().$_ssd(s.bodyRowHover(), false);
        indicator.createdStyles().$_ssd(s.rowIndicatorCreated(), false);
        indicator.updatedStyles().$_ssd(s.rowIndicatorUpdated(), false);
        indicator.deletedStyles().$_ssd(s.rowIndicatorDeleted(), false);
        this._displayOptions.tooltipStyles().$_ssd(s.tooltip(), false);
    },
    $_resetColumnWidths: function () {
        for (var i = this._rootColumn.visibleCount(); i--;) {
            var column = this._rootColumn.getVisibleItem(i);
            column._displayWidth = column._groupWidth = column._width = _int(column.width());
            if (column instanceof ColumnGroup) {
                column.resetGroupWidths();
            }
        }
    },
    _canMerge: function () {
        return false;
    },
    $_populateColMerges: function (col, init) {
        var merges = col.stateFor(ColumnMergeManager.MERGE_ROOMS);
        if (!merges) {
            merges = new ColumnMergeManager(col);
            col.setState(ColumnMergeManager.MERGE_ROOMS, merges);
        }
        merges.clear();
        init && merges.initialize(ColumnMergeRule.INIT_COUNT);
    },
    _populateMerges: function () {
        if (!this._canMerge() || !this.dataSource()) {
            return;
        }
        var i, j, col, col2, merges, level, init
            cnt = this.visibleColumnCount();
        for (i = 0; i < cnt; i++) {
            col = this.getVisibleColumn(i);
            if (col instanceof ColumnGroup) {
                for (j = col.visibleCount(); j--;) {
                    col2 = col.getVisibleItem(j);
                    col2.canMerge() && this.$_populateColMerges(col2, true);
                }
            } else if (col.canMerge()) {
                if (col instanceof DataColumn && col.mergeGrouped()) {
                    init = this.getGroupLevel(col.dataIndex()) > 0;
                } else {
                    init = true;
                }
                this.$_populateColMerges(col, init);
            }
        }
    },
    _sortRows: function (fields, directions, textCases) {
        var ds = this.dataSource();
        if (!ds) return;
        var i,
            fldCnt = ds.fieldCount(),
            flds = fields ? fields.concat() : [],
            dirs = directions ? directions.concat() : [],
            cases = textCases ? textCases.concat() : [];
        for (i = flds.length; i--;) {
            if (isNaN(flds[i]) || flds[i] < 0 || flds[i] >= fldCnt) {
                flds.splice(i, 1);
                if (dirs.length > i) dirs.splice(i, 1);
                if (cases.length > i) cases.splice(i, 1);
            }
        }
        this._toastManager.show(this.operateOptions().sortingToast(), true, function () {
            var row = !this.operateOptions().keepFocusedRowWhenSort() && this.$_focusedIndex() ? this.$_focusedIndex().getDataIndex(this) : -1;
            var leftPos = this.leftPos();
            this._doSortRows(fields, dirs, cases);
            if (row >= 0) {
                this.setFocusedDataRow(row, false, true);
                row = this.getRowOfDataIndex(row);
                row && this.makeRowVisible(row.index());
            }
        }.bind(this));
    },
    _doSortRows: function (fields, directions, textCases) {
        var items = this.itemSource();
        items && items.orderBy(fields, directions, textCases);
    },
    _clearFitWidths: function () {
        this._rootColumn.clearFitWidths();
    },
    _doOperateOptionsChanged: function () {
    },
    $_rowGroupDisplayModeChanged: function () {
        this._doRowGroupDisplayModeChanged();
    },
    _doRowGroupDisplayModeChanged: function () {
    },
    $_rowGroupAdornmentsChanged: function () {
        this._doRowGroupAdornmentsChanged();
    },
    _doRowGroupAdornmentsChanged: function () {
    },
    $_summaryModeChanged: function () {
        this._doSummaryModeChanged();
    },
    _doSummaryModeChanged: function () {
    },
    $_groupSummaryModeChanged: function () {
        this._doGroupSummaryModeChanged();
    },
    _doGroupSummaryModeChanged: function () {
    },
    _columnMergeRuleChanged: function (column) {
        this._populateMerges();
        this.refreshView();
    },
    $_columnFiltersChanged: function (columnFilter) {
        this._doColumnFiltersChanged(columnFilter);
    },
    _doColumnFiltersChanged: function (filter) {
        this.applyFilters();
    },
    _editorStarted: function (editor, index) {
        if (this.edit(index)) {
        }
    },
    _editorChange: function (editor, index, value) {//}, text) {
        this._fireEditChange(index, value);//, text);
    },
    getEditValue: function (editor, index, editResult) {
        this._doGetEditValue(index, editResult);
    },
    _doGetEditValue: function (index, editResult) {
        var cb = index.column.editCallback();
        cb && cb(index, editResult);
    },
    setEditValue: function (editor, index, value) {
        return this._doSetEditValue(index, value);
    },
    _doSetEditValue: function (index, value) {
        if (!index.column.editTextCallback) {
            return value;
        }
        var v,
            cb = index.column.editTextCallback();
        if (cb) {
            v = cb(index, value);
        }
        return v === undefined ? value : v;
    },
    editorCommit: function (editor, index, oldValue, newValue) {
        return this._doCellCommit(index, oldValue, newValue);
    },
    _doCellCommit: function (index, oldValue, newValue) {
        return this._fireEditCommit(index, newValue, oldValue);
    },
    editorCancel: function (editor, index, edited) {
        return this._fireEditCanceled(index, edited);
    },
    editorCanceled: function () {
        this.activeTool().resetFocus();
    },
    _editorSearch: function (editor, index, text) {
        this._fireEditSearch(index, text);
    },
    $_validateCell: function (index, value, inserting) {
        try {
            this._fireValidateCell(index, inserting, value);
        } catch (err) {
            if (err instanceof ValidationError && err.level !== ValidationLevel.IGNORE) {
                err.column = index.column;
                throw err;
            }
            throw err;
        }
    },
    $_validateRow: function (item, inserting) {
        var columns = this.getDataColumns();
        var i, column, index, value, values;
        for (i = 0, cnt = columns.length; i < cnt; i++) {
            column = columns[i];
            index = CellIndex.temp(item.index(), column);
            value = item.getValue(column.dataIndex());
            this.$_validateCell(index, value, inserting);
        }
        try {
            values = item.getRowObject();
            this._fireValidateRow(item, inserting, values);
        } catch (err) {
            if (err instanceof ValidationError) {
                if (ValidationLevel.compare(err.level, this.editOptions().commitLevel()) < 0) {
                    throw err;
                }
            } else {
                throw err;
            }
        }
    },
    $_validateCellValue: function (index, value) {
        try {
            var inserting = GridRowState.isInserting(index.getRow(this).rowState());
            this._validationManager.validateCell(index, inserting);
            this.$_validateCell(index, value, inserting);
            index.dataColumn().setError(null);
            index.dataColumn().setErrorLevel(ValidationLevel.IGNORE);
            return true;
        } catch (err) {
            if (err instanceof ValidationError) {
                index.dataColumn().setError(err.message || err);
                index.dataColumn().setErrorLevel(err.level || ValidationLevel.ERROR);
            } else {
                throw err;
            }
        }
        return false;
    },
    validateCellCommit: function (index, value) {
        if (this.editOptions().validateOnEdited()) {
            this.$_validateCellValue(index, value);
        }
    },
    scrollRow: function (delta) {
        var oldTop = this.topIndex();
        this.setTopIndex(oldTop + delta);
        delta = this.topIndex() - oldTop;
        if (delta) {
            if (delta > 0) {
            } else {
            }
        }
    },
    $_getFieldDefaults: function (ds) {
        return ds ? ds.getDefaultValues() : [];
    },
    $_getColumnDefaults: function (group, defaults) {
        for (var i = 0, cnt = group.count(); i < cnt; i++) {
            var column = group.getItem(i);
            if (column instanceof DataColumn) {
                var v = column.$_getDefaultValue(this._columnDefaultRuntime);
                if (v !== UNDEFINED) {
                    defaults[column.dataIndex()] = v;
                }
            } else if (column instanceof ColumnGroup) {
                this.$_getColumnDefaults(column, defaults);
            }
        }
    },
    $_getInsertDefaults: function (item) {
        var defaults = this.$_getFieldDefaults(this.itemSource().dataSource());
        this.$_getColumnDefaults(this._rootColumn, defaults);
        return defaults;
    },
    _clearColumnErrors: function () {
        function clearErrors(group) {
            for (var i = 0, cnt = group.count(); i < cnt; i++) {
                var dc = group.getItem(i);
                if (dc instanceof DataColumn) {
                    dc.setError(null);
                } else if (dc instanceof ColumnGroup) {
                    clearErrors(dc);
                }
            }
        }
        clearErrors(this._rootColumn);
    },
    $_checkCurrentRow: function (force) {
        var index = this.$_focusedIndex();
        if (index) {
            var id = index.getDataId(this);
            var row = index.getDataIndex(this);
            if (force || (id != this._currentRowId)) {
                clearTimeout(this._rowChangeTimer);
                var oldRow = this._currentRow;
                var delay = this._displayOptions.rowChangeDelay();
                var t = _getTimer();
                var needFire = force || delay <= 0 || (t - this._currentRowChanged >= delay);
                this._currentRowId = id;
                this._currentRow = row;
                this._currentRowChanged = t;
                if (needFire) {
                    this._fireCurrentRowChanged(row, oldRow);
                } else if (delay > 0) {
                    this._rowChangeTimer = setTimeout(this._rowChangeTimerCallback, delay);
                }
                return true;
            }
        }
        return false;
    },
    $_checkLastCellCommit: function (index) {
        if (index && index.isLastColumn()) {
        }
    },
    $_restoreEditValue: function (index) {
        index = index || this.$_focusedIndex();
        if (index) {
            var row = index.getRow(this);
            if (row && this.isRowEditing(row) && row.rowState() == GridRowState.UPDATING && !this.isEditing(index)) {
                var fld = index.column.dataIndex();
                row.setValue(fld, this.dataSource().getValue(row.dataIndex(), fld));
                return true;
            }
        }
        return false;
    },
    $_seriesColumnChanged: function (column) {
        column.cached() ? this._dataTags.addSeries(column) : this._dataTags.removeSeries(column);
    },
    $_calculatedColumnChanged: function (column) {
        column.cached() ? this._dataTags.addCalculated(column) : this._dataTags.removeCalculated(column);
    },
    _doColumnsReset: function (group, column) {
    },
    _columnsReset: function (group, column) {
        if (!this._columnsLock) {
            this._rootColumn.initVisibles();
            this._resetColumnIndices();
            this._columnVerticalGrouped = false;
            for (var i = 0, cnt = this._rootColumn.count(); i < cnt; i++) {
                var col = this._rootColumn.getItem(i);
                if (col instanceof ColumnGroup) {
                    col.initGroupWidths();
                    this._columnGrouped = true;
                    if (!this._columnVerticalGrouped) {
                        this._columnVerticalGrouped = col.$_isVeritcalGrouped();
                    }
                }
            }
            this._columnWidthsDirty = true;
            this._columnsDirty = true;
            this.$_initColumnStylesMap(column || group);
            this.refreshView();
            this._doColumnsReset(group);
        }
    },
    _columnsRestore: function (group) {
        if (!this._columnsLock) {
            this._rootColumn.initVisibles();
            this._resetColumnIndices();
            for (var i = 0, cnt = this._rootColumn.count(); i < cnt; i++) {
                var column = this._rootColumn.getItem(i);
                if (!isNaN(column._saveWidth)) {
                    column._width = column._displayWidth = column._groupWidth = column._saveWidth;
                }
                if (column instanceof ColumnGroup && column.count() > 0) {
                    column.restoreGroupWidths();
                }
            }
            this._columnWidthsDirty = true;
            this._columnsDirty = true;
            this.refreshView();
            this._doColumnsReset(group);
        }
    },
    _saveOrgWidths: function () {
        for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
            var c = this._orgColumns[i];
            c._orgWidth = c.saveWidth();
            if (c instanceof ColumnGroup) {
                c._saveOrgWidths();
            }
        }
    },
    _restoreOrgWidths: function () {
        for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
            var c = this._orgColumns[i];
            c.setSaveWidth(c._orgWidth);
            if (c instanceof ColumnGroup) {
                c._restoreOrgWidths();
            }
        }
    },
    $_customGridItemChanged: function (item) {
        this.refreshView();
    },
    $_invalidateEditor: function (column) {
        if (column === this.focusedColumn() && !this._dirtyEditor) {
            this._dirtyEditor = column;
            this.invalidateLayout();
        }
    },
    _parseRow: function (row) {
        if (!(row instanceof GridRow)) {
            row = this.getRow(row);
        }
        return row;
    },
    _parseRows: function (rows, all) {
        if (rows) {
            var i, r, list = [];
            for (i = rows.length; i--;) {
                r = rows[i];
                if (!(r instanceof GridRow)) {
                    r = this.getRow(r);
                }
                if (r || all) {
                    list.push(r);
                }
            }
            return list;
        }
    },
    $_getMergeCell: function (index) {
        var view = null;
        if (this._mergeView && this._mergeView.visible()) {
            view = this._mergeView.getCellView(index);
        }
        if (!view && this._fixedMergeView && this._fixedMergeView.visible()) {
            view = this._fixedMergeView.getCellView(index);
        }
        return view;
    },
    _doRevealRow: function (row) {
    },
    $_autoFilling: function (selection, dir, idx1, idx2) {
    },
    $_autoFillComplete: function (selection, dir, idx1, idx2) {
    },
    $_autoFillCompleted: function (selection, dir, idx1, idx2, result) {
        this._fireAutoFilled(selection, dir, idx1, idx2, result);
    },
    _getValidIndex: function (index) {
        if (index instanceof CellIndex) {
            return index;
        } else if (_isNumber(index)) {
            return new CellIndex(index, this.focusedColumn() || this.getFirstColumn());
        } else if (index instanceof GridColumn) {
            return new CellIndex(_forceInt(this.focusedRowIndex()), index);
        }
        return null;
    },
    _doCellButtonClicked: function (index, button) {
        this._fireCellButtonClicked(index, button);
    },
    _columnResizing: function (column, newWidth, oldWidth) {
        return this._fireColumnResizing(column, newWidth, oldWidth)
    },
    _columnResized: function (column, newWidth, oldWidth) {
        this._fireColumnResized(column, newWidth, oldWidth)
    },
    _rowResizing: function (rowIndex, newHeight, oldHeight) {
        return this._fireRowResizing(rowIndex, newHeight, oldHeight)
    },
    _rowResized: function (rowIndex, newHeight, oldHeight) {
        this._fireRowResized(rowIndex, newHeight, oldHeight)
    },
    _fireRowCountChanged: function (newCount, oldCount) {
        return this.fireEvent(GridBase.ROW_COUNT_CHANGED, newCount, oldCount);
    },
    _fireDisplayRowCountChanged: function (newCount, oldCount) {
        return this.fireEvent(GridBase.DISPLAY_ROW_COUNT_CHANGED, newCount, oldCount);
    },
    _fireDescendantRowCountChanged: function (newCount, oldCount) {
        return this.fireEvent(GridBase.DESCENDANT_ROW_COUNT_CHANGED, newCount, oldCount);
    },
    _fireDescendantDataCountChanged: function (newCount, oldCount) {
        return this.fireEvent(GridBase.DESCENDANT_DATA_COUNT_CHANGED, newCount, oldCount);
    },
    _fireCurrentChanging: function (newIndex, oldIndex) {
        return this.fireConfirmEvent(GridBase.CURRENT_CHANGING, newIndex, oldIndex);
    },
    _fireCurrentChanged: function (newIndex) {
        return this.fireEvent(GridBase.CURRENT_CHANGED, newIndex);
    },
    _fireCurrentRowChanged: function (newRow, oldRow) {
        return this.fireEvent(GridBase.CURRENT_ROW_CHANGED, newRow, oldRow);
    },
    _fireValidateCell: function (index, inserting, value) {
        return this.fireEvent(GridBase.VALIDATE_CELL, index, inserting, value);
    },
    _fireValidateRow: function (item, inserting, values) {
        return this.fireEvent(GridBase.VALIDATE_ROW, item, inserting, values);
    },
    _fireTopIndexChanged: function (newTop, oldTop) {
        return this.fireEvent(GridBase.TOP_INDEX_CHANGED, newTop, oldTop);
    },
    _fireLeftPosChanged: function (newPos, oldPos) {
        return this.fireEvent(GridBase.LEFT_POS_CHANGED, newPos, oldPos);
    },
    _fireScrollToBottom: function () {
        return this.fireEvent(GridBase.SCROLL_TO_BOTTOM);
    },
    _fireScrollToTop: function () {
        return this.fireEvent(GridBase.SCROLL_TO_TOP);
    },
    _fireMenuPopup: function (target, menu) {
        return this.fireConfirmEvent(GridBase.MENU_POPUP, target, menu);
    },
    _fireMenuItemClicked: function (menuItem) {
        return this.fireEvent(GridBase.MENU_ITEM_CLICKED, menuItem);
    },
    _fireContextMenuPopup: function (x, y) {
        return this.fireConfirmEvent(GridBase.CONTEXT_MENU_POPUP, x, y);
    },
    _fireContextMenuItemClicked: function (menuItem, index) {
        return this.fireEvent(GridBase.CONTEXT_MENU_ITEM_CLICKED, menuItem, index);
    },
    _fireUndoStateChanged: function (canUndo, canRedo) {
        return this.fireEvent(GridBase.UNDO_STATE_CHANGED, canUndo, canRedo);
    },
    _fireCellButtonClicked: function (index, button) {
        return this.fireEvent(GridBase.CELL_BUTTON_CLICKED, index, button);
    },
    _fireEditorButtonClicked: function (index) {
        return this.fireEvent(GridBase.EDITOR_BUTTON_CLICKED, index);
    },
    _fireDataButtonClicked: function (index) {
        return this.fireEvent(GridBase.DATA_BUTTON_CLICKED, index);
    },
    _fireSelectionChanged: function (selection) {
        return this.fireEvent(GridBase.SELECTION_CHANGED, selection);
    },
    _fireSelectionAdded: function (selection) {
        return this.fireEvent(GridBase.SELECTION_ADDED, selection);
    },
    _fireSelectionRemoved: function () {
        return this.fireEvent(GridBase.SELECTION_REMOVED);
    },
    _fireSelectionCleared: function () {
        return this.fireEvent(GridBase.SELECTION_CLEARED);
    },
    _fireSelectionResized: function (selection) {
        return this.fireEvent(GridBase.SELECTION_RESIZED, selection);
    },
    _fireSelectionEnded: function (selection) {
        return this.fireEvent(GridBase.SELECTION_ENDED, selection);
    },
    _fireUpdating: function (rowIndex, editor) {
        return this.fireConfirmEvent(GridBase.UPDATING, rowIndex, editor);
    },
    _fireInserting: function (rowIndex, shift, ctrl) {
        return this.fireConfirmEvent(GridBase.INSERTING, rowIndex, shift, ctrl);
    },
    _fireDeleting: function (rows) {
        return this.fireConfirmEvent(GridBase.DELETING, rows);
    },
    /*
     _fireItemCommit: function (itemIndex, dataRow) {
     return this.fireEvent(GridBase.ITEM_COMMIT);
     },
     */
    _fireUpdateStarted: function (item) {
        return this.fireEvent(GridBase.UPDATE_STARTED, item);
    },
    _fireInsertStarted: function (item, appending) {
        return this.fireEvent(GridBase.INSERT_STARTED, item, appending);
    },
    _fireKeyDown: function (key, ctrl, shift, alt) {
        return this.fireConfirmEvent(GridBase.KEY_DOWN, key, !!ctrl, !!shift, !!alt);
    },
    _fireShowEditor: function (index) {
        return this.fireConfirmEvent(GridBase.SHOW_EDITOR, index);
    },
    /*
     _fireHideEditor: function () {
     return this.fireEvent(GridBase.HIDE_EDITOR);
     },
     */
    _fireEditChange: function (index, value) {
        return this.fireEvent(GridBase.EDIT_CHANGE, index, value);
    },
    _fireEditCommit: function (index, newValue, oldValue) {
        return this.fireConfirmEvent(GridBase.EDIT_COMMIT, index, newValue, oldValue);
    },
    _fireEditCanceled: function (index, edited) {
        return this.fireEvent(GridBase.EDIT_CANCELED, index, edited);
    },
    _fireEditSearch: function (index, text) {
        this.fireEvent(GridBase.EDIT_SEARCH, index, text);
    },
    _fireEditCellUpdated: function (row, fieldIndex, newValue, oldValue) {
        this.fireEvent(GridBase.EDIT_CELL_UPDATED, row, fieldIndex, newValue, oldValue);
    },
    _fireEditRowCommitted: function (row, editingState) {
        this.fireEvent(GridBase.EDIT_ROW_COMMITTED, row, editingState);
    },
    _fireEditRowCanceled: function (orgRow, editingState) {
        this.fireEvent(GridBase.EDIT_ROW_CANCELED, orgRow, editingState);
    },
    _fireCopy: function (range, data) {
        return this.fireConfirmEvent(GridBase.COPY, range, data);
    },
    _firePaste: function (index, data) {
        return this.fireConfirmEvent(GridBase.PASTE, index, data);
    },
    _fireEditRowPasted: function (row, fields, newValues, oldValues) {
        this.fireEvent(GridBase.EDIT_ROW_PASTED, row, fields, newValues, oldValues);
    },
    _firePasted: function (row, updatedCount, appendedCount) {
        this.fireEvent(GridBase.PASTED, row, updatedCount, appendedCount);
    },
    _fireRowChecked: function (row, checked) {
        this.fireEvent(GridBase.ROW_CHECKED, row, checked);
    },
    _fireRowsChecked: function (rows, checked) {
        this.fireEvent(GridBase.ROWS_CHECKED, rows, checked);
    },
    _fireCheckedChanged: function (rows) {
        this.fireEvent(GridBase.CHECKED_CHANGED, rows);
    },
    _fireAllCheck: function (checked) {
        return this.fireConfirmEvent(GridBase.ALL_CHECK, checked);
    },
    _fireAllChecked: function (checked) {
        this.fireEvent(GridBase.ALL_CHECKED, checked);
    },
    _fireErrorClicked: function (cell, error) {
        this.fireEvent(GridBase.ERROR_CLICKED, cell.index(), error);
    },
    _fireFiltering: function (column) {
        return this.fireConfirmEvent(GridBase.FILTERING, column);
    },
    _fireSorting: function (column) {
        return this.fireConfirmEvent(GridBase.SORTING, column);
    },
    _fireAutoFilling: function (selection, dir, idx1, idx2) {
        return this.fireConfirmEvent(GridBase.AUTO_FILLING, selection, dir, idx1, idx2);
    },
    _fireAutoFilled: function (selection, dir, idx1, idx2, result) {
        return this.fireEvent(GridBase.AUTO_FILLED, selection, dir, idx1, idx2, result);
    },
    _fireColumnHeaderClicked: function (column, rightClicked) {
        return this.fireEvent(GridBase.COLUMN_HEADER_CLICKED, column, rightClicked);
    },
    _fireColumnHeaderDblClicked: function (column) {
        return this.fireEvent(GridBase.COLUMN_HEADER_DBL_CLICKED, column);
    },
    _fireColumnChecked: function (column, checked) {
        return this.fireEvent(GridBase.COLUMN_CHECKED, column, checked);
    },
    _fireHeaderHeadClicked: function () {
        return this.fireEvent(GridBase.HEADER_HEAD_CLICKED);
    },
    _fireHeaderHeadDblClicked: function () {
        return this.fireEvent(GridBase.HEADER_HEAD_DBL_CLICKED);
    },
    _fireFooterCellClicked: function (column) {
        return this.fireEvent(GridBase.FOOTER_CELL_CLICKED, column);
    },
    _fireFooterCellDblClicked: function (column) {
        return this.fireEvent(GridBase.FOOTER_CELL_DBL_CLICKED, column);
    },
    _fireFooterHeadClicked: function () {
        return this.fireEvent(GridBase.FOOTER_HEAD_CLICKED);
    },
    _fireFooterHeadDblClicked: function () {
        return this.fireEvent(GridBase.FOOTER_HEAD_DBL_CLICKED);
    },
    _fireHeaderSummaryCellClicked: function (column) {
        return this.fireEvent(GridBase.HEADER_SUMMARY_CELL_CLICKED, column);
    },
    _fireHeaderSummaryCellDblClicked: function (column) {
        return this.fireEvent(GridBase.HEADER_SUMMARY_CELL_DBL_CLICKED, column);
    },
    _fireHeaderSummaryHeadClicked: function () {
        return this.fireEvent(GridBase.HEADER_SUMMARY_HEAD_CLICKED);
    },
    _fireHeaderSummaryHeadDblClicked: function () {
        return this.fireEvent(GridBase.HEADER_SUMMARY_HEAD_DBL_CLICKED);
    },
    _fireRowIndicatorCellClick: function (rowIndex) {
        return this.fireEvent(GridBase.ROW_INDICATOR_CELL_CLICK, rowIndex);
    },
    _fireRowIndicatorCellClicked: function (rowIndex) {
        return this.fireEvent(GridBase.ROW_INDICATOR_CELL_CLICKED, rowIndex);
    },
    _fireRowIndicatorCellDblClicked: function (rowIndex) {
        return this.fireEvent(GridBase.ROW_INDICATOR_CELL_DBL_CLICKED, rowIndex);
    },
    _fireStateCellClicked: function (rowIndex) {
        return this.fireEvent(GridBase.STATE_CELL_CLICKED, rowIndex);
    },
    _fireStateCellDblClicked: function (rowIndex) {
        return this.fireEvent(GridBase.STATE_CELL_DBL_CLICKED, rowIndex);
    },
    _fireCheckCellClicked: function (rowIndex) {
        return this.fireEvent(GridBase.CHECK_CELL_CLICKED, rowIndex);
    },
    _fireCheckCellDblClicked: function (rowIndex) {
        return this.fireEvent(GridBase.CHECK_CELL_DBL_CLICKED, rowIndex);
    },
    _fireCheckBarHeadClicked: function () {
        return this.fireEvent(GridBase.CHECK_BAR_HEAD_CLICKED);
    },
    _fireCheckBarHeadDblClicked: function () {
        return this.fireEvent(GridBase.CHECK_BAR_HEAD_DBL_CLICKED);
    },
    _fireRowGroupHeadCellClicked: function (level) {
        return this.fireEvent(GridBase.ROWGROUP_HEAD_CELL_CLICKED, level);
    },
    _fireRowGroupHeadCellDblClicked: function (level) {
        return this.fireEvent(GridBase.ROWGROUP_HEAD_CELL_DBL_CLICKED, level);
    },
    _fireRowGroupHeaderClicked: function (rowIndex) {
        return this.fireEvent(GridBase.ROWGROUP_HEADER_CLICKED, rowIndex);
    },
    _fireRowGroupHeaderDblClicked: function (rowIndex) {
        return this.fireEvent(GridBase.ROWGROUP_HEADER_DBL_CLICKED, rowIndex);
    },
    _fireRowGroupFooterCellClicked: function (index) {
        return this.fireEvent(GridBase.ROWGROUP_FOOTER_CELL_CLICKED, index);
    },
    _fireRowGroupFooterCellDblClicked: function (index) {
        return this.fireEvent(GridBase.ROWGROUP_FOOTER_CELL_DBL_CLICKED, index);
    },
    _fireRowGroupBarClicked: function (index) {
        return this.fireEvent(GridBase.ROWGROUP_BAR_CLICKED, index);
    },
    _fireRowGroupBarDblClicked: function (index) {
        return this.fireEvent(GridBase.ROWGROUP_BAR_DBL_CLICKED, index);
    },
    _firePanelClicked: function () {
        return this.fireEvent(GridBase.PANEL_CLICKED);
    },
    _firePanelDblClicked: function () {
        return this.fireEvent(GridBase.PANEL_DBL_CLICKED);
    },
    _fireRowGroupPanelClicked: function (column) {
        return this.fireEvent(GridBase.ROWGROUP_PANEL_CLICKED, column);
    },
    _fireRowGroupPanelDblClicked: function (column) {
        return this.fireEvent(GridBase.ROWGROUP_PANEL_DBL_CLICKED, column);
    },
    _fireDataCellClick: function (index) {
        return this.fireEvent(GridBase.DATA_CELL_CLICK, index);
    },
    _fireDataCellClicked: function (index) {
        return this.fireEvent(GridBase.DATA_CELL_CLICKED, index);
    },
    _fireDataCellDblClicked: function (index) {
        return this.fireEvent(GridBase.DATA_CELL_DBL_CLICKED, index);
    },
    _fireColumnParentChanged: function (column, newParent, oldParent) {
        return this.fireEvent(GridBase.COLUMN_PARENT_CHANGED, column, newParent, oldParent);
    },
    _fireColumnMoved: function (column, newIndex, oldIndex) {
        return this.fireEvent(GridBase.COLUMN_MOVED, column, newIndex, oldIndex);
    },
    _fireColumnVisibleChanged: function (column) {
        return this.fireEvent(GridBase.COLUMN_VISIBLE_CHANGED, column);
    },
    _fireExcludeColumn: function (column) {
        return this.fireEvent(GridBase.EXCLUDE_COLUMN, column);
    },
    _fireColumnResizing: function (column, newWidth, oldWidth) {
        return this.fireConfirmEvent(GridBase.COLUMN_RESIZING, column, newWidth, oldWidth);
    },
    _fireColumnResized: function (column, newWidth, oldWidth) {
        return this.fireEvent(GridBase.COLUMN_RESIZED, column, newWidth, oldWidth);
    },
    _fireRowResizing: function (row, newHeight, oldHeight) {
        return this.fireConfirmEvent(GridBase.ROW_RESIZING, row, newHeight, oldHeight);
    },
    _fireRowResized: function (row, newHeight, oldHeight) {
        return this.fireEvent(GridBase.ROW_RESIZED, row, newHeight, oldHeight);
    },
    onPopupMenuManagerMenuItemClicked: function (manager, menuItem) {
        this._fireMenuItemClicked(menuItem);
    },
    onScrollBarScrolled: function (bar, eventType, delta, position) {
        if (bar.vertical()) {
            switch (eventType) {
                case ScrollEventType.LINE_DOWN:
                case ScrollEventType.LINE_UP:
                    this.scrollRow(delta);
                    break;
                case ScrollEventType.PAGE_DOWN:
                case ScrollEventType.PAGE_UP:
                    this.setTopIndex(this.topIndex() + delta * bar._page);
                    break;
                case ScrollEventType.THUMB_TRACK:
                    if (this.displayOptions().liveScroll()) {
                        this.setTopIndex(position);
                    } else {
                        this._vscrollView.setPosition(position, true);
                    }
                    break;
                default:
                    this.setTopIndex(position);
                    break;
            }
        } else {
            switch (eventType) {
                case ScrollEventType.LINE_RIGHT:
                case ScrollEventType.LINE_LEFT:
                    var step = Math.max(0, this.displayOptions().horzScrollStep()) || 8;
                    this.setLeftPos(this.leftPos() + delta * step);
                    break;
                case ScrollEventType.PAGE_RIGHT:
                    if (this._layoutManager) {
                        this.setLeftPos(this._layoutManager.scrollToNextColumn());
                    } else {
                        this.setLeftPos(this.leftPos() + bar._page);
                    }
                    break;
                case ScrollEventType.PAGE_LEFT:
                    if (this._layoutManager) {
                        this.setLeftPos(this._layoutManager.scrollToPrevColumn());
                    } else {
                        this.setLeftPos(this.leftPos() - bar._page);
                    }
                    break;
                case ScrollEventType.THUMB_TRACK:
                    if (this.displayOptions().horzLiveScroll()) {
                        this.setLeftPos(position);
                    } else {
                        this._hscrollView.setPosition(position, true);
                    }
                    break;
                default:
                    this.setLeftPos(position);
                    break;
            }
        }
    },
    onImageListImageLoaded: function (images, index) {
        var img = images.getImage(index);
        _console && _trace(images.name() + "'s image loaded at " + index + " [" + img.width + "," + img.height + "]");
        this._imageLoaded = images;
        this.invalidateLayout();
    },
    $_resetEditFocused: function () {
        if (this.itemSource().isEditing()) {
            if (!this._focusing) {
                if (this.isEditing()) {
                    this._editController.resetIndex(this.itemSource().editingItem());
                    this.$_makeFocusIndexVisible();
                } else {
                    this.invalidateEditor();
                }
            }
        } else { // 편집 행이 삭제됐을 수 있다. row provider 쪽에서 편집을 취소 시킨다.
            this.hideEditor();
        }
    },
    $_restoreFocusedRow: function (row) {
        if (this.dataSource().redoing() || this.dataSource().undoing()) {
            if (!this.itemSource().isEditing()) {
                this.setFocusedRow(row);
                this.makeRowVisible(row.index());
            }
        }
    },
    onRowProviderReset: function (rs) {
        if (this._ownedStyleManager === this._styleManager) {
            this._styleManager.setDataSource(this.dataSource());
        }
        this._dataChanged = true;
        this._resetColumnIndices();
        this._populateMerges();
        this.resetGrid();
        this.$_resetEditFocused();
    },
    onRowProviderRefresh: function (rs) {
        this._dataChanged = true;
        this._resetColumnIndices();
        this._populateMerges();
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderUndoStateChanged: function (rs, canUndo, canRedo) {
        this._fireUndoStateChanged(canUndo, canRedo);
    },
    onRowProviderCountChanged: function (rs, oldCount, newCount) {
        if (newCount < 1) {
            this._selections.clear();
        }
        this._fireRowCountChanged(newCount, oldCount);
    },
    onRowProviderRowCountChanged: function (rs, oldCount, newCount) {
        this._fireDescendantRowCountChanged(newCount, oldCount);
    },
    onRowProviderDataCountChanged: function (rs, oldCount, newCount) {
        this._fireDescendantDataCountChanged(newCount, oldCount);
    },
    onRowProviderDataCalculated: function (rs, rows) {
        this.refreshView();
    },
    onRowProviderItemInserted: function (rs, item) {
        this._dataChanged = true;
        this._populateMerges();
        this.refreshView();
        this.$_resetEditFocused();
        this.$_restoreFocusedRow(item);
    },
    onRowProviderItemDeleted: function (rs, item) {
        this.$_restoreFocusedRow(item);
        this._dataChanged = true;
        this._populateMerges();
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderItemUpdated: function (rs, item) {
        this._dataChanged = true;
        this._populateMerges();
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowStateChanged: function (rs, item) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowStatesChanged: function (rs, items) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowStatesCleared: function (rs) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowTagChanged: function (rs, item) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowTagsChanged: function (rs, items) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderRowTagsCleared: function (rs) {
        this.refreshView();
        this.$_resetEditFocused();
    },
    onRowProviderSorting: function (rs, fields, directions, cases) {
    },
    onRowProviderSorted: function (rs) {
        this.refreshView();
        this.fireEvent(GridBase.SORTED);
    },
    onRowProviderFilterAdded: function (rs) {
    },
    onRowProviderFilterRemoved: function (rs) {
    },
    onRowProviderFilterCleared: function (rs) {
    },
    onRowProviderFilterAllCleared: function (rs) {
    },
    onRowProviderFiltering: function (rs) {
    },
    onRowProviderFiltered: function (rs) {
        this.refreshView();
        this.fireEvent(GridBase.FILTERED);
    },
    $_focusEditRow: function (row) {
        var index = new CellIndex(row.index(), this.$_focusedIndex() ? this.$_focusedIndex().column : null);
        if (!index.column && this.visibleColumnCount() > 0) {
            index._column = this.getVisibleColumn(0);
        }
        this.setFocusedIndex(index, false, true);
        this.makeCellVisible(this.$_focusedIndex());
    },
    onItemEditCurrentChanging: function (rs, oldIndex, newIndex) {
        if (!this._focusing) {
            var oldIdx = this.$_focusedIndex();
            var value = CellIndex.create(newIndex, oldIdx.column);
            if (!this._fireCurrentChanging(value, oldIdx)) {
                return false;
            }
        }
    },
    onItemEditCurrentChanged: function (rs, oldIndex, newIndex, noCommit) {
        if (!this._focusing) {
            this._oldFocusIdx.set(oldIndex, this._focusedColumn);
            this._newFocusIdx.set(newIndex, this._focusedColumn);
            this._focusedIndexChanged(this._oldFocusIdx, this._newFocusIdx, true, this.displayOptions().autoRowFocus(), noCommit);
            this._fireCurrentChanged(this._shadowIndex.assign(this.$_focusedIndex()));
        }
    },
    onItemEditUpdating: function (rs, row) {
        if (!this.$_canUpdate(row)) {
            return false;
        }
    },
    $_prepareEditing: function (rs, row) {
        rs.setAutoCommit(this.editOptions().autoCommit());
        rs.clearUndo();
        this.execute(new EditRowCommand(this, row));
    },
    onItemEditUpdateStarted: function (rs, row) {
        this.$_prepareEditing(rs);
        this._clearColumnErrors();
        this.refreshView();
        this.clearSelection();
        this._fireUpdateStarted(row);
        var tool = this.activeTool();
        tool && tool.rowEditStarted(row);
    },
    $_prepareDefaults: function (defaults) {
        var ds = this.dataSource();
        if (ds) {
            var defs = this.$_getInsertDefaults();
            if (defs) {
                var len = Math.min(ds.fieldCount(), Math.max(defs.length, defaults.length));
                for (var i = len; i--;) {
                    if (defs[i] !== UNDEFINED) {
                        defaults[i] = defs[i];
                    }
                }
            }
        }
    },
    onItemEditAppending: function (rs, defaults) {
        if (!this.$_canAppend()) {
            return false;
        }
        defaults && this.$_prepareDefaults(defaults);
    },
    onItemEditAppendStarted: function (rs, row) {
        this.$_prepareEditing(rs);
        this.hideEditor();
        this.prepareEditor();
        this._clearColumnErrors();
        this._populateMerges();
        this.refreshView();
        this.$_focusEditRow(row);
        var tool = this.activeTool();
        tool && tool.rowEditStarted(row);
        this._fireInsertStarted(row, true);
    },
    onItemEditInserting: function (rs, row, defaults, shift, ctrl) {
        if (!this.$_canInsert(row, shift, ctrl)) {
            return false;
        }
        defaults && this.$_prepareDefaults(defaults);
    },
    onItemEditInsertStarted: function (rs, row) {
        this.$_prepareEditing(rs);
        this.hideEditor();
        this.reprepareEditor();
        this._clearColumnErrors();
        this._populateMerges();
        this.refreshView();
        this.$_focusEditRow(row);
        var tool = this.activeTool();
        tool && tool.rowEditStarted(row);
        this._fireInsertStarted(row, false);
    },
    onItemEditCellUpdated: function (itemProvider, row, field, oldValue, newValue) {
        this.refreshView();
        !this._cellUpdateEventLock && this._fireEditCellUpdated(row, field, newValue, oldValue);
    },
    onItemEditCommitting: function (itemProvider, row, editingState) {
        this.editController().commitEditor(true, false, true);
        this.editController().invalidateEditor();
        var options = this.editOptions();
        var index = this.$_focusedIndex();
        var force = false;
        switch (editingState) {
            case GridRowState.INSERTING:
                force = options.forceInsert();
                break;
            case GridRowState.APPENDING:
                force = options.forceAppend();
                break;
            case GridRowState.UPDATING:
                force = options.commitWhenNoEdit();
                break;
        }
        if (force || itemProvider.isEdited(row)) {
            var inserting = GridRowState.isInserting(editingState);
            try {
                this._validationManager.validateRow(row, inserting);
                this.$_validateRow(row, inserting);
            } catch (err) {
                if (err instanceof ValidationError && err.column instanceof DataColumn) {
                    err.column.setError(err.message || err);
                    err.column.setErrorLevel(err.level || ValidationLevel.ERROR);
                }
                throw err;
            }
        } else {
            return false;
        }
    },
    onItemEditCommitted: function (itemProvider, row, editingState) {
        this.hideEditor();
        this.refreshView();
        var tool = this.activeTool();
        tool && tool.rowEditEnded(row);
        this._fireEditRowCommitted(row, editingState)
    },
    onItemEditCanceling: function (itemProvider, orgItem, editingState) {
        this._toolTipManager.close();
        this.editController().cancelEditor(true);
        this.editController().invalidateEditor();
    },
    onItemEditCanceled: function (itemProvider, orgRow, editingState) {
        this.hideEditor();
        this._populateMerges();
        this.refreshView();
        var tool = this.activeTool();
        tool && tool.rowEditEnded(orgRow, true);
        this._fireEditRowCanceled(orgRow, editingState)
    },
    onItemEditCommitRequest: function (itemProvider) {
        this.commit(false);
    },
    onItemEditCancelReuqest: function (itemProvider) {
        this.cancel();
    },
    onLookupSourceProviderChanged: function (provider) {
        this.refreshView();
    },
    onSelectionManagerChanged: function (manager, item) {
        this._fireSelectionChanged(item);
    },
    onSelectionManagerAdded: function (manager, item) {
        this._addSelectionView(item);
        this._layoutSelectionViews();
        this._layoutAutoFillHandle();
        this._fireSelectionAdded(item);
    },
    onSelectionManagerRemoved: function (manager, item) {
        this._removeSelectionView(item, true);
        this._layoutSelectionViews();
        this._layoutAutoFillHandle();
        this._fireSelectionRemoved(item);
    },
    onSelectionManagerCleared: function (manager) {
        this._clearSelectionViews(true);
        this._clearCellSelections();
        this._layoutAutoFillHandle();
        this._fireSelectionCleared();
    },
    onSelectionManagerResized: function (manager, item) {
        this._layoutSelectionViews();
        this._layoutAutoFillHandle();
        this._fireSelectionResized(item);
    },
    onSelectionManagerEnded: function (manager, item) {
        this._layoutSelectionViews();
        this._layoutAutoFillHandle();
        this._fireSelectionEnded(item);
    },
    onMenuItemClick: function (menuItem) {
        var index = CellIndex.temp(-1, null);
        this._layoutManager.mouseToIndex(this._container._currentX, this._container._currentY, index);
        this._fireContextMenuItemClicked(menuItem, index);
    }
}, {
    createColumn: function (source, attachKey) {
        if (source) {
            var column = null;
            var t = source.type;
            if (t) t = t.trim();
            if (t === "group" || _isArray(source.columns)) {
                column = new ColumnGroup();
            } else if (t === "chart" || _isObject(source.chart)) {
                column = new ChartColumn();
            } else if (t === "series" || source.fieldNames) {
                column = new SeriesColumn();
            } else if (t === "label") {
                column = new LabelColumn();
            } else if (t === "calced") {
                column = new CalculatedColumn();
            } else {
                column = new DataColumn();
            }
            attachKey && (source[attachKey] = column);
            column.assign(source);
            if (column instanceof ColumnGroup && source.columns) {
                var columns = GridBase.createColumns(source.columns, attachKey);
                column.setColumns(columns);
            }
            return column;
        }
        return null;
    },
    createColumns: function (source, attachKey) {
        if (_isArray(source)) {
            var columns = [];
            for (var i = 0, cnt = source.length; i < cnt; i++) {
                var column = GridBase.createColumn(source[i], attachKey);
                column && columns.push(column);
            }
            return columns;
        }
        return null;
    },
    ROW_COUNT_CHANGED: "onGridBaseRowCountChanged",
    DISPLAY_ROW_COUNT_CHANGED: "onGridBaseDisplayRowCountChanged",
    DESCENDANT_ROW_COUNT_CHANGED: "onGridBaseDescendantRowCountChanged",
    DESCENDANT_DATA_COUNT_CHANGED: "onGridBaseDescendantDataCountChanged",
    CURRENT_CHANGING: "onGridBaseCurrentChanging",
    CURRENT_CHANGED: "onGridBaseCurrentChanged",
    CURRENT_ROW_CHANGED: "onGridBaseCurrentRowChanged",
    TOP_INDEX_CHANGED: "onGridBaseTopIndexChanged",
    SCROLL_TO_BOTTOM: "onGridBaseScrollToBottom",
    SCROLL_TO_TOP: "onGridBaseScrollToTop",
    LEFT_POS_CHANGED: "onGridBaseLeftPosChanged",
    SELECTION_ADDED: "onGridBaseSelectionAdded",
    SELECTION_CHANGED: "onGridBaseSelectionChanged",
    SELECTION_REMOVED: "onGridBaseSelectionRemoved",
    SELECTION_CLEARED: "onGridBaseSelectionCleared",
    SELECTION_RESIZED: "onGridBaseSelectionResized",
    SELECTION_ENDED: "onGridBaseSelectionEnded",
    VALIDATE_CELL: "onGridBaseValidateCell",
    VALIDATE_ROW: "onGridBaseValidateRow",
    UPDATING: "onGridBaseUpdating",
    INSERTING: "onGridBaseInserting",
    DELETING: "onGridBaseDeleting",
    INSERT_STARTED: "onGridBaseInsertStarted",
    UPDATE_STARTED: "onGridBaseUpdateStarted",
    KEY_DOWN: "onGridBaseKeyDown",
    SHOW_EDITOR: "onGridBaseShowEditor",
    HIDE_EDITOR: "onGridBaseHideEditor",
    EDIT_CHANGE: "onGridBaseEditChange",
    EDIT_COMMIT: "onGridBaseEditCommit",
    EDIT_CANCELED: "onGridBaseEditCanceled",
    EDIT_SEARCH: "onGridBaseEditSearch",
    EDIT_CELL_UPDATED: "onGridBaseEditCellUpdated",
    EDIT_ROW_COMMITTED: "onGridBaseEditRowCommitted",
    EDIT_ROW_CANCELED: "onGridBaseEditRowCanceled",
    COPY: "onGridBaseCopy",
    PASTE: "onGridBasePaste",
    EDIT_ROW_PASTED: "onGridBaseEditRowPasted",
    PASTED: "onGridBasePasted",
    ROW_CHECKED: "onGridBaseRowChecked",
    ROWS_CHECKED: "onGridBaseRowsChecked",
    CHECKED_CHANGED: "onGridBaseCheckedChanged",
    ALL_CHECKED: "onGridBaseAllChecked",
    ALL_CHECK: "onGridBaseAllCheck",
    ERROR_CLICKED: "onGridBaseErrorClicked",
    SORTING: "onGridBaseSorting",
    SORTED: "onGridBaseSorted",
    FILTERING: "onGridBaseFiltering",
    FILTERED: "onGridBaseFiltered",
    AUTO_FILLING: "onGridBaseAutoFilling",
    AUTO_FILLED: "onGridBaseAutoFilled",
    MENU_POPUP: "onGridBaseMenuPopup",
    MENU_ITEM_CLICKED: "onGridBaseMenuItemClicked",
    CONTEXT_MENU_POPUP: "onGridBaseContextMenuPopup",
    CONTEXT_MENU_ITEM_CLICKED: "onGridBaseContextMenuItemClicked",
    UNDO_STATE_CHANGED: "onGridBaseUndoStateChanged",
    COLUMN_WIDTH_CHANGED: "onGridBaseColumnWidthChanged",
    COLUMN_HEADER_CLICKED: "onGridBaseColumnHeaderClicked",
    COLUMN_HEADER_DBL_CLICKED: "onGridBaseColumnHeaderDblClicked",
    COLUMN_CHECKED: "onGridBaseColumnChecked",
    HEADER_HEAD_CLICKED: "onGridBaseHeaderHeadClicked",
    HEADER_HEAD_DBL_CLICKED: "onGridBaseHeaderHeadDblClicked",
    ROW_INDICATOR_CELL_CLICK: "onGridBaseRowIndicatorCellClick",
    ROW_INDICATOR_CELL_CLICKED: "onGridBaseRowIndicatorCellClicked",
    ROW_INDICATOR_CELL_DBL_CLICKED: "onGridBaseRowIndicatorCellDblClicked",
    STATE_CELL_CLICKED: "onGridBaseStateCellClicked",
    STATE_CELL_DBL_CLICKED: "onGridBaseStateCellDblClicked",
    CHECK_CELL_CLICKED: "onGridBaseCheckCellClicked",
    CHECK_CELL_DBL_CLICKED: "onGridBaseCheckCellDblClicked",
    CHECK_BAR_HEAD_CLICKED: "onGridBaseCheckBarHeadClicked",
    CHECK_BAR_HEAD_DBL_CLICKED: "onGridBaseCheckBarHeadDblClicked",
    FOOTER_CELL_CLICKED: "onGridBaseFooterCellClicked",
    FOOTER_CELL_DBL_CLICKED: "onGridBaseFooterCellDblClicked",
    FOOTER_HEAD_CLICKED: "onGridBaseFooterHeadClicked",
    FOOTER_HEAD_DBL_CLICKED: "onGridBaseFooterHeadDblClicked",
    HEADER_SUMMARY_CELL_CLICKED: "onGridBaseHeaderSummaryCellClicked",
    HEADER_SUMMARY_CELL_DBL_CLICKED: "onGridBaseHeaderSummaryCellDblClicked",
    HEADER_SUMMARY_HEAD_CLICKED: "onGridBaseHeaderSummaryHeadClicked",
    HEADER_SUMMARY_HEAD_DBL_CLICKED: "onGridBaseHeaderSummaryHeadDblClicked",
    ROWGROUP_HEAD_CELL_CLICKED: "onGridBaseRowGroupHeadCellClicked",
    ROWGROUP_HEAD_CELL_DBL_CLICKED: "onGridBaseRowGroupHeadCellDblClicked",
    ROWGROUP_HEADER_CLICKED: "onGridBaseRowGroupHeaderClicked",
    ROWGROUP_HEADER_DBL_CLICKED: "onGridBaseRowGroupHeaderDblClicked",
    ROWGROUP_FOOTER_CELL_CLICKED: "onGridBaseRowGroupFooterCellClicked",
    ROWGROUP_FOOTER_CELL_DBL_CLICKED: "onGridBaseRowGroupFooterCellDblClicked",
    ROWGROUP_BAR_CLICKED: "onGridBaseRowGroupBarClicked",
    ROWGROUP_BAR_DBL_CLICKED: "onGridBaseRowGroupBarDblClicked",
    PANEL_CLICKED: "onGridBasePanelClicked",
    PANEL_DBL_CLICKED: "onGridBasePanelDblClicked",
    ROWGROUP_PANEL_CLICKED: "onGridBaseRowGroupPanelClicked",
    ROWGROUP_PANEL_DBL_CLICKED: "onGridBaseRowGroupPanelDblClicked",
    CELL_BUTTON_CLICKED: "onGridBaseCellButtonClicked",
    DATA_BUTTON_CLICKED: "onGridBaseDataButtonClicked",
    EDITOR_BUTTON_CLICKED: "onGridBaseEditorButtonClicked",
    CLICKABLE_CELL_CLICKED: "onGridBaseClickableCellClicked",
    DATA_CELL_CLICK: "onGridBaseDataCellClick",
    DATA_CELL_CLICKED: "onGridBaseDataCellClicked",
    DATA_CELL_DBL_CLICKED: "onGridBaseDataCellDblClicked",
    COLUMN_PARENT_CHANGED: "onGridBaseColumnParentChanged",
    COLUMN_MOVED: "onGridBaseColumnMoved",
    COLUMN_VISIBLE_CHANGED: "onGridBaseColumnVisibleChanged",
    EXCLUDE_COLUMN: "onGridBaseExcludeColumn",
    COLUMN_RESIZING: "onGridBaseColumnResizing",
    COLUMN_RESIZED: "onGridBaseColumnResized",
    ROW_RESIZING: "onGridBaseRowResizing",
    ROW_RESIZED: "onGridBaseRowResized"
});
FillGradient['_mod_'] = _licmod;
/** @internal */
var RootColumn = defineClass("RootColumn", ColumnGroup, {
    init: function (owner) {
        this._super();
        this._owner = owner; // GridBase
        this._header._visible = false;
        this.$_last = true;
    },
    grid: function () {
        return this._owner;
    },
    _columnAdded: function (column) {
        this._super(column);
        var group = _cast(column, ColumnGroup);
        if (group) {
            this.$_groupAdded(group);
        }
    },
    _columnRemoved: function (column) {
    },
    $_groupAdded: function (group) {
        for (var i = 0, cnt = group.count(); i < cnt; i++) {
            var c = group.getItem(i);
            var g = _cast(c, ColumnGroup);
            if (g) {
                this.$_groupAdded(g);
            }
        }
    },
    first: function () {
        return $_getFirstColumn(this) || null;
    },
    last: function () {
        return $_getLastColumn(this) || null;
    }
});
var DataRootCollection = defineClass("DataRootCollection", null, {
    init: function () {
        this._super();
        this._root = null;
        this._dataRoots = [];
        this._list = [];
    },
    roots: function () {
        return this._dataRoots;
    },
    collect: function (root) {
        this._root = root;
        this._dataRoots.length = 0;
        if (root.visibleCount() > 0) {
            this.$_collectGroup(root);
            this.$_checkValid(root);
        }
    },
    collectDataColumns: function (c1, c2, columns) {
        if (!(c1 instanceof GridColumn) || !(c2 instanceof GridColumn)) {
            return [];
        }
        columns = _asArray(columns) || [];
        if (c1.dataRoot() !== c1) {
            c1 = c1.dataRoot();
        }
        if (c2.dataRoot() != c2) {
            c2 = c2.dataRoot();
        }
        var g = _cast(c1, ColumnGroup);
        if (g) {
            c1 = ColumnGroup.getFirstDataRoot(g);
        }
        g = _cast(c2, ColumnGroup);
        if (g) {
            c2 = ColumnGroup.getLastDataRoot(g);
        }
        var i1 = this._dataRoots.indexOf(c1);
        var i2 = this._dataRoots.indexOf(c2);
        var c, j, cnt, i;
        if (i1 > i2) {
            i = i1;
            i1 = i2;
            i2 = i;
        }
        for (i = i1; i <= i2; i++) {
            c = this._dataRoots[i];
            if (c.visible()) {
                g = _cast(c, ColumnGroup);
                if (g) {
                    this._list.length = 0;
                    this.$_collectDataColumns(g, this._list);
                    for (j = 0, cnt = this._list.length; j < cnt; j++) {
                        columns.push(this._list[j]);
                    }
                } else if (c instanceof DataColumn) {
                    columns.push(c);
                }
            }
        }
        return columns;
    },
    $_collectGroup: function (group) {
        var cnt = group.visibleCount();
        var c, g, i;
        if (cnt < 1) {
            this._dataRoots.push(group);
        } else if (cnt == 1) {
            c = group.getVisibleItem(0);
            g = _cast(c, ColumnGroup);
            if (!g) {
                this._dataRoots.push(c);
            } else {
                this.$_collectGroup(g);
            }
        } else if (group.vertical()) {
            this._dataRoots.push(group);
        } else {
            for (i = 0; i < cnt; i++) {
                c = group.getVisibleItem(i);
                g = _cast(c, ColumnGroup);
                if (!g) {
                    this._dataRoots.push(c);
                } else {
                    this.$_collectGroup(g);
                }
            }
        }
    },
    $_collectDataColumns: function (group, list) {
        for (var i = 0, cnt = group.visibleCount(); i < cnt; i++) {
            var col = group.getVisibleItem(i);
            if (col instanceof DataColumn) {
                list.push(col);
            } else if (col instanceof ColumnGroup) {
                this.$_collectDataColumns(col, list);
            }
        }
    },
    $_checkValid: function (group) {
    }
});
var DataTagManager = defineClass("DataTagManager", DataTag, {
    init: function (grid) {
        this._super();
        this._grid = grid;
        this._dataSource = undefined;
        this._series = {};
        this._calcs = {};
    },
    addSeries: function (column) {
        if (column) {
            var tag = this._series[column.$_hash];
            if (!tag) {
                tag = this._series[column.$_hash] = this._createSeriesTag(column);
            }
            tag.clearValues();
            this._dataSource && tag.connect(this._dataSource);
            column.$_setDataTag(tag);
            return tag;
        }
        return null;
    },
    removeSeries: function (column) {
        var tag = this._series[column.$_hash];
        if (tag) {
            tag.disconnect();
            delete this._series[column.$_hash];
        }
    },
    addCalculated: function (column) {
        if (column) {
            var tag = this._calcs[column.$_hash];
            if (!tag) {
                tag = this._calcs[column.$_hash] = this._createCalculatedTag(column);
            }
            this._dataSource && tag.connect(this._dataSource);
            column.$_setDataTag(tag);
            return tag;
        }
        return null;
    },
    removeCalculated: function (column) {
        var tag = this._calcs[column.$_hash];
        if (tag) {
            tag.disconnect();
            delete this._calcs[column.$_hash];
        }
    },
    saveValue: function (scope, row, field) {
        this._visitTags(function (tag) {
            tag.saveValue(scope, row, field);
        });
    },
    restoreValue: function (scope, row, field) {
        this._visitTags(function (tag) {
            tag.restoreValue(scope, row, field);
        });
    },
    saveRow: function (scope, row, deleting) {
        this._visitTags(function (tag) {
            tag.saveRow(scope, row, deleting);
        });
        this._dataSource.redoing() && this._grid.requestFocusedDataRow(row);
    },
    restoreRow: function (scope, row, created) {
        this._visitTags(function (tag) {
            tag.restoreRow(scope, row, created);
        });
        this._grid.requestFocusedDataRow(row, true);
    },
    saveRows: function (scope, rows, deleting) {
        if (rows === DataSet.ALL_ROWS || rows && rows.length > 0) {
            this._visitTags(function (tag) {
                tag.saveRows(scope, rows, deleting);
            });
            if (this._dataSource.redoing()) {
                if (deleting) {
                    this._grid.requestFocusedDataRow(rows[0]);
                } else {
                    this._grid.requestFocusedDataRow(rows[rows.length - 1]);
                }
            }
        }
    },
    restoreRows: function (scope, rows, created) {
        if (rows === DataSet.ALL_ROWS || rows && rows.length > 0) {
            this._visitTags(function (tag) {
                tag.restoreRows(scope, rows, created);
            });
            if (rows === DataSet.ALL_ROWS) {
                this._dataSource.rowCount() > 0 && this._grid.requestFocusedDataRow(0);
            } else {
                this._grid.requestFocusedDataRow(rows[0], true);
            }
        }
    },
    _createSeriesTag: function (column) {
    },
    _createCalculatedTag: function (column) {
    },
    _visitTags: function (callback) {
        for (var tag in this._series) {
            callback(this._series[tag]);
        }
        for (var tag in this._calcs) {
            callback(this._calcs[tag]);
        }
    }
});
var SeriesValueTag = defineClass("SeriesValueTag", null, {
    init: function (column) {
        this._super();
        this._column = column;
        this._exprNode = undefined;
        this._runtime = undefined;
    },
    column: function () {
        return this._column;
    },
    clearValues: function () {
    },
    getValues: function (row) {
    },
    saveValue: function (scope, row, field) {
        this.saveRow(scope, row);
    },
    restoreValue: function (scope, row, field) {
        this.restoreRow(scope, row);
    },
    saveRow: function (scope, row) {
    },
    restoreRow: function (scope, row, created) {
    },
    saveRows: function (scope, rows) {
    },
    restoreRows: function (scope, rows, created) {
    },
    $_calculate: function (dataIndex) {
        var ds = this._dataSource;
        if (ds) {
            var fields = this._column._fields;
            var cnt;
            if (fields && (cnt = fields.length) > 0) {
                var vals = new Array(cnt);
                for (var i = 0; i < cnt; i++) {
                    if (fields[i] >= 0) {
                        vals[i] = ds.getValue(dataIndex, fields[i]);
                    }
                }
                return vals;
            }
        }
    }
});
var $$_CVT_ALL = {};
var CalcluatedValueTag = defineClass("CalcluatedValueTag", null, {
    init: function (column) {
        this._super();
        this._column = column;
        this._reqRows = null;
    },
    column: function () {
        return this._column;
    },
    clearValues: function () {
    },
    hasValue: function (dataIndex) {
        return false;
    },
    getValue: function (column, row) {
        var r = row.dataIndex();
        var v = this._values[r];
        if (v === undefined) {
            v = this._values[r] = column.$_calcValue(row);
        }
        return v;
    },
    $_nextDataRow: function (grid, row) {
        for (var i = row.index() + 1, cnt = grid.rowCount(); i < cnt; i++) {
            row = grid.getRow(i);
            if (row.dataIndex() >= 0) {
                return row;
            }
        }
        return null;
    },
    $_prevDataRow: function (grid, row) {
        for (var i = row.index() - 1; i >= 0; i--) {
            row = grid.getRow(i);
            if (row.dataIndex() >= 0) {
                return row;
            }
        }
        return null;
    },
    $_getParent: function (row) {
        return row && row.parent();
    },
    calcValues: function (grid, column, row1, row2) {
        var grouped = (!row1 || row1 && row2) && column._calcBounds == ColumnCalcBounds.GROUP;
        switch (column._calcRange) {
            case ColumnCalcRange.FIRST:
                this._calcFirst(column, row1, grouped);
                break;
            case ColumnCalcRange.LAST:
                this._calcLast(column, row2, grouped);
                break;
            case ColumnCalcRange.LOWER:
                this._calcLower(column, row1, grouped);
                break;
            case ColumnCalcRange.UPPER:
                this._calcUpper(column, row2, grouped);
                break;
            case ColumnCalcRange.LOWER_BOUNDS:
                this._calcLowerBounds(column, row1, row2, grouped);
                break;
            case ColumnCalcRange.UPPER_BOUNDS:
                this._calcUpperBounds(column, row1, row2, grouped);
                break;
            default:
                this._values[row.dataIndex()] = column.$_calcValue(row1);
                break;
        }
    },
    _calcFirst: function (column, row, grouped) {
        var i, group, r, cnt, rows,
            grid = column.grid();
        if (grouped && this._isGrouped(grid)) {
            row = row || grid.getRow(0);
            if (row.dataIndex() < 0) {
                row = this.$_nextDataRow(grid, row);
            }
            while (row) {
                group = this.$_getParent(row);
                if (!group) break;
                rows = group.getDescendants(false, true);
                for (i = 0, cnt = rows.length; i < cnt; i++) {
                    this._values[rows[i].dataIndex()] = column.$_calcRange(rows, i);
                }
                row = rows[cnt - 1];
                row = this.$_nextDataRow(grid, row);
            }
        } else {
            rows = grid.getDescendantRows(false, true);
            if (rows && rows.length > 0) {
                r = row ? row.dataIndex() : -1;
                cnt = rows.length;
                i = 0;
                if (r >= 0) {
                    while (i < cnt) {
                        if (rows[i].dataIndex() == r) {
                            break;
                        }
                        i++;
                    }
                }
                for (; i < cnt; i++) {
                    this._values[rows[i].dataIndex()] = column.$_calcRange(rows, i);
                }
            }
        }
    },
    _calcLast: function (column, row, grouped) {
        var i, group, cnt, rows,
            grid = column.grid();
        if (grouped && this._isGrouped(grid)) {
            row = row || grid.getRow(grid.rowCount() - 1);
            if (row.dataIndex() < 0) {
                row = this.$_prevDataRow(grid, row);
            }
            while (row) {
                group = this.$_getParent(row);
                if (!group) break;
                rows = group.getDescendants(false, true);
                for (i = rows.length; i--;) {
                    this._values[rows[i].dataIndex()] = column.$_calcRange(rows, i);
                }
                row = rows[0];
                row = this.$_prevDataRow(grid, row);
            }
        } else {
            rows = grid.getDescendantRows(false, true);
            if (rows && rows.length > 0) {
                r = row ? row.dataIndex() : -1;
                i = rows.length - 1;
                if (r >= 0) {
                    while (i >= 0) {
                        if (rows[i].dataIndex() == r) {
                            break;
                        }
                        i--;
                    }
                }
                for (; i >= 0; i--) {
                    this._values[rows[i].dataIndex()] = column.$_calcRange(rows, i);
                }
            }
        }
    },
    _calcLower: function (column, row, grouped) {
        this._calcFirst(column, row, grouped);
    },
    _calcUpper: function (column, row, grouped) {
        this._calcLast(column, row, grouped);
    },
    _calcLowerBounds: function (column, row1, row2, grouped) {
        this._calcFirst(column, row1, grouped);
    },
    _calcUpperBounds: function (column, row1, row2, grouped) {
        this._calcFirst(column, row2, grouped);
    },
    $_setRange: function (rows) {
        this._rows = rows;
    },
    "get": function (index) {
        return this._values[this._rows[index].dataIndex()];
    },
    $_get: function (row) {
        return this._values[row.dataIndex()];
    },
    clearReqRows: function () {
        this._reqRows = null;
    },
    hasReqRow: function () {
        return this._reqRows;
    },
    firstRequest: function () {
        return this._reqRows[0];
    },
    lastRequest: function () {
        return this._reqRows[this._reqRows.length - 1];
    },
    requestAll: function () {
        this._reqRows = $$_CVT_ALL;
    },
    requestRow: function (r) {
        if (r === $$_CVT_ALL || r < 0) {
            this._reqRows = r;
        } else if (this._reqRows !== $$_CVT_ALL) {
            var row, cnt,
                grid = this._column.grid(),
                row = grid.getRowIndexOfDataIndex(r);
            if (row >= 0) {
                rows = this._reqRows = this._reqRows || [];
                cnt = rows.length;
                if (cnt > 0) {
                    if (row < rows[0]) rows.splice(0, 0, row);
                    else if (row > rows[cnt - 1]) rows.push(row);
                } else {
                    rows.push(row);
                }
            }
        }
    },
    isAllRequested: function () {
        return this._reqRows === $$_CVT_ALL;
    },
    saveValue: function (scope, row, field) {
        this.saveRow(scope, row);
    },
    restoreValue: function (scope, row, field) {
        this.restoreRow(scope, row);
    },
    saveRow: function (scope, row) {
    },
    restoreRow: function (scope, row, created) {
    },
    saveRows: function (scope, rows) {
    },
    restoreRows: function (scope, rows, created) {
    }
});
var GridView = defineClass("GridView", GridBase, {
	init : function(dom, container, readMode) {
		this._super(dom, container, readMode);
        this.registerCustomGridItemType("chart", GridChartItem);
        var rg = this.rowGroup();
        rg.registerGroupHeaderType("chart", GroupChartItem);
        rg.registerGroupFooterType("chart", GroupChartItem);
        this._groupHeaderItems = rg.headerItems();
        this._groupFooterItems = rg.footerItems();
        this.setRowSource(this._createItemSource());
		this.operateOptionsChanged();
	},
	customGroupItemChanged: function (item) {
		this._items && this._items.resetCustomGroupItems(item);
	},
    getCustomHeaderRows: function (groupRow, list) {
        this._groupHeaderItems.getRows(groupRow, list);
    },
    getCustomFooterRows: function (groupRow, list) {
        this._groupFooterItems.getRows(groupRow, list);
    },
    onPaged: DLCallback,
    onPageCountChanged: DLCallback,
    onPageIndexChanging: DLCallback,
    onPageIndexChanged: DLCallback,
    onGrouping: DLCallback,
    onGrouped: DLCallback,
    onExpanding: DLCallback,
    onExpanded: DLCallback,
    onCollapsing: DLCallback,
    onCollapsed: DLCallback,
	onRowGroupHeadCellClicked: DLCallback,
	onRowGroupHeadCellDblClicked: DLCallback,
	onRowGroupHeaderClicked: DLCallback,
	onRowGroupHeaderDblClicked: DLCallback,
	onRowGroupFooterCellClicked: DLCallback,
	onRowGroupFooterCellDblClicked: DLCallback,
    pageSize: 10,
    pageCount: 0,
    pageIndex: -1,
    pageOffset: 0,
    pageRows: null,
    rowGroupLevels: {
        get: function () {
            return this._items.groupLevels();
        },
        set: null
    },
	rowGroupFields: {
        get: function () {
            return this._items.groupByFields();
        },
        set: null
    },
    paged: {
        get: function () {
            return this._items.isPaging();
        },
        set: null
    },
	rowGrouped: {
        get: function () {
            return this._items.isGrouped();
        },
        set: null,
        value: false
	},
	mergedRowGrouped: {
        get: function () {
            return this._items.isMergedRowGrouped();
        },
        set: null,
        value: false
	},
    pageSize_: function () {
        return this._items.pageSize();
    },
    setPageSize: function (value) {
        this._items.setPageSize(value);
        return this;
    },
    pageCount_: function () {
        return this._items.pageCount();
    },
    setPageCount: function (value) {
        this._items.setPageCount(value);
		return this;
    },
    pageIndex_: function () {
        return this._items.pageIndex();
    },
    setPageIndex: function (newPage) {
        this._items.setPageIndex(newPage);
        return this;
    },
    pageOffset_: function () {
        return this._items.pageOffset();
    },
    setPageOffset: function (value) {
        this._items.setPageOffset(value);
        return this;
    },
    setPageAndOffset: function (index, offset) {
        this._items.setPageAndOffset(index, offset);
        return this;
    },
    pageRows: function () {
        return this._items.pageRows();
    },
    setPageRows: function (value) {
        this._items.setPageRows(value);
        return this;
    },
    setPageAndRows: function (page, rows) {
        this._items.setPageAndRows(page, rows);
        return this;
    },
    getDataRow: function (dataIndex) {
        return this._items.getDataRow(dataIndex);
    },
    getDataIndicesOfRows: function (rows, all) {
        if (rows) {
            var i, r,
                cnt = rows.length;
                ids = [];
            for (i = 0; i < cnt; i++) {
                r = rows[i];
                if (!(r instanceof GridRow)) {
                    r = this.getRow(r);
                }
                r = r ? r.dataIndex() : -1;
                if (r >= 0 || all) {
                    ids.push(r);
                }
            }
            return ids;
        }
    },
	getRowsOfDataIndices: function (indices, all) {
		return this.rowSource().getRowsOfDataRows(indices, all);
	},
	isGrouped: function (dataColumn/* DataColumn */) {
		return dataColumn instanceof DataColumn && dataColumn.groupLevel() > 0;
	},
	$_getVisibleRootByField: function (fld) {
		var i;
		var col;
		var cnt = this.visibleColumnCount();
		for (i = 0; i < cnt; i++) {
			col = _cast(this.getVisibleColumn(i), DataColumn);
			if (col && col.dataIndex() == fld) {
				return col;
			}
		}
		return null;
	},
	groupBy: function (fields, sorting, direction, textCase) {
        sorting = arguments.length > 1 ? sorting : true;
        direction = arguments.length > 2 ? direction : SortDirection.ASCENDING;
		textCase = textCase || SortCase.SENSITIVE;
        var cnt, flds, fldCount, i, f, fld, column,
            ds = this.dataSource();
        if (!this._items) {
            return;
        }
        if (__epochlc > _licsond) {
            return;
        }
        if (!ds) {
            return;
        }
		this.clearColumnMergeGrouped();
        cnt = (fields = _makeArray(fields)).length;
		if (cnt > 0) {
			flds = [];
            fldCount = ds.fieldCount();
			for (i = 0; i < cnt; i++) {
				f = ds.getFieldIndexEx(fields[i]);
				if (f >= 0 && f < fldCount) {
					flds.push(f);
				}
			}
			if (flds.length > 0) {
				if (this.rowGroup().isMergeMode()) {
					for (i = flds.length - 1; i >= 0; i--) {
						column = this.$_getVisibleRootByField(flds[i]);
						if (column) {
							column._setMergeGrouped(true);
						} else {
							flds.splice(i, 1);
						}
					}
				}
				if (flds.length > 0/* && this.$_canGroupBy(flds)*/) {
                    this._toastManager.show(this.operateOptions().groupingToast(), true, function () {
    					this._items.groupBy(flds, sorting, direction, textCase);
                    }.bind(this));
				}
			}
		} else /*if (this.$_canGroupBy(null))*/ {
            this._toastManager.show(this.operateOptions().groupingToast(), true, function () {
                this._items.groupBy(null, true, SortDirection.ASCENDING);
            }.bind(this));
		}
	},
	clearGroupBy: function () {
        if (this._items && this._items.isGrouped()) { // this.$_canGroupBy(null)) {
            this._items.groupBy(null, true, SortDirection.ASCENDING);
        }
	},
	addGroupBy: function (index, column, sorting, direction, textCase) {
		var options = this.operateOptions();
		sorting = sorting === undefined ? options.groupSorting() : sorting;
		direction = direction === undefined ? options.groupSortDirection() : direction;
		textCase = textCase === undefined ? options.groupSortCase() : textCase;
		if (typeof column === 'number') {
			column = this.columnByField(column);
		}
		if (!(column instanceof DataColumn)) {
			return;
		}
		if (this.isGrouped(column)) {
			return;
		}
		if (!column.isRoot() && this.rowGroup().isMergeMode()) {
			return;
		}
		if (column.dataIndex() >= 0) {
			column._setMergeGrouped(this.rowGroup().isMergeMode());
			this._toastManager.show(options.groupingToast(), true, function () {
				try {
					this._items.addGroupBy(index, column.dataIndex(), sorting, direction, textCase);
				} catch (err) {
					column._setMergeGrouped(false);
					throw err;
				}
			}.bind(this));
		}
	},
	removeGroupBy: function (column) {
        if (column instanceof GridColumn) {
            if (this.isGrouped(column)) {
                this._items.removeGroupBy(column.dataIndex());
            }
        } else if (typeof column == "number") {
            this._items.removeGroupBy(column);
        }
	},
	expand: function (group, recursive, force) {
        if (!group || group instanceof GroupRow) {
            this._items.expand(group, recursive, force);
        }
	},
	collapse: function (group, recursive, force) {
        if (!group || group instanceof GroupRow) {
            this._items.collapse(group, recursive, force);
        }
	},
    expandAll: function (level) {
		level = arguments.length > 0 ? level : 0;
        this._items.expand(null, true, true, level);
    },
    collapseAll: function () {
        this._items.collapse(null, true, true);
    },
	setPaging: function (paging, pageSize, pageCount, pageOffset) {
        if (this.isRowEditing(null)) {
            return;
        }
        var paged = this.paged();
        if (paging != paged) {
            pageSize = arguments.length > 1 ? pageSize : 10;
            pageCount = arguments.length > 2 ? pageCount : -1;
            pageOffset = arguments.length > 3 ? pageOffset : 0;
            this._items.setPaging(paging, pageSize, pageCount, pageOffset);
        }
	},
	setHidden: function (row, hidden) {
        if (row instanceof GridRow) row = row.dataIndex();
		row = Math.floor(row);
        return row >= 0 && this._items.setHiddenRow(row, hidden);
	},
	setHiddenRows: function (rows, hidden) {
        if (_isArray(rows)) {
            var i, r, list = [];
            for (i = rows.length; i--;) {
                r = rows[i];
                if (r instanceof GridRow) r = r.dataIndex();
                r = Math.floor(r);
                r >= 0 && list.push(r);
            }
            return list.length > 0 && this._items.setHiddenRows(list, hidden);
        }
		return 0;
	},
    getHiddenRows: function () {
        return this._items.getHiddenRows();
    },
	isHidden: function (dataIndex) {
        return this._items.isRowHidden(dataIndex);
	},
    hiddenRowCount: function () {
        return this._items.hiddenRowCount();
    },
    unhideAllRows: function () {
        return this._items.unhideAllRows();
    },
	setRowSource: function (value) {
		if (value != this.rowSource()) {
			this._super(value);
			this._items = value;
			if (value instanceof GridRowProvider) {
				value.setCustomRowProvider(this);
				value.setSummaryMode(this.displayOptions().summaryMode());
				value.setRowGroupSummaryMode(this.rowGroup().summaryMode());
				this._doOperateOptionsChanged();
			}
		}
		return this;
	},
	_createLayoutManager: function () {
		return new GridViewLayoutManager(this);
	},
	_createItemSource: function () {
		return new GridRowProvider(true);
	},
	_createDataTagManager: function () {
		return new GridDataTagManager(this);
	},
	_createPanelView: function () {
		return new GridPanelElement(this._dom);
	},
    _createGroupPanelView: function (dom, panel) {
        return new GroupPanelElement(dom, panel);
    },
	_doColumnsReset: function (group, column) {
		this.clearGroupBy();
		this._super(group, column);
	},
	getSummarizer: function () {
		return this._items.summarizer();
	},
	isGroupedField: function (field) {
		return this._items.isGroupedField(field);
	},
	isGroupedColumn: function (column, noCheck) {
		return column && this._items.isGroupedField(column.dataIndex()) &&
            (noCheck || column.root().displayIndex() < this._items.getGroupLevels());
	},
	getGroupLevels: function () {
		return this._items.getGroupLevels();
	},
	getGroupLevel: function (field) {
		if (typeof field == "number") {
			return this._items.getGroupLevel(field);
		} else if (field) {
			var ds = this.dataSource();
			if (ds) {
				field = ds.getFieldIndexEx(field);
				return this._items.getGroupLevel(field);
			}
		}
        return -1;
	},
	_canMerge: function () {
		return true;
	},
	_doRowGroupAdornmentsChanged: function () {
		var rg = this.rowGroup();
		this._items.setGroupedStyle(rg.expandedAdornments(), rg.collapsedAdornments(), rg.createFooterCallback());
	},
	_doRowGroupDisplayModeChanged: function () {
		this.clearColumnMergeGrouped();
		if (this.rowGroup().mergeMode()) {
			var i;
			var flds = this._items.groupByFields();
			if (flds && flds.length > 0) {
				for (i = flds.length - 1; i >= 0; i--) {                
					var column = this.$_getVisibleRootByField(flds[i]);
					if (column) {
						column._setMergeGrouped(true);
					} else {
						flds.splice(i, 1);
					}
				}
			}
			if (flds && flds.length > 0) {
				this._items.groupByMode(flds, true);
			} else {
				this._items.groupByMode(null, true);
			}
		} else {
			this._items.setMergeMode(false);
		}
	},
	_doSummaryModeChanged: function () {
		this._items.setSummaryMode(this.displayOptions().summaryMode());
	},
	_doGroupSummaryModeChanged: function () {
		this._items.setRowGroupSummaryMode(this.rowGroup().summaryMode());
	},
	_doOperateOptionsChanged: function () {
		this._items.setExpandWhenGrouping(this.operateOptions().expandWhenGrouping());
	},
	getIndicatorIndex: function (row) {
		return this._items.getDisplayItemIndex(row);
	},
	updatePastedRow: function (row, values, checkEmpty) {
		var r = row.dataIndex();
		if (r >= 0) {
			var ds = this.dataSource();
            ds && ds.updateRow(r, values, false, false, checkEmpty);
		}
	},
    updatePastedCell: function (row, field, value) {
        var r = row.dataIndex();
        if (r >= 0) {
            var ds = this.dataSource();
            ds && ds.setValue(r, field, value);
        }
    },
	appendPastedRow: function (values) {
		var ds = this.dataSource();
		if (ds) {
			ds.appendRow(values);
		}
	},
	canMoveIndex: function (index) {
		var can = this._super(index);
		if (can && this.mergedRowGrouped() && this.operateOptions().mergeGroupedColumnsFixed()) {
			can = index >= this.rowGroupLevels();
		}
		return can;
	},
	canMoveToIndex: function (index) {
		var can = this._super(index);
		if (can && this.mergedRowGrouped() && this.operateOptions().mergeGroupedColumnsFixed()) {
			can = index >= this.rowGroupLevels();
		}
		return can;
	},
	_doRevealRow: function (row) {
		return this._items.reveal(row);
	},
	_parseDataRows: function (rows) {
		if (rows) {
			var i, r, list = [];
			for (i = rows.length; i--;) {
				r = rows[i];
				if (!(r instanceof GridRow)) {
					r = this.getRow(r);
				}
				if (r instanceof DataRow) {
					list.push(r);
				}
			}
			return list;
		}
	},
    _firePaged: function (paged) {
        this.onPaged && this.onPaged(this, paged);
        this.fireEvent(GridView.PAGED, paged);
    },
    _firePageCountChanged: function (newCount, oldCount) {
        this.onPageCountChanged && this.onPageCountChanged(this, newCount, oldCount);
        this.fireEvent(GridView.PAGE_COUNT_CHANGED, newCount, oldCount);
    },
	_firePageIndexChanging: function (newPage, oldPage) {
        var ret = !this.onPageIndexChanging || this.onPageIndexChanging(this, newPage, oldPage) !== false;
		return ret && this.fireConfirmEvent(GridView.PAGE_INDEX_CHANGING, newPage, oldPage);
	},
	_firePageIndexChanged: function (newPage, oldPage) {
        this.onPageIndexChanged && this.onPageIndexChanged(this, newPage, oldPage);
		this.fireEvent(GridView.PAGE_INDEX_CHANGED, newPage, oldPage);
	},
	_fireGrouping: function (fields) {
        var ret = !this.onGrouping || this.onGrouping(this, fields) !== false;
		return ret && this.fireConfirmEvent(GridView.GROUPING, fields);
	},
	_fireGrouped: function () {
        this.onGrouped && this.onGrouped(this);
		this.fireEvent(GridView.GROUPED);
	},
	_fireExpanding: function (group) {
        var ret = !this.onExpanding || this.onExpanding(this, group) !== false;
		return ret && this.fireConfirmEvent(GridView.EXPANDING, group);
	},
	_fireExpanded: function (group) {
        this.onExpanded && this.onExpanded(this, group);
		this.fireEvent(GridView.EXPANDED, group);
	},
	_fireCollapsing: function (group) {
        var ret = !this.onCollapsing || this.onCollapsing(this, group) !== false;
		return ret && this.fireConfirmEvent(GridView.COLLAPSING, group);
	},
	_fireCollapsed: function (group) {
        this.onCollapsed && this.onCollapsed(this, group);
		return this.fireEvent(GridView.COLLAPSED, group);
	},
    onRowProviderPaged: function (provider, paged) {
        this._firePaged(paged);
    },
    /*
    onRowProviderPageSizeChanged: function (provider, oldSize, newSize) {
        this._firePageSizeChanged(oldSize, newSize);
    },
    */
    onRowProviderPageCountChanged: function (provider, oldCount, newCount) {
        this._firePageCountChanged(newCount, oldCount);
    },
    onRowProviderPageIndexChanging: function (provider, oldPage, newPage) {
        return this._firePageIndexChanging(newPage, oldPage);
    },
    onRowProviderPageIndexChanged: function (provider, oldPage, newPage) {
        return this._firePageIndexChanged(newPage, oldPage);
    },
	onGroupedRowProviderGrouping: function (provider, fields) {
		return this._fireGrouping(fields);
	},
	$_clearGroupedIndex: function (group) {
		for (var i = group.count() - 1; i >= 0; i--) {
			var column = group.getItem(i);
			var dcolumn = _cast(column, DataColumn);
			if (dcolumn) {
				dcolumn.setGroupLevel(-1);
			}
			if (column instanceof ColumnGroup) {
				this.$_clearGroupedIndex(column);
			}
		}
	},
	$_setGroupedIndex: function (group) {
		for (var i = group.count() - 1; i >= 0; i--) {
			var column = group.getItem(i);
			var dcolumn = _cast(column, DataColumn);
			if (dcolumn) {
				dcolumn.setGroupLevel(this._items.getGroupLevel(dcolumn.dataIndex()));
			}
			if (column instanceof ColumnGroup) {
				this.$_setGroupedIndex(column);
			}
		}
	},
	onGroupedRowProviderGrouped: function (provider) {
		this.selections().clear();
		this.$_clearGroupedIndex(this._rootGroup());
		var cols, cnt, i, dcolumn, merges,
			fields = this._items.groupByFields();
		if (fields && fields.length > 0) {
			this.$_setGroupedIndex(this._rootGroup());
		}
		if (this.rowGroup().mergeMode()) { // TODO: group item provider의 mergeMode만을 기준으로 해야 한다.
			cols = [];
            cnt = this.visibleColumnCount();
			for (i = 0; i < cnt; i++) {
				dcolumn = _cast(this.getVisibleColumn(i), DataColumn);
				if (dcolumn) {
					if (dcolumn.mergeGrouped() && dcolumn.groupLevel() <= 0) {
						merges = _cast(dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS), ColumnMergeManager);
						if (merges) {
							merges.clear();
						}
						dcolumn._setMergeGrouped(false);
					} else if (dcolumn.mergeGrouped()) {
						merges = _cast(dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS), ColumnMergeManager);
						if (!merges) {
							merges = new ColumnMergeManager(dcolumn);
							dcolumn.setState(ColumnMergeManager.MERGE_ROOMS, merges);
						}
						cols.push(dcolumn);
					}
				}
			}
			cnt = cols.length;
			if (cnt > 0) {
				cols = cols.sort(function (col1, col2) {
					return col1.groupLevel() - col2.groupLevel();
				});
				for (i = 0; i < cnt; i++) {
					cols[i].setDisplayIndex(i);
					merges = cols[i].stateFor(ColumnMergeManager.MERGE_ROOMS);
					merges.clear();
					merges.initialize(RowGroupMergeRule.INIT_COUNT);
				}
			}
            cnt = this.visibleColumnCount();
            for (i = 0; i < cnt; i++) {
                dcolumn = _cast(this.getVisibleColumn(i), DataColumn);
                if (dcolumn && !dcolumn.mergeGrouped()) {
                    merges = dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS);
                    if (merges) {
                        merges.clear();
                        merges.initialize(RowGroupMergeRule.INIT_COUNT);
                    }
                }
            }
		}
		return this._fireGrouped();
	},
	onGroupedRowProviderExpand: function (provider, group) {
		return this._fireExpanding(group);
	},
	onGroupedRowProviderExpanded: function (provider, group) {
		return this._fireExpanded(group);
	},
	onGroupedRowProviderCollapse: function (provider, group) {
		return this._fireCollapsing(group);
	},
	onGroupedRowProviderCollapsed: function (provider, group) {
		return this._fireCollapsed(group);
	},
	$$_uncheckAll: function () {
		this.checkAll(false);
	},
	onGridRowProviderSaveRow: function (rs, scope, row, rowId) {
		row.$_saveChecked(scope, this, rowId, this.checkBar().exclusive());
	},
	onGridRowProviderSaveRows: function (rs, scope, rows) {
		var i, r, ex = this.checkBar().exclusive();
        if (rows) {
            for (i = rows.length; i--;) {
                rows[i].$_saveChecked(scope, this, rows[i].dataIndex(), ex);
            }
        } else {
            for (i = this.rowCount(); i--;) {
                r = this.getRow(i);
                (r instanceof DataRow) && r.$_saveChecked(scope, this, r.dataIndex(), ex);
            }
        }
	},
	onGridRowProviderRestoreRow: function (rs, scope, row, rowId) {
		row.$_restoreChecked(scope, this, rowId, this.$$_uncheckAll);
	},
	onGridRowProviderRestoreRows: function (rs, scope, rows) {
        var i;
        if (rows) {
            for (i = rows.length; i--;) {
                rows[i].$_restoreChecked(scope, this, rows[i].dataIndex(), this.$$_uncheckAll);
            }
        } else {
            for (i = this.rowCount(); i--;) {
                r = this.getRow(i);
                (r instanceof DataRow) && r.$_restoreChecked(scope, this, r.dataIndex(), this.$$_uncheckAll);
            }
        }
	}
}, null, function (f) {
	f.PAGED = "onGridViewPaged";
	f.PAGE_COUNT_CHANGED = "onGridViewPageCountChanged";
	f.PAGE_INDEX_CHANGING = "onGridViewPageIndexChanging";
	f.PAGE_INDEX_CHANGED = "onGridViewPageIndexChanged";
	f.GROUPING = "onGridViewGrouping";
	f.GROUPED = "onGridViewGrouped";
	f.EXPANDING = "onGridViewExpanding";
	f.EXPANDED = "onGridViewExpanded";
	f.COLLAPSING = "onGridViewCollapsing";
	f.COLLAPSED = "onGridViewCollapsed";
});
var GridViewLayoutManager = defineClass("GridViewLayoutManager", GridLayoutManager, {
	init: function(grid) {
		this._super(grid);
	},
    _getRowGroup: function () {
        return this._grid.rowGroup();
    },
	rowGrouped: function () {
        return this._grid.rowGrouped() && this._grid.rowGroup().displayMode() != RowGroupDisplayMode.MERGED;
	},
	rowGroupLevels: function () {
		return this._grid.rowGroupLevels();
	}
});
var GridViewSelectionTool = defineClass("GridViewSelectionTool", GridSelectionTool, {
	init : function(owner) {
		this._super(owner);
	},
    _doKeyDown: function (key, ctrl, shift, alt) {
        var row,
			grid = this.grid(),
        	lm = grid.layoutManager(),
        	options = grid.editOptions(),
        	focused = this.focused(),
        	index = focused.clone(),
        	fixed = index.isFixed(grid),
        	mergeView = fixed ? grid._fixedMergeView : grid._mergeView,
        	cellView = mergeView.getCellView(focused);
        if (cellView instanceof MergedDataCellElement) {
            if (key == Keys.LEFT || key == Keys.RIGHT) {
                row = cellView.groupRow();
                if (row && ctrl) {
                    if (key == Keys.LEFT) {
                        if (row.expanded()) {
                            grid.collapse(row, false, false);
                        } else {
                            index.left();
                        }
                    } else if (key == Keys.RIGHT) {
                        if (row.collapsed()) {
                            grid.expand(row, false, false);
                        } else {
                            index.right();
                        }
                    }
                    index.setRow(row);
                    grid.setFocusedIndex(index, true);
                    grid.makeCellVisible(index);
                    return true;
                } else {
                    if (key == Keys.LEFT) {
                        index.left();
                    } else if (key == Keys.RIGHT) {
                        index.right();
                    }
                    if (shift && grid.selections().count() > 0) {
                        this.setFocused(index, false);
                        grid.selections().getItem(0).resizeTo(index);
                        this._keySelecting = true;
                    } else {
                        this.setFocused(index, true);
                    }
                    return true;
                }
            }
        }
        return this._super(key, ctrl, shift, alt);
    },
	_getEditRequest: function (source, x, y, ctrlKey, shiftKey) {
		var index, dcol,
			grid = this.grid(),
			request = this._super(source, x, y, ctrlKey, shiftKey);
		if (request) {
			return request;
		}
		if (source instanceof HeaderCellElement) {
            index = source.index();
			dcol = index.dataColumn();
			if (dcol && dcol.groupable() && grid.operateOptions().groupingEnabled() && grid.groupPanel().visible()) {
				return new RowGroupingRequest(source);
			}
		}
		return null;
	},
	_getDragTracker: function (request, x, y, ctrlKey, shiftKey, metaKey) {
		/*if (request instanceof PanelCellRequest) {
			return new PanelCellTracker(this.grid(), request);
		} else*/ if (request instanceof RowGroupingRequest) {
			return new RowGroupingTracker(this.grid(), request);
		}
		return this._super(request, x, y, ctrlKey, shiftKey, metaKey);
	},
    _doClick: function (x, y) {
        var elt = this.findElementAt(x, y, true);
        if (elt instanceof GroupPanelFieldCloseElement) {
            this._grid.removeGroupBy(elt.field());
        }
        this._super(x, y);
    },
	_doColumnHeaderClicked: function (column, rightClicked) {
		this._super(column);
        if (!rightClicked) {
			this.grid().$_sortColumnByUser(column);
        }
	},
	_doHandleClicked: function (handle) {
        var leftPos, group, row,
		    grid = this.grid();
		if (handle instanceof ColumnSortHandle) {
			leftPos = grid.leftPos();
			grid.$_sortColumnByUser(handle.cellView().index().dataColumn());
			grid.setLeftPos(leftPos);
		} else if (handle instanceof RowGroupExpandHandle) {
			group = _cast(handle.cellView().item(), GroupRowImpl);
			if (group) {
				if (group.expanded()) {
					grid.collapse(group);
				} else {
					grid.expand(group, false, false)
				}
			}
		} else if (handle instanceof DataCellExpandHandle) {
			group = handle.group();
			if (group) {
				if (group.expanded()) {
					grid.collapse(group);
				} else {
					grid.expand(group, false, false)
				}
				if (!group.expanded()) {
					row = group.index() >= 0 ? group : null;//group.firstLeaf();
					if ((!row || row.index() < 0) && group.footer()) {
						row = group.footer();
					}
					if (row) {
						grid.makeRowVisible(row.index());
					}
				}
			}
		} else {
			this._super(handle);
		}
	}
});
var GridPanelElement = defineClass("GridPanelElement", PanelElement, {
    init: function(dom) {
        this._super(dom);
        this.setElementContext(true);
    },
    /*
     state: 0,
     groupingIndex: -1,
     setState: function (value) {
     if (value != this._state) {
     this._state = value;
     switch (value) {
     case GridPanelElement.NORMAL:
     this._groupingIndex = -1;
     break;
     case GridPanelElement.GROUPING:
     this._groupingIndex = this._groupByView.childCount();
     break;
     case GridPanelElement.UNGROUPING:
     this._groupingIndex = 0;
     break;
     }
     this.layoutContent(null);
     this.invalidate();
     }
     },
     setGroupingIndex: function (value) {
     if (value != this._groupingIndex) {
     this._groupingIndex = value;
     this.layoutContent(null);
     this.invalidate();
     }
     },
     */
    _doMeasure: function (grid, hintWidth, hintHeight) {
        /*
         var sz;
         var sz2;
         var options = grid.operateOptions();
         this._messageView.setText(options.groupingPrompt());
         this._messageView.updateStyles(this.model().styles());
         this._groupByView.setLinear(false);
         sz = this._groupByView.measure(hintWidth, hintHeight).clone();
         if (this._groupByView.fieldCount() < 1) {
         sz = this._messageView.measure(hintWidth, hintHeight).clone();
         }
         sz2 = this._super(grid, hintWidth, hintHeight);
         sz.width = Math.max(sz.width, sz2.width);
         sz.height = Math.max(sz.height, sz2.height, 30);
         return sz;
         */
        return { width: hintWidth, height: hintHeight };
    },
    _doLayoutContent: function (lm) {
        /*
         var w = this.width();
         var h = this.height();
         this._messageView.setVisible((this._state == GridPanelElement.NORMAL) && !this.grid().rowGrouped());
         if (this._messageView.visible()) {
         var sz = this._messageView.measure(w, h);
         this._messageView.setBounds(4, 0, sz.width + 10, h);
         }
         this._groupByView.setVisible(true);
         if (this._groupByView.visible()) {
         this._groupByView.setBounds(0, 0, w, h);
         this._groupByView.layoutContent(lm);
         }
         */
    }
});
var GroupPanelElement = defineClass("GroupPanelElement", VisualObjectElement, {
    init : function(dom, panel) {
        this._super(dom, "groupPanelView", panel);
        this._headView = new GroupPanelHeadElement(dom, panel);
        this._fields = null;
        this._fieldViews = [];
		this.setElementContext(true);
    },
    fieldCount: function () {
        return this._fields ? this._fields.length : 0;
    },
    getFieldView: function (field) {
        for (var i = 0; i < this._fieldViews.length; i++) {
            if (this._fieldViews[i].fieldIndex() == field) {
                return this._fieldViews[i];
            }
        }
        return null;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
		var hMin,
			m = this.model(),
			h = m.height();
        this._fields = this.container().gridView().rowGroupFields();
        this.$_prepareColumnViews(this._fields);
		hMin = m.minHeight();
		if (!isNaN(h) && h > 0) {
			if (!isNaN(hMin) && hMin > 0) {
				h = Math.min(h, hMin);
			}
		} else if (!isNaN(hMin) && hMin > 0) {
			h = hMin;
		}
		h = isNaN(h) && h > 0 ? hintHeight : Math.max(0, h);
        return Size.create(hintWidth, h);
    },
    _doLayoutContent: function (lm) {
        this.$_layoutColumnViews(this._fields);
    },
    _doRender : function(g, r) {
        var panel = this.model();
        var styles = panel.styles();
        var fill = styles.background();
        if (!fill || !fill.opqaue) {
            g.drawRectI(SolidBrush.WHITE, null, r);
        }
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        GridElement.drawStyledBorders(g, r, styles);
    },
    _doRenderHtml: function (r) {
        var panel = this.model();
        var styles = panel.styles();
        var fill = styles.background();
        this._dom.style.background = fill ? fill.css() : "#fff";
		GridElement.drawStyledHtmlBorders(this._dom.style, styles);
    },
    $_prepareColumnViews: function (fields) {
		var cnt, view,
        	panel = this.model();
        if (fields && (cnt = fields.length) > 0) {
            while (this._fieldViews.length < cnt) {
                view = new GroupPanelFieldElement(this._dom, panel);
                this.addElement(view);
                this._fieldViews.push(view);
            }
        }
    },
    $_layoutColumnViews: function (fields) {
		var ds, x, fill, i, column, s, sz,
			grid = this.grid(),
			lm = grid.lm(),
			styles = this.model().styles(),
			w = this.width(),
			h = this.height() - 1,
			view = this._headView,
			sz = view.measure(this, w, h);
        this.hideAll();
        this.addElement(view);
        view.setBounds(0, 0,  sz.width, h);// - styles.borderBottomWidth());
        view.layoutContent(lm);
        view.setVisible(true);
		if (fields) {
			ds = grid.dataSource();
            if (ds) {
                x = sz.width;
                fill = styles.background();
                for (i = 0; i < fields.length; i++) {
                    column = grid.columnByField(fields[i]);
                    s = (column && column.header().text()) || ds.getField(fields[i]).displayText();
                    view = this._fieldViews[i];
                    view.setFieldIndex(fields[i]);
                    view.setText(s);
                    view.setOwnerBackground(i == fields.length - 1 ? fill : null);
                    sz = view.measure(grid);
                    view.setBounds(x, 0, sz.width, h);
                    view.layoutContent(lm);
                    view.setVisible(true);
                    x += sz.width;
                }
            }
		}
    }
}, {
    NORMAL: 0,
    GROUPING: 1,
    UNGROUPING: 2
});
var GroupPanelMenuElement = defineClass("GroupPanelMenuElement", GridElement, {
    init: function (dom) {
        this._super(dom, 'panelMenuView');
    },
    background: null,
    color: null,
    hoveredColor: null,
    expanded: false,
    setColor: function (value) {
        if (value != this._color) {
            this._color = value;
            this._stroke = value ? new SolidPen(value.color(), 2) : null;
        }
    },
    setHoveredColor: function (value) {
        if (value != this._hoveredColor) {
            this._hoveredColor = value;
            this._hoveredStroke = value ? new SolidPen(value.color(), 2) : null;
        }
    },
    _doMeasure: function (grid/*, hintWidth, hintHeight*/) {
		/*
        this._grid = grid;
        this._dirty = this._dirty || grid._imageLoaded;
        var img = grid.getAssetImage('group_bottom');
        if (img && img.width) {
            return { width: img.width, height: img.height };
        } else {
            return {width: 11, height: 11};
        }
		*/
		return {width: 11, height: 11};
    },
    _doRender: function(g, r) {
        var fill = this._background;
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        /*
        var grid = this.grid();
        var imgEN = grid.getAssetImage('group_right');
        var imgEH = grid.getAssetImage('group_right_hover');
        var imgCN = grid.getAssetImage('group_bottom');
        var imgCH = grid.getAssetImage('group_bottom_hover');
        var img = this._expanded ? (this._hovered ? imgEH : imgEN) : (this._hovered ? imgCH : imgCN);
        var w, h;
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            g.drawImageI(img, (r.width - w) / 2, (r.height - h) / 2, w, h);
        } else {
        }
        */
        var pen = this._hovered ? this._hoveredStroke : this._stroke;
        if (pen) {
            var y = r.y + (r.height - 10) / 2;
            var dy = 3 / 2;
            var w = Math.min(9, r.width);
            var x = r.x + (r.width - w) / 2;
            y += 1;
            g.drawHLine(pen, y, x, x + w);
            y += 3.5;
            g.drawHLine(pen, y, x, x + w);
            y += 3.5;
            g.drawHLine(pen, y, x, x + w);
        }
    },
    _doRenderHtml: function (r) {
        this._doRender(this.$_getGraphics(true), r);
    },
    _hoveredChanged: function () {
        this.invalidate();
    },
    propertyChanged: function () {
        this.invalidate();
    }
});
var GroupPanelHeadElement = defineClass("GroupPanelHeadElement", GridElement, {
    init : function(dom, panel) {
        this._super(dom, "panelHeadView");
        this._panel = panel;
        if (this._dom) {
            this.addElement(this._backView = new GraphicElement());
        }
        this.addElement(this._menuView = new CellMenuElement(dom, this));
        this._borderRect = new Rectangle();
        this._menuSize = null;
		this._menuPadding = 5;
        this._expanded = true;
    },
    background: SolidBrush.WHITE,
    borderTop: null,
    borderLeft: null,
    borderBottom: null,
    borderRight: SolidBrush.GRAY,
	paddingLeft: 0,
    innerBorderTop: SolidBrush.WHITE,
    innerBorderLeft: null,
    innerBorderBottom: null,
    innerBorderRight: SolidBrush.WHITE,
	color: SolidBrush.DIMGRAY,
    shapeColor: SolidBrush.DKGRAY,
    shapeHoveredColor: SolidBrush.DIMGRAY,
    _doMeasure: function (panelView, hintWidth, hintHeight) {
        this._expanded = panelView.fieldCount() <= 0;
		this._menuView.setVisible(this._panel.head().showMenu());
        this._menuSize = this._menuView.visible() ? this._menuView.measure(panelView.grid()) : null;
        if (this._expanded) {
            return Size.create(hintWidth, hintHeight);
        } else if (this._menuSize) {
            return Size.create(this._menuSize.width + this._menuPadding * 2, hintHeight);
        } else {
			return Size.create(0, hintHeight);
		}
    },
    _doLayoutContent: function (lm) {
        var sz = this._menuSize;
        var p = this._panel;
        var h = p.head();
        var mv = this._menuView;
        var styles = h.styles();
        var instyles = h.innerStyles();
        this.setBackground(styles.background());
        this.setBorderTop(styles.borderTop());
        this.setBorderLeft(styles.borderLeft());
        this.setBorderBottom(styles.borderBottom());
        this.setBorderRight(styles.borderRight());
		this.setPaddingLeft(styles.paddingLeft());
        this.setInnerBorderTop(instyles.borderTop());
        this.setInnerBorderLeft(instyles.borderLeft());
        this.setInnerBorderBottom(instyles.borderBottom());
        this.setInnerBorderRight(instyles.borderRight());
        this.setColor(styles.color());
        this.setShapeColor(styles.shapeColor());
        this.setShapeHoveredColor(styles.shapeHoveredColor());
		if (mv.visible()) {
			mv.setBoundsI(this._menuPadding, (this.height() - sz.height + 1) / 2, sz.width, sz.height);
			mv.setBackground(this._background);
			mv.setColor(this._shapeColor);
			mv.setHoveredColor(this._shapeHoveredColor);
		}
    },
    _doRender : function(g, r) {
		var fill, s, span, r2, b, w;
        fill = this._background;
        if (fill) {
            g.drawRectI(fill, null, r);
        }
		s = this._panel.prompt();
		if (this._expanded && s && this._color) {
			w = this._menuSize ? this._menuSize.width + this._menuPadding * 2 : this._paddingLeft;
            if (this._dom) {
                span = this.$_prepareSpan();
                Dom.renderTextBounds(span, null, this._color, s, w, this._borderTop, r.width - w, r.height - this._borderTop - this._borderBottom - 1);
            } else {
                g.drawTextBounds(null, this._color, s, w, this._borderTop, r.width - w, r.height - this._borderTop - this._borderBottom - 1);
            }
		}
		if (!this._expanded) {
            r2 = this._borderRect.copy(r);
            if ((b = this._borderLeft) && (w = b.width()) > 0) {
				r2.leftBy(w);
                w = _floor(w / 2);
                g.drawVLineI(b, r.x + w, r.y, r.bottom());
            }
			if ((b = this._borderRight) && (w = b.width()) > 0) {
				r2.rightBy(-w);
				w = _floor((w + 1) / 2);
				g.drawVLineI(b, r.right() - w, r.y, r.bottom());
			}
			if ((b = this._borderTop) && (w = b.width()) > 0) {
				r2.topBy(w);
				w = _floor(w / 2);
				g.drawHLineI(b, r.y + w, r.x, r.right());
			}
			if ((b = this._borderBottom) && (w = b.width()) > 0) {
				r2.bottomBy(-w);
				w = _floor((w + 1) / 2);
				g.drawHLineI(b, r.bottom() - w, r.x, r.right());
			}
			if ((b = this._innerBorderLeft) && (w = b.width()) > 0) {
				w = _floor(w / 2);
				g.drawVLineI(b, r2.x + w, r2.y, r2.bottom());
			}
			if ((b = this._innerBorderRight) && (w = b.width()) > 0) {
				w = _floor((w + 1) / 2);
				g.drawVLineI(b, r2.right() - w, r2.y, r2.bottom());
			}
			if ((b = this._innerBorderTop) && (w = b.width()) > 0) {
				w = _floor(w / 2);
				g.drawHLineI(b, r2.y + w, r2.x, r2.right());
			}
			if ((b = this._innerBorderBottom) && (w = b.width()) > 0) {
				w = _floor((w + 1) / 2);
				g.drawHLineI(b, r2.bottom() - w, r2.x, r2.right());
			}
			/*
			var stroke = this._borderRight;
			var styles = this._panel.head().styles();
			if (stroke) {
				g.drawLineI(stroke, r.width - 1, 0, r.width - 1, r.height);
				g.drawLineI(SolidPen.WHITE, r.width - 2, 0, r.width - 2, r.height);
				g.drawLineI(SolidPen.WHITE, 0, 0, r.width - 1, 0);
			}
			*/
		}
    },
    _doRenderHtml: function (r) {
        this._doRender(this._backView.$_getGraphics(true, r), r);
    },
    propertyChanged: function () {
        this.invalidate();
    }
});
var GroupPanelFieldCloseElement = defineClass("GroupPanelFieldCloseElement", GridElement, {
    init: function (dom) {
        this._super(dom, 'groupPanelCloseView');
        this._grid = null;
    },
    field: -1,
    _doMeasure: function (grid/*, hintWidth, hintHeight*/) {
        this._grid = grid;
        this._dirty = this._dirty || grid._imageLoaded;
        return { width: 13, height: 13 };
    },
    _doDraw: function(g) {
        var r = this.getClientRect(this._drawRect);
        var imgNormal = this._grid.getAssetImage('group_close');
        var imgHover = this._grid.getAssetImage('group_close_hover');
        var img = this._hovered ? imgHover : imgNormal;
        var w, h;
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            g.drawImageI(img, (r.width - w) / 2, (r.height - h) / 2, w, h);
        } else {
        }
    },
    _doDrawHtml: function () {
        this._doDraw(this.$_getGraphics(true))
    },
    propertyChanged: function () {
        this.invalidate();
    }
});
var GroupPanelFieldElement = defineClass("GroupPanelFieldElement", GridElement, {
    init : function(dom, panel) {
        this._super(dom, "panelHeadView", panel);
        this._panel = panel;
        this.addElement(this._closeView = new GroupPanelFieldCloseElement(dom));
		this._borderRect = new Rectangle();
        this._closeSize = null;
    },
	fieldIndex: -1,
	text: null,
	ownerBackground: null,
    background: SolidBrush.WHITE,
	borderTop: null,
	borderLeft: null,
	borderBottom: null,
    borderRight: SolidBrush.GRAY,
	innerBorderTop: null,
	innerBorderLeft: null,
	innerBorderBottom: null,
	innerBorderRight: SolidBrush.WHITE,
	paddingLeft: 0,
	paddingRight: 0,
    color: SolidBrush.GRAY,
	font: null,
    _doMeasure: function (grid, hintWidth, hintHeight) {
		var styles = this._panel.itemStyles();
		var instyles =this._panel.itemInnerStyles();
		this.setBackground(styles.background());
		this.setBorderTop(styles.borderTop());
		this.setBorderLeft(styles.borderLeft());
		this.setBorderBottom(styles.borderBottom());
		this.setBorderRight(styles.borderRight());
		this.setInnerBorderTop(instyles.borderTop());
		this.setInnerBorderLeft(instyles.borderLeft());
		this.setInnerBorderBottom(instyles.borderBottom());
		this.setInnerBorderRight(instyles.borderRight());
		this.setPaddingLeft(styles.paddingLeft());
		this.setPaddingRight(styles.paddingRight());
		this.setFont(styles.font());
        this.setColor(styles.color());
		var w = this._paddingLeft + this._paddingRight;
		w += grid.measureText(this._font, this._text) +  20;
        this._closeSize = this._closeView.measure(grid);
        this._closeView.setField(this._fieldIndex);
        return Size.create(w + this._closeSize.width, hintHeight);
    },
    _doLayoutContent: function (lm) {
        this._closeView.setBounds(this.width() - 14 - this._closeSize.width, 3, this._closeSize.width, this._closeSize.height);
    },
    $_renderCell: function (g, r) {
		var fill = this._background;
		if (fill) {
			g.drawPolygonArray(fill, null, [r.x, r.y, r.right() - 14 - 1, r.y, r.right() - 1, r.bottom(), r.x, r.bottom()]);
		}
		var borderTop = this._borderTop;
		var topWidth = borderTop ? borderTop.width() : 0;
		var borderBottom = this._borderBottom;
		var bottomWidth = borderBottom ? borderBottom.width() : 0;
		var innerTop = this._innerBorderTop;
		var innerTopWidth = innerTop ? innerTop.width() : 0;
		var innerBottom = this._innerBorderBottom;
		var innerBottomWidth = innerBottom ? innerBottom.width() : 0;
        var s = this._text;
        var fill = this._color;
        if (s && fill) {
            var font = this._font;
            var x = r.x + this._paddingLeft;
            var y = r.y + topWidth + innerTopWidth - 1;
            var w = r.width - this._paddingLeft - this._paddingRight - 15;
            var h = r.height - (topWidth + innerTopWidth + bottomWidth + innerBottomWidth);
            if (this._dom) {
                var span = this.$_prepareSpan();
                Dom.renderTextBounds(span, font, fill, s, x, y, w, h);
            } else {
                g.drawTextBounds(font, fill, s, x, y, w, h);
            }
        }
		var r2 = this._borderRect.copy(r);
		var b, w;
		if ((b = this._borderLeft) && (w = b.width()) > 0) {
			r2.leftBy(w);
			w = _floor(w / 2);
			g.drawVLineI(b, r.x + w, r.y, r.bottom());
		}
		if ((b = this._borderRight) && (w = b.width()) > 0) {
			r2.rightBy(-w);
			w = _floor((w + 1) / 2);
			g.drawLine(b, r.right() - w - 14, r.y, r.right(), r.bottom());
		}
		if ((w = topWidth) > 0) {
			r2.topBy(w);
			w = _floor(w / 2);
			g.drawHLineI(borderTop, r.y + w, r.x, r.right());
		}
		if ((w = bottomWidth) > 0) {
			r2.bottomBy(-w);
			w = _floor((w + 1) / 2);
			g.drawHLineI(borderBottom, r.bottom() - w, r.x, r.right());
		}
		if ((b = this._innerBorderLeft) && (w = b.width()) > 0) {
			w = _floor(w / 2);
			g.drawVLineI(b, r2.x + w, r2.y, r2.bottom());
		}
		if ((b = this._innerBorderRight) && (w = b.width()) > 0) {
			w = _floor((w + 1) / 2);
			g.drawLine(b, r2.right() - w - 14, r2.y, r2.right(), r2.bottom());
		}
		if ((w = innerTopWidth) > 0) {
			w = _floor(w / 2);
			g.drawHLineI(innerTop, r2.y + w, r2.x, r2.right());
		}
		if ((w = innerBottomWidth) > 0) {
			w = _floor((w + 1) / 2);
			g.drawHLineI(innerBottom, r2.bottom() - w, r2.x, r2.right());
		}
		/*
        var stroke = this._borderRight;
        if (stroke) {
            g.drawLine(stroke, r.right() - 14, r.y, r.width, r.height);
            g.drawLine(SolidPen.WHITE, r.right() - 15, 0, r.width - 1, r.height);
        }
        */
    },
    _doRender : function(g, r) {
        var fill = this._ownerBackground || this._background;
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        this.$_renderCell(g, r);
    },
    _doRenderHtml: function (r) {
        var fill = this._ownerBackground || this._background;
        _norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
        this.$_renderCell(this.$_getGraphics(true, r, this._closeView._dom), r);
    },
    _hoveredChanged: function () {
        this.invalidate(false, true);
    },
    propertyChanged: function () {
        this.invalidate(false, true);
    }
});
var ColumnView = defineClass("ColumnView", HeaderCellElement, {
    init: function(dom, grid) {
        this._super(dom, "columnView");
        this._grid = grid;
        this._stroke = new SolidPen(0x88000000, 3);
        this.setShowHandles(false);
    },
    acceptable: true,
    setAcceptable: function (value) {
        if (value != this._acceptable) {
            this._acceptable = value;
            this.invalidate();
        }
    },
    grid: function () {
        return this._grid;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var w = this.container().measureText(this.font(), this.text()) + this.paddingHorz() + this.borderWidth() * 2;
        return new Size(w, hintHeight);
    },
    _doRender: function (g, r) {
		var fill = null,
			border = this.border(),
        	borderWidth = border ? border.width() : 0;
        if (this._acceptable) {
            fill = this.background();
        } else {
            fill = SolidBrush.LTGRAY;
        }
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        if (borderWidth > 0) {
            r.inflate(borderWidth, borderWidth);
        }
        fill = null;
        if (this._acceptable) {
            fill = this.color();
        } else {
            fill = SolidBrush.WHITE;
        }
        if (fill) {
            g.drawTextRect(this.font(), fill, this.text(), r, TextAlign.CENTER);
        }
        if (!this._acceptable) {
            border = SolidPen.GRAY;
        }
        if (border) {
            r.inflate(-borderWidth, -borderWidth);
            g.drawBoundsI(null, border, r.x, r.y, r.right() - 1, r.bottom() - 1);
        }
    }
});
var RowGroupingRequest = defineClass("RowGroupingRequest", CellRequest, {
    init: function (cell) {
        this._super(cell);
    },
    groupIndex: -1,
    column: function () {
        return _cast(this.cell().index().column, DataColumn);
    },
    cursor: function () {
        return null;
    }
});
var RowGroupingTracker = defineClass("RowGroupingTracker2", GridDragTracker, {
    init: function (grid, request) {
        this._super(grid, "rowGroupingTracker");
        this._request = request;
        this._columnView = null;
        this._border = new SolidPen(0xffcccccc, 1);
        this._border2 = new SolidPen(0xff555555, 1);
        this.setNeedRedraw(true);
        this.setCancelable(true);
    },
    request: function () {
        return this._request;
    },
    _doStart: function (x, y) {
        return true;
    },
    _canAccept: function (x, y) {
        var lm = this.grid().lm();
        return y - 2 < lm.headerBounds().y && y > lm.groupPanelBounds().y;
    },
    _doCompleted: function () {
        var grid = this.grid();
        if (!grid.isGrouped(this._request.column())) {
            grid.addGroupBy(10000, this._request.column());
        }
    },
    _doEnded: function () {
    },
    _showFeedback: function (x, y) {
        var grid = this.grid(),
            col = this._request.column(),
            can = !grid.isGrouped(col),
            cv = this._columnView,
            index = CellIndex.temp(-1, col);
        if (!cv) {
            cv = this._columnView = new ColumnView(grid._dom, grid);
        }
        cv.setAcceptable(can);
        cv.updateCell(grid.header().getCell(index));
        cv._border = can ? this._border : null;
        cv.setBounds(0, 0, 110, 22);
        cv.invalidate();
        grid.addFeedbackElement(this._columnView);
        cv.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
    },
    _moveFeedback: function (x, y) {
        var grid = this.grid(),
            lm = grid.lm(),
            cv = this._columnView;
            if (cv.acceptable()) {
                cv.setBorder(this._canAccept(x, y) ? this._border2 : this._border);
            }
            cv.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
    },
    _hideFeedback: function () {
        this.grid().removeFeedbackElement(this._columnView);
    }
});
var GridDataTagManager = defineClass("GridDataTagManager", DataTagManager, {
    init: function (grid) {
        this._super(grid);
    },
    _createSeriesTag: function (column) {
        return new GridSeriesValueTag(column);
    },
    _createCalculatedTag: function (column) {
        return new GridCalcluatedValueTag(column);
    },
    connect: function (dataSet) {
		this._dataSource = dataSet;
		this._lm = this._grid.layoutManager();
		this._anis = this._grid._animations;
        this._visitTags(function (tag) {
           tag.connect(dataSet);
        });
    },
    disconnect: function () {
        this._dataSource = undefined;
        this._visitTags(function (tag) {
            tag.disconnect();
        });
    },
    clearRows: function () {
        this._visitTags(function (tag) {
            tag.clearRows();
        });
        this._anis.clear();
    },
    setRows: function () {
        this._visitTags(function (tag) {
            tag.setRows();
        });
        this._grid.requestLoadAnimation(true);
    },
    setRowCount: function (newCount) {
        this._visitTags(function (tag) {
            tag.setRowCount(newCount);
        });
    },
    insertRow: function (row) {
        this._visitTags(function (tag) {
            tag.insertRow(row);
        });
    },
    insertRows: function (row, count) {
        this._visitTags(function (tag) {
            tag.insertRows(row, count);
        });
    },
    removeRow: function (row) {
        this._visitTags(function (tag) {
            tag.removeRow(row);
        });
    },
    removeRows: function (rows) {
        this._visitTags(function (tag) {
            tag.removeRows(rows);
        });
    },
    updateRow: function (row) {
        this._visitTags(function (tag) {
            tag.updateRow(row);
        });
		this._anis.requestUpdate(this._lm, this._dataSource.getRowId(row), -1);
    },
    updateRows: function (rows) {
        this._visitTags(function (tag) {
            tag.updateRows(rows);
        });
    },
    setValue: function (row, field) {
        this._visitTags(function (tag) {
            tag.setValue(row, field);
        });
		this._anis.requestUpdate(this._lm, this._dataSource.getRowId(row), field);
    },
    moveRow: function (row, newRow) {
        this._visitTags(function (tag) {
            tag.moveRow(row, newRow);
        });
    },
    moveRows: function (row, count, newRow) {
        this._visitTags(function (tag) {
            tag.moveRows(row, count, newRow);
        });
    }
});
var GridSeriesValueTag = defineClass("GridSeriesValueTag", SeriesValueTag, {
    init: function (column) {
        this._super(column);
        this._rows = [];
    },
    clearValues: function () {
        this._rows = [];
    },
    getValues: function (dataIndex) {
        var v = this._rows[dataIndex];
        if (v === undefined) {
            v = this.$_calculate(dataIndex);
            this._rows[dataIndex] = v;
        }
        return v;
    },
    connect: function (dataSource) {
        this._dataSource = dataSource;
        this._rows = [];
    },
    disconnect: function () {
        this._dataSource = undefined;
        this._rows = undefined;
    },
    clearRows: function () {
        this._rows = [];
    },
    setRows: function () {
        this._rows = [];
    },
    setRowCount: function (rowCount) {
        this._rows.length = Math.min(this._rows.length, rowCount);
    },
    insertRow: function (row) {
        var v = this.$_calculate(row);
        this._rows.splice(row, 0, v);
    },
    insertRows: function (row, count) {
        var i, r, v,
            col = this._column;
        for (i = 0; i < count; i++) {
            r = row + i;
            v = this.$_calculate(r);
            this._rows.splice(r, 0, v);
        }
    },
    removeRow: function (row) {
        this._rows.splice(row, 1);
    },
    removeRows: function (rows) {
        for (var i = rows.length; i--;) {
            this._rows.splice(rows[i], 1);
        }
    },
    updateRow: function (row) {
        this._rows[row] = this.$_calculate(row);
    },
    updateRows: function (rows) {
        var i, r, col = this._column;
        for (i = rows.length; i--;) {
            r = rows[i];
            this._rows[r] = this.$_calculate(r);
        }
    },
    setValue: function (row, field) {
        this._rows[row] = this.$_calculate(row);
    },
    moveRow: function (row, newRow) {
        var rows = this._rows,
            v = rows[row];
        rows.splice(row, 1);
        rows.splice(newRow, 0, v);
    },
    moveRows: function (row, count, newRow) {
        var i, cnt,
            rows = this._rows,
            list = rows.splice(row, count);
        for (i = 0, cnt = list.length; i < cnt; i++) {
            rows.splice(newRow + i, 0, list[i]);
        }
    },
	saveRow: function (scope, row) {
	},
	restoreRow: function (scope, row, created) {
        this._rows[row] = this.$_calculate(row);
	},
	saveRows: function (scope, rows) {
	},
	restoreRows: function (scope, rows, created) {
	}
});
var GridCalcluatedValueTag = defineClass("GridCalcluatedValueTag", CalcluatedValueTag, {
    init: function (column) {
        this._super(column);
		this._values = [];
    },
    clearValues: function () {
		this._values = [];
    },
    hasValue: function (dataIndex) {
        return this._values[dataIndex] !== UNDEFINED;
    },
	_isGrouped: function (grid) {
		return grid.rowGrouped();
	},
	_indexOfRow: function (rows, dataRow) {
		for (var i = rows.length; i--;) {
			if (rows[i].dataIndex() == dataRow) {
				return i;
			}
		}
		return -1;
	},
    connect: function (dataSet) {
		this._values = [];
        this.requestAll();
    },
    disconnect: function () {
		this._values = undefined;
    },
    clearRows: function () {
		this._values = [];
    },
    setRows: function () {
		this._values = [];
        this.requestAll();
    },
    setRowCount: function (newCount) {
		this._values.length = Math.min(this._values.length, newCount);
        this.requestAll();
    },
    insertRow: function (row) {
		this._values.splice(row, 0, undefined);
        this.requestRow(row);
    },
    insertRows: function (row, count) {
		for (var i = 0; i < count; i++) {
			this._values.splice(row + i, 0, undefined);
		}
        this.requestRow(row);
    },
    removeRow: function (row) {
		this._values.splice(row, 1);
        this.requestRow(row);
    },
    removeRows: function (rows) {
		for (var i = rows.length; i--;) {
			this._values.splice(rows[i], 1);
		}
        this.requestRow(rows[0]);
    },
    updateRow: function (row) {
		if (row < this._values.length) {
			this._values[row] = undefined;
            this.requestRow(row);
		}
    },
    updateRows: function (rows) {
        var i, row;
		for (i = 0; i < rows.length; i++) {
			row = rows[i];
			if (row < this._values.length) {
				this._values[row] = undefined;
			}
		}
        this.requestRow(rows[0]);
    },
    setValue: function (row, field) {
		if (row < this._values.length) {
			this._values[row] = undefined;
            this.requestRow(row);
		}
    },
    moveRow: function (row, newRow) {
		var rows = this._values;
		if (row < rows.length) {
			rows[row] = undefined;
		}
		if (newRow < rows.length) {
			rows[row] = undefined;
		}
        this.requestRow(row);
    },
    moveRows: function (row, count, newRow) {
        var i, r,
		    rows = this._values;
		for (i = 0; i < count; i++) {
			r = row + i;
			if (r < rows.length) {
				rows[row] = undefined;
			}
		}
		for (i = 0; i < count; i++) {
			r = newRow + i;
			if (r < rows.length) {
				rows[row] = undefined;
			}
		}
        this.requestRow(row);
    },
	saveRow: function (scope, row) {
	},
	restoreRow: function (scope, row, created) {
		this._values.length > row && (this._values[row] = undefined);
	},
	saveRows: function (scope, rows) {
	},
	restoreRows: function (scope, rows, created) {
	}
});
var GridRowSource = defineClass("GridRowSource", GridRowProvider, {
	init: function () {
		this._super(true);
	}
});
/** @internal */
var GridCellStyleMap = defineClass("GridCellStyleMap", CellStyleMap, {
    init: function () {
        this._super();
    }
    ,
    connect: function (provider) {
        this._ds = provider;
    },
    disconnect: function () {
        this._ds = null;
    },
    clearRows: function () {
        this._styleMap = [];
    },
    setRows: function () {
        if (this._ds) {
            this._styleMap.length = Math.min(this._styleMap.length, this._ds.rowCount());
        }
    },
    setRowCount: function (newCount) {
        this._styleMap.length = newCount;
    },
    insertRow: function (row) {
        this._styleMap.splice(row, 0, null);
    },
    insertRows: function (row, count) {
        for (var i = 0; i < count; i++) {
            this._styleMap.splice(row, 0, null);
        }
    },
    removeRow: function (row) {
        this._styleMap.splice(row, 1);
    },
    /** rows가 정렬되었다고 가정한다. */
    removeRows: function (rows) {
        for (var i = rows.length - 1; i >= 0; i--) {
            this._styleMap.splice(rows[i], 1);
        }
    },
    updateRow: function () {
    },
    updateRows: function (rows) {
    },
    setValue: function (row, field) {
    },
    moveRow: function (row, newRow) {
        var styles = this._styleMap.splice(row, 1);
        this._styleMap.splice(newRow, styles[0]);
    },
    moveRows: function (row, count, newRow) {
        var styles = this._styleMap.splice(row, count);
        for (var i = 0; i < count; i++) {
            this._styleMap.splice(newRow + i, 0, styles[i]);
        }
    },
    saveRow: function (scope, row, deleting) {
        if (deleting) {
            var key = this.$_hash + '_' + row,
                val = this._styleMap[row];
            scope.set(key, val);
        }
    },
    restoreRow: function (scope, row, created) {
        if (created) {
            var key = this.$_hash + '_' + row,
                val = scope.get(key);
            scope.unset(key);
            this._styleMap[row] = val;
        }
    },
    saveRows: function (scope, rows, deleting) {
		var i, r, key, val,
			hash = this.$_hash,
			map = this._styleMap;
        if (deleting) {
			if (rows === DataSet.ALL_ROWS) {
				for (r = Math.min(this._ds.rowCount(), map.length); r--;) {
					key = hash + '_' + r;
					val = map[r];
					scope.set(key, val);
				}
			} else {
				for (i = rows.length; i--;) {
					r = rows[i];
					key = hash + '_' + r;
					val = map[r];
					scope.set(key, val);
				}
			}
        }
    },
    restoreRows: function (scope, rows, created) {
		var i, r, key, val,
			hash = this.$_hash,
			map = this._styleMap;
		if (created) {
			if (rows === DataSet.ALL_ROWS) {
				for (r = this._ds.rowCount(); r--;) {
					key = hash + '_' + r;
					val = scope.get(key);
					scope.unset(key);
					map[r] = val;
				}
			} else {
				for (i = rows.length; i--;) {
					r = rows[i];
					key = hash + '_' + r;
					val = scope.get(key);
					scope.unset(key);
					map[r] = val;
				}
			}
        }
    }
});
var ScrollEventType = {
	LINE_UP: "lineUp",
	LINE_DOWN: "lineDown",
	LINE_LEFT: "lineLeft",
	LINE_RIGHT: "lineRight",
	PAGE_UP: "pageUp",
	PAGE_DOWN: "pageDown",
	PAGE_LEFT: "pageLeft",
	PAGE_RIGHT: "pageRight",
	THUMB_TRACK: "thumbTrack",
	THUMB_END: "thumbEnd"
};
var _iseval = _licson["product"] != "prod"
var ScrollEdgeElement = defineClass("ScrollEdgeElement", GridElement, {
	init: function (dom, vertical) {
		this._super(dom, "scrollEdge");
		this._fill = SolidBrush.SCROLL;
	},
    fill: null,
	updateElement: function (styles) {
		this.setFill(styles.background());
	},
	_doRender: function(g, r) {
		g.drawRectI(this._fill, null, r);
	},
	_doRenderHtml: function (r) {
		var fill = this._fill;
		_ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
	},
});
var ScrollBarElement = defineClass("ScrollBarElement", GridElement, {
	init: function (dom, vertical) {
		this._super(dom, "scrollBarView");
		this._nearButton = new ScrollButton(dom, this, false);
		this.addElement(this._nearButton);
		this._farButton = new ScrollButton(dom, this, true);
		this.addElement(this._farButton);
		this._thumb = new ScrollThumb(dom, this);
		this.addElement(this._thumb);
		this._vertical = vertical;
		this._buttonSize = 20;
		this._min = 0;
		this._max = 0;
		this._pos = 0;
		this._page = 0;
		this._maxPosition = 0;
		this.setElementContext(true, false);
	},
    buttonLocation: ScrollButtonLocation.NORMAL,
	lineScrollSize: 1,
	pageScrollSize: 1,
	minThumbSize: 20,
	vertical: function () {
		return this._vertical;
	},
	maxPosition: function () {
		return this._maxPosition;
	},
	setProperties: function (min, max, page) {
		min = _int(Math.max(0, min));
		max = _int(Math.max(min, max));
		if (min != this._min || max != this._max || page != this._page) {
			this._min = min;
			this._max = max;
			this._page = page;
			this._pos = Math.min(this._max, Math.max(this._min, this._pos));
			this._maxPosition = Math.max(0, this._max - this._page);
			this.invalidate(true, true);
		}
	},
	setPosition: function (value, layout) {
		value = _int(Math.min(this._maxPosition, Math.max(this._min, value)));
		if (value != this._pos) {
			this._pos = value;
			this.invalidate(true, true);
			layout && this._doLayoutContent();
		}
	},
    updateElement: function (model) {
        this._buttonLocation = model.buttonLocation();
        this._lineScrollSize = model.lineScrollSize();
        this._pageScrollSize = model.pageScrollSize();
        this._minThumbSize = model.minThumbSize();
        this._fill = model.styles().background();
		this._nearButton.updateElement(model.buttonStyles());
		this._farButton.updateElement(model.buttonStyles());
		this._thumb.updateElement(model.thumbStyles());
    },
	ptInTrack: function (x, y, isFar) {
		var thumb = this._thumb,
			p = this.containerToElement(x, y);
		switch (this._buttonLocation) {
			case ScrollButtonLocation.NEAR:
				if (this._vertical) {
					if (p.y >= this._farButton.bottom() && p.y < this.height()) {
						return !isFar && p.y < thumb.y() || isFar && p.y > thumb.bottom();
					}
				} else {
					if (p.x >= this._farButton.right() && p.x < this.width()) {
						return !isFar && p.x < thumb.x() || isFar && p.x > thumb.right();
					}
				}
				break;
			case ScrollButtonLocation.FAR:
				if (this._vertical) {
					if (p.y >= 0 && p.y < this._nearButton.y()) {
						return !isFar && p.y < thumb.y() || isFar && p.y >= thumb.bottom();
					}
				} else {
					if (p.x >= 0 && p.x < this._nearButton.x()) {
						return !isFar && p.x < thumb.x() || isFar && p.x >= thumb.right();
					}
				}
				break;
			case ScrollButtonLocation.HIDDEN:
				if (this._vertical) {
					if (p.y >= 0 && p.y < this.height()) {
						return !isFar && p.y < thumb.y() || isFar && p.y >= thumb.bottom();
					}
				} else {
					if (p.x >= 0 && p.x < this.width()) {
						return !isFar && p.x < thumb.x() || isFar && p.x >= thumb.right();
					}
				}
				break;
			case ScrollButtonLocation.NORMAL:
			default :
				if (this._vertical) {
					if (p.y >= this._nearButton.height() && p.y < this._farButton.y()) {
						return !isFar && p.y < thumb.y() || isFar && p.y >= thumb.bottom();
					}
				} else {
					if (p.x >= this._nearButton.width() && p.x < this._farButton.x()) {
						return !isFar && p.x < thumb.x() || isFar && p.x >= thumb.right();
					}
				}
				break;
		}
		return false;
	},
	_doLayoutContent: function () {
		var vertical = this._vertical;
		var szBtn = this._buttonLocation == "hidden" ? 0 : this._buttonSize;
		var szTrack = (vertical ? this._height : this._width) - szBtn * 2;
		var szThumb = Math.min(szTrack, Math.max(this._minThumbSize, _int(szTrack * this._page / Math.max(1, (this._max - this._min + 1)))));
		var pos = szBtn + Math.min(szTrack - szThumb, Math.max(0, ((szTrack - szThumb) * this._pos / Math.max(1, (this._maxPosition - this._min)))));
        this._nearButton.setVisible(szBtn > 0);
        this._farButton.setVisible(szBtn > 0);
        if (szBtn > 0) {
            this._nearButton.setEnabled(this._pos > this._min);
            this._farButton.setEnabled(this._pos < this._maxPosition);
        }
		if (vertical) {
			if (szBtn > 0) {
				switch (this._buttonLocation) {
					case "near":
						this._nearButton.setBounds(0, 0, this._width, szBtn);
						this._farButton.setBounds(0, szBtn, this._width, szBtn);
						pos += szBtn;
						break;
					case "far":
						this._farButton.setBounds(0, this._height - szBtn, this._width, szBtn);
						this._nearButton.setBounds(0, this._height - szBtn - szBtn, this._width, szBtn);
						pos -= szBtn;
						break;
					default:
						this._nearButton.setBounds(0, 0, this._width, szBtn);
						this._farButton.setBounds(0, this._height - szBtn, this._width, szBtn);
						break;
				}
			}
			if (szThumb <= szTrack) {
				this._thumb.setBounds(1, pos, this._width - 2, szThumb);
			}
		} else {
			if (szBtn > 0) {
				switch (this._buttonLocation) {
					case "near":
						this._nearButton.setBounds(0, 0, szBtn, this._height);
						this._farButton.setBounds(szBtn, 0, szBtn, this._height);
						pos += szBtn;
						break;
					case "far":
						this._farButton.setBounds(this._width - szBtn, 0, szBtn, this._height);
						this._nearButton.setBounds(this._width - szBtn - szBtn, 0, szBtn, this._height);
						pos -= szBtn;
						break;
					default:
						this._nearButton.setBounds(0, 0, szBtn, this._height);
						this._farButton.setBounds(this._width - szBtn, 0, szBtn, this._height);
						break;
				}
			}
			if (szThumb <= szTrack) {
				this._thumb.setBounds(pos, 1, szThumb, this._height - 2);
			}
		}
	},
	_doRender: function(g, r) {
		g.drawRectI(this._fill, null, r);
	},
	_doRenderHtml: function (r) {
		var fill = this._fill;
		_ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
	},
	_doScroll: function (eventType, delta, position) {
		this.fireEvent(ScrollBarElement.SCROLLED, eventType, delta, position);
	},
	_mouseOut: function () {
		this._nearButton.setPressed(false);
		this._farButton.setPressed(false);
		this._thumb.setPressed(false);
	}
});
ScrollBarElement.SCROLLED = "onScrollBarScrolled";
var ScrollButton = defineClass("ScrollButton", UIElement, {
	init: function (dom, scrollBar, far) {
		this._super(dom);
		this._scrollBar = scrollBar;
		this._far = far;
		this._enabled = true;
	},
	background: null,
	hoveredBackground: null,
	selectedBackground: null,
	border: null,
	shapeColor: null,
	shapeSelectedColor: null,
	shapeInactiveColor: null,
	pressed: false,
	enabled: true,
	vertical: function () {
		return this._scrollBar._vertical;
	},
	far: function () {
		return this._far;
	},
	scrollBar: function () {
		return this._scrollBar;
	},
	setPressed: function (value) {
		if (value != this._pressed) {
			this._pressed = value;
            this._scrollBar.invalidate(true, true);
		}
	},
	setEnabled: function (value) {
		if (value != this._enabled) {
			this._enabled = value;
            this._scrollBar.invalidate(true, true);
		}
	},
	updateElement: function (styles) {
		this.setBackground(styles.background());
		this.setHoveredBackground(styles.hoveredBackground());
		this.setSelectedBackground(styles.selectedBackground());
		this.setBorder(styles.border());
		this.setShapeColor(SolidPen.fromFill(styles.shapeColor()));
		this.setShapeSelectedColor(SolidPen.fromFill(styles.shapeSelectedColor()));
		this.setShapeInactiveColor(SolidPen.fromFill(styles.shapeInactiveColor()));
	},
	_hoveredChanged: function () {
        this._scrollBar.invalidate(true, true);
	},
	$_drawTrianlge: function (g, s, x, y) {
		if (this._scrollBar._vertical) {
			if (this._far) {
				g.drawVLineI(s, x, y - 1, y + 3);
				g.drawHLineI(s, y - 1, x - 3, x + 4);
				g.drawHLineI(s, y, x - 2, x + 3);
				g.drawHLineI(s, y + 1, x - 1, x + 2);
			} else {
				g.drawVLineI(s, x, y - 2, y + 1);
				g.drawHLineI(s, y + 1, x - 3, x + 4);
				g.drawHLineI(s, y, x - 2, x + 3);
				g.drawHLineI(s, y - 1, x - 1, x + 2);
			}
		} else {
			if (this._far) {
				g.drawHLineI(s, y, x - 1, x + 3);
				g.drawVLineI(s, x - 1, y - 3, y + 4);
				g.drawVLineI(s, x, y - 2, y + 3);
				g.drawVLineI(s, x + 1, y - 1, y + 2);
			} else {
				g.drawHLineI(s, y, x - 2, x + 1);
				g.drawVLineI(s, x + 1, y - 3, y + 4);
				g.drawVLineI(s, x, y - 2, y + 3);
				g.drawVLineI(s, x - 1, y - 1, y + 2);
			}
		}
	},
	_doDraw: function(g) {
		var r = this.getClientRect();
		var x = _int(r.width / 2);
		var y = _int(r.height / 2);
		this.$_getDrawings();
		g.drawRectI(this._fill, null, r);
		if (this._border) {
			r.rightBy(-1);
			r.bottomBy(-1);
			g.drawRectI(null, this._border, r);
		}
		this.$_drawTrianlge(g, this._stroke, x, y);
	},
	_doDrawHtml: function () {
		var r = this.getClientRect();
		var x = _int(r.width / 2);
		var y = _int(r.height / 2);
		this.$_getDrawings();
		_ieOld ? this.$_setCssFill(this._fill) : (this._css.background = this._fill ? this._fill.css() : '');
		this._css.border = this._border ? this._border.css() : '';
		if (!this._svg) {
			this._svg = new SvgSprite(this, this.container());
		}
		var self = this;
		this._svg.render(function (s, g, w, h) {
			self.$_drawTrianlge(g, self._stroke, x, y);
		});
	},
	$_getDrawings: function () {
		this._fill = this._pressed ? this._selectedBackground : this.hovered() ? this._hoveredBackground : this._background;
		this._stroke = this._pressed ? this._shapeSelectedColor : this._enabled ? this._shapeColor : this._shapeInactiveColor;
	}
});
var ScrollThumb = defineClass("ScrollThumb", UIElement, {
	init: function (dom, scrollBar) {
		this._scrollBar = scrollBar;
		this._super(dom);
	},
	borderRadius: 0,
	background: null,
	hoveredBackground: null,
	selectedBackground: null,
	border: null,
	pressed: false,
    setBorderRadius: function (value) {
        this._borderRadius = Math.max(0, _forceInt(value));
    },
    setPressed: function (value) {
        if (value != this._pressed) {
            this._pressed = value;
            this._scrollBar.invalidate(true, true);
        }
    },
	scrollBar: function () {
		return this._scrollBar;
	},
	vertical: function () {
		return this._scrollBar._vertical;
	},
	updateElement: function (styles) {
		this.setBorderRadius(styles.borderRadius());
		this.setBackground(styles.background());
		this.setHoveredBackground(styles.hoveredBackground());
		this.setSelectedBackground(styles.selectedBackground());
		this.setBorder(styles.border());
	},
	_hoveredChanged: function () {
        this._scrollBar.invalidate(true, true);
	},
	_doDraw: function(g) {
		var vert, w, h,
			r = this.getClientRect(),
			rd = this._borderRadius;
			fill = this._pressed ? this._selectedBackground : this.hovered() ? this._hoveredBackground : this._background;
		if (rd > 0) {
			vert = this.vertical();
			w = this.width();
			h = this.height();
			rd = Math.min(rd, (vert ? w : h) - 2, _int((vert ? h : w) / 2 - 1));
		}
		rd > 0 ? g.drawRoundRectI(fill, this._border, r, rd, rd, rd, rd) : g.drawRectI(fill, this._border, r);
	},
	_doDrawHtml: function(g) {
		var r = this.getClientRect(),
            rd = this._borderRadius;
			fill = this._pressed ? this._selectedBackground : this.hovered() ? this._hoveredBackground : this._background;
		_ieOld ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
		this._css.border = this._border ? this._border.css() : '';
		this._css.borderRadius = rd > 0 ? (rd + 'px') : 0;
	}
});
var ScrollThumbRequest = defineClass("ScrollThumbRequest", GridEditRequest, {
	init: function (thumb) {
		this._super();
		this._thumb = thumb;
	},
	thumb: function () {
		return this._thumb;
	},
	scrollBar: function () {
		return this._thumb.scrollBar();
	},
	cursor: function () {
		return Cursor.ARROW;
	},
	isSelectable: function () {
		return false;
	}
});
var ScrollThumbTracker = defineClass("ScrollThumbTracker", DragTracker, {
	init: function (request, x, y) {
		this._super(request.scrollBar().container(), "scrollThumbTracker");
		this._request = request;
		this._thumb = request.thumb();
		this._scrollBar = request.scrollBar();
		this._vertical = this._scrollBar.vertical();
		var p = this._scrollBar.containerToElement(x, y);
		if (this._scrollBar.vertical()) {
			this._offset = p.y - this._thumb.y();
		} else {
			this._offset = p.x - this._thumb.x();
		}
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._thumb.setPressed(true);
		return true;
	},
	_doDrag: function (x, y) {
		return this.$_doScroll(x, y, ScrollEventType.THUMB_TRACK);
	},
	_doCompleted: function (x, y) {
		return this.$_doScroll(x, y, ScrollEventType.THUMB_END);
	},
	_doCanceled: function (x, y) {
	},
	_doEnded: function () {
		this._thumb.setPressed(false);
	},
	$_doScroll: function (x, y, eventType) {
		var szBar, szThumb, d,
			bar = this._scrollBar,
			len = bar._maxPosition - bar._min + 1,
			szBtn = bar._buttonSize,
			p = bar.containerToElement(x, y);
		if (bar.vertical()) {
			szBar = bar.height();
			szThumb = this._thumb.height();
			d = p.y - this._offset;
		} else {
			szBar = bar.width();
			szThumb = this._thumb.width();
			d = p.x - this._offset;
		}
		switch (bar.buttonLocation()) {
			case ScrollButtonLocation.FAR:
				d = d * len;
				break;
			case ScrollButtonLocation.NEAR:
				d = (d - szBtn * 2) * len;
				break;
			case ScrollButtonLocation.HIDDEN:
				szBtn = 0;
			case ScrollButtonLocation.NORMAL:
			default:
				d = (d - szBtn) * len;
				break;
		}
		d = d / (szBar - szBtn * 2 - szThumb);
		bar._doScroll(eventType, 0, _int(d));
		return true;
	}
});
var ScrollButtonTimer = defineClass("ScrollButtonTimer", EventAware, {
	init: function (button) {
		this._super();
		this._button = button;
		this._scrollBar = button.scrollBar();
		this._active = false;
		this._timer = UNDEFINED;
		this._ready = false;
	},
	start: function () {
		this._button.setPressed(true);
		this._active = true;
		this.$_fireEvent();
		setTimeout( function () {
			if (this._ready) {
				this._ready = false;
				this._timer = setInterval(function () {
					if (this._active) {
						this.$_fireEvent();
					}
				}.bind(this), 50);
			}
		}.bind(this), 200);
		this._ready = true;
	},
	move: function (x, y) {
		var p = this._button.containerToElement(x, y);
		this._active = this._button.containsInClient(p.x, p.y);
	},
	stop: function (x, y) {
		this._ready = false; // 위 setTimeout callback이 실행되기 전에 stop()이 호출되면 무시해야 한다.
		if (this._timer) {
			clearInterval(this._timer);
		}
		this._button.setPressed(false);
	},
	$_fireEvent: function () {
		var type = null;
		var delta = 1;
		if (this._scrollBar.vertical()) {
			if (this._button.far()) {
				type = ScrollEventType.LINE_DOWN;
			} else {
				type = ScrollEventType.LINE_UP;
				delta = -1;
			}
		} else {
			if (this._button.far()) {
				type = ScrollEventType.LINE_RIGHT;
			} else {
				type = ScrollEventType.LINE_LEFT;
				delta = -1;
			}
		}
		this._scrollBar._doScroll(type, this._scrollBar.lineScrollSize() * delta, 0);
	}
});
var ScrollTrackTimer = defineClass("ScrollTrackTimer", EventAware, {
	init: function (bar, isFar) {
		this._super(bar);
		this._scrollBar = bar;
		this._isFar = isFar;
		this._active = false;
		this._timer = UNDEFINED;
		this._ready = false;
	},
	start: function () {
		this._active = true;
		this.$_fireEvent();
		setTimeout( function () {
			if (this._ready) {
				this._ready = false;
				this._timer = setInterval(function () {
					if (this._active) {
						this.$_fireEvent();
					}
				}.bind(this), 50);
			}
		}.bind(this), 200);
		this._ready = true;
	},
	move: function (x, y) {
		var p = this._scrollBar.containerToElement(x, y);
		this._active = this._scrollBar.ptInTrack(p.x, p.y, this._isFar);
	},
	stop: function (x, y) {
		this._ready = false;
		if (this._timer) {
			clearInterval(this._timer);
		}
	},
	$_fireEvent: function () {
		var type = null;
		var delta = 0;
		var thumb = this._scrollBar._thumb;
		if (this._scrollBar.vertical()) {
			var y = this._scrollBar.mouseY();
			if (this._isFar && y > thumb.bottom()) {
				type = ScrollEventType.PAGE_DOWN;
				delta = 1;
			} else if (y < thumb.y()) {
				type = ScrollEventType.PAGE_UP;
				delta = -1;
			}
		} else {
			var x = this._scrollBar.mouseX();
			if (this._isFar && x > thumb.right()) {
				delta = 1;
				type = ScrollEventType.PAGE_RIGHT;
			} else if (x < thumb.x()) {
				type = ScrollEventType.PAGE_LEFT;
				delta = -1;
			}
		}
		delta != 0 && this._scrollBar._doScroll(type, this._scrollBar.pageScrollSize() * delta, 0);
	}
});
_licsond = _licsond || new Date(_licson["expiration"]);
var GridScrollTool = defineClass("GridScrollTool", null, {
    init: function (owner) {
        this._super(owner, "gridScrollTool");
        this._tracker = null;
        this._scrollTimer = null;
    },
    isScrolling: function () {
        return this._tracker != null || this._scrollTimer != null;
    },
    stop: function (x, y) {
        if (this._tracker && this._tracker.isDragging()) {
            try {
                this._tracker.drop(x, y);
                this._tracker.deactivate();
            } finally {
                this._tracker = null;
            }
        } else {
            if (this._scrollTimer) {
                this._scrollTimer.stop(x, y);
                this._scrollTimer = null;
            }
        }
    },
    start: function (element, x, y) {
        if (element instanceof ScrollThumb) {
            this._tracker = new ScrollThumbTracker(new ScrollThumbRequest(element), x, y);
            this._tracker.activate();
            if (!this._tracker.start(x, y)) {
                this._tracker = null;
                return false;
            }
            return true;
        }
        if (element instanceof ScrollButton) {
            if (element.enabled()) {
                this._scrollTimer = new ScrollButtonTimer(element);
                this._scrollTimer.start();
            }
            return true;
        }
        if (element instanceof ScrollBarElement) {
            if (element.ptInTrack(x, y, true)) {
                this._scrollTimer = new ScrollTrackTimer(element, true);
            } else if (element.ptInTrack(x, y, false)) {
                this._scrollTimer = new ScrollTrackTimer(element, false);
            }
            if (this._scrollTimer) {
                this._scrollTimer.start();
                return true;
            }
        }
        return false;
    },
    move: function (x, y) {
        if (this._tracker && this._tracker.isDragging()) {
            if (!this._tracker.drag(x, y)) {
                try {
                    this._tracker.cancel(x, y);
                    this._tracker.deactivate();
                } finally {
                    this._tracker = null;
                }
            }
        } else if (this._scrollTimer) {
            this._scrollTimer.move(x, y);
        }
    }
});
var _invalidFieldIndex = function (index) {
	throw new ExpressionEvaluationError(GridLocale._default.dataFieldIndexOutOfBounds + ": " + index);
}
var DataRowExpressionRuntime = defineClass("DataRowExpressionRuntime", ExpressionRuntime, {
	init: function (grid) {
		this._super();
		this._grid = grid;
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setItem: function (item) {
		this._item = item;
		this._group = _cast(item, GroupRow);
	},
    scope: function () {
        return this._item;
    },
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataRowExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return DataRowExpressionRuntime.IDENTS[token];
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
		case DataRowExpressionRuntime.ID_ROW:
			return this._item.index();
		case DataRowExpressionRuntime.ID_DATA_ROW:
			return this._item.dataIndex();
		case DataRowExpressionRuntime.ID_CHECKED:
			return this._grid.isChecked(this._item);
		case DataRowExpressionRuntime.ID_STATE:
			switch (this._item.dataState()) {
			case DataRowState.CREATED:
				return "c";
			case DataRowState.UPDATED:
				return "u";
			case DataRowState.DELETED:
				return "d";
			case DataRowState.CREATE_AND_DELETED:
				return "x";
			}
			return UNDEFINED;
		case DataRowExpressionRuntime.ID_COUNT:
			return this._group ? this._group.count() : 0;
		case DataRowExpressionRuntime.ID_DCOUNT:
			return this._group ? this._group.descendantCount() : 0;
		case DataRowExpressionRuntime.ID_TAG:
            return this._dataSource.getRowTag(this._item.dataIndex());
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._item) {
			if (idKey == DataRowExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(index);
			}
			return this._super(idKey, index);
		}
		return undefined;
	},
	evaluateIndexerS: function (idKey, index) {
		if (idKey == DataRowExpressionRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(idx);
			} else {
				return undefined;
			}
		}
		return this._super(idKey, index);
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUES: 3,
	ID_STATE: 4,
	ID_COUNT: 5,
	ID_DCOUNT: 6,
	ID_TAG: 7
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checked: f.ID_CHECKED,
		values: f.ID_VALUES,
		state: f.ID_STATE,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT,
		tag: f.ID_TAG
	};
});
var DataCellExpressionRuntime = defineClass("DataCellExpressionRuntime", ExpressionRuntime, {
	init: function (grid) {
		this._super();
		this._grid = grid;
		this._cell = null;
		this._row = null;
		this._dataSource = null;
		this._fieldCount = 0;
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setCell: function (value) {
		this._cell = value;
		this._row = value.row();
	},
    scope: function () {
        return this._cell;
    },
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return DataCellExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataCellExpressionRuntime.ID_VALUE:
				return this._cell.value();
			case DataCellExpressionRuntime.ID_ROW:
				return this._row.index();
			case DataCellExpressionRuntime.ID_DATA_ROW:
				return this._row.dataIndex();
			case DataCellExpressionRuntime.ID_INDEX:
				return this._cell.index().column.index();
			case DataCellExpressionRuntime.ID_FIELD:
				return this._cell.index().dataField();
			case DataCellExpressionRuntime.ID_CHECKED:
				return this._grid.isChecked(this._row);
			case DataCellExpressionRuntime.ID_STATE:
				switch (this._row.dataState()) {
					case DataRowState.CREATED:
						return "c";
					case DataRowState.UPDATED:
						return "u";
					case DataRowState.DELETED:
						return "d";
					case DataRowState.CREATE_AND_DELETED:
						return "x";
				}
				return undefined;
			case DataCellExpressionRuntime.ID_TAG:
				return this._cell.index().column.tag();
			case DataCellExpressionRuntime.ID_COUNT:
				return this._row instanceof GroupRow ? this._row.count() : 0;
			case DataCellExpressionRuntime.ID_DCOUNT:
				return this._row instanceof GroupRow ? this._row.descendantCount() : 0;
			case DataCellExpressionRuntime.ID_ROWTAG:
				return this._row.dataTag();
			case DataCellExpressionRuntime.ID_UPDATED:
				var r = this._row.dataIndex();
				return r >= 0 && this._dataSource.isUpdated(r, this._cell.index().dataField());
            case DataCellExpressionRuntime.ID_MERGED:
                return this._cell.merged();
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._row) {
			if (idKey == DataCellExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(index);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index) {
		if (idKey == DataCellExpressionRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(idx);
			} else {
				return undefined;
			}
		}
		return this._super(idKey, index);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_STATE: 6,
	ID_TAG: 7,
	ID_BASE: 8,
	ID_VALUES: 9,
	ID_COUNT: 10,
	ID_DCOUNT: 11,
	ID_ROWTAG: 12,
	ID_UPDATED: 13,
    ID_MERGED: 14
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT,
		rowtag: f.ID_ROWTAG,
		updated: f.ID_UPDATED,
        merged: f.ID_MERGED
	};
});
var FooterExpressionRuntime = defineClass("FooterExpressionRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
        this._cell = null;
    },
    setCell: function (cell) {
        this._cell = cell;
    },
    scope: function () {
        return this._cell;
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (FooterExpressionRuntime.IDENTS.hasOwnProperty(token)) {
            return FooterExpressionRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        switch (idKey) {
            case FooterExpressionRuntime.ID_VALUE:
                return this._cell.value();
            case FooterExpressionRuntime.ID_FIELD:
                return this._cell.index().dataField();
            case FooterExpressionRuntime.ID_LEVEL:
                return this._cell.level();
        }
		return this._super(idKey);
    },
    evaluateIndexerI: function (idKey, index) {
        return undefined;
    },
    evaluateIndexerS: function (idKey, index, capitalized) {
        return undefined;
    }
}, {
    ID_VALUE: 0,
    ID_FIELD: 1,
    ID_LEVEL: 2
}, function (f) {
    f.IDENTS = {
        value: f.ID_VALUE,
        field: f.ID_FIELD,
        level: f.ID_LEVEL
    };
});
var RowGroupStatementRuntime = defineClass("RowGroupStatementRuntime", ExpressionRuntime, {
	init : function() {
		this._super();
	},
	setGrid: function (value) {
		this._grid = value;
	},
	setGroup: function (value) {
		this._group = value;
	},
    scope: function () {
        return this._group;
    },
	isIdentifier : function(token) {
		token = token.toLowerCase();
		if (RowGroupStatementRuntime.IDENTS.hasOwnProperty(token)) {
			return RowGroupStatementRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier : function(idKey) {
		var field, column, header, item;
		switch (idKey) {
			case RowGroupStatementRuntime.ID_GROUP_FIELD:
				field = this._group.dataSource().getField(this._group.groupField());
				return field ? field.fieldName() : "";
			case RowGroupStatementRuntime.ID_FIELD_HEADER:
				field = this._group.dataSource().getField(this._group.groupField());
				return field ? field.header() : "";
			case RowGroupStatementRuntime.ID_GROUP_COLUMN:
				column = this._grid ? this._grid.columnByField(this._group.groupField()) : null;
				return column ? column.displayText() : this._group.dataSource().getFieldName(this._group.groupField());
			case RowGroupStatementRuntime.ID_COLUMN_HEADER:
				column = this._grid ? this._grid.columnByField(this._group.groupField()) : null;
				if (column) {
					header = column.header();
					return header ? header.text() : column.displayText();
				} else {
					return this._group.dataSource().getFieldName(this._group.groupField());
				}
			case RowGroupStatementRuntime.ID_GROUP_VALUE:
				item = this._group.firstLeaf();
				return item ? item.getValue(this._group.groupField()) : undefined;
			case RowGroupStatementRuntime.ID_ROW_COUNT:
				return this._group.descendantDataCount();
		}
		return this._super(idKey);
	}
}, {
	ID_GROUP_FIELD	: 0,
	ID_FIELD_HEADER	: 1,
	ID_GROUP_COLUMN	: 2,
	ID_COLUMN_HEADER: 3,
	ID_GROUP_VALUE	: 4,
	ID_ROW_COUNT	: 5
}, function (f) {
	f.IDENTS = {
		groupfield	: f.ID_GROUP_FIELD,
		fieldheader	: f.ID_FIELD_HEADER,
		groupcolumn	: f.ID_GROUP_COLUMN,
		columnheader: f.ID_COLUMN_HEADER,
		groupvalue	: f.ID_GROUP_VALUE,
		rowcount	: f.ID_ROW_COUNT
	};
});
var ColumnMergeRuntime = defineClass("ColumnMergeRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._grid = null;
		this._item = null;
		this._field = -1;
		this._dataSource = null;
		this._fieldCount = 0;
		this._scope = { item: null, field: -1 };
	},
	scope: function () {
		this._scope = this._item;
		this._scope = this._field;
		return this._scope;
	},
    setDataSource: function (value, grid) {
        this._dataSource = value;
		this._grid = grid;
        this._fieldCount = value ? value.fieldCount() : 0;
    },
	setItem: function (item, field) {
		this._item = item;
		this._field = field;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (ColumnMergeRuntime.IDENTS.hasOwnProperty(token)) {
			return ColumnMergeRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		if (this._item) {
			switch (idKey) {
			case ColumnMergeRuntime.ID_VALUE:
				return this._item.getValue(this._field);
			case ColumnMergeRuntime.ID_ROW:
				return this._item.index();
			case ColumnMergeRuntime.ID_DATA_ROW:
				return this._item.dataIndex();
			case ColumnMergeRuntime.ID_CHECKED:
				return this._grid.isChecked(this._item);
			case ColumnMergeRuntime.ID_GROUP:
				return this._item.parent();
			}
			return this._super(idKey);
		} else {
			return undefined;
		}
	},
	evaluateIndexerI: function(idKey, index) {
		if (this._item) {
			if (idKey == ColumnMergeRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(index);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function(idKey, index) {
		if (this._item && this._dataSource) {
			if (idKey == ColumnMergeRuntime.ID_VALUES) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(idx);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUE: 3,
	ID_VALUES: 4,
	ID_GROUP: 5
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checked: f.ID_CHECKED,
		value: f.ID_VALUE,
		values: f.ID_VALUES,
		group: f.ID_GROUP
	};
});
var ColumnMergeValueRuntime = defineClass("ColumnMergeValueRuntime", ExpressionRuntime, {
    init: function (grid) {
        this._super();
		this._grid = grid;
        this._value = undefined;
        this._item = null;
        this._field = -1;
        this._dataSource = null;
        this._fieldCount = 0;
    },
    setDataSource: function (value) {
        this._dataSource = value;
        this._fieldCount = value ? value.fieldCount() : 0;
    },
    setValue: function (item, field, value) {
        this._item = item;
        this._field = field;
        this._value = value;
    },
    isIdentifier: function(token) {
        token = token.toLowerCase();
        if (ColumnMergeValueRuntime.IDENTS.hasOwnProperty(token)) {
            return ColumnMergeValueRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function(idKey) {
        if (this._item) {
            switch (idKey) {
                case ColumnMergeValueRuntime.ID_VALUE:
                    return this._value;
                case ColumnMergeValueRuntime.ID_ROW:
                    return this._item.index();
                case ColumnMergeValueRuntime.ID_DATA_ROW:
                    return this._item.dataIndex();
                case ColumnMergeValueRuntime.ID_CHECKED:
					return this._grid.isChecked(this._item);
                case ColumnMergeValueRuntime.ID_GROUP:
                    return this._item.parent();
            }
			return this._super(idKey);
        } else {
            return undefined;
        }
    },
    evaluateIndexerI: function(idKey, index) {
        if (this._item) {
            if (idKey == ColumnMergeValueRuntime.ID_VALUES) {
                if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(index);
            }
			return this._super(idKey, index);
        } else {
            return undefined;
        }
    },
    evaluateIndexerS: function(idKey, index) {
        if (this._item && this._dataSource) {
            if (idKey == ColumnMergeValueRuntime.ID_VALUES) {
                var idx = this._dataSource.getFieldIndex(index);
                if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(idx);
            }
			return this._super(idKey, index);
        } else {
            return undefined;
        }
    }
}, {
    ID_ROW: 0,
    ID_DATA_ROW: 1,
    ID_CHECKED: 2,
    ID_VALUE: 3,
    ID_VALUES: 4,
    ID_GROUP: 5
}, function (f) {
    f.IDENTS = {
        row: f.ID_ROW,
        datarow: f.ID_DATA_ROW,
        checked: f.ID_CHECKED,
        value: f.ID_VALUE,
        values: f.ID_VALUES,
        group: f.ID_GROUP
    };
});
var ColumnFilterRuntime = defineClass("ColumnFilterRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._field = -1;
		this._fieldCount = 0;
	},
	setDataSource: function(dataSource) {
		this._dataSource = dataSource;
		this._fieldCount = dataSource ? dataSource.fieldCount() : 0;
	},
	setData: function (item, field) {
		this._item = item;
		this._field = field;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (ColumnFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return ColumnFilterRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		switch (idKey) {
            case ColumnFilterRuntime.ID_VALUE:
                return this._item.getValue(this._field);
            case ColumnFilterRuntime.ID_FIELD:
                return this._field;
            case ColumnFilterRuntime.ID_MAX:
                return 0;
            case ColumnFilterRuntime.ID_MIN:
                return 0;
            case ColumnFilterRuntime.ID_AVG:
                return 0;
        }
		return this._super(idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		if (this._item) {
			if (idKey == ColumnFilterRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(index);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index) {
        if (this._item && this._dataSource) {
            if (idKey == ColumnFilterRuntime.ID_VALUES) {
                var idx = this._dataSource.getFieldIndex(index);
                if (idx < 0 || idx >= this._fieldCount) {
                    _invalidFieldIndex(index);
                }
                return this._item.getValue(idx);
            }
            return this._super(idKey, index);
        } else {
            return undefined;
        }
	}
}, {
	ID_VALUE: 0,
	ID_FIELD: 1,
	ID_VALUES: 2,
	ID_MAX	: 3,
	ID_MIN	: 4,
	ID_AVG	: 5
}, function(f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		field: f.ID_FIELD,
		values: f.ID_VALUES,
		min: f.ID_MAX,
		max: f.ID_MIN,
		mean: f.ID_AVG
	};
});
var RowFilterRuntime = defineClass("RowFilterRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._field = -1;
		this._fieldCount = 0;
	},
	setDataSource: function(dataSource) {
		this._dataSource = dataSource;
		this._fieldCount = dataSource ? dataSource.fieldCount() : 0;
	},
	setRow: function (row) {
		this._row = row;
		return this;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (RowFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return RowFilterRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		switch (idKey) {
			case RowFilterRuntime.ID_ROW:
				return this._row.dataIndex();
			case RowFilterRuntime.ID_STATE:
				switch (this._row.dataState()) {
					case DataRowState.CREATED:
						return "c";
					case DataRowState.UPDATED:
						return "u";
					case DataRowState.DELETED:
						return "d";
					case DataRowState.CREATE_AND_DELETED:
						return "x";
				}
				return undefined;
			case RowFilterRuntime.ID_TAG:
				return this._row.dataTag();
			case RowFilterRuntime.ID_ROWCOUNT:
				return this._dataSource.rowCount();
			case RowFilterRuntime.ID_LEVEL:
				return this._row.level();
			case RowFilterRuntime.ID_CHILDINDEX:
				return this._row.childIndex();
			case RowFilterRuntime.ID_CHILDCOUNT:
				return this._row.count();
			case RowFilterRuntime.ID_SIBLINGCOUNT:
				return this._row.parent().count();
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		if (this._row) {
			if (idKey == RowFilterRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(index);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index) {
		if (this._row && this._dataSource) {
			if (idKey == RowFilterRuntime.ID_VALUES) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(idx);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	}
}, {
	ID_ROW: 0,
	ID_STATE: 1,
	ID_TAG: 2,
	ID_ROWCOUNT: 3,
	ID_LEVEL: 4,
	ID_CHILDINDEX: 5,
	ID_CHILDCOUNT: 6,
	ID_SIBLINGCOUNT: 7,
	ID_VALUES: 8
}, function(f) {
	f.IDENTS = {
		row: f.ID_ROW,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		rowcount: f.ID_ROWCOUNT,
		level: f.ID_LEVEL,
		childindex: f.ID_CHILDINDEX,
		childcount: f.ID_CHILDCOUNT,
		siblingcount: f.ID_SIBLINGCOUNT,
		values: f.ID_VALUES
	};
});
var ColumnDefaultRuntime = defineClass("ColumnDefaultRuntime", ExpressionRuntime, {
    init: function(grid) {
        ColumnDefaultRuntime.Base.init.call(this);
        this._grid = grid;
        /*
        this._dataSource = null;
        this._fieldCount = 0;
        this._column = null;
        this._scope = this._createScope();
        */
    },
    setColumn: function(column) {
        /*
        this._scope._column = this._column = column;
        this._scope._dataSource = this._dataSource = grid ? grid.dataSource() : null;
        this._scope._fieldCount = this._fieldCount = this._dataSource ? this._dataSource.fieldCount() : 0;
        this._scope._summarizer = this._summarizer = grid ? summarizer : null;
        */
    },
    scope: function () {
        return this._scope;
    },
    _createScope: function () {
    }
});
/** @abstract */
var SummaryExpressionRuntime = defineClass("SummaryExpressionRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (SummaryExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return SummaryExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		switch (idKey) {
            case SummaryExpressionRuntime.ID_COUNT:
                return this._getCount();
            case SummaryExpressionRuntime.ID_SUM:
                return this._getSum();
            case SummaryExpressionRuntime.ID_MAX:
                return this._getMax();
            case SummaryExpressionRuntime.ID_MIN:
                return this._getMin();
            case SummaryExpressionRuntime.ID_AVG:
                return this._getAvg();
            case SummaryExpressionRuntime.ID_VAR:
                return this._getVar();
            case SummaryExpressionRuntime.ID_VARP:
                return this._getVarp();
            case SummaryExpressionRuntime.ID_STDEV:
                return this._getStdev();
            case SummaryExpressionRuntime.ID_STDEVP:
                return this._getStdevp();
        }
		return this._super(idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		return this._super(idKey, index);
	},
	evaluateIndexerS: function(idKey, index, capitalized) {
		return this._super(idKey, index);
	},
	_getCount: function () {
		return NaN;
	},
	_getSum: function () {
		return NaN;
	},
	_getMax: function () {
		return NaN;
	},
	_getMin: function () {
		return NaN;
	},
	_getAvg: function () {
		return NaN;
	},
	_getVar: function () {
		return NaN;
	},
	_getVarp: function () {
		return NaN;
	},
	_getStdev: function () {
		return NaN;
	},
	_getStdevp: function () {
		return NaN;
	}
}, {
	ID_COUNT: 0,
	ID_SUM: 1,
	ID_MAX: 2,
	ID_MIN: 3,
	ID_AVG: 4,
	ID_VAR: 5,
	ID_VARP: 6,
	ID_STDEV: 7,
	ID_STDEVP: 8,
	ID_LAST: 8
}, function(f) {
	f.IDENTS = {
		count: f.ID_COUNT,
		sum: f.ID_SUM,
		max: f.ID_MAX,
		min: f.ID_MIN,
		avg: f.ID_AVG,
		"var": f.ID_VAR,
		varp: f.ID_VARP,
		stdev: f.ID_STDEV,
		stdevp: f.ID_STDEVP
	};
});
var ColumnSummaryScope = defineClass("ColumnSummaryScope", null, {
    init: function () {
        ColumnSummaryScope.Base.init.call(this);
        this._dataSource = null;
        this._fieldCount = 0;
        this._column = null;
        this._summarizer = null;
    },
    column: function () {
        return this._column;
    },
    count: function (field) {
        return this._summarizer ? this._summarizer.getCount(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : 0;
    },
    sum: function (field) {
        return this._summarizer ? this._summarizer.getSum(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : 0;
    },
    max: function (field) {
        return this._summarizer ? this._summarizer.getMax(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    min: function (field) {
        return this._summarizer ? this._summarizer.getMin(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    avg: function (field) {
        return this._summarizer ? this._summarizer.getAvg(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    "var": function (field) {
        return this._summarizer ? this._summarizer.getVar(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    varp: function (field) {
        return this._summarizer ? this._summarizer.getVarp(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    stdev: function (field) {
        return this._summarizer ? this._summarizer.getStdev(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    stdevp: function (field) {
        return this._summarizer ? this._summarizer.getStdevp(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    $_getFieldIndex: function (field) {
        if (typeof field !== "number") {
            field =  this._dataSource.getFieldIndex(field);
        }
        if (field < 0 || field >= this._fieldCount) {
			_invalidFieldIndex(field);
        }
        return field;
    }
});
var ColumnSummaryRuntime = defineClass("ColumnSummaryRuntime", SummaryExpressionRuntime, {
	init: function() {
        ColumnSummaryRuntime.Base.init.call(this);
		this._grid = null;
        this._dataSource = null;
        this._fieldCount = 0;
		this._column = null;
		this._summarizer = null;
        this._scope = this._createScope();
	},
	setColumn: function(column, summarizer) {
		var grid = this._grid = column && column.grid();
        this._scope._column = this._column = column;
        this._scope._dataSource = this._dataSource = grid ? grid.dataSource() : null;
        this._scope._fieldCount = this._fieldCount = this._dataSource ? this._dataSource.fieldCount() : 0;
        this._scope._summarizer = this._summarizer = grid ? summarizer : null;
	},
    scope: function () {
        return this._scope;
    },
	_getCount: function () {
		return this._summarizer ? this._summarizer.getCount(this._column.dataIndex()) : 0;
	},
	_getSum: function () {
		return this._summarizer ? this._summarizer.getSum(this._column.dataIndex()) : 0;
	},
	_getMax: function () {
		return this._summarizer ? this._summarizer.getMax(this._column.dataIndex()) : NaN;
	},
	_getMin: function () {
		return this._summarizer ? this._summarizer.getMin(this._column.dataIndex()) : NaN;
	},
	_getAvg: function () {
		return this._summarizer ? this._summarizer.getAvg(this._column.dataIndex()) : NaN;
	},
	_getVar: function () {
		return this._summarizer ? this._summarizer.getVar(this._column.dataIndex()) : NaN;
	},
	_getVarp: function () {
		return this._summarizer ? this._summarizer.getVarp(this._column.dataIndex()) : NaN;
	},
	_getStdev: function () {
		return this._summarizer ? this._summarizer.getStdev(this._column.dataIndex()) : NaN;
	},
	_getStdevp: function () {
		return this._summarizer ? this._summarizer.getStdevp(this._column.dataIndex()) : NaN;
	},
    evaluateIndexerI: function (idkey, index) {
        if (this._summarizer) {
            if (index < 0 || index >= this._fieldCount) {
				_invalidFieldIndex(index);
            }
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                    return this._summarizer.getSum(index);
                case SummaryExpressionRuntime.ID_COUNT:
                    return this._summarizer.getCount(index);
                case SummaryExpressionRuntime.ID_MAX:
                    return this._summarizer.getMax(index);
                case SummaryExpressionRuntime.ID_MIN:
                    return this._summarizer.getMin(index);
                case SummaryExpressionRuntime.ID_AVG:
                    return this._summarizer.getAvg(index);
                case SummaryExpressionRuntime.ID_VAR:
                    return this._summarizer.getVar(index);
                case SummaryExpressionRuntime.ID_VARP:
                    return this._summarizer.getVarp(index);
                case SummaryExpressionRuntime.ID_STDEV:
                    return this._summarizer.getStdev(index);
                case SummaryExpressionRuntime.ID_STDEVP:
                    return this._summarizer.getStdevp(index);
            }
			return this._super(idKey, index);
        } else {
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                case SummaryExpressionRuntime.ID_COUNT:
                    return 0;
                case SummaryExpressionRuntime.ID_MAX:
                case SummaryExpressionRuntime.ID_MIN:
                case SummaryExpressionRuntime.ID_AVG:
                case SummaryExpressionRuntime.ID_VAR:
                case SummaryExpressionRuntime.ID_VARP:
                case SummaryExpressionRuntime.ID_STDEV:
                case SummaryExpressionRuntime.ID_STDEVP:
                    return NaN;
            }
            return undefined;
        }
    },
    evaluateIndexerS: function (idkey, index) {
        if (this._summarizer && this._dataSource) {
            var idx = this._dataSource.getFieldIndex(index);
            if (idx < 0 || idx >= this._fieldCount) {
				_invalidFieldIndex(index);
            }
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                    return this._summarizer.getSum(idx);
                case SummaryExpressionRuntime.ID_COUNT:
                    return this._summarizer.getCount(idx);
                case SummaryExpressionRuntime.ID_MAX:
                    return this._summarizer.getMax(idx);
                case SummaryExpressionRuntime.ID_MIN:
                    return this._summarizer.getMin(idx);
                case SummaryExpressionRuntime.ID_AVG:
                    return this._summarizer.getAvg(idx);
                case SummaryExpressionRuntime.ID_VAR:
                    return this._summarizer.getVar(idx);
                case SummaryExpressionRuntime.ID_VARP:
                    return this._summarizer.getVarp(idx);
                case SummaryExpressionRuntime.ID_STDEV:
                    return this._summarizer.getStdev(idx);
                case SummaryExpressionRuntime.ID_STDEVP:
                    return this._summarizer.getStdevp(idx);
            }
			return this._super(idKey, index);
        } else {
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                case SummaryExpressionRuntime.ID_COUNT:
                    return 0;
                case SummaryExpressionRuntime.ID_MAX:
                case SummaryExpressionRuntime.ID_MIN:
                case SummaryExpressionRuntime.ID_AVG:
                case SummaryExpressionRuntime.ID_VAR:
                case SummaryExpressionRuntime.ID_VARP:
                case SummaryExpressionRuntime.ID_STDEV:
                case SummaryExpressionRuntime.ID_STDEVP:
                    return NaN;
            }
            return undefined;
        }
    },
    _createScope: function () {
        return new ColumnSummaryScope();
    }
});
var RowGroupSummaryScope = defineClass("RowGroupSummaryScope", ColumnSummaryScope, {
    init: function () {
        this._super();
        this._item = null;
    },
    row: function () {
        return this._item;
    },
    count: function (field) {
        return this._item ? this._item.getNumber(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : 0;
    },
    sum: function (field) {
        return this._item ? this._item.getSum(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : 0;
    },
    max: function (field) {
        return this._item ? this._item.getMax(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    min: function (field) {
        return this._item ? this._item.getMin(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    avg: function (field) {
        return this._item ? this._item.getAvg(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    "var": function (field) {
        return this._item ? this._item.getVar(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    varp: function (field) {
        return this._item ? this._item.getVarp(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    stdev: function (field) {
        return this._item ? this._item.getStdev(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    stdevp: function (field) {
        return this._item ? this._item.getStdevp(field === undefined ? this._column.dataIndex() : this.$_getFieldIndex(field)) : NaN;
    },
    $_getFieldIndex: function (field) {
        if (typeof field !== "number") {
            field =  this._dataSource.getFieldIndex(field);
        }
        if (field < 0 || field >= this._fieldCount) {
			_invalidFieldIndex(field);
		}
		return field;
    }
});
var RowGroupSummaryRuntime = defineClass("RowGroupSummaryRuntime", ColumnSummaryRuntime, {
	init: function() {
		this._super();
		this._item = null;
	},
	item: null,
	setItem: function (value) {
		this._scope._item = this._item = value;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (RowGroupSummaryRuntime.IDENTS.hasOwnProperty(token)) {
			return RowGroupSummaryRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		var item;
		switch (idKey) {
			case RowGroupSummaryRuntime.ID_VALUE:
				item = this._item.firstLeaf();
				return item ? item.getValue(this._column.dataIndex()) : undefined;
		}
		return this._super(idKey);
	},
    _createScope: function () {
        return new RowGroupSummaryScope();
    },
	_getCount: function() {
		return this._item.getNumber(this._column.dataIndex());
	},
	_getSum: function() {
		return this._item.getSum(this._column.dataIndex());
	},
	_getMax: function() {
		return this._item.getMax(this._column.dataIndex());
	},
	_getMin: function() {
		return this._item.getMin(this._column.dataIndex());
	},
	_getAvg: function() {
		return this._item.getAvg(this._column.dataIndex());
	},
	_getVar: function() {
		return this._item.getVar(this._column.dataIndex(), 1);
	},
	_getVarp: function() {
		return this._item.getVar(this._column.dataIndex(), 0);
	},
	_getStdev: function() {
		return this._item.getStdev(this._column.dataIndex(), 1);
	},
	_getStdevp: function() {
		return this._item.getStdev(this._column.dataIndex(), 0);
	}
}, {
	ID_VALUE: SummaryExpressionRuntime.ID_LAST + 1
}, function (f) {
	f.IDENTS = _extend({
		value: f.ID_VALUE
	}, SummaryExpressionRuntime.IDENTS);
});
var CheckableExpressionRuntime = defineClass("CheckableExpressionRuntime", DataRowExpressionRuntime, {
	init : function() {
		this._super();
	}
});
var DataCellRendererRuntime = defineClass("DataCellRendererRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._grid = null;
		this._target = null; // DataCellElement
		this._item = null; // GridRow
		this._dataSource = null;
		this._fieldCount = 0;
	},
	setDataSource: function (value, grid) {
		this._dataSource = value;
		this._grid = grid;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setTarget: function (value) {
		this._target = value;
		this._item = this._grid.getRow(value.index().rowIndex);
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellRendererRuntime.IDENTS.hasOwnProperty(token)) {
			return DataCellRendererRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		assert(this._target != null, "target is null");
		switch (idKey) {
			case DataCellRendererRuntime.ID_VALUE:
				return this._target.value();
			case DataCellRendererRuntime.ID_ROW:
				return this._item.index();
			case DataCellRendererRuntime.ID_DATA_ROW:
				return this._item.dataIndex();
			case DataCellRendererRuntime.ID_INDEX:
				return this._target.index().column.index();
			case DataCellRendererRuntime.ID_FIELD:
				return this._target.index().dataField();
			case DataCellRendererRuntime.ID_CHECKED:
				return this._grid.isChecked(this._item);
			case DataCellRendererRuntime.ID_STATE:
				if (this._item) {
					switch (this._item.dataState()) {
						case DataRowState.CREATED:
							return "c";
						case DataRowState.UPDATED:
							return "u";
						case DataRowState.DELETED:
							return "d";
						case DataRowState.CREATE_AND_DELETED:
							return "x";
					}
				}
				return UNDEFINED;
			case DataCellRendererRuntime.ID_TAG:
				return this._target.index().column.tag();
			case DataCellRendererRuntime.ID_COUNT:
				return this._target.index().childCount();
			case DataCellRendererRuntime.ID_DCOUNT:
				return this._target.index().descendantCount();
			case DataCellRendererRuntime.ID_ROWTAG:
				return this._item.dataTag();
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (idKey == DataCellRendererRuntime.ID_VALUE) { // for series
			var vals = this._target.value();
			if (_isArray(vals) && index >= 0 && index < vals.length) {
				return vals[index];
			}
			throw new ExpressionEvaluationError(GridLocale._default.valueIndexOutOfBounds + ": " + index);
		} else if (idKey == DataCellRendererRuntime.ID_VALUES) {
			if (this._dataSource) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(index);
			} else {
				return undefined;
			}
		}
		return this._super(idKey, index);
	},
	evaluateIndexerS: function (idKey, index) {
		if (idKey == DataCellRendererRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._item.getValue(idx);
			} else {
				return undefined;
			}
		}
		return this._super(idKey, index);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_STATE: 6,
	ID_TAG: 7,
	ID_BASE: 8,
	ID_VALUES: 9,
	ID_COUNT: 10,
	ID_DCOUNT: 11,
	ID_ROWTAG: 12
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT,
		rowtag: f.ID_ROWTAG
	};
});
var LinkCellRendererRuntime = defineClass("LinkCellRendererRuntime", ExpressionRuntime, {
	init : function() {
		this._super();
		this._item = null;
		this._dataSource = null;
	},
	setIndex: function (index) {
        var grid = index.column.grid();
		this._item = index.getRow(grid);
		this._dataSource = grid.dataSource();
	},
	isIdentifier: function (token) {
		if (this._dataSource) {
			var fld = this._dataSource.getFieldIndex(token);
			if (fld >= 0) {
				return fld;
			}
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		if (idKey >= 0) {
			var v = this._item.getValue(idKey);
			return v;
		}
		return this._super(idKey);
	}
});
var DataRowRuntime = defineClass("DataRowRuntime", ExpressionRuntime, {
	init: function (dataSet) {
		this._super();
		this._dataSet = dataSet;
		this._row = undefined;
		this._values = null;
		this._state = undefined;
		this._fieldMap = {};
	},
	setRow: function (row, values) {
		this._row = row;
		this._values = values;
	},
	scope: function () {
		return this._values;
	},
	isIdentifier: function (token) {
        token = token.toLowerCase();
		if (DataRowRuntime.IDENTS.hasOwnProperty(token)) {
			return DataRowRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataRowRuntime.ID_ROW:
				return this._row;
			case DataRowRuntime.ID_STATE:
				if (this._rowState == undefined) {
					this._rowState = this._dataSet.getRowState(this._row);
				}
				switch (this._rowState) {
					case DataRowState.CREATED:
						return "c";
					case DataRowState.UPDATED:
						return "u";
					case DataRowState.DELETED:
						return "d";
					case DataRowState.CREATE_AND_DELETED:
						return "x";
				}
				return undefined;
			case DataRowRuntime.ID_TAG:
				return this._dataSet.getRowTag(this._row);
		}
		return this._super(idKey, index);
	},
	evaluateIndexerI: function (idKey, index) {
		if (idKey == DataRowRuntime.ID_VALUES) {
			if (index < 0 || index >= this._values.length) {
				_invalidFieldIndex(index);
			}
			return this._values[index];
		}
		return this._super(idKey, index);
	},
	evaluateIndexerS: function (idKey, index) {
		if (idKey == DataRowRuntime.ID_VALUES) {
			if (this._dataSet) {
				var fld = this._fieldMap[index];
				if (fld === undefined) {
					fld = this._dataSet.getFieldIndex(index);
					this._fieldMap[index] = fld;
				}
				if (fld < 0 || fld >= this._values.length) {
					_invalidFieldIndex(index);
				}
				return this._values[fld];
			}
		}
		return this._super(idKey);
	}
}, {
	ID_ROW: 0,
	ID_VALUES: 1,
	ID_STATE: 2,
	ID_TAG: 3
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		values: f.ID_VALUES
	};
});
var GridRowStyleRangeRuntime = defineClass("GridRowStyleRangeRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
        this._rowCount = 0;
		this._row = -1;
	},
    setGrid: function (grid) {
        this._rowCount = grid.rowCount();
    },
	setRow: function (row) {
		this._row = row;
	},
	isIdentifier: function (token) {
        token = token.toLowerCase();
		if (GridRowStyleRangeRuntime.IDENTS.hasOwnProperty(token)) {
			return GridRowStyleRangeRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case GridRowStyleRangeRuntime.ID_ROW:
				return this._row;
            case GridRowStyleRangeRuntime.ID_ROWCOUNT:
                return this._rowCount;
		}
		return this._super(idKey);
	}
}, {
	ID_ROW: 0,
    ID_ROWCOUNT: 1
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
        rowcount: f.ID_ROWCOUNT
	};
});
/** @internal */
var SeriesValueRuntime = defineClass("SeriesValueRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
	},
    setCell: function (column, row) {
		this._column = column;
        this._row = row;
		this._values = undefined;
    },
    isIdentifier: function(token) {
        token = token.toLowerCase();
        if (SeriesValueRuntime.IDENTS.hasOwnProperty(token)) {
            return SeriesValueRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function(idKey) {
        switch (idKey) {
            case SeriesValueRuntime.ID_SUM:
                return this.$_getSum();
            case SeriesValueRuntime.ID_MAX:
                return this.$_getMax();
            case SeriesValueRuntime.ID_MIN:
                return this.$_getMin();
            case SeriesValueRuntime.ID_AVG:
                return this.$_getAvg();
            case SeriesValueRuntime.ID_VAR:
                return this.$_getVar();
            case SeriesValueRuntime.ID_VARP:
                return this.$_getVarp();
            case SeriesValueRuntime.ID_STDEV:
                return this.$_getStdev();
            case SeriesValueRuntime.ID_STDEVP:
                return this.$_getStdevp();
        }
		return this._super(idKey);
    },
    evaluateIndexerI: function(idKey, index) {
        if (idKey == SeriesValueRuntime.ID_VALUES) {
			var v = this.$_getValues();
			return v[index];
        }
		return this._super(idKey, index);
    },
    evaluateIndexerS: function(idKey, index) {
		return this._super(idKey, index);
    },
    $_getValues: function () {
		if (!this._values) {
			var fields = column._fields;
			var cnt;
			if (fields && (cnt = fields.length) > 0) {
				var vals = new Array(cnt);
				for (var i = 0; i < cnt; i++) {
					if (fields[i] >= 0) {
						vals[i] = this._row.getValue(fields[i]);
					}
				}
				this._values = vals;
			}
		}
		return this._values;
    },
	$_getSum: function () {
		var vals = this.$_getValues();
		var s = 0;
		for (var i = vals.length; i--;); {
			var v = vals[i];
			if (!isNaN(v)) s += v;
		}
		return s;
	}
}, {
    ID_VALUES: 0,
    ID_SUM: 1,
    ID_MAX: 2,
    ID_MIN: 3,
    ID_AVG: 4,
    ID_VAR: 5,
    ID_VARP: 6,
    ID_STDEV: 7,
    ID_STDEVP: 8
}, function(f) {
    f.IDENTS = {
        values: f.ID_VALUES,
        sum: f.ID_SUM,
        max: f.ID_MAX,
        min: f.ID_MIN,
        avg: f.ID_AVG,
        "var": f.ID_VAR,
        varp: f.ID_VARP,
        stdev: f.ID_STDEV,
        stdevp: f.ID_STDEVP
    };
});
/** @internal */
var CalculatedColumnRuntime = defineClass("CalculatedColumnRuntime", ExpressionRuntime, {
    init: function (column) {
        this._super();
        this._column = column;
    },
    prepare: function () {
		var grid = this._grid = this._column.grid();
		var ds = this._dataSource = grid.dataSource();
        this._tag = this._column._dataTag;
        this._rowCount = grid.rowCount();
        this._fieldCount = ds.fieldCount();
    },
    setRow: function (row) {
        this._rows = undefined;
        this._row = row;
    },
    setRange: function (rows, index) {
        this._rows = rows;
        this._index = index;
        this._row = rows[index];
    },
    isIdentifier: function(token) {
        var fld = this._dataSource.getFieldIndex(token, true);
        if (fld >= 0) {
            return fld + CalculatedColumnRuntime.ID_FIELD;
        }
        token = token.toLowerCase();
        if (CalculatedColumnRuntime.IDENTS.hasOwnProperty(token)) {
            return CalculatedColumnRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function(idKey) {
        if (idKey >= CalculatedColumnRuntime.ID_FIELD) {
            return this._row.getValue(idKey - CalculatedColumnRuntime.ID_FIELD);
        }
        var r;
        switch (idKey) {
			case CalculatedColumnRuntime.ID_PREVVAL:
                if (this._rows) {
                    return this._index > 0 ? this._tag.get(this._index - 1) : 0;
                } else 	if ((r = this._row.index()) > 0) {
					return this._tag.$_get(this._grid.getRow(r - 1));
				} else {
					return 0;
				}
            case CalculatedColumnRuntime.ID_NEXTVAL:
                if (this._rows) {
                    return this._index < this._rows.length - 1 ? this._tag.get(this._index + 1) : 0;
                } else if ((r = this._row.index()) < this._rowCount - 1) {
                    return this._tag.$_get(this._grid.getRow(r + 1));
                } else {
                    return 0;
                }
            case CalculatedColumnRuntime.ID_TAG:
                return this._row.dataTag();
            case CalculatedColumnRuntime.ID_DATA_ROW:
                return this._row.dataIndex();
            case CalculatedColumnRuntime.ID_ROW:
                return this._row.index();
            case CalculatedColumnRuntime.ID_STATE:
                switch (this._row.dataState()) {
                    case DataRowState.CREATED:
                        return "c";
                    case DataRowState.UPDATED:
                        return "u";
                    case DataRowState.DELETED:
                        return "d";
                    case DataRowState.CREATE_AND_DELETED:
                        return "x";
                }
                return UNDEFINED;
        }
        return this._super(idKey);
    },
    evaluateIndexerI: function(idKey, index) {
		var r;
		switch (idKey) {
			case CalculatedColumnRuntime.ID_VALUES:
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(index);
			case CalculatedColumnRuntime.ID_PREVVALS:
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				if (this._rows) {
					return this._index > 0 ? this._rows[this._index - 1].getValue(index) : 0;
				} else 	if ((r = this._row.index()) > 0) {
					return this._grid.getRow(r - 1).getValue(index);
				} else {
					return 0;
				}
			case CalculatedColumnRuntime.ID_NEXTVALS:
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				if (this._rows) {
					return this._index < this._rows.length - 1 ? this._rows[this._index + 1].getValue(index) : 0;
				} else if ((r = this._row.index()) < this._rowCount - 1) {
					return this._grid.getRow(r + 1).getValue(index);
				} else {
					return 0;
				}
		}
		return this._super(idKey, index);
    },
    evaluateIndexerS: function (idKey, index) {
		var idx, r;
		switch (idKey) {
			case CalculatedColumnRuntime.ID_VALUES:
				idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(idx);
			case CalculatedColumnRuntime.ID_PREVVALS:
				idx = this._dataSource.getFieldIndex(index);
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				if (this._rows) {
					return this._index > 0 ? this._rows[this._index - 1].getValue(index) : 0;
				} else 	if ((r = this._row.index()) > 0) {
					return this._grid.getRow(r - 1).getValue(index);
				} else {
					return 0;
				}
			case CalculatedColumnRuntime.ID_NEXTVALS:
				idx = this._dataSource.getFieldIndex(index);
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				if (this._rows) {
					return this._index < this._rows.length - 1 ? this._rows[this._index + 1].getValue(index) : 0;
				} else if ((r = this._row.index()) < this._rowCount - 1) {
					return this._grid.getRow(r + 1).getValue(index);
				} else {
					return 0;
				}
		}
        return this._super(idKey, index);
    }
}, {
    ID_VALUES: 0,
	ID_PREVVAL: 1,
	ID_PREVVALS: 2,
	ID_NEXTVAL: 3,
	ID_NEXTVALS: 4,
    ID_TAG: 5,
    ID_DATA_ROW: 6,
    ID_ROW: 7,
    ID_STATE: 8,
    ID_FIELD: 10
}, function(f) {
    f.IDENTS = {
		value: f.ID_VALUE,
        values: f.ID_VALUES,
		prevval: f.ID_PREVVAL,
		prevvals: f.ID_PREVVALS,
		nextval: f.ID_NEXTVAL,
		nextvals: f.ID_NEXTVALS,
        tag: f.ID_TAG,
        datarow: f.ID_DATA_ROW,
        row: f.ID_ROW,
        state: f.ID_STATE
    };
});
var CellRendererExpressionRuntime = defineClass("CellRendererExpressionRuntime", ExpressionRuntime, {
	init: function (grid) {
		this._super();
		this._grid = grid;
		this._cell = null;
		this._row = null;
		this._dataSource = null;
		this._fieldCount = 0;
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setCell: function (value) {
		this._cell = value;
		this._row = value.row();
		return this;
	},
	scope: function () {
		return this._cell;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (CellRendererExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return CellRendererExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case CellRendererExpressionRuntime.ID_VALUE:
				return this._cell.value();
			case CellRendererExpressionRuntime.ID_ROW:
				return this._row.index();
			case CellRendererExpressionRuntime.ID_DATA_ROW:
				return this._row.dataIndex();
			case CellRendererExpressionRuntime.ID_INDEX:
				return this._cell.index().column.index();
			case CellRendererExpressionRuntime.ID_FIELD:
				return this._cell.index().dataField();
			case CellRendererExpressionRuntime.ID_CHECKED:
				return this._grid.isChecked(this._row);
			case CellRendererExpressionRuntime.ID_STATE:
				switch (this._row.dataState()) {
					case DataRowState.CREATED:
						return "c";
					case DataRowState.UPDATED:
						return "u";
					case DataRowState.DELETED:
						return "d";
					case DataRowState.CREATE_AND_DELETED:
						return "x";
				}
				return undefined;
			case CellRendererExpressionRuntime.ID_TAG:
				return this._cell.index().column.tag();
			case CellRendererExpressionRuntime.ID_COUNT:
				return this._row instanceof GroupRow ? this._row.count() : 0;
			case CellRendererExpressionRuntime.ID_DCOUNT:
				return this._row instanceof GroupRow ? this._row.descendantCount() : 0;
			case CellRendererExpressionRuntime.ID_ROWTAG:
				return this._row.dataTag();
		}
		return this._super(idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._row) {
			if (idKey == CellRendererExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(index);
			}
			return this._super(idKey, index);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index) {
		if (idKey == CellRendererExpressionRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					_invalidFieldIndex(index);
				}
				return this._row.getValue(idx);
			} else {
				return undefined;
			}
		}
		return this._super(idKey, index);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_STATE: 6,
	ID_TAG: 7,
	ID_BASE: 8,
	ID_VALUES: 9,
	ID_COUNT: 10,
	ID_DCOUNT: 11,
	ID_ROWTAG: 12
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT,
		rowtag: f.ID_ROWTAG
	};
});
/** @abstract */
var CellButtonRenderer = defineClass("CellButtonRenderer", null, {
	init: function (name) {
		this._super();
		this._name = name;
	},
	name: function () {
		return this._name;
	},
	measure: function (index, hintWidth, hintHeight) {
		return this._doMeasure(index, hintWidth, hintHeight);	
	},
	render: function (index, g, r, hovered, pressed, focused) {
		this._doRender(index, g, r, hovered, pressed, focused);
	},
	hitTest: function (w, h, x, y) {
		return this._doHitTest(w, h, x, y);
	},
	toString: function () {
		return this._name;
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doRender: function (index, g, r, hovered, pressed, focused) {
	},
	_doHitTest: function (w, h, x, y) {
		return true;
	}
});
var DefaultCellButtonRenderer = defineClass("DefaultCellButtonRenderer", CellButtonRenderer, {
	init: function (name) {
		this._super(name);
		this._inited = false;
		this._imageUrls = this._getImageUrls();
		this._images = {};
	},
	prepare: function (grid) {
		if (!this._inited) {
			for (var p in this._imageUrls) {
				grid.getImage($$_rootContext + $$_assets + this._imageUrls[p]);
			}
			this._inited = true;
		}
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		return new Size(DefaultCellButtonRenderer.BUTTON_WIDTH + 4, hintHeight);
	},
	_doRender: function (index, g, r, hovered, pressed, focused) {
		if (index.column instanceof DataColumn) {
			var br = r.clone();
			if (focused && index.grid().isEditing()) {
				br.leftBy(2);
				br.rightBy(-2);
			} else {
				br.leftBy(1);
				br.rightBy(-3);
			}
            this._drawButton(index, g, br, hovered, pressed);
		}
	},
    _getImageUrls: function () {
        return {
            ed: "ellipsis_down.png",
            eh: "ellipsis_hover.png",
            eu: "ellipsis_up.png",
            dd: "dropdown_down.png",
            dh: "dropdown_hover.png",
            du: "dropdown_up.png",
            pd: "popup_down.png",
            ph: "popup_hover.png",
            pu: "popup_up.png",
            cd: "calendar_down.png",
            ch: "calendar_hover.png",
            cu: "calendar_up.png"
        };
    },
    _drawButton: function (index, g, br, hovered, pressed) {
        var button = index.column.button();
        if (button == CellButton.ACTION) {
            this.$_drawEllipsisButton(index.grid(), g, br, true, hovered, pressed);
        } else if (button == CellButton.POPUP) {
            this.$_drawMenuButton(index.grid(), g, br, true, hovered, pressed);
        }
    },
	$_getUrl: function (url) {
		return $$_rootContext + $$_assets + url;
	},
	$_getImage: function (grid, key, url) {
		var img = this._images[key];
		if (!img) {
			img = grid.getImage(this.$_getUrl(url));
			if (img) {
				this._images[key] = img;
			}
		}
		return img;
	},
    $_drawButton: function (grid, g, r, img) {
        var w, h, x, y;
        img = this.$_getImage(grid, img, this._imageUrls[img]);
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            x = _int(r.x + (r.width - w) / 2);
            y = _int(r.y + (r.height - h) / 2);
            g.drawImage(img, x, y, w, h);
        }
    },
	$_drawEllipsisButton: function (grid, g, r, enabled, hovered, pressed) {
        this.$_drawButton(grid, g, r, pressed ? "ed" : hovered ? "eh" : "eu");
	},
    $_drawDropDownButton: function (grid, g, r, enabled, hovered, pressed) {
        this.$_drawButton(grid, g, r, pressed ? "dd" : hovered ? "dh" : "du");
    },
	$_drawMenuButton: function (grid, g, r, enabled, hovered, pressed) {
        this.$_drawButton(grid, g, r, pressed ? "pd" : hovered ? "ph" : "pu");
	},
	$_drawCalendarButton: function (grid, g, r, enabled, hovered, pressed) {
        this.$_drawButton(grid, g, r, pressed ? "cd" : hovered ? "ch" : "cu");
	}
});
DefaultCellButtonRenderer.BUTTON_WIDTH = 16;
DefaultCellButtonRenderer.BUTTON_HEIGHT = 14;
var EditorButtonType = _enum('EditorButtonType', {
	COMBO: "combo",
	ELLIPSIS: "ellipsis",
	CALENDAR: "calendar"
});
/** @internal */
var EditorButtonRenderer = defineClass("EditorButtonRenderer", DefaultCellButtonRenderer, {
	init: function (name) {
		this._super(name);
	},
	buttonType: EnumProp(EditorButtonType, EditorButtonType.COMBO),
	_doRender: function(index, g, rc, hovered, pressed, focused) {
		var column = index.dataColumn();
		if (column) {
			var br = rc.clone();
			br.leftBy(1);
			br.rightBy(-3);
			br.topBy(Math.max(1, _int((rc.height - DefaultCellButtonRenderer.BUTTON_HEIGHT) / 2)));
			br.setBottom(Math.min(br.y + DefaultCellButtonRenderer.BUTTON_HEIGHT, br.bottom() - 3));
			switch (this._buttonType) {
				case EditorButtonType.COMBO:
					this.$_drawDropDownButton(index.grid(), g, br, true, hovered, pressed);
					break;
				case EditorButtonType.ELLIPSIS:
					this.$_drawEllipsisButton(index.grid(), g, br, true, hovered, pressed);
					break;
				case EditorButtonType.CALENDAR:
					this.$_drawCalendarButton(index.grid(), g, br, true, hovered, pressed);
					break;
			}
		}
	}
});
var CustomButton = defineClass("CustomButton", null, {
    init: function (config) {
        this._super();
        config && this.assign(config);
    },
    visibility: EnumProp(ButtonVisibility, ButtonVisibility.DEFAULT),
    callback: null,         // function (CellIndex);
    displayCallback: null,  // function (CellIndex):Boolean;
    enabledCallback: null,  // function (CellIndex):Boolean;
	assetImages: false,
    imageUrl: null,
    hoverUrl: null,
    downUrl: null,
    position: EnumProp(ButtonPosition, ButtonPosition.DEFAULT),
	imageWidth: 16,
});
var CustomButtonRenderer = defineClass("CustomButtonRenderer", DefaultCellButtonRenderer, {
    init: function () {
        this._super('customButtonRenderer');
    },
    button: null,   // CustomButton
	setButton: function (value) {
		if (value != this._button) {
			var urls = this._imageUrls = {},
				b = this._button = value;
            this._images = {};
			urls.u = b._imageUrl;
			urls.d = b._downUrl;
			urls.h = b._hoverUrl;
		}
	},
	prepare: function (grid) {
	},
	_getImageUrls: function () {
        return null;
    },
	$_getUrl: function (url) {
		return this._button._assetImages ? this._super(url) : url;
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		var b = this._button;
		if (b) {
			return new Size(b.imageWidth() + 4, hintHeight);
		}
		return new Size(DefaultCellButtonRenderer.BUTTON_WIDTH + 4, hintHeight);
	},
    _drawButton: function (index, g, br, hovered, pressed) {
		this.$_drawButton(index.grid(), g, br, pressed ? "d" : hovered ? "h" : "u");
    }
});
/** @abstract */
var DataCellRenderer = defineClass("DataCellRenderer", GridObject, {
	init: function () {
		this._super();
		this._rect = new Rectangle();
		this._runtime = null;
	},
	owner: null,
    showTooltip: false,
	minWidth: 4,
	editable: function () {
		return false;
	},
	isEditable: function () {
		return false;
	},
	editOnClick: function () {
		return false;
	},
	isEditOnClick: function () {
		return false;
	},
	isDblClickEnabled: function () {
		return false;
	},
	isClickable: function (cell) {
		return false;
	},
    isButton: function () {
        return false;
    },
    canAnimate: function () {
        return false;
    },
    /** @internal */
    measure: function (grid, cell, hintWidth, hintHeight) {
		return this._doMeasure(grid, cell, this.minWidth(), hintHeight);
	},
    /** @internal */
    measureHeight: function (grid, cell, width, maxHeight) {
        return this._doMeasureHeight(grid, cell, width, maxHeight);
    },
    /** @internal */
    render: function (cell, g, r) {
	},
    /** @internal */
    renderHtml: function (cell, r) {
	},
    /** @internal */
    getButtonRenderer: function () {
		return null;
	},
    /** @internal */
    isEditableKey: function (index, key) {
		return false;
	},
    /** @internal */
    performEdit: function (index) {
	},
    /** @internal */
    performClick: function (cell, x, y) {
		return false;
	},
    /** @internal */
    getTooltip: function (cell) {
        if (this.showTooltip()) {
            var s = this._getTooltipText(cell);
            return s ? s : undefined;
        }
		return undefined;
	},
	assign: function (source) {
		this._super(source);
		if (source && !source.hasOwnProperty("dynamicOptions") && source.hasOwnProperty("dynamicStyles")) {
			this.setDynamicOptions(source.dynamicStyles);
		}
	},
	propertyChanged: function (prop, newValue) {
		this._changed();
	},
	renderHtml: function (cell, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        cell._renderText(null, this._getText(cell), cell._textColor, r);
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		return new Size(Math.max(this._minWidth, hintWidth), hintHeight);
	},
    _doMeasureHeight: function (grid, cell, width, maxHeight) {
        return 0;
    },
    _getRenderRect: function (cell, r) {
        r = this._rect.copy(r);
        cell.deflatePadding2(r);
        return (r.width > 0 && r.height > 0) ? r : null;
    },
	_getText: function (cell) {
		var t, s = cell.text() || "";
		if (s) {
			if (t = cell.prefix()) {
				s = t + s;
			}
			if (t = cell.suffix()) {
				s += t;
			}
		}
		return s;
	},
    _getTooltipText: function (cell) {
        return this._getText(cell);
    },
	_changed: function () {
		this._owner && this._owner.rendererChanged(this);
	},
	_checkCellCommit: function (grid) {
		if (grid) {
			var options = grid.editOptions();
			var items = grid.itemSource();
			var cellCommit = options.updateByCell() && items.isUpdating() ||
				options.insertByCell() && (items.isInserting() || items.isAppending());
			if (cellCommit) {
				grid.commit();
			}
		}
	}
}, {
	consumeKey: function (index, key, shift, ctrl) {
		var cell, rendererId, renderer,
            grid = index ? index.grid() : null;
		if (grid && grid.isValidCell(index) && index.column instanceof ValueColumn && !grid.isEditing()) {
			cell = grid.body().getCell(index);
			rendererId = cell ? cell.styles().renderer() : null;
			renderer = rendererId ? grid.dataCellRenderers().getRenderer(rendererId) : index.column.rendererObj();
			if (renderer && renderer.editable() && renderer.isEditableKey(index, key, shift, ctrl)) {
				if (!grid.getReadOnlyAt(index.rowIndex, index.column)) {
					if (grid.edit()) {
						grid.makeCellVisible(index, true);
						renderer.performEdit(index);
						return true;
					}
				}
			}
		}
		return false;
	}
});
/** @internal */
var DataCellRendererCollection = function (delegate) {
	var _delegate = delegate;
	var _options = {};
	var _renderers = {};
	this.addRenderers = function (renderers) {
		if (renderers) {
			var options = renderers;
			if (!_isArray(options)) {
				options = [renderers];
			}
			for (var i = 0, cnt = options.length; i < cnt; i++) {
				var opt = options[i];
				if (opt && opt.hasOwnProperty("id") && opt.id) {
					_options[opt.id] = _extend({}, opt);
				}
			}
		}
	};
    this.removeRenderers = function (rendererIds) {
        if (isArray(rendererIds)) {
            for (var i = rendererIds.length; i--;) {
                delete _options[rendererIds[i]];
                delete _renderers[rendererIds[i]];
            }
        } else if (rendererIds) {
            delete _options[rendererIds];
            delete _renderers[rendererIds];
        }
    };
	this.getRenderer = function (id) {
		var options = _options[id];
		if (options) {
			var renderer = _cast(_renderers[id], DataCellRenderer);
			if (!renderer) {
				renderer = delegate.createRenderer(options);
				if (renderer) {
					_renderers[id] = renderer;
				}
			}
			return renderer;
		}
		return null;
	};
};
var TextCellRenderer = defineClass("TextCellRenderer", DataCellRenderer, {
	init: function () {
		this._super();
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
        var sz = cell._measureText(this._getText(cell), 1000000, hintHeight);
        sz.width += cell.paddingHorz();
        return sz;
	},
    _doMeasureHeight: function (grid, cell, width, maxHeight) {
        var sz = cell._measureText(this._getText(cell), width, maxHeight);
        return sz.height + cell.paddingVert();
    },
	render: function (cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
		var s = this._getText(cell);
        if (s) {
            cell._renderText(g, s, cell._textColor, r);
        }
	},
	renderHtml: function (cell, r) {
		this.render(cell, null, r);
	}
});
TextCellRenderer.Default = new TextCellRenderer();
var BarCellRenderer = defineClass("BarCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(100);
	},
	minimum: 0,
	maximum: 100,
    integral: false,
	showLabel: false,
	origin: "left",
	$_drawBar: function (cell, g, r) {
		if (this._maximum > this._minimum) {
			var v = cell.value(),
				rate = Math.min(1, (v - this._minimum) / (this._maximum - this._minimum)),
				border = cell._selected ? (cell._shapeSelectedBorder || cell._shapeBorder) : cell._shapeBorder,
				fill = cell._selected ? (cell._shapeSelectedColor || cell._shapeColor) : cell._shapeColor;
			if (border || fill) {
				switch (this._origin) {
					case BarCellRenderer.ORIGIN_LEFT:
						this.$_drawLeft(cell, g, fill, border, r, rate);
						break;
					case BarCellRenderer.ORIGIN_RIGHT:
						this.$_drawRight(cell, g, fill, border, r, rate);
						break;
                    case BarCellRenderer.ORIGIN_TOP:
                        this.$_drawTop(cell, g, fill, border, r, rate);
                        break;
					case BarCellRenderer.ORIGIN_BOTTOM:
						this.$_drawBottom(cell, g, fill, border, r, rate);
						break;
					default:
						this.$_drawLeft(cell, g, fill, border, r, rate);
						break;
				}
			}
		}
	},
	render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
		this.$_drawBar(cell, g, r);
		if (this._showLabel) {
			var s = this._getText(cell);
			s && cell._renderText(g, s, cell._textColor, r);
		}
	},
	renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true, r), r);
	},
	$_drawLeft: function (cell, g, fill, border, r, rate) {
		var h, sz,
            w = r.width * rate;
		if (w >= 0) {
			h = r.height;
			sz = cell.shapeSize();
			if (sz) {
				h = sz.getDimension(h);
			}
			if (h >= 0) {
                if (this._integral) {
                    w = Math.floor(w);
                    h = Math.floor(h);
                }
				g.drawBoundsI(fill, border, r.x, r.y + (r.height - h) / 2, w, h);
			}
		}
	},
	$_drawRight: function (cell, g, fill, border, r, rate) {
		var h, sz,
            w = r.width * rate;
		if (w >= 0) {
			h = r.height;
			sz = cell.shapeSize();
			if (sz) {
				h = sz.getDimension(h)
			}
			if (h >= 0) {
                if (this._integral) {
                    w = Math.floor(w);
                    h = Math.floor(h);
                }
				g.drawBoundsI(fill, border, r.right() - w, r.y + (r.height - h) / 2, w, h);
			}
		}
	},
	$_drawTop: function (cell, g, fill, border, r, rate) {
		var w, sz,
            h = r.height * rate;
		if (h >= 0) {
			w = r.width;
			sz = cell.shapeSize();
			if (sz) {
				w = sz.getDimension(w)
			}
			if (w >= 0) {
                if (this._integral) {
                    h = Math.floor(h);
                    w = Math.floor(w);
                }
				g.drawBoundsI(fill, border, r.x + (r.width - w) / 2, r.y, w, h);
			}
		}
	},
    $_drawBottom: function (cell, g, fill, border, r, rate) {
        var w, sz,
            h = r.height * rate;
        if (h >= 0) {
            w = r.width;
            sz = cell.shapeSize();
            if (sz) {
                w = sz.getDimension(w)
            }
            if (w >= 0) {
                if (this._integral) {
                    h = Math.floor(h);
                    w = Math.floor(w);
                }
                g.drawBoundsI(fill, border, r.x + (r.width - w) / 2, r.bottom() - h, w, h);
            }
        }
    }
});
BarCellRenderer.ORIGIN_LEFT = "left";
BarCellRenderer.ORIGIN_RIGHT = "right";
BarCellRenderer.ORIGIN_TOP = "top";
BarCellRenderer.ORIGIN_BOTTOM = "bottom";
var CheckCellRenderer = defineClass("CheckCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._values = {};
		this._falseValue = undefined;
		this._trueValue = undefined;
        this._trect = new Rectangle();
	},
	trueValues: null,
	falseValues: null,
	spaceKey: true,
	editable: false,
	dblClickEditable: false,
	editOnClick: false,
	threeStates: false,
	setTrueValues: function (value) {
		if (value !== this._trueValues) {
			this._trueValues = value;
			this.$_resetValues();
		}
	},
	falseValues: null,
	setFalseValues: function (value) {
		if (value !== this._falseValues) {
			this._falseValues = value;
			this.$_resetValues();
		}
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var loc, s,
            sz = _tempSize(cell.paddingHorz(), hintHeight),
		    w = 12,
		    dim = cell.shapeSize();
		if (dim) {
			w = dim.getDimension(12);
		}
		sz.width += w;
		loc = cell.iconLocation();
		if (loc == IconLocation.LEFT || loc == IconLocation.RIGHT) {
			s = this._getText(cell)
			if (s) {
				sz.width += cell.iconOffset() + cell._measureText(s, 1000000, hintHeight).width;
			}
		}
		return sz;
	},
	render: function(cell, g, rc) {
        var r;
        if (!(r = this._getRenderRect(cell, rc))) return;
        var x, y, w, h, tr, s, sz, svg, grid,
		    value = cell.value(),
		    v = this.$_getValue(value),
		    empty = (this._threeStates && v === undefined),
		    border = empty ? null : (cell._selected ? (cell._shapeSelectedBorder || cell._shapeBorder) : cell._shapeBorder),
		    fill =  empty ? null : v ? (cell._selected ? (cell._shapeSelectedColor || cell._shapeColor) : cell._shapeColor) : cell._shapeInactiveColor,
		    iconOff = cell.iconOffset();
		if (fill || border) {
			w = 12;
			h = 10;
			sz = cell.shapeSize();
			if (sz) {
				w = sz.getDimension(w);
				h = w * 10 / 12;
			}
			tr = null;
			switch (cell.iconLocation()) {
				case IconLocation.LEFT:
					x = r.x + iconOff;
					y = r.y + (r.height - h) / 2;
					tr = this._trect;
					tr.copy(r);
					tr.leftBy(iconOff + w + cell.iconPadding());
					break;
				case IconLocation.RIGHT:
					x = r.right() - iconOff - w;
					y = r.y + (r.height - h) / 2;
                    tr = this._trect;
					tr.copy(r);
					tr.rightBy(-iconOff - w - cell.iconPadding());
					break;
				case IconLocation.TOP:
					x = r.x + (r.width - w) / 2;
					y = r.y + iconOff;
                    tr = this._trect;
					tr.copy(r);
					tr.topBy(h + cell.iconPadding());
					break;
				case IconLocation.BOTTOM:
					x = r.x + (r.width - w) / 2;
					y = r.bottom() - iconOff - h;
                    tr = this._trect;
					tr.copy(r);
					tr.bottomBy(-h - cell.iconPadding());
					break;
				default:
					x = r.x + (r.width - w) / 2;
					y = r.y + (r.height - h) / 2;
					break;
			}
			if (tr) {
				s = this._getText(cell);
				if (s) {
					cell._renderText(g, s, cell._textColor, tr);
				}
			}
			var pol = [
				x + w * 1.25 / 8, y + h * 2.65 / 7,
				x + w * 0, y + h * 4.25 / 7,
				x + w * 3.95 / 8, y + h * 7.0 / 7,
				x + w * 8.0 / 8, y + h * 1.2 / 7,
				x + w * 6.3 / 8, y + h * 0,
				x + w * 3.45 / 8, y + h * 4.25 / 7
			];
			if (cell._dom) {
				svg = cell.$_prepareSvg();
				svg.setBounds(rc.x, rc.y, rc.width, rc.height);
				svg.render(function (s, g, w, h) {
					g.drawPolygonArray(fill, border, pol);
				});
			} else {
				g.drawPolygonArray(fill, border, pol);
			}
		}
		if (this.editable() && cell.focused()) {
			grid = cell.grid();
			if (grid && !grid.isReadOnlyCell(cell.index())) {
				rc.inflate(-3, -3);
				if (!r.isEmpty()) {
					if (cell._dom) {
						if (!svg) {
							svg = cell.$_prepareSvg();
							rc.inflate(3, 3);
							svg.setBounds(rc.x, rc.y, rc.width, rc.height);
							rc.inflate(-3, -3);
							svg.render(function (s, g, w, h) {
								g.drawRectI(null, SolidPen.FOCUS, rc);
							});
						} else {
							svg.renderAdd(function (s, g, w, h) {
								g.drawRectI(null, SolidPen.FOCUS, rc);
							});
						}
					} else {
						g.drawRect(null, SolidPen.FOCUS, rc);
					}
				}
                rc.inflate(3, 3);
			}
		}
	},
	renderHtml: function (cell, r) {
		this.render(cell, null, r);
	},
	isEditableKey: function (index, key) {
		return this.spaceKey() && key == Keys.SPACE;
	},
	performEdit: function (index) {
		var v = this.$_getValue(index.getValue()),
		    fld = index.dataField(),
            grid = index.column.grid(),
		    ds = grid.dataSource(),
		    row = index.getRow(grid);
		if (fld >= 0 && ds.getValueType(fld) == ValueType.BOOLEAN) {
			if (this._threeStates && v !== undefined && !v) {
				v = undefined;
			} else {
				v = !v;
			}
		} else {
			if (v) {
				v = this._falseValue ? this._falseValue : false;
			} else if (v !== undefined && this._threeStates) {
				v = undefined;
			} else {
				v = this._trueValue ? this._trueValue : true;
			}
		}
        row.setValue(fld, v);
		this._checkCellCommit(grid);
		if (grid) {
			grid.validateCellCommit(index, v);
		}
	},
	$_resetValues: function () {
		var vals, len, i;
		this._values = {};
		if (this._falseValues) {
			vals = this._falseValues.split(",");
			if (vals) {
				this._falseValue = (len = vals.length) > 0 ? vals[0] : undefined;
				for (i = 0; i < len; i++) {
					this._values[vals[i]] = false;
				}
			} else {
				this._falseValue = undefined;
			}
		} 
		if (this._trueValues) {
			vals = this._trueValues.split(",");
			if (vals) {
				this._trueValue = (len = vals.length) > 0 ? vals[0] : undefined;
				for (i = 0; i < len; i++) {
					this._values[vals[i]] = true;
				}
			} else {
				this._trueValue = undefined;
			}
		}
	},
	$_getValue: function (v) {
		if (typeof v === "boolean") {
			return v;
		} else {
			var val = String(v);
			if (this._values.hasOwnProperty(val)) {
				return this._values[val];
			} else if (this._threeStates && (v == "" || v === undefined || v === null)) {
				return undefined;
			} else {
				return Boolean(v);
			}
		}
	}
});
var ShapeCellRenderer = defineClass("ShapeCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._ellipse = null;
		this._polygon = null;
		this._rect = new Rectangle();
        this._size = { w: 0, h: 0 };
	},
	textVisible: true,
	sizeRate: 0.6,
    scaleX: 1.0,
    scaleY: 1.0,
    setSizeRate: function (value) {
        value = parseFloat(value);
        if (!isNaN(value) && value !== this._sizeRate) {
            this._sizeRate = value;
            this._changed();
        }
    },
    setScaleX: function (value) {
        value = parseFloat(value);
        if (!isNaN(value) && value !== this._scaleX) {
            this._scaleX = value;
            this._changed();
        }
    },
    setScaleY: function (value) {
        value = parseFloat(value);
        if (!isNaN(value) && value !== this._scaleY) {
            this._scaleY = value;
            this._changed();
        }
    },
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var sz = cell._measureText(this._getText(cell), 1000000, hintHeight);
		var shape = ShapeDrawing.getShape(this, cell.shapeName());
		var szShape = this.$_getSize(cell, hintWidth, hintHeight);
		var loc;
		sz.width += cell.paddingHorz();
		if (shape && !isNaN(szShape.w) && IconLocation.isHorz(loc = cell.shapeLocation())) {
			sz.width += szShape.w;
			if (loc != IconLocation.CENTER) {
				sz.width += cell.shapePadding() + cell.shapeOffset();
			}
		}
		return sz;
	},
    _doMeasureHeight: function (grid, cell, width, maxHeight) {
        var h = cell._measureText(this._getText(cell), width, maxHeight).height;
        var shape = ShapeDrawing.getShape(this, cell.shapeName());
        var fs = cell.shapeSize();
        var loc;
        if (shape && (fs && fs.fixed())) {
            loc = cell.shapeLocation();
            if (IconLocation.isStrictVert(loc)) {
                h += fs._value + cell.shapePadding() + cell.shapeOffset();
            } else if (IconLocation.isCenter(loc)) {
                h = Math.max(h, fs._value);
            }
        }
        return h + cell.paddingVert();
    },
	render: function (cell, g, r) {
		if (!(r = this._getRenderRect(cell, r))) return;
        var wrap, font, fill, img, dx, dy, tr, sz, x, y, w, h,
		    shapeType = cell.shapeName(),
		    shape = ShapeDrawing.getShape(this, shapeType),
		    text = this._textVisible ? this._getText(cell) : undefined,
		    shapeOff = cell.shapeOffset(),
		    shapeGap = cell.shapePadding(),
		    loc = cell.shapeLocation(),
		    align = cell.textAlignment(),
		    valign = cell.lineAlignment(),
		    cx = r.x,
		    cy = r.y,
		    cw = r.width,
		    ch = r.height;
		if (text) {
			font = cell.font();
			fill = cell._textColor;
		}
		if (shape) {
			sz = this.$_getSize(cell, r.width, r.height);
			x = cx;
			y = cy;
			w = sz.w;
			h = sz.h;
			switch (loc) {
				case IconLocation.RIGHT:
				case IconLocation.RIGHT_SIDE:
					x = r.right() - w - shapeOff;
					switch (cell.shapeAlignment()) {
						case Alignment.CENTER:
							y += (ch - h + 1) / 2;
							break;
						case Alignment.FAR:
							y += ch - h;
							break;
					}
					cw -= shapeOff + w + shapeGap;
					if (loc === IconLocation.RIGHT && text) {
						switch (align) {
							case Alignment.NEAR:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dx = cw - tr.width;
								if (dx > 0) {
									x -= dx;
								}
								break;
							case Alignment.FAR:
								break;
							case Alignment.CENTER:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dx = _int((cw - tr.width) / 2);
								if (dx > 0) {
									x -= dx;
									cx = x - shapeGap - tr.width;
									cw = tr.width;
								}
								break;
						}
					}
					break;
				case IconLocation.TOP:
				case IconLocation.TOP_SIDE:
					y += shapeOff;
					switch (cell.shapeAlignment()) {
						case Alignment.CENTER:
							x += (cw - w) / 2;
							break;
						case Alignment.FAR:
							x += cw - w;
							break;
					}
					dy = shapeOff + h + shapeGap;
					cy += dy;
					ch -= dy;
					if (loc === IconLocation.TOP && text) {
						switch (valign) {
							case Alignment.NEAR:
								break;
							case Alignment.FAR:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dy = ch - tr.height;
								if (dy > 0) {
									y += dy;
								}
								break;
							case Alignment.CENTER:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dy = _int((ch - tr.height) / 2);
								if (dy > 0) {
									y += dy;
									cy = y + h + shapeGap;
									ch = tr.height;
								}
								break;
						}
					}
					break;
				case IconLocation.BOTTOM:
				case IconLocation.BOTTOM_SIDE:
					y = r.bottom() - h - shapeOff;
					switch (cell.shapeAlignment()) {
						case Alignment.CENTER:
							x += (cw - w) / 2;
							break;
						case Alignment.FAR:
							x += cw - w;
							break;
					}
					ch -= shapeOff + h + shapeGap;
					if (loc === IconLocation.BOTTOM && text) {
						switch (valign) {
							case Alignment.NEAR:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dy = ch - tr.height;
								if (dy > 0) {
									y -= dy;
								}
								break;
							case Alignment.FAR:
								break;
							case Alignment.CENTER:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dy = _int((ch - tr.height) / 2);
								if (dy > 0) {
									y -= dy;
									cy = y - shapeGap - tr.height;
									ch = tr.height;
								}
								break;
						}
					}
					break;
				case IconLocation.LEFT:
				case IconLocation.LEFT_SIDE:
					x += shapeOff;
					switch (cell.shapeAlignment()) {
						case Alignment.CENTER:
							y += (ch - h + 1) / 2;
							break;
						case Alignment.FAR:
							y += ch - h;
							break;
					}
					dx = shapeOff + w + shapeGap;
					cx += dx;
					cw -= dx;
					if (loc === IconLocation.LEFT && text) {
						switch (align) {
							case Alignment.NEAR:
								break;
							case Alignment.FAR:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dx = cw - tr.width;
								if (dx > 0) {
									x += dx;
								}
								break;
							case Alignment.CENTER:
								tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
								dx = _int((cw - tr.width) / 2);
								if (dx > 0) {
									x += dx;
									cx = x + w + shapeGap;
									cw = tr.width;
								}
								break;
						}
					}
					break;
				case IconLocation.CENTER:
					x += (cw - w) / 2;
					y += (ch - h) / 2;
					text = null;
					break;
				case IconLocation.CENTER_BACK:
					x += (cw - w) / 2;
					y += (ch - h) / 2;
					break;
				default:
					shape = null;
					break;
			}
			if (shape) {
				this._rect.set(x, y, w, h);
                if (cell._selected) {
                    shape.draw(g, this._rect, cell._shapeSelectedColor || cell._shapeColor, cell._shapeSelectedBorder || cell._shapeBorder, cell._shapeRotate);
                } else {
                    shape.draw(g, this._rect, cell._shapeColor, cell._shapeBorder, cell._shapeRotate);
                }
			}
		}
		if (text) {
			cell._renderTextBounds(g, text, fill, cx, cy, cw, ch);
		}
	},
	renderHtml: function (cell, r) {
		this.render(cell, cell.$_getGraphics(true), r);
	},
    $_getSize: function (cell, tw, th) {
        var sh, fs,
			sz = this._size;
        sw = Math.min(tw, th);
        sh = sw;
        fs = cell.shapeSize();
        if (fs) {
            sw = fs.getDimension(sw);
            sh = fs.getDimension(sh);
        } else {
            sw = sw * this._sizeRate;
            sh = sh * this._sizeRate;
        }
        sz.w = sw * this._scaleX;
        sz.h = sh * this._scaleY;
        return sz;
    }
	/*
	_drawNone: function (cell, shape, g, r) {
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				cell._renderTextBounds(g, s, cell._color, r.x, r.y, r.width, r.height);
			}
		}
	},
	_drawLeftSide: function (cell, shape, g, r) {
		var shapeOff = shape ? cell.shapeOffset() : 0;
		var shapeGap = shape ? cell.shapePadding() + shapeOff : 0;
		var tx = r.x;
		var ty = r.y;
		var tw = r.width;
		var th = r.height;
		var sz, x, y;
		if (shape) {
            sz = this.$_getSize(cell, tw, th);
			x = tx + shapeOff;
			y = ty;
			switch (cell.shapeAlignment()) {
				case Alignment.CENTER:
					y += (th - sz.h) / 2;
					break;
				case Alignment.FAR:
					y += th - sz.h;
					break;
			}
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		} else {
            sz = this._size;
            sz.w = 0;
        }
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				tx += sz.w + shapeGap;
				tw -= sz.w + shapeGap;
                cell._renderTextBounds(g, s, cell._color, tx, ty, tw, th);
			}
		}
	},
	_drawLeft: function (cell, shape, g, r) {
		var shapeOff = shape ? cell.shapeOffset() : 0;
		var shapeGap = shape ? cell.shapePadding() + shapeOff : 0;
		var tx = r.x;
		var ty = r.y;
		var tw = r.width;
		var th = r.height;
		var sz, x, y;
		if (shape) {
			sz = this.$_getSize(cell, tw, th);
			x = tx + shapeOff;
			y = ty;
			switch (cell.shapeAlignment()) {
				case Alignment.CENTER:
					y += (th - sz.h) / 2;
					break;
				case Alignment.FAR:
					y += th - sz.h;
					break;
			}
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		} else {
			sz = this._size;
			sz.w = 0;
		}
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				tx += sz.w + shapeGap;
				tw -= sz.w + shapeGap;
				cell._renderTextBounds(g, s, cell._color, tx, ty, tw, th);
			}
		}
	},
	_drawRight: function (cell, shape, g, r) {
		var shapeOff = shape ? cell.shapeOffset() : 0;
		var shapeGap = shape ? cell.shapePadding() + shapeOff : 0;
		var tx = r.x;
		var ty = r.y;
		var tw = r.width;
		var th = r.height;
		if (shape) {
            var sz = this.$_getSize(cell, tw, th);
			var x = r.right() - sz.w - shapeOff;
			var y = ty;
			switch (cell.shapeAlignment()) {
				case Alignment.CENTER:
					y += (th - sz.h) / 2;
					break;
				case Alignment.FAR:
					y += th - sz.h;
					break;
			}
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		} else {
            sz = this._size;
            sz.w = 0;
        }
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				tw -= sz.w + shapeGap;
                cell._renderTextBounds(g, s, cell._color, tx, ty, tw, th);
			}
		}
	},
	_drawTop: function (cell, shape, g, r) {
		var shapeOff = shape ? cell.shapeOffset() : 0;
		var shapeGap = shape ? cell.shapePadding() + shapeOff : 0;
		var tx = r.x;
		var ty = r.y;
		var tw = r.width;
		var th = r.height;
		if (shape) {
            var sz = this.$_getSize(cell, tw, th);
			var x = tx;
			var y = ty + shapeOff;
			switch (cell.shapeAlignment()) {
				case Alignment.CENTER:
					x += (tw - sz.w) / 2;
					break;
				case Alignment.FAR:
					x += tw - sz.w;
					break;
			}
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		} else {
            sz = this._size;
            sz.h = 0;
        }
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				ty += sz.h + shapeGap;
				th -= sz.h + shapeGap;
                cell._renderTextBounds(g, s, cell._color, tx, ty, tw, th);
			}
		}
	},
	_drawBottom: function (cell, shape, g, r) {
		var shapeOff = shape ? cell.shapeOffset() : 0;
		var shapeGap = shape ? cell.shapePadding() + shapeOff : 0;
		var tx = r.x;
		var ty = r.y;
		var tw = r.width;
		var th = r.height;
		if (shape) {
            var sz = this.$_getSize(cell, tw, th);
            var x = tx;
			var y = r.bottom() - sz.h - shapeOff;
			switch (cell.shapeAlignment()) {
				case Alignment.CENTER:
					x += (tw - sz.w) / 2;
					break;
				case Alignment.FAR:
					x += tw - sz.w;
					break;
			}
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		} else {
            sz = this._size;
            sz.h = 0;
        }
		if (this._textVisible) {
			var s = this._getText(cell);
			if (s) {
				th -= sz.h + shapeGap;
                cell._renderTextBounds(g, s, cell._color, tx, ty, tw, th);
			}
		}
	},
	_drawCenter: function (cell, shape, g, r) {
		if (shape) {
			var shapeOff = cell.shapeOffset();
			var shapeGap = cell.shapePadding() + shapeOff;
			var tx = r.x;
			var ty = r.y;
			var tw = r.width;
			var th = r.height;
			var sz = this.$_getSize(cell, tw, th);
			var x = tx + shapeOff;
			var y = ty + shapeOff;
			x += (tw - sz.w) / 2;
			y += (th - sz.h) / 2;
			this._rect.set(x, y, sz.w, sz.h);
			shape.draw(g, this._rect, cell.shapeColor(), cell.shapeBorder(), cell.shapeRotate());
		}
	}
	*/
});
var SignalBarCellRenderer = defineClass("SignalBarCellRenderer", DataCellRenderer, {
	init : function() {
		this._super();
		this.setMinWidth(100);
	},
	barCount: 10,
    barGap: 2,
    barRate: 1.0,
	minimum: 0,
	maximum: 100,
    startRate: 0.4,
    endRate: 1.0,
    detailed: false,
	setBarCount: function (value) {
		value = Math.max(1, value);
		if (value != this._barCount) {
			this._barCount = value;
			this._changed();
		}
	},
    setStartRate: function (value) {
        value = parseFloat(value)
        if (!isNaN(value)) {
            value = Math.max(0, Math.min(1, value));
            if (value != this._startRate) {
                this._startRate = value;
                this._changed();
            }
        }
    },
    setEndRate: function (value) {
        value = parseFloat(value)
        if (!isNaN(value)) {
            value = Math.max(0, Math.min(1, value));
            if (value != this._endRate) {
                this._endRate = value;
                this._changed();
            }
        }
    },
	render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var h, fillInactive, w, x, y, bg, bw, bx, by, dy, bh, isig, detailed, i, f,
            v = cell.value(),
            border = (cell._selected && cell._shapeSelectedBorder) || cell._shapeBorder,
		    fill = (cell._selected && cell._shapeSelectedColor) || cell._shapeColor,
            cnt = this._barCount,
		    sig = 0;
		if (!isNaN(this._minimum) && !isNaN(this._maximum) && this._maximum > this._minimum) {
			sig = cnt * (v - this._minimum) / (this._maximum - this._minimum);
		}
		if (border || fill) {
            h = r.height * this._barRate;
            r.y += (r.height - h) / 2;
            r.height = h;
			fillInactive = cell.shapeInactiveColor();
			w = r.width;
			x = r.x;
			y = r.y;
			bg = this._barGap;
			bw = (w - (cnt  - 1) * bg) / cnt;
			bx = x;
			by = r.bottom();
			dy = h * (this._endRate - this._startRate) / (cnt - 1);
            bh = h * this._startRate;
            isig = Math.floor(sig);
            detailed = this._detailed && (sig != isig)
			for (i = 0; i < cnt; i++) {
                if (detailed && i == isig ) {
                    w = bw * (sig - isig);
                    g.drawBoundsI(fill, border, bx, by, w, -bh);
                    g.drawBoundsI(fillInactive, border, bx + w, by, bw - w, -bh);
                } else {
                    f = i < sig ? fill : fillInactive;
                    g.drawBoundsI(f, border, bx, by, bw, -bh);
                }
				bx += bw + bg;
                bh += dy;
			}
		}
	},
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    }
});
var IconCellRenderer = defineClass("IconCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
	},
	textVisible: true,
    _doMeasure: function (grid, cell, hintWidth, hintHeight) {
        return IconCellRenderer.measure(grid, cell, this._getText(cell), hintWidth, hintHeight);
    },
    _doMeasureHeight: function (grid, cell, width, maxHeight) {
        return IconCellRenderer.measureHeight(grid, cell, this._getText(cell), width, maxHeight);
    },
    render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var s = this._textVisible ? this._getText(cell) : undefined;
		IconCellRenderer.renderBitmapText(cell, s, g, r);
	},
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    }
}, {
    measure: function (grid, cell, text, hintWidth, hintHeight) {
        var sz = cell._measureText(text, 1000000, hintHeight);
        var img, loc;
        if ((img = cell.getIcon()) && !isNaN(img.width) && IconLocation.isHorz(loc = cell.iconLocation())) {
            sz.width += img.width;
            if (loc != IconLocation.CENTER) {
                sz.width += cell.iconPadding() + cell.iconOffset();
            }
        }
        sz.width += cell.paddingHorz();
        return sz;
    },
    measureHeight: function (grid, cell, text, width, maxHeight) {
        var h = cell._measureText(text, width, maxHeight).height;
        var img, loc;
        if ((img = cell.getIcon()) && !isNaN(img.height)) {
            loc = cell.iconLocation();
            if (IconLocation.isStrictVert(loc)) {
                h += img.height + cell.iconPadding() + cell.iconOffset();
            } else if (IconLocation.isCenter(loc)) {
                h = Math.max(h, img.height);
            }
        }
        return h + cell.paddingVert();
    },
	renderBitmapText: function (cell, text, g, r, hovered, textRect) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding();
		var loc = cell.iconLocation();
		var align = cell.textAlignment();
		var valign = cell.lineAlignment();
		var cx = r.x;
		var cy = r.y;
		var cw = r.width;
		var ch = r.height;
        var wrap, font, fill, img, dx, dy, tr;
        if (text) {
            font = cell.font();
            fill = hovered ? cell._hoveredColor : cell._textColor;
        }
		if (img = cell.getIcon()) {
			var x = cx;
			var y = cy;
			var w = img.width;
			var h = img.height;
			switch (loc) {
                case IconLocation.RIGHT:
				case IconLocation.RIGHT_SIDE:
                    x = r.right() - w - iconOff;
                    switch (cell.iconAlignment()) {
                        case Alignment.CENTER:
                            y += (ch - h + 1) / 2;
                            break;
                        case Alignment.FAR:
                            y += ch - h;
                            break;
                    }
                    cw -= iconOff + w + iconGap;
                    if (loc === IconLocation.RIGHT && text) {
                        switch (align) {
                            case Alignment.NEAR:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dx = cw - tr.width;
                                if (dx > 0) {
                                    x -= dx;
                                }
                                break;
                            case Alignment.FAR:
                                break;
                            case Alignment.CENTER:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dx = _int((cw - tr.width) / 2);
                                if (dx > 0) {
                                    x -= dx;
                                    cx = x - iconGap - tr.width;
                                    cw = tr.width;
                                }
                                break;
                        }
                    }
                    break;
                case IconLocation.TOP:
				case IconLocation.TOP_SIDE:
                    y += iconOff;
                    switch (cell.iconAlignment()) {
                        case Alignment.CENTER:
                            x += (cw - w) / 2;
                            break;
                        case Alignment.FAR:
                            x += cw - w;
                            break;
                    }
                    dy = iconOff + h + iconGap;
                    cy += dy;
                    ch -= dy;
                    if (loc === IconLocation.TOP && text) {
                        switch (valign) {
                            case Alignment.NEAR:
                                break;
                            case Alignment.FAR:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dy = ch - tr.height;
                                if (dy > 0) {
                                    y += dy;
                                }
                                break;
                            case Alignment.CENTER:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dy = _int((ch - tr.height) / 2);
                                if (dy > 0) {
                                    y += dy;
                                    cy = y + h + iconGap;
                                    ch = tr.height;
                                }
                                break;
                        }
                    }
                    break;
                case IconLocation.BOTTOM:
				case IconLocation.BOTTOM_SIDE:
                    y = r.bottom() - h - iconOff;
                    switch (cell.iconAlignment()) {
                        case Alignment.CENTER:
                            x += (cw - w) / 2;
                            break;
                        case Alignment.FAR:
                            x += cw - w;
                            break;
                    }
                    ch -= iconOff + h + iconGap;
                    if (loc === IconLocation.BOTTOM && text) {
                        switch (valign) {
                            case Alignment.NEAR:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dy = ch - tr.height;
                                if (dy > 0) {
                                    y -= dy;
                                }
                                break;
                            case Alignment.FAR:
                                break;
                            case Alignment.CENTER:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dy = _int((ch - tr.height) / 2);
                                if (dy > 0) {
                                    y -= dy;
                                    cy = y - iconGap - tr.height;
                                    ch = tr.height;
                                }
                                break;
                        }
                    }
                    break;
                case IconLocation.LEFT:
				case IconLocation.LEFT_SIDE:
                    x += iconOff;
                    switch (cell.iconAlignment()) {
                        case Alignment.CENTER:
                            y += (ch - h + 1) / 2;
                            break;
                        case Alignment.FAR:
                            y += ch - h;
                            break;
                    }
                    dx = iconOff + w + iconGap;
                    cx += dx;
                    cw -= dx;
                    if (loc === IconLocation.LEFT && text) {
                        switch (align) {
                            case Alignment.NEAR:
                                break;
                            case Alignment.FAR:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dx = cw - tr.width;
                                if (dx > 0) {
                                    x += dx;
                                }
                                break;
                            case Alignment.CENTER:
                                tr = cell._calcTextRect(g, font, text, cx, cy, cw, ch);
                                dx = _int((cw - tr.width) / 2);
                                if (dx > 0) {
                                    x += dx;
                                    cx = x + w + iconGap;
                                    cw = tr.width;
                                }
                                break;
                        }
                    }
                    break;
                case IconLocation.CENTER:
                    x += (cw - w) / 2;
                    y += (ch - h) / 2;
                    text = null;
                    break;
				case IconLocation.CENTER_BACK:
					x += (cw - w) / 2;
					y += (ch - h) / 2;
					break;
                default:
                    img = null;
                    break;
			}
			if (img) {
				g.drawImageAlphaI(img, cell.iconAlpha(), x, y, w, h);
			}
		}
		if (text) {
            cell._renderTextBounds(g, text, fill, cx, cy, cw, ch);
			if (textRect) {
				textRect.copy(cell._calcTextRect(g, font, text, cx, cy, cw, ch));
			}
		} else if (textRect) {
			if (img) {
				textRect.set(x, y, img.width, img.height);
			} else {
				textRect.width = textRect.height = 0;
			}
		}
	}
});
var ImageCellRenderer = defineClass("ImageCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(100);
	},
    imageDisplay: EnumProp(ImageDisplay, ImageDisplay.NORMAL),
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var url = cell.value();
		if (url) {
			var img = cell.grid().getImage(url);
			if (img && (w = img.width) > 0 && (h = img.height) > 0) {
				return {width: img.width + cell.paddingHorz(), height: hintHeight};
			}
		}
		return this._super(grid, cell, hintWidth, hintHeight);
	},
    _doMeasureHeight: function (grid, cell, width, maxHeight) {
        var h = 0;
        var url = cell.value();
        if (url) {
            var img = cell.grid().getImage(url);
            h += img ? img.height : 0;
        }
        return h + cell.paddingVert();
    },
	render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var img, w, h, x, y, ratio, rw, rh,
			url = cell.value();
		if (url) {
			img = cell.grid().getImage(url);
			if (img && (w = img.width) > 0 && (h = img.height) > 0) {
				x = r.x;
				y = r.y;
				switch (this._imageDisplay) {
					case ImageDisplay.CENTER:
						x += (r.width - w) / 2;
						y += (r.height - h) / 2;
						break;
					case ImageDisplay.BOTH:
						w = r.width;
						h = r.height;
						break;
					case ImageDisplay.WIDTH:
						w = r.width;
						y += (r.height - h) / 2;
						break;
					case ImageDisplay.HEIGHT:
						h = r.height;
						x += (r.width - w) / 2;
						break;
					case ImageDisplay.AUTO:
						rw = r.width / w;
						rh = r.height / h;
						ratio = Math.min(r.width / w, r.height / h);
						w = w * ratio;
						h = h * ratio;
						if (rw > rh) {
							x += (r.width - w) / 2;
						} else {
							y += (r.height - h) / 2;
						}
						break;
					case ImageDisplay.DEFAULT:
					default:
						break;
				}
                g.save();
                g.clipRect(r);
                g.drawImageAlpha(img, cell.iconAlpha(), x, y, w, h);
                g.restore();
			} else {
            }
		}
	},
	renderHtml: function (cell, r) {
		this.render(cell, cell.$_getGraphics(true, r), r);
	}
});
/** @abstract */
var ClickableCellRenderer = defineClass("ClickableCellRenderer", DataCellRenderer, {
	init : function() {
		this._super();
	},
	alwaysRedraw: false,
	isClickable: function (cell) {
		return true;
	},
	performClick: function (cell, x, y) {
		return this._doClick(cell.index());
	},
	render: function(cell, g, r) {
	},
	_getClickSource: function () {
		return null;
	},
	_getClickData: function () {
		return null;
	},
	_doClick: function (index, x, y) {
		var data = this._getClickData(index);
		if (data) {
			this._fireClicked(index, this._getClickSource(), data);
			return true;
		}
		return false;
	},
	_fireClicked: function (index, source, data) {
		var grid = index.grid();
		grid && grid.fireEvent(GridBase.CLICKABLE_CELL_CLICKED, index, source, data);
	}
});
ClickableCellRenderer.LINKABLE_CELL = "linkableCell";
ClickableCellRenderer.DATA_BUTTON_CELL = "dataButtonCell";
var LinkCellRenderer = defineClass("LinkCellRenderer", ClickableCellRenderer, {
	init : function() {
		this._super();
		this._urlFunc = null;
		this._reqFields = null;
		this._urlStatement = new ExpressionStatement(null, true);
		this._urlRuntime = new LinkCellRendererRuntime();
		this._textRect = new Rectangle();
        this.setShowTooltip(true);
	},
	urlCallback: null,
	urlField: null,
	url: null,
	requiredFields: null,
    /** @Deprecated use showTooltip instead */
	showUrl: true,
    showUrl_: function () {
        return this.showTooltip();
    },
    setShowUrl: function (value) {
        this.setShowTooltip(value);
    },
	setUrlCallback: function (value) {
		if (value !== this._urlCallback) {
			this._urlCallback = value;
			if (typeof value == "function") {
				this._urlFunc = value;
			} else if (typeof value == "string") {
				this._urlFunc = eval('({func: function(ds, index){' + value + '}})').func;
			} else {
				this._urlFunc = null;
			}
		}
	},
	setUrl: function (value) {
		if (value != this._url) {
			this._url = value;
			this._urlStatement.setSource(value);
			this._changed();
		}
	},
	setRequiredFields: function (value) {
		if (value != this._requiredFields) {
			this._requiredFields = value;
			if (value) {
				this._reqFields = value.split(',');
			} else {
				this._reqFields = null;
			}
		}
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
        return IconCellRenderer.measure(grid, cell, this._getText(cell), hintWidth, hintHeight);
	},
	render: function (cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var s = cell.iconLocation() != IconLocation.CENTER ? this._getText(cell) : null;
		IconCellRenderer.renderBitmapText(cell, s, g, r, cell._hovered, this._textRect);
		cell.$_clickRect = this._textRect.clone();
	},
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    },
	_getClickSource: function () {
		return ClickableCellRenderer.LINKABLE_CELL;
	},
	_getClickData: function (index) {
		return this._getUrl(index);
	},
	_getTooltipText: function (cell) {
        return this._getUrl(cell.index());
	},
	_getUrl: function (index) {
		if (!index || !index.column) {
			return null;
		}
        var grid = index.column.grid();
		var row = index.getRow(grid);
		if (!row) {
			return null;
		}
		var ds = row.dataSource();
		if (ds) {
			if (this.$_checkRequiredFields(ds, row)) {
				if (this._urlField) {
					var fld = ds.getFieldIndex(this._urlField);
					if (fld >= 0) {
						return row.getValue(fld);
					}
				} else if (typeof this._urlFunc == "function") {
					return this._urlFunc.call(window, grid, ds, index);
				} else if (this._url) {
					this._urlRuntime.setIndex(index);
					return this._urlStatement.evaluate(this._urlRuntime);
				} else {
					return index.getValue();
				}
			}
		}
		return null;
	},
	$_checkRequiredFields: function (ds, row) {
		if (this._reqFields) {
			var flds = ds.getValidFields(this._reqFields);
			if (flds && flds.length > 0) {
				for (var i = flds.length; i--;) {
					var f = flds[i];
					var v = row.getValue(f.index());
					if (f.isEmpty(v)) {
						return false;
					}
				}
			}
		}
		return true;
	}
});
var ButtonCellRenderer = defineClass("ButtonCellRenderer", ClickableCellRenderer, {
	init : function() {
		this._super();
		this._exprNode = null;
		this._alwaysRedraw = true;
	},
	imageUrl: null,
	disabledImageUrl: null,
	hoveredImageUrl: null,
	disableHoveredImageUrl: null,
	activeImageUrl: null,
	text: null,
	hoveredText: undefined,
	disabledText: undefined,
	disableHoveredText: undefined,
	textVisible: true,
	enabledExpression: null,
	enabledCallback: null, // function (index:CellIndex):Boolean;
	textOnImage: true,
	textPadding: 5,
    downOffset: IntProp_0,
    imageDisplay: EnumProp(ImageDisplay, ImageDisplay.CENTER),
	setEnabledExpression: function (value) {
		value = _trim(value);
		if (value != this._enabledExpression) {
			this._enabledExpression = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value) : UNDEFINED;
			this._changed();
		}
	},
	setEnabledCallback: function (value) {
		value = _asFunction(value);
		if (value !== this._enabledCallback) {
			this._enabledCallback = value;
			this._changed();
		}
	},
    ptInButton: function (cell, bx, by) {
        var url, img, w, h, br,
            r = this._rect,
            x = r.x,
            y = r.y;
        url = this._hoveredImageUrl || this._imageUrl;
        img = url && cell._grid.getImage(url);
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            br = this.$_calcBounds(r, w, h);
            return (bx >= br.x && bx <= br.x + br.w && by >= br.y && by <= br.y + br.h);
        }
    },
    isButton: function () {
        return true;
    },
	isClickable: function (cell) {
		return this._getEnabled(cell);
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var sz,
            w = 0,
		    img = cell.grid().getImage(this._imageUrl);
		if (img && img.width) {
			w = img.width;
		}
		sz = cell._measureText(this._getText(cell), 1000000, hintHeight);
		sz.width = Math.max(w, sz.width);
		return sz;
	},
	_getEnabled: function (cell) {
		if (cell) {
			if (this._enabledCallback) {
				return this._enabledCallback(cell.index());
			}
			if (this._exprNode) {
				return this._exprNode.evaluate(cell._grid.cellRendererRuntime().setCell(cell));
			}
		}
		return true;
	},
	render: function (cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
		var s, x, y, w, h, url, img, br,
            tv = this._textVisible,
        	grid = cell._grid,
			enabled = this._getEnabled(cell);
        cell.setClickable(enabled);
        url = this._imageUrl;
		if (tv) {
			s = _defined(this._text) ? this._text : this._getText(cell);
		}
		if (!enabled) {
			s = tv && _defined(this._disabledText) ? this._disabledText : s;
			url = this._disabledImageUrl || url;
            if (cell.hovered()) {
                url = this._disableHoveredImageUrl || url;
                s = tv && _defined(this._disableHoveredText) ? this._disableHoveredText : s;
            }
		} else if (cell.pressed()) {
			url = this._activeImageUrl || url;
		} else if (cell.hovered()) {
			url = this._hoveredImageUrl || url;
			s = tv && _defined(this._hoveredText) ? this._hoveredText : s;
		}
        img = grid.getImage(url) || grid.getImage(this._imageUrl);
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            br = this.$_calcBounds(r, w, h);
            if (cell.pressed() && enabled) {
				br.x += this._downOffset;
				br.y += this._downOffset;
			}
            g.drawImage(img, br.x, br.y, br.w, br.h);
			if (this._textOnImage) {
				br.x += this._textPadding;
				br.w -= this._textPadding * 2;
				r.set(br.x, br.y, br.w, br.h);
			}
        }
		if (s) {
			cell._renderTextBounds(g, s, cell._textColor, r.x, r.y, r.width, r.height);
			/*
			switch (cell.textWrap()) {
				case TextWrap.EXPLICIT:
					g.drawTextBoundsExplicit(cell.font(), cell.color(), s, r.x, r.y, r.width, r.height, cell.textAlign(), cell.lineAlign());
					break;
				case TextWrap.NORMAL:
					g.drawTextBoundsWrap(cell.font(), cell.color(), s, r.x, r.y, r.width, r.height, cell.textAlign(), cell.lineAlign());
					break;
				default:
					g.drawTextBounds(cell.font(), cell.color(), s, r.x, r.y, r.width, r.height, cell.textAlign(), cell.lineAlign());
					break;
			}
			*/
		}
	},
    renderHtml: function (cell, r) {
		this.render(cell, cell.$_getGraphics(true), r);
		/*
        if (!(r = this._getRenderRect(cell, r))) return;
        var span = this._text || cell.$_prepareSpan();
        var s = this._textVisible ? this._getText(cell) : "";
        Dom.renderTextBounds(span, cell.font(), cell.color(), s, r.x, r.y, r.width, r.height, cell.textAlign(), cell.lineAlign());
        */
    },
    $_calcBounds: function (r, w, h) {
        var x = r.x,
            y = r.y;
        switch (this._imageDisplay) {
            case ImageDisplay.CENTER:
                x += (r.width - w) / 2;
                y += (r.height - h) / 2;
                break;
            case ImageDisplay.BOTH:
                w = r.width;
                h = r.height;
                break;
            case ImageDisplay.WIDTH:
                w = r.width;
                y += (r.height - h) / 2;
                break;
            case ImageDisplay.HEIGHT:
                h = r.height;
                x += (r.width - w) / 2;
                break;
            case ImageDisplay.AUTO:
                rw = r.width / w;
                rh = r.height / h;
                ratio = Math.min(r.width / w, r.height / h);
                w = w * ratio;
                h = h * ratio;
                if (rw > rh) {
                    x += (r.width - w) / 2;
                } else {
                    y += (r.height - h) / 2;
                }
                break;
            case ImageDisplay.DEFAULT:
            default:
                x += (r.width - w) / 2;
                y += (r.height - h) / 2;
                break;
        }
        return {
            x: x,
            y: y,
            w: w,
            h: h
        };
    }
});
var SeriesTextCellRenderer = defineClass("SeriesTextCellRenderer", TextCellRenderer, {
	init: function () {
		this._super();
	},
	_getText: function (cell) {
		var vals = cell.value();
		return _isArray(vals) ? SeriesCell.getText(vals) : this._super(cell);
	}
});
SeriesTextCellRenderer.Default = new SeriesTextCellRenderer();
/** @abstract */
var SeriesCellRenderer = defineClass("SeriesCellRenderer", DataCellRenderer, {
	init: function () {
		this._super();
		this.setMinWidth(100);
	},
	_getValues: function (cell) {
		var vals = cell.value();
		return _isArray(vals) ? vals : [vals];
	},
	_getLabels: function (cell) {
		var labels = cell.labels();
		return _isArray(labels) ? labels : [labels];
	}
}); 
/** @abstract */
var SparkChartRenderer = defineClass("SparkChartRenderer", SeriesCellRenderer, {
	init: function() {
		this._super();
        /*
		this._firstBrush = null;// SolidPen.GRAY;
		this._lastBrush = null;// SolidPen.GRAY;
		this._highBrush = null;// SolidPen.GRAY;
		this._lowBrush = null;// SolidPen.GRAY;
		this._belowBrush = null;// SolidPen.GRAY;
		*/
	},
	baseValue: NaN,
	firstColor: null,
	lastColor: null,
	highColor: null,
	lowColor: null,
	belowColor: null,
	setFirstColor: function (value) {
		if (value != this._firstColor) {
			this._firstBrush = value ? new SolidBrush(this._firstColor = value) : null;
			this._changed();
		}
	},
	setLastColor: function (value) {
		if (value != this._lastColor) {
			this._lastBrush = value ? new SolidBrush(this._lastColor = value) : null;
			this._changed();
		}
	},
	setHighColor: function (value) {
		if (value != this._highColor) {
			this._highBrush = value ? new SolidBrush(this._highColor = value) : null;
			this._changed();
		}
	},
	setLowColor: function (value) {
		if (value != this._lowColor) {
			this._lowBrush = value ? new SolidBrush(this._lowColor = value) : null;
			this._changed();
		}
	},
	setBelowColor: function (value) {
		if (value != this._belowColor) {
			this._belowBrush = value ? new SolidBrush(this._belowColor = value) : null;
			this._changed();
		}
	},
	render: function (cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
		var i, v, base, cnt, min, max,
			values = this._getValues(cell);
		if (values && values.length > 0) {
			cnt = values.length;
			min = values[0];
			max = values[0];
			i = 1;
			while (isNaN(min) && i < cnt) {
				max = min = values[i++];
			}
			for (; i < cnt; i++) {
				v = Number(values[i]);
				if (!isNaN(v)) {
					if (v < min) min = v;
					if (v > max) max = v;
				}
			}
			base = isNaN(this._baseValue) ? min : this._baseValue;
			if (!isNaN(min)) {
				this._renderChart(cell, g, r, values, min, max, base);
			}
		}
	},
	renderHtml: function (cell, r) {
		this.render(cell, cell.$_getGraphics(true), r);
	},
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
	},
	_getPoints: function (cell, r, values, minimum, maximum) {
		var i, x, y, v,
			cnt = values.length,
			pts = [],
			sx = r.x,
			w = r.width,
			sy = r.y,
			h = r.height,
			len = maximum - minimum;
		for (i = 0; i < cnt; i++) {
			v = Number(values[i]);
			x = sx + i / (cnt - 1) * w;
			y = sy + ((isNaN(v) || len == 0) ? h : (1 - (v - minimum) / len) * h);
			pts.push(x, y);
		}
		return pts;
	},
	_getBasePoint: function (cell, r, minimum, maximum, base) {
		var h = r.height,
		    len = maximum - minimum;
		return r.y + ((isNaN(base) || len == 0) ? h : (1 - (base - minimum) / len) * h);
	}
}); 
var SparkLineRenderer = defineClass("SparkLineRenderer", SparkChartRenderer, {
	init : function() {
		this._super();
        this._stroke = new SolidPen(this._lineColor);
        this._selStroke = new SolidPen(this._selectedLineColor);
	},
	curved: false,
    lineColor: '#808080',
    selectedLineColor: '#fff',
    setLineColor: function (value) {
        if (value != this._lineColor) {
            this._lineColor = value;
            this._stroke = value ? new SolidPen(value) : null;
        }
    },
    setSelectedLineColor: function (value) {
        if (value != this._selectedLineColor) {
            this._selectedLineColor = value;
            this._selStroke = value ? new SolidPen(value) : null;
        }
    },
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
        var i, x, y, fill,
		    stroke = (cell._selected ? (this._selStroke || this._stroke) : this._stroke) || cell._line,
		    max = maximum,//isNaN(base) ? maximum : Math.max(maximum, base),
		    min = minimum,//isNaN(base) ? minimum : Math.min(minimum, base),
		    pts = this._getPoints(cell, r, values, min, max),
		    cnt = values.length;
        if (stroke) {
            for (i = 0; i < cnt - 1; i++) {
                g.drawLine(stroke, pts[i * 2], pts[i * 2 + 1], pts[(i + 1) * 2], pts[(i + 1) * 2 + 1]);
            }
        }
		if (fill = this._firstBrush) {
			x = pts[0];
			y = pts[1];
			g.drawCircle(fill, null, x, y, 2);
		}
		if (fill = this._lastBrush) {
			x = pts[(cnt - 1) * 2];
			y = pts[(cnt - 1) * 2 + 1];
			g.drawCircle(fill, null, x, y, 2);
		}
		if (fill = this._highBrush) {
			for (i = 0; i < cnt; i++) {
				if (values[i] >= maximum) {
					x = pts[i * 2];
					y = pts[i * 2 + 1];
					g.drawCircle(fill, null, x, y, 2);
				}
			}
		}
		if (fill = this._lowBrush) {
			for (i = 0; i < cnt; i++) {
				if (values[i] <= minimum) {
					x = pts[i * 2];
					y = pts[i * 2 + 1];
					g.drawCircle(fill, null, x, y, 2);
				}
			}
		}
	}
}); 
var SparkColumnRenderer = defineClass("SparkColumnRenderer", SparkChartRenderer, {
	init: function() {
		this._super();
	},
	barWidth: 0.8,
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
		var max, vmin, min, cnt, p, w, h, x, len, cw, i, v, f, y,
			fill = (cell._selected && cell._shapeSelectedColor) || cell._shapeColor;
		if (!fill) {
			return;
		}
		max = maximum;// isNaN(base) ? maximum : Math.max(maximum, base);
		min = minimum;//isNaN(base) ? minimum : Math.min(minimum, base);
		if (!isNaN(base)) {
			min = base;// Math.min(base, min);
			max = Math.max(max, base);
		}
		vmin = min;
		min -= (max - min) * 0.1;
		cnt = values.length;
		len = max - min;
		p = _int(this._getBasePoint(cell, r, min, max));//base));
		w = r.width / cnt;
		h = r.height;
		x = r.x + w / 2;
		cw = _int(w * this._barWidth);
		for (i = 0; i < cnt; i++) {
			v = values[i];
			if (!isNaN(v) && v >= vmin) {
				if (v <= minimum && this._lowBrush) {
					f = this._lowBrush;
				} else if (v >= maximum && this._highBrush) {
					f = this._highBrush;
				}/* else if (v < base && this._belowBrush) {
					f = this._belowBrush;
				}*/ else {
					f = fill;
				}
				y = len == 0 ? 1 : Math.max(1, _int((v - min) * h / len));
				g.drawBoundsI(f, null, _int(x - cw / 2), p, cw, -y);
			}
			x += w;
		}
	}
}); 
var SparkWinLossRenderer = defineClass("SparkWinLossRenderer", SparkChartRenderer, {
	init: function() {
		this._super();
		this.setBaseValue(0);
	},
	barWidth: 0.8,
	belowHeight: 0.4,
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
		var fill = (cell._selected && cell._shapeSelectedColor) || cell._shapeColor;
		if (!fill) {
			return;
		}
		var i, v, f, y,
		    cnt = values.length,
		    w = r.width / cnt,
		    h = r.height,
		    x = r.x + w / 2,
		    sy = r.y,
		    cw = w * this._barWidth,
		    p = sy + h * (1 - this._belowHeight);
		for (i = 0; i < cnt; i++) {
			v = values[i];
			if (!isNaN(v) && v != base) {
				f = fill;
				if (v < base && this._belowBrush) {
					f = this._belowBrush;
				}
				y = (v < base) ? (sy + h) : sy;
				g.drawBoundsI(f, null, _int(x - cw / 2), _int(y), _int(cw), _int(p - y));
			}
			x += w;
		}
	}
}); 
var SeriesLegendCellRenderer = defineClass("SeriesLegendRenderer", SeriesCellRenderer, {
    init: function () {
        this._super();
    },
    labels: null,
    direction: "horizontal",    // "horizontal", "vertical"
    displayCount: IntProp_0,
    itemGap: IntProp(10),
    lineGap: IntProp(2),
    wrapable: false,
    setLabels: function (value) {
        if (value !== this._labels) {
            this._labels = _isArray(value) ? value : null;
        }
    },
    render: function (cell, g, r) {
        var labels = this._labels || this._getLabels(cell);
        if (labels) {
            var cnt = Math.min(cell.fieldCount(), this._displayCount > 0 ? Math.min(this._displayCount, labels.length) : labels.length);
            if (cnt > 0) {
                cell.deflatePadding2(r);
                if (this._direction === "vertical") {
                    this.$_renderVert(cell, g, r, labels, cnt);
                } else {
                    this.$_renderHorz(cell, g, r, labels, cnt);
                }
                cell.inflatePadding2(r);
            }
        }
    },
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    },
    $_renderHorz: function (cell, g, r, labels, cnt) {
        var i, s, tr, lines, widths, len, j, k, n, y3, max, w2, f,
            font = cell.font(),
            color = cell.color(),
            fill = cell.shapeColor(),
            fills = cell.shapeColors(),
            stroke = cell.shapeBorder(),
            shapeGap = cell.shapePadding(),
            hText = font.size,
            dim = cell.shapeSize() || DEF_SIZE,
            hShape = _int(dim.getDimension(hText)),
            wShape = _int(hShape * 1.2),
            hLine = Math.max(hText, hShape),
            itemGap = this._itemGap,
            lineGap = this._lineGap,
            y = (r.y + (r.height - hText) / 2),
            y2 = y + hText - hShape,// (r.y + (r.height - hShape) / 2),
            x = 0,
            w = cnt * (wShape + shapeGap) + (cnt - 1) * itemGap,
            wTexts = [];
        for (i = 0; i < cnt; i++) {
            s = labels[i];
            tr = cell._calcTextRectEx(g, font, s, 0, 0, 10000, 10000, null, null, false);
            w += wTexts[i] = tr.width;
        }
        if (w > r.width && this.wrapable) {
            lines = [];
            widths = [];
            w = 0;
            i = 0;
            max = 0;
            while (i < cnt) {
                if (w == 0) {
                    w = wTexts[i] + wShape + shapeGap;
                    lines.push(i);
                    i++;
                } else {
                    w2 = wTexts[i] + wShape + shapeGap + itemGap;
                    w;
                    if (w + w2 > r.width) {
                        max = Math.max(max, w);
                        widths.push(w);
                        w = 0;
                    } else {
                        w += w2;
                        i++;
                    }
                }
            }
            max = Math.max(max, w);
            widths.push(w);
            len = lines.length;
            y3 = Math.max(r.y, r.y + (r.height - hLine * len - lineGap * (len - 1)) / 2);
            for (i = 0, j = 0; j < len; j++) {
                n = j < lines.length - 1 ? lines[j + 1] : cnt;
                x = Math.max(r.x, r.x + (r.width - widths[j]) / 2);
                if (j > 0) {
                    y3 += hLine + lineGap;
                }
                y = y3 + (hLine - hText) / 2;
                y2 = y3 + hText - hShape;// (y3 + (hLine - hShape) / 2);
                while (i < n) {
                    var f = fills ? fills.getItem(i) : fill;
                    if (f || stroke) {
                        g.drawBoundsI(f, stroke, x, y2, wShape, hShape);
                        x += wShape + shapeGap;
                    }
                    g.drawText(font, color, labels[i], x, y);
                    x += wTexts[i] + itemGap;
                    i++;
                }
            }
        } else {
            x = r.x + _int((r.width - w) / 2);
            for (i = 0; i < cnt; i++) {
                f = fills ? fills.getItem(i) : fill;
                if (f || stroke) {
                    g.drawBoundsI(f, stroke, x, y2, wShape, hShape);
                    x += wShape + shapeGap;
                }
                g.drawText(font, color, labels[i], x, y);
                x += wTexts[i] + itemGap;
            }
        }
    },
    $_renderVert: function (cell, g, r, labels, cnt) {
        var i, s, tr, x2, y, y2, y3, lines, widths, f,
            len, j, k, n, y3, max, w2,
            font = cell.font(),
            color = cell.color(),
            fill = cell.shapeColor(),
            fills = cell.shapeColors(),
            stroke = cell.shapeBorder(),
            shapeGap = cell.shapePadding(),
            hText = font.size,
            dim = cell.shapeSize() || DEF_SIZE,
            hShape = _int(dim.getDimension(hText)),
            wShape = _int(hShape * 1.2),
            hLine = Math.max(hText, hShape),
            itemGap = this._itemGap,
            lineGap = this._lineGap,
            x = 0,
            wTexts = [],
            h = cnt * hLine + (cnt - 1) * itemGap,
            w = 0;
        if (h > r.height && this.wrapable) {
            lines = [];
            widths = [];
            h = 0;
            i = 0;
            while (i < cnt) {
                h += hLine + itemGap;
                if (h > r.height) {
                    break;
                }
                i++;
            }
            k = Math.ceil(cnt / Math.max(i, 1));
            for (j = 0; j < k; j++) {
                lines[j] = j * i;
            }
            lines.push(cnt);
            h = hLine * lines[1] + itemGap * (lines[1] - 1);
            len = lines.length - 1;
            i = 0;
            w2 = 0;
            for (j = 0; j < len; j++) {
                w = 0;
                for (k = lines[j]; k < lines[j + 1] && i < cnt; k++, i++) {
                    s = labels[i];
                    tr = cell._calcTextRectEx(g, font, s, 0, 0, 10000, 10000, null, null, false);
                    w = Math.max(w, tr.width);
                }
                w2 += widths[j] = w + wShape + shapeGap;
            }
            w2 += lineGap * (len - 1);
            x = Math.max(r.x, r.x + (r.width - w2) / 2);
            y2 = Math.max(r.y, r.y + (r.height - h) / 2);
            for (i = 0, j = 0; j < len; j++) {
                n = j < lines.length - 1 ? lines[j + 1] : cnt;
                y = y2;
                while (i < n) {
                    var f = fills ? fills.getItem(i) : fill;
                    if (f || stroke) {
                        y3 = y + hText - hShape;
                        g.drawBoundsI(f, stroke, x, y3, wShape, hShape);
                    }
                    y3 = (y + (hLine - hText) / 2);
                    g.drawText(font, color, labels[i], x + wShape + shapeGap, y3);
                    y += hLine + itemGap;
                    i++;
                }
                x += widths[j] + lineGap;
            }
        } else {
            for (i = 0; i < cnt; i++) {
                s = labels[i];
                tr = cell._calcTextRectEx(g, font, s, 0, 0, 10000, 10000, null, null, false);
                w = Math.max(w, wTexts[i] = tr.width);
            }
            w += wShape + shapeGap;
            x = Math.max(r.x, r.x + _int((r.width - w) / 2));
            x2 = x + wShape + shapeGap;
            y3 = r.y + (r.height - h) / 2;
            for (i = 0; i < cnt; i++) {
                y = (y3 + (hLine - hText) / 2);
                y2 = y + hText - hShape;// (r.y + (r.height - hShape) / 2);
                f = fills ? fills.getItem(i) : fill;
                if (f || stroke) {
                    g.drawBoundsI(f, stroke, x, y2, wShape, hShape);
                }
                g.drawText(font, color, labels[i], x2, y);
                y3 += hLine + itemGap;
            }
        }
    }
}, {
    DEF_SIZE: new Dimension("80%")
});
var GaugeDirection = _enum("GaugeDirection", {
    LEFT: "left",
    RIHGT: "right",
    TOP: "top",
    BOTTOM: "bottom"
});
var GaugeValueLocation = _enum("", {
    DEFAULT: "default",
    INNER: "innder",
    TOP: "top",
    BOTTOM: "bottom",
    LEFT: "left",
    TOP: "top"
});
var GaugeLabelLocation = _enum("GaugeLabelLocation", {
    NONE: "none",
    DEFAULT: "default",
    START: "start",
    END: "end",
    CENTER: "center",
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
    TOP_LEFT: "topLeft",
    TOP_RIGHT: "topRight",
    BOTTOM_LEFT: "bottomLeft",
    BOTTOM_RIGHT: "bottomRight"
});
var GaugeBodyShape = _enum("GaugeBodyShape", {
    DEFAULT: "default",
    INCLINED: "incremental",
    REVERED: "reversed"
});
var ValueHandShape = _enum("ValueHandShape", {
    TRIANGLE: "triangle"
});
var ValueHandLocation = _enum("", {
    NONE: "none",
    DEFAULT: "default",
    TOP: "top",
    BOTTOM: "bottom",
    LEFT: "left",
    RIGHT: "right"
});
var GaugeRange = defineClass("GaugeRange", null, {
    init: function () {
        this._super();
    },
    startValue: undefined,
    endValue: undefined,
    label: null,
    background: SolidBrush.LTGRAY,
    border: null,
    thickness: 1.0,
    setBackground: function (value) {
        if (value !== this._background) {
            this._background = _createFill(value);
        }
    },
    setBorder: function (value) {
        if (value !== this._border) {
            this._border = _createStroke(value);
        }
    }
});
var GaugeRangeCollection = defineClass("GaugeRangeCollection", null, {
    init: function () {
        this._super();
        this._items = [];
    },
    count: function () {
        return this._items.length;
    },
    getItem: function (index) {
        return this._items[index];
    },
    clear: function () {
    },
    assign: function (value) {
        var items = this._items = [];
        var i, r;
        if (value instanceof GaugeRangeCollection) {
            for (i = 0; i < value.count(); i++) {
                r = value.getItem(i);
                if (r instanceof GaugeRange) {
                    items.push(r.clone());
                }
            }
        } else if (_isArray(value)) {
            for (i = 0; i < value.length; i++) {
                r = value[i];
                if (r) {
                    items.push(new GaugeRange().assign(r));
                }
            }
        }
    }
});
var GaugeScale = defineClass("GaugeScale", null, {
    init: function () {
        this._super();
        this._font = this.$_parseFont();
    },
    ticks: null,
    tickLength: 3,
    fontName: null,
    fontSize: 10,
    lineStroke: SolidPen.GRAY,
    tickStroke: SolidPen.GRAY,
    color: SolidBrush.GRAY,
    labelVisible: true,
    labelForamt: null,
    setTicks: function (value) {
        if (value !== this._ticks) {
            this._ticks = _isArray(value) ? value.concat() : null;
        }
    },
    setFontName: function (value) {
        if (value != this._fontName) {
            this._fontName = value;
            this._font = this.$_parseFont();
        }
    },
    setFontSizee: function (value) {
        if (value != this._fontSize) {
            this._fontSize = value;
            this._font = this.$_parseFont();
        }
    },
    setLineStroke: function (value) {
        if (value !== this._lineStroke) {
            this._lineStroke = _createStroke(value);
        }
    },
    setTickStroke: function (value) {
        if (value !== this._tickStroke) {
            this._tickStroke = _createStroke(value);
        }
    },
    setColor: function (value) {
        if (value !== this._color) {
            this._color = _createFill(value);
        }
    },
    font: function () {
        return this._font;
    },
    visible: function () {
        return this._ticks && this._ticks.length > 0;
    },
    getHeight: function () {
        return this._tickLength + (this._labelVisible ? this._font.size : 0);
    },
    $_parseFont: function () {
        return { font: (this._fontSize || 10) + "px " + (this._fontName || "Tahoma"), size: this._fontSize };
    }
});
var ValueHand = defineClass("ValueHand", null, {
    init: function () {
        this._super();
    },
    shape: EnumProp(ValueHandShape, ValueHandShape.TRIANGLE),
    location: EnumProp(ValueHandLocation, ValueHandLocation.DEFAULT),
    width: 9,
    height: 11,
    offset: 0,
    background: SolidBrush.LTGRAY,
    border: SolidPen.DIMGRAY,
    setBackground: function (value) {
        if (value != this._background) {
            this._background = _createFill(value);
        }
    },
    setBorder: function (value) {
        if (value != this._border) {
            this._border = _createStroke(value);
        }
    }
});
var GaugeDrawing = defineClass("GaugeDrawing", null, {
    init : function() {
        this._super();
        this.valueLocation = GaugeValueLocation.DEFAULT;
        this.labelLocation = GaugeLabelLocation.DEFAULT;
        this.labelOffset = 2;
        this.ranges = null;
        this.scale = null;
        this.subScale = null;
        this.rangeScale = null;
        this.bodyShape = GaugeBodyShape.DEFAULT;
        this.thickness = 5;
        this.valueThickness = 1.0;
        this.valueOffset = 2;
        this.baseBorder = null;
        this.baseFill = SolidBrush.LTGRAY;
        this.valueBorder = SolidPen.LTGRAY;
        this.valueFill = SolidBrush.GRAY;
        this.labelOffset = 0;
        this.font = null;
        this.color = SolidBrush.BLACK;
        this.baseValue = undefined;
        this.startValue = 0;
        this.endValue = 100;
        this.value = 0;
        this.text = null;
    },
    draw: function(cell, g, r) {
    }
}, {
    DefFont: { font: "12px Tahoma", size: 12 }
});
var LinearGauge = defineClass("LinearGauge", GaugeDrawing, {
    init : function() {
        this._super();
        this.direction = GaugeDirection.RIGHT;
    },
    draw: function(cell, g, r) {
        switch (this.direction) {
            case GaugeDirection.RIGHT:
                this.$_drawRight(cell, g, r);
                break;
            case GaugeDirection.LEFT:
                break;
            case GaugeDirection.BOTTOM:
                break;
            case GaugeDirection.TOP:
                break;
            default:
                this.$_drawRight(cell, g, r);
                break;
        }
    },
    $_drawRight: function(cell, g, r) {
        var yBase, yScale, yValue, yText, i, cnt, x, fill, stroke, v, ranges, range, v2, ticks, tlen, sfont, scolor, gg, s,
            runtime = this.$_runtime,
            startValue = runtime && !isNaN(runtime.startValue) ? runtime.startValue : this.startValue,
            endValue = runtime && !isNaN(runtime.endValue) ? runtime.endValue : this.endValue,
            s = this.text,
            cw = r.width,
            cx = r.x + cw / 2,
            cy = r.y + r.height / 2,
            x1 = r.x,
            vlen = endValue - startValue,
            wValue = vlen && !isNaN(this.value) ? Math.max(0, Math.min(cw, (this.value - startValue) / vlen * cw)) : this.startValue,
            hBase = this.thickness,
            hValue = this.valueThickness * hBase,
            valueOff = this.valueOffset,
            font = this.font || GaugeDrawing.DefFont,
            hText = font.size + this.labelOffset,
            labelOff = this.labelOffset,
            scale = this.scale && this.scale.visible() ? this.scale : null,
            hScale = scale ? scale.getHeight() : 0;
        switch (this.valueLocation) {
            case GaugeValueLocation.TOP:
                cy += hValue / 2 + valueOff;
                break;
            case GaugeValueLocation.BOTTOM:
                cy -= hValue / 2 + valueOff;
                break;
        }
        switch (this.labelLocation) {
            case GaugeLabelLocation.DEFAULT:
            case GaugeLabelLocation.TOP:
                cy += hText / 2;
                break;
            case GaugeLabelLocation.BOTTOM:
                cy -= hText / 2;
                break;
        }
        cy -= hScale / 2;
        yBase = cy - hBase / 2;
        switch (this.valueLocation) {
            case GaugeValueLocation.TOP:
                yValue = yBase - valueOff - hValue;
                break;
            case GaugeValueLocation.BOTTOM:
                yValue = yBase + hBase + hScale + valueOff;
                break;
            default:
                yValue = cy - hValue / 2;
                break;
        }
        if (scale) {
            yScale = Math.max(yValue + hValue, yBase + hBase);
        }
        switch (this.labelLocation) {
            case GaugeLabelLocation.DEFAULT:
            case GaugeLabelLocation.TOP:
                yText = Math.min(yValue, yBase) - labelOff; // "bottom"으로 정렬한다.
                break;
            case GaugeLabelLocation.BOTTOM:
                yText = Math.max(yValue + hValue, yBase + hBase) + hScale + labelOff; // "top"으로 정렬한다.
                break;
            default:
                yText = Math.min(yValue, yBase) - labelOff; // "bottom"으로 정렬한다.
                break;
        }
        g.drawBoundsI(this.baseFill, null, x1, yBase, cw, hBase);
        ranges = this.ranges;
        if (ranges && (cnt = ranges.count()) > 0) {
            for (i = 0; i < cnt; i++) {
                range = ranges.getItem(i);
                if (range && (fill = range.background()) && !isNaN(v = range.endValue())) {
                    v2 = isNaN(range.startValue()) ? startValue : range.startValue();
                    x = x1 + (v2 - startValue) / vlen * cw;
                    g.drawBoundsI(fill, null, x, yBase, (v - v2) / vlen * cw, hBase);
                }
            }
        }
        g.drawBoundsI(this.valueFill, null, x1, yValue, wValue, hValue);
        if (this.baseBorder) {
            g.drawBoundsI(null, this.baseBorder, x1, yBase, cw, hBase);
        }
        if (scale) {
            ticks = scale.ticks();
            tlen = scale.tickLength();
            sfont = scale.font();
            scolor = scale.color();
            if (stroke = scale.lineStroke()) {
                g.drawHLineI(stroke, yScale, x1, x1 + cw);
            }
            if (tlen > 0) {
                stroke = scale.tickStroke();
            }
            if (tlen > 0 && stroke || scale.labelVisible()) {
                for (i = 0; i < ticks.length; i++) {
                    x = x1 + (ticks[i] - startValue) / vlen * cw;
                    if (tlen > 0 && stroke) {
                        g.drawVLineI(stroke, _int(x), yScale, yScale + tlen);
                    }
                    gg = cell._dom ? cell.$_prepareItemSpan(i) : g;
                    if (i == 0) {
                        cell._renderTextBoundsEx(gg, ticks[i] + "", sfont, scolor, x1, yScale + tlen, cw, 1000, "left", "top");
                    } else if (i == ticks.length - 1) {
                        cell._renderTextBoundsEx(gg, ticks[i] + "", sfont, scolor, x1, yScale + tlen, cw, 1000, "right", "top");
                    } else {
                        cell._renderTextBoundsEx(gg, ticks[i] + "", sfont, scolor, x - 1000, yScale + tlen, 2000, 1000, "center", "top");
                    }
                }
            }
        }
        /*
        var sz = 7;
        p += r.x;
        g.drawPolygonArray(this.valueFill, SolidPen.DIMGRAY, [
            p, y2, p - sz / 2, y2 + sz, p + sz / 2, y2 + sz
        ]);
        */
        s = this.text;
        if (s) {
            /*
            var tw = cell.container().measureText(this.font, s);
            cell._renderTextBoundsEx(g, s, this.font, this.color, Math.max(r.x, p - tw / 2), y2 + sz, tw, r.height, "center", "top");
            */
            cell._renderTextBounds2(g, s, font, this.color, x1, r.y, cw, yText - r.y, "left", "bottom");
        }
    }
});
var CircleGauge = defineClass("CircleGauge", GaugeDrawing, {
    init : function() {
        this._super();
        this.startAngle = 0;
    },
    draw: function(cell, g, r) {
        var s,
            v = this.value,
            cx = r.x + r.width / 2,
            cy = r.y + r.height / 2,
            rd = Math.min(r.width / 2, r.height / 2),
            w = Math.min(rd, this.thickness),
            angle = (v - this.startValue) / (this.endValue - this.startValue) * Math.PI * 2;
        g.drawDounut(this.baseFill, null, cx, cy, rd, w);
        g.drawArcSector2(this.valueFill, null, cx, cy, rd - w, rd - w, rd, rd, 0, angle, 0);
        s = this.text;
        if (s) {
            rd -= this.thickness;
            cell._renderTextBounds2(g, s, this.font, this.color, cx - rd, cy - rd, rd * 2, rd * 2, "center", "center");
        }
    }
});
var BulletGraph = defineClass("BulletGraph", GaugeDrawing, {
    init : function() {
        this._super();
        this.direction = GaugeDirection.RIGHT;
        this.baseBorder = SolidPen.LTGRAY;
        this.targetValue = 77;
        this.targetFill = SolidBrush.DIMGRAY;
        this.targetWidth = 0.7;
    },
    draw: function(cell, g, r) {
        var t, hValue, wTarget, pTarget, s, textOffset,
            v = this.value,
            cw = r.width,
            cx = r.x + cw / 2,
            cy = r.y + r.height / 2,
            tBase = this.thickness,
            yBase = cy - tBase / 2,
            wValue = (v - this.startValue) / (this.endValue - this.startValue) * cw;
        g.drawBoundsI(this.baseFill, null, r.x, yBase, cw, tBase);
        hValue = this.valueThickness * tBase;
        g.drawBoundsI(this.valueFill, null, r.x, cy - hValue / 2 , wValue, hValue);
        if (!isNaN(this.targetValue) && this.targetFill) {
            wTarget = 3;
            pTarget = r.x + (this.targetValue - this.startValue) / (this.endValue - this.startValue) * cw;
            t = this.targetWidth * tBase;
            g.drawBoundsI(this.targetFill, null, pTarget - wTarget / 2, cy - t / 2, wTarget, t);
        }
        if (this.baseBorder) {
            g.drawBoundsI(null, this.baseBorder, r.x, yBase, cw, tBase - 1);
        }
        /*
         var sz = 7;
         p += r.x;
         g.drawPolygonArray(this.valueFill, SolidPen.DIMGRAY, [
         p, y2, p - sz / 2, y2 + sz, p + sz / 2, y2 + sz
         ]);
         */
        s = this.text;
        if (s) {
            /*
             var tw = cell.container().measureText(this.font, s);
             cell._renderTextBoundsEx(g, s, this.font, this.color, Math.max(r.x, p - tw / 2), y2 + sz, tw, r.height, "center", "top");
             */
            textOffset = 2;
            cell._renderTextBoundsEx(g, s, this.font, this.color, r.x, r.y, cw, yBase - r.y - textOffset, "left", "bottom");
        }
    }
});
var GaugeCellRenderer = defineClass("GaugeCellRenderer", DataCellRenderer, {
    init: function () {
        this._super();
        this._gauge = this._createDrawing();
        this._valueLocation = GaugeValueLocation.DEFAULT;
        this._labelLocation = GaugeLabelLocation.DEFAULT;
        this._labelMask = null;     // label이 차지할 영역의 너비를 계산하는데 사용되는 문자열.
        this._labelOffset = 2;
        this._ranges = null;
        this._scale = null;         // 아래쪽, 오른쪽
        this._subScale = null;      // 위쪽, 왼쪽
        this._rangeScale = null;    // scale이나 subscale만 있으면 반대쪽, 없으면 아래쪽, 오른쪽. 모두 있으면 표시하지 못함.
        this.setMinWidth(100);
    },
    valueLocation: GaugeValueLocation.DEFAULT,
    labelLocation: GaugeLabelLocation.DEFAULT,
    labelOffset: 2,
    ranges: null,
    scale: null,
    subScale: null,
    rangeScale: null,
    bodyShape: GaugeBodyShape.DEFAULT,
    thickness: 5,
    valueThickness: 1.0,
    baseValue: undefined,
    startValue: 0,
    endValue: 100,
    /** @deprecated use startValue */
    minValue: 0,
    /** @deprecated use endValue */
    maxValue: 0,
    valueLocation_: function () {
        return this._gauge.valueLocation;
    },
    setValueLocation: function (value) {
        if (value != this._gauge.valueLocation) {
            this._gauge.valueLocation = value;
            this._changed();
        }
    },
    labelLocation_: function () {
        return this._gauge.labelLocation;
    },
    setLabelLocation: function (value) {
        if (value != this._gauge.labelLocation) {
            this._gauge.labelLocation = value;
            this._changed();
        }
    },
    labelOffset_: function () {
        return this._gauge.labelOffset;
    },
    setLabelLocation: function (value) {
        if (value != this._gauge.labelOffset) {
            this._gauge.labelOffset = value;
            this._changed();
        }
    },
    setRanges: function (value) {
        if (value != this._ranges) {
            if (value && !this._ranges) {
                this._ranges = new GaugeRangeCollection();
            }
            this._ranges && this._ranges.assign(value);
            this._gauge.ranges = this._ranges;
            this._changed();
        }
    },
    setScale: function (value) {
        if (value != this._scale) {
            if (value && !this._scale) {
                this._scale = new GaugeScale();
            }
            this._scale && this._scale.assign(value);
            this._gauge.scale = this._scale;
            this._changed();
        }
    },
    setSubScale: function (value) {
        if (value != this._subScale) {
            if (value && !this._subScale) {
                this._subScale = new GaugeScale();
            }
            this._subScale && this._subScale.assign(value);
            this._changed();
        }
    },
    setRangeScale: function (value) {
        if (value != this._rangeScale) {
            if (value && !this._rangeScale) {
                this._rangeScale = new GaugeScale();
            }
            this._rangeScale && this._rangeScale.assign(value);
            this._changed();
        }
    },
    bodyShape_: function () {
        return this._gauge.bodyShape;
    },
    setBodyShape: function (value) {
        if (value != this._gauge.bodyShape) {
            this._gauge.bodyShape = value;
            this._changed();
        }
    },
    thickness_: function () {
        return this._gauge.thickness;
    },
    setThickness: function (value) {
        if (value != this._gauge.thickness) {
            this._gauge.thickness = value;
            this._changed();
        }
    },
    valueThickness_: function () {
        return this._gauge.valueThickness;
    },
    setValueThickness: function (value) {
        if (value != this._gauge.valueThickness) {
            this._gauge.valueThickness = value;
            this._changed();
        }
    },
    baseValue_: function () {
        return this._gauge.baseValue;
    },
    setBaseValue: function (value) {
        if (value != this._gauge.baseValue) {
            this._gauge.baseValue = value;
            this._changed();
        }
    },
    startValue_: function () {
        return this._gauge.startValue;
    },
    setStartValue: function (value) {
        if (value != this._gauge.startValue) {
            this._gauge.startValue = value;
            this._changed();
        }
    },
    endValue_: function () {
        return this._gauge.endValue;
    },
    setEndValue: function (value) {
        if (value != this._gauge.endValue) {
            this._gauge.endValue = value;
            this._changed();
        }
    },
    minValue_: function () {
        return this._gauge.startValue;
    },
    setMinValue: function (value) {
        if (value != this._gauge.startValue) {
            this._gauge.startValue = value;
            this._changed();
        }
    },
    maxValue_: function () {
        return this._gauge.endValue;
    },
    setMaxValue: function (value) {
        if (value != this._gauge.endValue) {
            this._gauge.endValue = value;
            this._changed();
        }
    },
    canAnimate: function () {
        return true;
    },
    render: function(cell, g, r) {
        this._rect.copy(r)
        cell.inflatePadding(r);
        var gauge = this._gauge;
        var anis = cell.getAnimations();
        this._doRender(cell, g, r, gauge, anis);
    },
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    },
    /* abstract */ _createDrawing: function () {
    },
    /* abstract */ _doRender: function (cell, g, r, gauge, anis) {
        var v, s,
            rate = anis ? anis.current() : 1;
        if (rate < 1) {
            v = anis.startValue();
            v = v + (cell.value() - v) * rate;
            s = (cell.numberFormatter().format(v));
        } else {
            v = cell.value();
            s = cell.text();
        }
        gauge.$_runtime = this._runtimeOptions;
        gauge.baseFill = cell.shapeInactiveColor();
        gauge.valueFill = cell.shapeColor();
        gauge.baseBorder = cell.shapeBorder();
        gauge.font = cell.font();
        gauge.color = cell.color();
        gauge.value = v;
        gauge.text = s;
        gauge.draw(cell, g, r);
    }
});
var LinearGaugeCellRenderer = defineClass("LinearGaugeCellRenderer", GaugeCellRenderer, {
    init: function () {
        this._super();
        this.setThickness(11);
    },
    _createDrawing: function () {
        return new LinearGauge();
    }
});
var CircleGaugeCellRenderer = defineClass("CircleGaugeCellRenderer", GaugeCellRenderer, {
	init : function() {
		this._super();
	},
    startAngle: 0,
    startAngle_: function () {
        return this._gauge.startAngle;
    },
    setStartAngle: function (value) {
        if (value != this._gauge.startAngle) {
            this._gauge.startAngle = value;
            this._changed();
        }
    },
    _createDrawing: function () {
        return new CircleGauge();
    }
});
var BulletGraphCellRenderer = defineClass("BulletGraphCellRenderer", GaugeCellRenderer, {
    init : function() {
        this._super();
        this.setThickness(13);
        this.setvalueThickness(0.3);
    },
    targetValue: 0,
    targetValue_: function () {
        return this._gauge.targetValue;
    },
    setTargetValue: function (value) {
        if (value != this._gauge.targetValue) {
            this._gauge.targetValue = value;
            this._changed();
        }
    },
    targetWidth: 0.7,
    targetWidth_: function () {
        return this._gauge.targetWidth;
    },
    setTargetWidth: function (value) {
        if (value != this._gauge.targetWidth) {
            this._gauge.targetWidth = value;
            this._changed();
        }
    },
    _createDrawing: function () {
        return new BulletGraph();
    }
});
var Code39CellRenderer = defineClass("Code39CellRenderer", DataCellRenderer, {
    init: function() {
        this._super();
        this._barcode = new Code39();
        this.setMinWidth(100);
    },
    render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var s = String(cell.value());
        if (!s) {
            return;
        }
        var fill = (cell._selected && cell._shapeSelectedColor) || cell._shapeColor;
        if (fill) {
            this._barcode.setValue(s.toUpperCase());
            this._barcode.setBarFill(fill);
            this._barcode.render(g, r);
        }
    },
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    }
});
var Code128CellRenderer = defineClass("Code128CellRenderer", DataCellRenderer, {
    init: function() {
        this._super();
        this._barcode = new Code128();
        this.setMinWidth(100);
    },
    render: function(cell, g, r) {
        if (!(r = this._getRenderRect(cell, r))) return;
        var s = cell.value();
        if (!s) {
            return;
        }
        var fill = (cell._selected && cell._shapeSelectedColor) || cell._shapeColor;
        if (fill) {
            this._barcode.setValue(s);
            this._barcode.setBarFill(fill);
            this._barcode.render(g, r);
        }
    },
    renderHtml: function (cell, r) {
        this.render(cell, cell.$_getGraphics(true), r);
    }
});
var ChartDataDirection = _enum("ChartDataDirection", {
    DEFAULT: "default",
    VERTICAL: "vertical",
    HORIZONTAL: "horizontal"
});
var ChartDataSyncMode = _enum('ChartDataSyncMode', {
    INHERIT: "inherit",
    NONE: "none",
    CELL: "cell",
    COLUMN: "column",
    ROW: "row",
    ROWGROUP: "rowgroup",
    SELECTION: "selection"
});
var ChartItemPosition = _enum("ChartItemPosition", {
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
    FLOATING: "floating",
    ANCHORING: "anchoring",
    FILL: "fill"
});
var ChartStackMode = _enum("ChartStackMode", {
    NONE: "none",
    NORMAL: "normal",
    FILL: "fill",
    OVERLAPPED: "overlapped"
});
var ChartAxisOrientation = _enum("ChartAxisOrientation", {
    HORIZONTAL : "horizontal",
    VERTICAL : "vertical"
});
var ChartAxisLocation = _enum("ChartAxisLocation", {
    NORMAL : "normal",
    OPPOSITE : "opposite",
    BETWEEN: "between"
});
var NumericAxisBase = _enum("NumericAxisBase", {
    NONE: "none",
    BOTTOM: "bottom",
    CENTER: "center"
});
var ChartLineType = _enum("ChartLineType", {
    STRAIGHT: "straight",
    CURVED: "curved",
    STEPPED: "stepped"
});
var ChartLabelPosition = _enum("ChartLabelPosition", {
    DEFAULT: "default",
    FAR: "far",
    CENTER: "center",
    NEAR: "near"
});
var ChartHorizontalAlign = _enum('ChartHorizontalAlign', {
    DEFAULT: "default",
    LEFT: "left",
    CENTER: "center",
    RIGHT: "right"
});
var ChartVerticalAlign = _enum('ChartVerticalAlign', {
    DEFAULT: "default",
    TOP: "top",
    MIDDLE: "middle",
    BOTTOM: "bottom"
});
var ChartLegendDirection = _enum("ChartLegendDirection", {
    VERTICAL: "vertical",
    HORIZONTAL: "horizontal"
});
var ChartOverflowPolicy = _enum("ChartOverflowPolicy", {
    NONE: "none",
    JUSTIFY: "justify"
});
var ChartItemDisplayOrder = _enum('ChartItemDisplayOrder', {
    FIRST: "first",
    LAST: "last",
    MAX: "max",
    MIN: "min"
});
var ChartDataSynchronizer = defineClass("ChartDataSynchronizer", null, {
    init: function (parent) {
        this._super();
        this._parent = parent;
        this._inherited = true;
    },
    mode: EnumProp(ChartDataSyncMode, ChartDataSyncMode.INHERIT),
    setMode: function (value) {
        if (value !== this._mode) {
            this._mode = value;
            this._inherited = !value || (value === ChartDataSyncMode.INHERIT);
        }
    },
    chart: function () {
        return this._parent && this._parent.chart();
    },
    dirty: function () {
        return (this._inherited && this._parent) ? this._parent.dirty() : this._dirty;
    },
    setFocused: function (grid, index) {
        var oldColumn = this._column,
            oldRow = this._row;
        this._grid = grid;
        if (index) {
            this._column = index.column;
            this._row = index.getRow(grid);
        } else {
            this._column = null;
            this._row = null;
        }
    },
    getValue: function (field) {
        if (this._inherited) {
            return this._parent.getValue(field);
        }
        if (this._grid) {
            switch (this._mode) {
                case ChartDataSyncMode.CELL:
                case ChartDataSyncMode.COLUMN:
                case ChartDataSyncMode.ROWGROUP:
                case ChartDataSyncMode.SELECTION:
                case ChartDataSyncMode.ROW:
                    return this._grid.getValueAt(this._row, field);
            }
        }
        return undefined;
    }
});
/** @internal */
var RootDataSynchronizer = defineClass("RootDataSynchronizer", ChartDataSynchronizer, {
    init: function (chart) {
        this._super(null);
        this._chart = chart;
    },
    chart: function () {
        return this._chart;
    }
});
var AxisIndicatorStatementRuntime = defineClass("AxisIndicatorStatementRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
    },
    setIndicator: function (value) {
        this._indicator = value;
        return this;
    },
    isIdentifier : function(token) {
        token = token.toLowerCase();
        if (AxisIndicatorStatementRuntime.IDENTS.hasOwnProperty(token)) {
            return AxisIndicatorStatementRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier : function(idKey) {
        switch (idKey) {
            case AxisIndicatorStatementRuntime.ID_VALUE:
                return this._indicator.getCalcedValue("value");
        }
        return this._super(idKey);
    }
}, {
    ID_VALUE	: 5
}, function (f) {
    f.IDENTS = {
        value: f.ID_VALUE
    };
    f.Default = new f();
});
var ChartSeriesFilterRuntime = defineClass("ChartSeriesFilterRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
    },
    prepare: function (dataSource, synchronizer) {
        this._dataSource = dataSource;
        this._fieldCount = dataSource ? dataSource.fieldCount() : 0;
        this._synchronizer = synchronizer;
    },
    setRow: function (row) {
        this._item = row;
        return this;
    },
    scope: function () {
        return this._item;
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (ChartSeriesFilterRuntime.IDENTS.hasOwnProperty(token)) {
            return ChartSeriesFilterRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        switch (idKey) {
            case ChartSeriesFilterRuntime.ID_ROW:
                return this._item.index();
            case ChartSeriesFilterRuntime.ID_DATA_ROW:
                return this._item.dataIndex();
            case ChartSeriesFilterRuntime.ID_CHECKED:
                return this._grid.isChecked(this._item);
            case ChartSeriesFilterRuntime.ID_STATE:
                switch (this._item.dataState()) {
                    case DataRowState.CREATED:
                        return "c";
                    case DataRowState.UPDATED:
                        return "u";
                    case DataRowState.DELETED:
                        return "d";
                    case DataRowState.CREATE_AND_DELETED:
                        return "x";
                }
                return UNDEFINED;
            case ChartSeriesFilterRuntime.ID_TAG:
                return this._item.dataTag();
        }
        return this._super(idKey);
    },
    evaluateIndexerI: function (idKey, index) {
        if (this._item) {
            if (idKey === ChartSeriesFilterRuntime.ID_VALUES) {
                if (index < 0 || index >= this._fieldCount) {
                    _invalidFieldIndex(index);
                }
                return this._item.getValue(index);
            } else if (idKey === ChartSeriesFilterRuntime.ID_CURR) {
                return this._synchroizer ? this._synchroizer.getValue(index) : undefined;
            }
            return this._super(idKey, index);
        } else {
            return undefined;
        }
    },
    evaluateIndexerS: function (idKey, index) {
        if (idKey == ChartSeriesFilterRuntime.ID_VALUES) {
            if (this._dataSource) {
                var idx = this._dataSource.getFieldIndex(index);
                if (idx < 0 || idx >= this._fieldCount) {
                    _invalidFieldIndex(index);
                }
                return this._item.getValue(idx);
            } else {
                return undefined;
            }
        } else if (idKey === ChartSeriesFilterRuntime.ID_CURR) {
            return this._synchroizer ? this._synchroizer.getValue(index) : undefined;
        }
        return this._super(idKey, index);
    }
}, {
    ID_ROW: 0,
    ID_DATA_ROW: 1,
    ID_CHECKED: 2,
    ID_STATE: 3,
    ID_TAG: 4,
    ID_VALUES: 5,
    ID_CURR: 6
}, function (f) {
    f.IDENTS = {
        row: f.ID_ROW,
        datarow: f.ID_DATA_ROW,
        checked: f.ID_CHECKED,
        state: f.ID_STATE,
        tag: f.ID_TAG,
        values: f.ID_VALUES,
        curr: f.ID_CURR
    };
    f.Default = function () { return f.$_Default || (f.$_Default = new f()); }
});
var ChartSeriesValueRuntime = defineClass("ChartSeriesValueRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
    },
    setSeries: function (series) {
        this._series = series;
        this._summary = series && series._summary;
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (ChartSeriesValueRuntime.IDENTS.hasOwnProperty(token)) {
            return ChartSeriesValueRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        if (this._summary) {
            switch (idKey) {
                case ChartSeriesValueRuntime.ID_MIN:
                    return this._summary.min;
                case ChartSeriesValueRuntime.ID_MAX:
                    return this._summary.max;
                case ChartSeriesValueRuntime.ID_AVG:
                    return this._summary.avg;
                case ChartSeriesValueRuntime.ID_SUM:
                    return this._summary.sum;
            }
        }
        return NaN;
    }
}, {
    ID_MIN: 0,
    ID_MAX: 1,
    ID_AVG: 2,
    ID_SUM: 3
}, function (f) {
    f.IDENTS = {
        min: f.ID_MIN,
        max: f.ID_MAX,
        avg: f.ID_AVG,
        sum: f.ID_SUM
    };
    f.Default = function () { return f.$_Default || (f.$_Default = new f()); }
});
var ChartSeriesItemRuntime = defineClass("ChartSeriesItemRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
        this._item = null; // ChartSeriesItem
        this._series = null;
    },
    setItem: function (value) {
        this._item = value;
        this._series = value._series;
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (ChartSeriesItemRuntime.IDENTS.hasOwnProperty(token)) {
            return ChartSeriesItemRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        switch (idKey) {
            case ChartSeriesItemRuntime.ID_INDEX:
                return this._item.index();
            case ChartSeriesItemRuntime.ID_VALUE:
                return this._item.getProp(this._series.valueField());
            case ChartSeriesItemRuntime.ID_SUM:
                return this._series._summary && this._series._summary.sum;
            case ChartSeriesItemRuntime.ID_MIN:
                return this._series._summary && this._series._summary.min;
            case ChartSeriesItemRuntime.ID_MAX:
                return this._series._summary && this._series._summary.max;
            case ChartSeriesItemRuntime.ID_AVG:
                return this._series._summary && this._series._summary.avg;
            case ChartSeriesItemRuntime.ID_VAR:
                return this._series._summary && this._series._summary.var;
            case ChartSeriesItemRuntime.ID_VARP:
                return this._series._summary && this._series._summary.varp;
            /*
            case ChartSeriesItemRuntime.ID_ROW:
                return this._item.index();
            case ChartSeriesItemRuntime.ID_DATA_ROW:
                return this._item.dataIndex();
            case ChartSeriesItemRuntime.ID_INDEX:
                return this._target.index().column.index();
            case ChartSeriesItemRuntime.ID_FIELD:
                return this._target.index().dataField();
            case ChartSeriesItemRuntime.ID_CHECKED:
                return this._grid.isChecked(this._item);
            case ChartSeriesItemRuntime.ID_STATE:
                if (this._item) {
                    switch (this._item.dataState()) {
                        case DataRowState.CREATED:
                            return "c";
                        case DataRowState.UPDATED:
                            return "u";
                        case DataRowState.DELETED:
                            return "d";
                        case DataRowState.CREATE_AND_DELETED:
                            return "x";
                    }
                }
                return UNDEFINED;
            case ChartSeriesItemRuntime.ID_TAG:
                return this._target.index().column.tag();
            case ChartSeriesItemRuntime.ID_COUNT:
                return this._target.index().childCount();
            case ChartSeriesItemRuntime.ID_DCOUNT:
                return this._target.index().descendantCount();
            case ChartSeriesItemRuntime.ID_ROWTAG:
                return this._item.dataTag();
                */
        }
        return this._super(idKey);
    },
    evaluateIndexerI: function (idKey, index) {
        if (idKey == ChartSeriesItemRuntime.ID_VALUE) { // for series
            var vals = this._target.value();
            if (_isArray(vals) && index >= 0 && index < vals.length) {
                return vals[index];
            }
            throw new ExpressionEvaluationError(GridLocale._default.valueIndexOutOfBounds + ": " + index);
        } else if (idKey == ChartSeriesItemRuntime.ID_VALUES) {
            if (this._dataSource) {
                if (index < 0 || index >= this._fieldCount) {
                    _invalidFieldIndex(index);
                }
                return this._item.getValue(index);
            } else {
                return undefined;
            }
        }
        return this._super(idKey, index);
    },
    evaluateIndexerS: function (idKey, index) {
        if (idKey == ChartSeriesItemRuntime.ID_VALUES) {
            if (this._dataSource) {
                var idx = this._dataSource.getFieldIndex(index);
                if (idx < 0 || idx >= this._fieldCount) {
                    _invalidFieldIndex(index);
                }
                return this._item.getValue(idx);
            } else {
                return undefined;
            }
        }
        return this._super(idKey, index);
    }
}, {
    ID_INDEX: 0,
    ID_VALUE: 1,
    ID_SUM: 2,
    ID_MIN: 3,
    ID_MAX: 4,
    ID_AVG: 5,
    ID_VAR: 6,
    ID_VARP: 7
}, function (f) {
    f.IDENTS = {
        index: f.ID_INDEX,
        value: f.ID_VALUE,
        sum: f.ID_SUM,
        min: f.ID_MIN,
        max: f.ID_MAX,
        avg: f.ID_AVG,
        "var": f.ID_VAR,
        varp: f.ID_VARP
    };
    f.Default = new f();
});
/** @abstract */
var GridChart = defineClass("GridChart", null, {
    init: function (owner) {
        this._super();
        this._owner = owner;
        this._palettes = owner ? owner._palettes : null;
        this._plotArea = new ChartPlotArea(this);
        this._legend = new ChartLegend();
        this._axes = [];
        this._xAxes = [];
        this._yAxes = [];
        this._series = [];
        this._seriesAll = [];
        this._seriesDirty = false;
        this._styles = new GridStyles(this, "chart");
        this._synchronizer = new RootDataSynchronizer(this);
        this._styles.setPaddingLeft(2);
        this._styles.setPaddingRight(6);
        this._styles.setPaddingTop(6);
        this._styles.setPaddingBottom(2);
    },
    stylesChanged: function (stypeProp) {
        this._changed();
    },
    getPaletteScope: function () {
        return this;
    },
    getPalette: function (pal) {
        return this._palettes ? this._palettes._palettes[pal] : null;
    },
    getPaletteIndex: function (index) {
        return index;
    },
    dataSync: EnumProp(ChartDataSyncMode, ChartDataSyncMode.NONE),
    plotArea: null,
    legend: null,
    xAxes: null,
    yAxes: null,
    styles: null,
    hovering: false,
    crosshair: null,
    setPlotArea: function (value) {
        if (value !== this._plotArea) {
            this._plotArea.assign(value);
        }
        return this;
    },
    setLegend: function (value) {
        if (value !== this._legend) {
            this._legend.assign(value);
        }
        return this;
    },
    xAxes_: function () {
        return this._xAxes.slice();
    },
    setXAxes: function (value) {
        var i, cnt, axis,
            list = this._xAxes = [];
        if (value instanceof ChartAxis) {
            this.$_addAxis(value, list);
        } else if (_isArray(value)) {
            for (i = 0, cnt = value.length; i < cnt; i++) {
                axis = value[i];
                if (axis instanceof ChartAxis) {
                    this.$_addAxis(axis, list);
                }
            }
        }
        return this;
    },
    yAxes_: function () {
        return this._yAxes.slice();
    },
    setYAxes: function (value) {
        var i, cnt, axis,
            list = this._yAxes = [];
        if (value instanceof ChartAxis) {
            this.$_addAxis(value, list);
        } else if (_isArray(value)) {
            for (i = 0, cnt = value.length; i < cnt; i++) {
                axis = value[i];
                if (axis instanceof ChartAxis) {
                    this.$_addAxis(axis, list);
                }
            }
        }
        return this;
    },
    setStyles: function (value) {
        if (value != this._styles) {
            this._styles.extend(value);
        }
        return this;
    },
    owner: function () {
        return this._owner;
    },
    isPolar: function () {
        return this._series && this._series.length > 0 && this._series[0].isPolar();
    },
    seriesDirty: function () {
        return this._seriesDirty;
    },
    seriesCount: function () {
        return this._series.length;
    },
    loadChart: function (config) {
        return GridChartLoader.Default.load(config, this);
    },
    setItemSource: function (source) {
        var i, ser;
        for (i = this._series.length; i--;) {
            ser = this._series[i];
            ser && ser.loadItems(source);
        }
    },
    invalidate: function () {
    },
    getAxes: function(orientation, location, polar) {
        var i, cnt, axis,
            axes = [];
        if (polar) {
            for (i = 0, cnt = this._xAxes.length; i < cnt; i++) {
                axis = this._xAxes[i];
                if (axis instanceof PolarAxis) {
                    axes.push(axis);
                }
            }
            for (i = 0, cnt = this._yAxes.length; i < cnt; i++) {
                axis = this._yAxes[i];
                if (axis instanceof CartesianAxis) {
                    axes.push(axis);
                }
            }
        } else if (orientation == ChartAxisOrientation.HORIZONTAL) {
            for (i = 0, cnt = this._xAxes.length; i < cnt; i++) {
                axis = this._xAxes[i];
                if (axis instanceof CartesianAxis && axis.location() == location) {
                    axes.push(axis);
                }
            }
        } else if (orientation == ChartAxisOrientation.VERTICAL) {
            for (i = 0, cnt = this._yAxes.length; i < cnt; i++) {
                axis = this._yAxes[i];
                if (axis instanceof CartesianAxis && axis.location() == location) {
                    axes.push(axis);
                }
            }
        }
        return axes;
    },
    setSeries: function (value) {
        var i,
            cnt = this._series.length;
        this._series = [];
        if (value instanceof ChartSeries || value instanceof ChartSeriesGroup) {
            this.addSeries(value);
        } else {
            for (i = 0, cnt = value.length; i < cnt; i++) {
                this.addSeries(value[i]);
            }
        }
    },
    addSeries: function (series) {
        var i, cnt;
        if (series) {
            if ((cnt = this._series.length) > 0) {
                for (i = 0; i < cnt; i++) {
                    if (this._series[i] === series || !this._series[i].mixableWith(series)) {
                        return false;
                    }
                }
            }
            this._series.push(series);
            return true;
        }
        return false;
    },
    getLegendItems: function () {
        var i, j, cnt, cnt2, ser,
            items = [];
        for (i = 0, cnt = this._series.length; i < cnt; i++) {
            ser = this._series[i];
            if (ser instanceof ChartSeries) {
                if (ser.itemsLegend()) {
                    for (j = 0, cnt2 = ser.itemCount(); j < cnt2; j++) {
                        items.push(ser.getItem(j));
                    }
                }  else {
                    items.push(ser);
                }
            } else if (ser instanceof ChartSeriesGroup) {
                for (j = 0, cnt2 = ser.count(); j < cnt2; j++) {
                    items.push(ser.getItem(j));
                }
            }
        }
        return items;
    },
    setFocused: function (grid, index) {
        this._synchronizer.setFocused(grid, index);
        for (var i = this._seriesAll.length; i--;) {
            this._seriesAll.setFocused(grid, index);
        }
    },
    _changed: function () {
    },
    $_addAxis: function (axis, list) {
        if (axis && list) {
            for (var i = list.length; i--;) {
                if (list[i] === axis) {
                    return;
                }
            }
            list.push(axis);
            this.invalidate();
        }
    },
    $_resetAxisTicks: function (axis, orientation, resized, seriesDirty, r) {
        if (axis.update(this, resized || seriesDirty)) {
            if (axis instanceof CartesianAxis) {
                var sz;
                if (this.isPolar()) {
                    sz = Math.min(r.height, r.width) * this.plotArea().polarSize();
                } else {
                    sz = orientation == ChartAxisOrientation.VERTICAL ? r.height : r.width;
                }
                axis.refreshTicks(this, orientation, sz);
            } else {
                axis.refreshTicks(this, orientation, 0);
            }
        }
    },
    $_updateModels: function (r, resized) {
        var i, cnt,
            seriesDirty = this._seriesDirty,
            xAxes = this._xAxes,
            yAxes = this._yAxes;
        this.$_collectAxes();
        this.$_collectSeries();
        this.$_connectSeries();
        if (xAxes && (cnt = xAxes.length) > 0) {
            for (i = 0; i < cnt; i++) {
                axis = xAxes[i];
                if (axis._series instanceof PieSeries) {
                    axis.setVisible(false);
                } else {
                    axis.update(this);
                }
                this.$_resetAxisTicks(axis, ChartAxisOrientation.HORIZONTAL, resized, seriesDirty, r);
            }
        }
        if (yAxes && (cnt = yAxes.length) > 0) {
            for (i = 0; i < cnt; i++) {
                axis = yAxes[i];
                if (axis._series instanceof PieSeries) {
                    axis.setVisible(false);
                }
                this.$_resetAxisTicks(axis, ChartAxisOrientation.VERTICAL, resized, seriesDirty, r);
            }
        }
        this._legend.setSource(this);
        this._legend.update(this, true);
    },
    $_collectAxes: function () {
        this._topAxes = this._bottomAxes = this._leftAxes = this._rightAxes = [];
        this._axes = this._xAxes.concat(this._yAxes);
    },
    $_collectSeries: function () {
        function collect(chart, group, list) {
            var i, ser;
            group.update(chart);
            for (i = 0; i < group.count(); i++) {
                ser = group.getItem(i);
                if (ser instanceof ChartSeriesGroup) {
                    collect(chart, ser, list);
                } else {
                    if (ser.update(chart)) {
                        this._seriesDirty = true;
                    }
                    list.push(ser);
                }
            }
        }
        var i, cnt, ser,
            series = [];
        this._seriesDirty = false;
        if (series) {
            for (i = 0, cnt = this._series.length; i < cnt; i++) {
                ser = this._series[i];
                if (ser instanceof ChartSeriesGroup) {
                    collect(this, ser, series);
                } else {
                    if (ser.update(this)) {
                        this._seriesDirty = true;
                    }
                    series.push(ser);
                }
            }
        }
        return this._seriesAll = series;
    },
    $_connectSeries: function () {
        var i, cnt,
            series = this._series;//All;
        for (i = 0, cnt = series.length; i < cnt; i++) {
            series[i].disconnectFromAxis();
            series[i].connectToAxes(this._xAxes, this._yAxes);
        }
        return series;
    },
    $_getSeries: function (seriesOnly) {
        return this._seriesAll;
    }
});
/** @abstract */
var ChartObject = defineClass("ChartObject", null, {
    init: function (owner, styleName) {
        this._super();
        this._owner = owner;
        this._palettes = owner ? owner._palettes : null;
        this._createChildren();
        this._styles = new GridStyles(this, styleName || 'chartObject');
        this._needUpdate = true;
    },
    stylesChanged: function (stypeProp) {
        this._changed();
    },
    getPaletteScope: function () {
        return this;
    },
    getPalette: function (pal) {
        return this._palettes ? this._palettes._palettes[pal] : null;
    },
    getPaletteIndex: function (index) {
        return index;
    },
    styles: null,
    visible: true,
    setStyles: function (value) {
        if (value != this._styles) {
            this._styles.extend(value);
        }
        return this;
    },
    invalidate: function () {
        this._needUpdate = true;
    },
    update: function (chart, force) {
        if (this._needUpdate || force) {
            this._doUpdate(chart);
            this._needUpdate = false;
            return true;
        }
        return false;
    },
    assignSimple: function (value) {
        if (_isBoolean(value)) {
            this.setVisible(value);
        }
    },
    propertyChanged: function (/*prop, oldValue, newValue*/) {
        this._changed();
    },
    /** @abstract */
    _createChildren: function () {},
    _changed: function () { this.invalidate(); },
    _doUpdate: function (chart) {}
});
/** @abstract */
var ChartLabelBase = defineClass('ChartLabelBase', ChartObject, {
    init: function (owner, styleName, parentStyles) {
        this._super(owner, styleName || "label");
        parentStyles && this._styles.setParent(parentStyles);
        this._styles.setBorder(null);
        this._styles.setBackground(null);
    },
    position: ChartLabelPosition.DEFAULT,
    offsetX: IntProp(0),
    offsetY: IntProp(0),
    horizontalAlign: ChartHorizontalAlign.DEFAULT,
    verticalAlign: ChartVerticalAlign.DEFAULT,
    _changed: function () {
        this._owner && this._owner.labelChanged(this);
    }
});
/** @abstract */
var ChartLayout = defineClass("ChartLayout", null, {
    init: function () {
        this._super();
    }
});
var ChartPlotArea = defineClass("ChartPlotArea", ChartObject, {
    init: function (owner) {
        this._super(owner);
    },
    polarSize: 0.8
    /*
    crossHair: null,
    setCrossHair: function (value) {
        this._crossHair.assign(value);
    },
    */
});
var ChartAxisTitle = defineClass("ChartAxisTitle", ChartObject, {
    init: function (owner) {
        this._super(owner);
    },
    caption: null,
    assignSimple: function (source) {
        this.setCaption(source);
    }
});
var ChartAxisGrid = defineClass("ChartAxisGrid", ChartObject, {
    init: function (owner) {
        this._super(owner);
        this._baseStyles = new GridStyles(null, "axisGridBase");
        this._styles.setLine("#20000000");
        this._baseStyles.setLine("#60000000");
    },
    baseStyles: null,
    setBaseStyles: function (value) {
        if (value !== this._baseStyles) {
            this._baseStyles.extend(value);
        }
        return this;
    }
});
var ChartAxisIndicatorLabel = defineClass('ChartAxisIndicatorLabel', ChartLabelBase, {
    init: function (owner, parentStyles) {
        this._super(owner, "indicatorLabel", parentStyles);
        this._runtime = AxisIndicatorStatementRuntime.Default;
    },
    text: null,
    setText: function (value) {
        if (value != this._text) {
            this._text = value;
            this._statement = value ? new ExpressionStatement(value) : null;
        }
        return this;
    },
    getText: function () {
        return this._statement ? this._statement.evaluate(this._runtime.setIndicator(this._owner)) : this._label;
    },
    assignSimple: function (value) {
        this.setText(value);
    }
});
var ChartAxisIndicator = defineClass("ChartAxisIndicator", ChartObject, {
    init: function (config) {
        this._super();
        this._label = new ChartAxisIndicatorLabel(this, this._styles);
        config && this.assign(config);
    },
    label: null,
    front: false,
    value: undefined,
    series: null,
    setLabel: function (value) {
        if (value !== this._label) {
            this._label.assign(value);
            this._changed();
        }
        return this;
    },
    setValue: function (value) {
        if (value != this._value) {
            this._value = value;
            this._valueNode = _isString(value) && value ? ExpressionParser.Default.parse(value, null) : null;
        }
        return this;
    },
    getValue: function (axis) {
        return this._calcedValue = (this._valueNode ? this._evaluate(this._valueNode) : this._value);
    },
    labelChanged: function (label) {
        this._changed();
    },
    getCalcedValue: function (prop) {
        var f, v;
        if ((f = this._label._styles.numberFormat()) != this._format || this._formatter) {
            this._formatter = f ? new DecimalFormatter(f) : null;
            this._format = f;
        }
        v = this._calcedValue;
        return this._formatter ? this._formatter.format(v) : v;
    },
    _evaluate: function (node) {
        var runtime = ChartSeriesValueRuntime.Default(),
            series = axis.getSeries(this._series, true);
        runtime.setSeries(series);
        return node.evaluate(runtime);
    }
});
var ChartAxisBandIndicator = defineClass("ChartAxisBandIndicator", ChartAxisIndicator, {
    init: function (config) {
        this._super(config);
    },
    startValue: undefined,
    endValue: undefined,
    setStartValue: function (value) {
        if (value != this._startValue) {
            this._startValue = value;
            this._startNode = _isString(value) && value ? ExpressionParser.Default.parse(value, null) : null;
        }
        return this;
    },
    setEndValue: function (value) {
        if (value != this._endValue) {
            this._endValue = value;
            this._endNode = _isString(value) && value ? ExpressionParser.Default.parse(value, null) : null;
        }
        return this;
    },
    getStartValue: function (axis) {
        return this._startNode ? this._evaluate(this._startNode) : this._startValue;
    },
    getEndValue: function (axis) {
        return this._endNode ? this._evaluate(this._endNode) : this._endValue;
    }
});
var ChartAxisLineIndicator = defineClass("ChartAxisLineIndicator", ChartAxisIndicator, {
    init: function (config) {
        this._super(config);
    }
});
/** @abstract */
var ChartAxis = defineClass("ChartAxis", ChartObject, {
    init: function (name) {
        this._super();
        this._name = name;
        this._title = new ChartAxisTitle(this);
        this._grid = new ChartAxisGrid(this);
        this._frontGrid = new ChartAxisGrid(this);
        this._tickStyles = new GridStyles(null, "axisTick");
        this._tickStyles.setFontSize(10);
        this._sources = [];
        this._indicators = [];
        this._series = null;
        this._seriesAll = [];
        this._styles.setLine("#ccc");
        this._tickStyles.setLine("#ccc");
    },
    name: null,
    title: null,
    grid: null,
    frontGrid: null,
    indicators: null,
    tickStyles: null,
    orientation: ChartAxisOrientation.VERTICAL,
    locationRate: 1,
    labelInterval: 1,
    useNumberSymbols: true,
    numberSymbols: null,
    tickLength: 5,
    setTitle: function (value) {
        if (value !== this._title) {
            this._title.assign(value);
        }
        return this;
    },
    setGrid: function (value) {
        if (value !== this._grid) {
            this._grid.assign(value);
        }
        return this;
    },
    setFrontGrid: function (value) {
        if (value !== this._frontGrid) {
            this._frontGrid.assign(value);
        }
        return this;
    },
    indicators_: function () {
        return this._indicators.slice();
    },
    setIndicators: function (value) {
        function loadIndicator(src) {
            var indicator = null;
            switch (src.type) {
                case "band":
                    indicator = new ChartAxisBandIndicator(src);
                    break;
                case "line":
                default:
                    indicator = new ChartAxisLineIndicator(src);
                    break;
            }
            return indicator;
        }
        var indicator, i, cnt,
            styles = this.styles();
        if (value !== this._indicators) {
            this._indicators = [];
            if (_isArray(value)) {
                for (i = 0, cnt = value.length; i < cnt; i++) {
                    indicator = loadIndicator(value[i]);
                    if (indicator) {
                        this._indicators.push(indicator);
                        indicator.styles().setParent(styles);
                    }
                }
            } else if (value) {
                indicator = loadIndicator(value);
                this._indicators.push(indicator);
                indicator.styles().setParent(styles);
            }
            this.invalidate();
        }
        return this;
    },
    setTickStyles: function (value) {
        if (value !== this._tickStyles) {
            this._tickStyles.extend(value);
        }
        return this;
    },
    numberSymbols_: function () {
        return this._numberSymbols || ChartAxis.NumberSymbols;
    },
    isValueAxis: function () {
        return this._series && this._series.isValueAxis(this);
    },
    isVertical: function () {
        return this._orientation == ChartAxisOrientation.VERTICAL;
    },
    isOppositeOf: function (series) {
        return this._location === ChartAxisLocation.OPPOSITE// ||
    },
    getSeries: function (seriesName, force) {
        for (var i = this._seriesAll.length; i--;) {
            if (this._seriesAll[i].name() == seriesName) {
                return this._seriesAll[i];
            }
        }
        return force ? this._series : null;
    },
    getSeriesAt: function (index) {
        return this._serieslAll[index];
    },
    addSource: function (source) {
        var sources = this._sources;
        if (sources.indexOf(source) < 0) {
            if (this._connectableWith(source)) {
                sources.push(source);
                if (!this._series) {
                    if (source instanceof ChartSeries) {
                        this._series = source;
                    } else {
                        this._series = source.getItem(0);
                    }
                }
                this.invalidate();
                return true;
            }
        }
        return false;
    },
    removeSource: function (source) {
        var cnt,
            removed = false,
            sources = this._sources,
            i = sources.indexOf(source);
        if (i >= 0) {
            sources.splice(i, 1);
            if (source === this._series || (source instanceof ChartSeriesGroup && source.getItem(0) == this._series)) {
                this._series = null;
            }
            this.invalidate();
            removed = true;
        }
        if (!this._seires && sources.length > 0) {
            this._series = sources instanceof ChartSeries ? source : source.getItem(0);
        }
        return removed;
    },
    refreshTicks: function (chart, orientation, size) {
        this._orientation = orientation;
        this._doRefreshTicks(chart, size);
    },
    getTickList: function () {},
    getTickNumber: function () {},
    getTick: function (index) {},
    getTickPosition: function (index) {},
    getGridPosition: function (index) {
        return this.getTickPosition(index);
    },
    _calculateRange: function (baseValue, minValue, maxValue) {
        var i, j, cnt, cnt2, lowVals, highVals, source, low, high, group,
            calcedMin = NaN,
            calcedMax = NaN;
        if (!isNaN(minValue) && !isNaN(maxValue)) {
            calcedMin = minValue;
            calcedMax = maxValue;
        } else {
            lowVals = [];
            highVals = [];
            for (i = 0, cnt = this._sources.length; i < cnt; i++) {
                source = this._sources[i];
                if (source instanceof ChartSeries && (group = source.group())) {
                    if (source.itemCount() > 0 && source.groupIndex() == 0) {
                        lowVals.push(group.getMinValueAt(this));
                        highVals.push(group.getMaxValueAt(this));
                    }
                } else if (source["getMinValueAt"] && source["getMaxValueAt"]) {
                    lowVals.push(source.getMinValueAt(this));
                    highVals.push(source.getMaxValueAt(this));
                } else if (_isArray(source)) {
                    for (j = 0, cnt2 = source.length; j < cnt2; j++) {
                        lowVals.push(source[j]);
                        highVals.push(source[j]);
                    }
                }
            }
            cnt = lowVals.length;
            if (cnt > 0) {
                for (i = 0; i < cnt; i++) {
                    low = lowVals[i];
                    high = highVals[i];
                    if (isNaN(calcedMin)) {
                        if (!isNaN(low)) calcedMin = low;
                        if (!isNaN(high)) calcedMax = high;
                    } else if (!isNaN(low) && !isNaN(high)) {
                        calcedMin = Math.min(low, high, calcedMin);
                        calcedMax = Math.max(low, high, calcedMax);
                    }
                }
                if (!isNaN(baseValue)) {
                    calcedMin = Math.min(baseValue, calcedMin);
                }
            }
            if (isNaN(calcedMin) || isNaN(calcedMax)) {
                calcedMin = 0;
                calcedMax = 1;
            }
        }
        return { minValue: calcedMin, maxValue: calcedMax };
    },
    _doUpdate: function (chart) {
        var src, i, j, cnt,
            sources = this._sources,
            all = this._seriesAll = [];
        if (sources) {
            for (i = 0, cnt = sources.length; i < cnt; i++) {
                src = sources[i];
                if (src instanceof ChartSeries) {
                    all.push(src);
                } else {
                    for (j = 0; j < src.count(); j++) {
                        all.push(src.getItem(j));
                    }
                }
            }
        }
    }
}, {
    NumberSymbols: ["k", "M", "G", "T", "P", "E"]
});
var CartesianAxis = defineClass("CartesianAxis", ChartAxis, {
    init: function (name) {
        this._super(name);
    },
    location: ChartAxisLocation.NORMAL,
    reversed: false,
    _connectableWith: function (series) {
        return (series instanceof ChartSeries || series instanceof ChartSeriesGroup);
    }
});
var ChartAxisCategory = function (v) {
    if (_isObject(v)) {
        this.label = _toStr(v.label);
        this.width = v.hasOwnProperty("width") ? v.width : 1.0;
        this.paddingNear = v.hasOwnProperty("paddingNear") ? v.paddingNear : 0;
        this.paddingFar = v.hasOwnProperty("paddingFar") ? v.paddingFar : 0;
    } else {
        this.label = _toStr(v);
        this.width = 1.0;
        this.paddingNear = 0;
        this.paddingFar = 0;
    }
    this.index = -1;
};
ChartAxisCategory.prototype.toString = function () {
    return this.label;
};
var CategorizedAxis = defineClass("CategorizedAxis", CartesianAxis, {
    init: function (name) {
        this._super(name);
        this._categoriesDirty = false;
        this._categories = null;
        this._categoryList = [];
        this._positions = [];
        this._ends = [];
        this._unit;
    },
    data: null,
    firstIndent: 0,
    lastIndent: 0,
    startIndex: 0,
    displayCount: 0,
    paddingNear: 0,
    paddingFar: 0,
    padding: 0,
    categories: null,
    padding_: NullFunc,
    setPadding: function (value) {
        this.setPaddingNear(value);
        this.setPaddingFar(value);
        return this;
    },
    categories_: function () {
        return this._categories ? this._categories.slice() : null;
    },
    setCategories: function (value) {
        this._categories = value && value.slice();
        this._invalidateCategories();
    },
    categoryCount: function () {
        return this._categoryList.length;
    },
    setData: function (value) {
        if (value !== this._data) {
            if (isObject(value)) {
                this._data = _extend({}, CategorizedAxis.DATA_CONFIG, value);
            } else if (value) {
                this._data = _extend({}, CategorizedAxis.DATA_CONFIG);
                this._data.id = value;
            } else {
                this._data = null;
            }
            this._invalidateCategories();
        }
        return this;
    },
    visibleCount: function () {
        return this._displayCount > 0 ? Math.min(this._displayCount, this._categoryList.length) : this._categoryList.length;
    },
    getCategory: function (index) {
        return this._categoryList[index];
    },
    getCategoryAt: function (w, x) {
        var i, cnt;
        if (x <= 0) {
            return this._categoryList[0];
        }
        for (i = 0, cnt = this._categoryList.length; i < cnt - 1; i++) {
            if (x > _floor(this.getCategoryPosition(i) * w) &&
                x <= _floor((this.getCategoryPosition(i) + this.getCategoryWidth(i)) * w)) {
                return this._categoryList[i];
            }
        }
        return this._categoryList[cnt - 1];
    },
    getCategoryPosition: function (item) {
        var i = item instanceof ChartSeriesItem ? item._category.index : item - this._startIndex;
        return this._positions[i] * this._locationRate;
    },
    getCategoryWidth: function (item) {
        var i = item instanceof ChartSeriesItem ? item._category.index : item - this._startIndex;
        return (this._positions[i + 1] - this._positions[i]) * this._locationRate;
    },
    getDisplayPosition: function (item) {
        var i = item instanceof ChartSeriesItem ? item._category.index : item - this._startIndex;
        return this._ends[i * 2] * this._locationRate;
    },
    getDisplayWidth: function (item) {
        var i = item instanceof ChartSeriesItem ? item._category.index : item - this._startIndex;
        return (this._ends[i * 2 + 1] - this._ends[i * 2]) * this._locationRate;
    },
    _styleSheetRegion: function () {
        return "categorizedAxis";
    },
    connectableWith: function (series) {
        this._super(series);
    },
    invalidate: function () {
        this._invalidateCategories();
    },
    _doChartDataChanged: function (dataId) {
        this._invalidateCategories();
    },
    _doUpdate: function (chart, force) {
        function updateGroup(group, groupPos, groupWidth) {
            var ser, p, w, i, j, len, items, arr,
                cnt = group.count();
            switch (group.stackMode()) {
                case ChartStackMode.NONE:
                    len = 0;
                    for (i = 0; i < cnt; i++) {
                        ser = group.getItem(i);
                        len += ser.clusterWidth();
                    }
                    p = groupPos;
                    for (i = 0; i < cnt; i++) {
                        ser = group.getItem(i);
                        w = ser.clusterWidth() / len;
                        w *= groupWidth;
                        ser.clusterInfo = { index: i, position: p, width: w };
                        p += w;
                    }
                    break;
                case ChartStackMode.OVERLAPPED:
                    items = {};
                    for (i = 0; i < cnt; i++) {
                        ser = group.getItem(i);
                        arr = items[ser.zindex()];
                        if (!arr) {
                            items[ser.zindex()] = arr = [ser];
                        } else {
                            arr.push(ser);
                        }
                    }
                    for (var index in items) {
                        arr = items[index];
                        if (arr.length == 1) {
                            p = groupPos;
                            arr[0].clusterInfo = { index: 0, position: p, width: groupWidth };
                        } else {
                            len = 0;
                            for (j = 0; j < arr.length; j++) {
                                ser = arr[j];
                                len += ser.clusterWidth();
                            }
                            p = groupPos;
                            for (j = 0; j < arr.length; j++) {
                                ser = arr[j];
                                w = ser.clusterWidth() / len;
                                w *= groupWidth;
                                ser.clusterInfo = { index: j, position: p, width: w };
                                p += w;
                            }
                        }
                    }
                    break;
                case ChartStackMode.FILL:
                case ChartStackMode.NORMAL:
                default:
                    p = groupPos;
                    for (i = 0; i < cnt; i++) {
                        ser = group.getItem(i);
                        ser.clusterInfo = { index: i, position: p, width: groupWidth };
                    }
                    break;
            }
        }
        this._super(chart, force);
        var i, ser, p, w,
            series = [],
            len = 0,
            sources = this._sources;
        if (!sources || sources.length < 1) {
            return;
        }
        for (i = 0; i < sources.length; i++) {
            ser = sources[i];
            if (ser.isClusterable() && ser.clusteredAxis() == this) {
                len += ser.clusterWidth();
                series.push(ser);
            }
        }
        p = 0;
        for (i = 0; i < series.length; i++) {
            ser = series[i];
            w = ser.clusterWidth() / len;
            ser.clusterInfo = { index: i, position: p, width: w };
            if (ser instanceof ChartSeriesGroup) {
                updateGroup(ser, p, w);
            }
            p += w;
        }
        this.invalidate();
    },
    _doRefreshTicks: function(chart, size) {
        function categoryIndex (label, cats) {
            var i, cnt;
            for (i = 0, cnt = cats.length; i < cnt; i++) {
                if (label == cats[i].label) {
                    return i;
                }
            }
            return -1;
        }
        function refreshCatSeries(src, catList) {
            var cats, i, item, n,
                cnt = Math.min(src.itemCount(), catList.length),
                labelFld = src.labelField();
            if (labelFld) {
                cats = catList.slice();
                for (i = 0; i < cnt; i++) {
                    item = src.getItem(i);
                    n = categoryIndex(item.getProp(labelFld), cats);
                    if (n >= 0) {
                        item._category = cats[n];
                        cats.splice(n, 1);
                    } else {
                        item._category = null;
                    }
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    src.getItem(i)._category = catList[i];
                }
            }
        }
        function refreshCatGroup(g, catList) {
            var i, ser,
                cnt = g.count();
            for (i = 0; i < cnt; i++) {
                ser = g.getItem(i);
                if (ser instanceof ChartSeries) {
                    refreshCatSeries(ser, catList);
                } else if (ser instanceof ChartSeriesGroup) {
                    refreshCatGroup(ser, catList);
                }
            }
        }
        function refreshSeries(src, catList) {
            var cnt, cats, i, item, label, idx,
                labelFld = src.labelField();
            if (labelFld) {
                cnt = src.itemCount();
                cats = catList.slice();
                for (i = 0; i < cnt; i++) {
                    item = src.getItem(i);
                    label = item.getProp(labelFld);
                    idx = categoryIndex(label, cats);
                    if (idx < 0) {
                        catList.push(item._category = new ChartAxisCategory(label));
                    } else {
                        item._category = cats[idx];
                        cats.splice(idx, 1);
                    }
                }
            }
        }
        function refreshGroup(g, catList) {
            var i, ser,
                cnt = g.count();
            for (i = 0; i < cnt; i++) {
                ser = g.getItem(i);
                if (ser instanceof ChartSeries) {
                    refreshSeries(ser, catList);
                } else if (ser instanceof ChartSeriesGroup) {
                    refreshGroup(ser, catList);
                }
            }
        }
        if (this._categoriesDirty) {
            var i, clen, cat, src,
                catList = this._categoryList = [],
                categories = this.categories(),
                sources = this._sources,
                cnt = sources.length;
            if (isArray(categories) && (clen = categories.length) > 0) {
                for (i = 0; i < clen; i++) {
                    cat = new ChartAxisCategory(categories[i]);
                    catList.push(cat);
                    cat.index = i;
                }
                for (i = 0; i < cnt; i++) {
                    src = sources[i];
                    if (src instanceof ChartSeries) {
                        refreshCatSeries(src, catList);
                    } else if (src instanceof ChartSeriesGroup) {
                        refreshCatGroup(src, catList);
                    }
                }
            }  else {
                for (i = 0; i < cnt; i++) {
                    src = sources[i];
                    if (src instanceof ChartSeries) {
                        refreshSeries(src, catList);
                    } else if (src instanceof ChartSeriesGroup) {
                        refreshGroup(src, catList);
                    }
                }
                for (i = catList.length; i--;) {
                    catList[i].index = i;
                }
            }
            this._positions = this.calcPositions();
            this._ends = this.calcEnds(this._positions);
            this._categoriesDirty = false;
        }
    },
    /*
     _doRefreshTicks: function(chart, size) {
     if (this._categoriesDirty) {
     var catList = this._categoryList = [];
     var cats = this.categories();
     var i, cnt, labelFld, item, data, row;
     if (isArray(cats) && cats.length > 0) {
     for (i = 0, cnt = cats.length; i < cnt; i++) {
     catList.push(new ChartAxisCategory(cats[i]));
     }
     } else if (this._data && this._data.id) {
     data = this.getChartData(chart, this._data.id);
     if (data) {
     labelFld = this._categoryField;
     for (i = 0, cnt = data.rowCount(); i < cnt; i++) {
     row = data.getRow(i);
     catList.push(new ChartAxisCategory(row[labelFld]));
     }
     }
     } else {
     var sources = this._sources;
     var source = sources.length > 0 ? sources[0] : null;
     var cats;
     if (source instanceof ChartSeries && source.labelField) {
     cnt = source.itemCount();
     labelFld = source.labelField();
     for (i = 0; i < cnt; i++) {
     item = source.getItem(i);
     catList.push(item._category = new ChartAxisCategory(item.getProp(labelFld)));
     }
     for (j = 1; j < sources.length; j++) {
     source = sources[j];
     cnt = source.itemCount();
     cats = catList.slice();
     for (i = 0; i < cnt; i++) {
     item = source.getItem(i);
     var label = item.getProp(labelFld);
     var idx = this.getLabelIndex(label, cats);
     if (idx < 0) {
     catList.push(item._category = new ChartAxisCategory(label));
     } else {
     item._category = cats[idx];
     cats.splice(idx, 1);
     }
     }
     }
     } else if (_isArray(source)) {
     cnt = source.length;
     if (cnt > 0) {
     for (i = 0; i < cnt; i++) {
     catList.push(new ChartAxisCategory(source[i]));
     }
     }
     }
     }
     for (i = catList.length; i--;) {
     catList[i].index = i;
     }
     this._positions = this.calcPositions();
     this._ends = this.calcEnds(this._positions);
     this._categoriesDirty = false;
     }
     },
     */
    calcPositions: function () {
        var width, len, w, i,
            cnt = this.visibleCount(),
            cats = this._categoryList,
            pts = new Array(cnt + 1),
            firstIndent = this.firstIndent(),
            lastIndent = this.lastIndent(),
            margins = firstIndent + lastIndent;
        if (cnt > 0) {
            width = 0;
            for (i = 0; i < cnt; i++) {
                width += cats[i].width;
            }
            len = width + margins;
            this._unit = w = (1.0 / width) * (width / len);
            pts[0] = firstIndent / len;
            for (i = 1; i < cnt; i++) {
                pts[i] = pts[i - 1] + w * cats[i - 1].width;
            }
            pts[cnt] = (len - lastIndent) / len;
        }
        return pts;
    },
    calcEnds: function (pts) {
        var i, w, p,
            cnt = pts.length - 1,
            ends = [];
        for (i = 0; i < cnt; i++) {
            w = pts[i + 1] - pts[i];
            p = this._categoryList[i].paddingNear;
            ends[i * 2] = pts[i] + w * p + this._paddingNear * this._unit;
            p = this._categoryList[i].paddingFar;
            ends[i * 2 + 1] = pts[i + 1] - w * p - this._paddingFar * this._unit;
        }
        return ends;
    },
    getTick: function (index) {
        return this._categoryList[index];
    },
    getTickList: function () {
        return this._categoryList.concat();
    },
    getTickNumber: function () {
        return this._categoryList.length;
    },
    getTickPosition: function (index) {
        return this._positions[index - this._startIndex];
    },
    getGridPosition: function (index) {
        return this._positions[index - this._startIndex];
    },
    _invalidateCategories: function () {
        if (!this._categoriesDirty) {
            this._categoriesDirty = true;
            this.invalidate();
        }
    }
}, {
    DATA_CONFIG: {
        id: null
    }
});
var TIC_MULTIPLES = [1, 2, 2.5, 5, 10];
function correctFloat(num) {
    return parseFloat(
        num.toPrecision(14)
    );
}
var DefaultNumericAxisMeasurer = function () {
    var _magnitude = 0;
    var _calcInterval = function(min, max, maxCount) {
        if (min != max) {
            maxCount = Math.max(1, maxCount);
            if (min <= -1) {
                min = Math.floor(min);
            }
            if (max >= 1) {
                max = Math.ceil(max);
            }
            var unit, i, cnt,
                range = max - min,
                interval = range / maxCount;
            _magnitude = Math.floor(Math.log(interval) * Math.LOG10E);
            unit = Math.pow(10, _magnitude);
            for (i = 0, cnt = TIC_MULTIPLES.length; i < cnt; i++) {
                interval = unit * TIC_MULTIPLES[i];
                if (range / interval <= maxCount) {
                    if (TIC_MULTIPLES[i] == 2.5) {
                        _magnitude--;
                    }
                    break;
                }
            }
            return interval;
        } else {
            return 1;
        }
    };
    this.createTicks = function (minimum, maximum, maxCount) {
        var val,
            ticks = [],
            interval = _calcInterval(minimum, maximum, maxCount),
            mag = -Math.min(0, _magnitude),
            min = _floor(minimum / interval) * interval,
            max = _ceil(maximum / interval) * interval;
        if (min < 0 && max > 0) {
            val = 0;
            ticks.push(val);
            while (val < max) {
                val += interval;
                ticks.push(val);
                val = mag ? Number(val.toFixed(mag)) : val;
            }
            val /= 2;
            if (val > max) {
                ticks[ticks.length - 1] = val;
            }
            val = 0;
            while (val > min) {
                val -= interval;
                ticks.unshift(val);
                val = mag ? Number(val.toFixed(mag)) : val;
            }
            val /= 2;
            if (val < min) {
                ticks[0] = val;
            }
        } else if (min != max) {
            val = min;
            while (val < max) {
                ticks.push(val);
                val += interval;
                val = mag ? Number(val.toFixed(mag)) : val;
            }
            ticks.push(val);
        } else {
            if (max > 0) {
                ticks.push(0, max);
            } else if (min < 0) {
                ticks.push(min, 0);
            } else {
                ticks.push(0, 1);
            }
        }
        this.interval = interval;
        this.magnitude = _magnitude;
        return ticks;
    };
};
DefaultNumericAxisMeasurer.Default = new DefaultNumericAxisMeasurer();
var LinearAxis = defineClass("LinearAxis", CartesianAxis, {
    init: function (name) {
        this._super(name);
        this._cacledCount = 0;
        this._calcedMin = NaN;
        this._calcedMax = NaN;
        this._calcedInterval = NaN;
        this._tickList = [];
    },
    baseMode: NumericAxisBase.BOTTOM,
    baseValue: 0,
    minValue: NaN,
    maxValue: NaN,
    fitInterval: true,
    maxPadding: 0.05,
    minPadding: 0.05,
    tickCount: 0,
    tickIntervalWidth: 70,
    ticks: null,
    measurer: DefaultNumericAxisMeasurer.Default,
    setBaseValue: function (value) {
        value = parseFloat(value);
        if (value != this._baseValue) {
            this._baseValue = value;
            this._changed();
        }
        return this;
    },
    calcedBaseValue: function () {
        return isNaN(this._baseValue) ? this._calcedMin : this._baseValue;
    },
    measuredMinimum: function () {
        return this._calcedMin;
    },
    measuredMaximum: function () {
        return this._calcedMax;
    },
    getPositionOf: function (value) {
        return (value - this._calcedMin) / (this._calcedMax - this._calcedMin) * this._locationRate;
    },
    getValueAt: function (position) {
        return this._calcedMin + (this._calcedMax - this._calcedMin) * position;
    },
    isValid: function () {
        return this._calcedMax > this._calcedMin;
    },
    _styleSheetRegion: function () {
        return "linearAxis";
    },
    isContinuous: function () {
        return true;
    },
    _doRefreshTicks: function (chart, size) {
        var range, m, mag, cnt, min, max, pad, fit;
        this._tickList = this.$_parseTicks();
        if (this._tickList) {
            this._calcedInterval = NaN;
        } else {
            range = this._calculateRange(this.baseValue(), this.minValue(), this.maxValue());
            this._calcedMin = range.minValue;
            this._calcedMax = range.maxValue;
            this._calcedCount = this._tickCount;
            if (this._calcedCount <= 0) {
                this._calcedCount = _floor(size / this.tickIntervalWidth());
            }
            m = this.measurer();
            this._tickList = m.createTicks(this._calcedMin, this._calcedMax, this._calcedCount);
            this._calcedInterval = m.interval;
            mag = m.magnitude;
            cnt = this._tickList.length;
            min = this._tickList[0];
            max = this._tickList[cnt - 1];
            pad = Number(this.maxPadding());
            fit = max == this._calcedMax || this.fitInterval();
            if (!fit) {
                max = this._tickList[cnt - 1] = this._calcedMax;
            }
            if (pad > 0) {
                pad = (max - min) * pad;
                if (fit) {
                    if (max === this._calcedMax) {
                        this._tickList.push(max + pad);
                    }
                } else {
                    this._tickList[cnt - 1] += pad;
                }
                pad = _round10(this._tickList[cnt - 1], mag - 1);
                this._tickList[cnt - 1] = pad;
            }
        }
        this._calcedMin = this._tickList[0];
        this._calcedMax = this._tickList[this._tickList.length - 1];
    },
    getTickList: function () {
        return this._tickList.slice();
    },
    getTickNumber: function () {
        return this._tickList.length;
    },
    getTick: function (index) {
        return this._tickList[index];
    },
    getTickPosition: function (index) {
        return this.getPositionOf(this._tickList[index]);
    },
    $_parseTicks: function () {
        var s, cnt, i, v, vals,
            list = null,
            ticks = this.ticks();
        if (!isArray(ticks) && ticks) {
            s = String(ticks).trim();
            ticks = s && s.split(",");
        }
        if (ticks) {
            vals = [];
            for (i = 0, cnt = ticks.length; i < cnt; i++) {
                v = Number(String(ticks[i]).trim());
                if (!isNaN(v)) {
                    vals.push(v);
                }
            }
            if (vals.length > 0) {
                vals.sort(function (v1, v2) { return v1 - v2; });
                ticks = vals;
            } else {
                ticks = [];
            }
            cnt = ticks.length;
            if (!isNaN(this._minValue) && (cnt == 0 || this._minValue < ticks[0])) {
                ticks.unshift(this._minValue);
            }
            cnt = ticks.length;
            if (!isNaN(this._maxValue) && (cnt == 0 || this._maxValue > ticks[0])) {
                ticks.push(this._maxValue);
            }
            cnt = ticks.length;
            if (!isNaN(this._baseValue) && cnt > 0) {
                if (this._baseValue < ticks[0]) {
                    ticks.unshift(this._baseValue);
                } else if (this._baseValue > ticks[cnt - 1]) {
                    ticks.push(this._baseValue);
                }
            }
            if ((cnt = ticks.length) >= 2) {
                list = [];
                for (i = 0; i < cnt; i++) {
                    list.push(ticks[i]);
                }
            }
        }
        this._calcedCount = list ? list.length : 0;
        return list;
    }
});
var PolarAxis = defineClass("RadarAxis", CategorizedAxis, {
    init: function (name) {
        this._super(name);
        this._ticks = [];
        this._curved = false;
    },
    originAngle: Math.PI * 3 / 2,
    startAngle: 0,
    clockwise: true,
    spokeCount: function () {
        return this.categoryCount();
    },
    connectableWith: function (series) {
        return this.sources().length === 0;
    },
    getTickPoints: function (bounds, polarSize) {
        var rd, cx, cy, angle, start, i, p,
            pts = [],
            spokes = this.spokeCount();
        if (spokes > 0) {
            rd = Math.min(bounds.width, bounds.height) / 2;
            rd *= polarSize;
            cx = bounds.x + bounds.width / 2;
            cy = bounds.y + bounds.height / 2;
            angle = (2 * Math.PI) / spokes;
            start = 0;
            for (i = 0; i < spokes; i++) {
                p = this.getPointOf(start, cx, cy, rd);
                start += angle;
                pts.push(p);
            }
        }
        return pts;
    },
    getPositionOf: function (value) {
        return 1.0;
    },
    getPointOf: function (angle, x, y, radius) {
        return Graphics.getEllipsePoint(x, y, radius, radius,
            this.startAngle() + angle, this.originAngle(), this.clockwise());
    },
    _styleSheetRegion: function () {
        return "polarAxis";
    }
});
var LinearPolarAxis = defineClass("LinearPolarAxis", PolarAxis, {
    init: function (name) {
        this._super(name);
    }
});
var CategorizedPolarAxis = defineClass("CategorizedPolarAxis", PolarAxis, {
    init: function (name) {
        this._super(name);
    }
});
var DatetimeAxis = defineClass("DatetimeAxis", CartesianAxis, {
    init: function (name) {
        this._super(name);
    }
});
var PlottingSource = defineClass("PlottingSource", ChartObject, {
    init: function (owner, name, styleName) {
        this._super(owner, styleName);
        this._name = name;
        this._xAxisObj = null;
        this._yAxisObj = null;
    },
    name: null,
    xAxis: null,
    yAxis: null,
    zindex: 0,
    clusterWidth: 1.0,
    xAxisObj: function () {
        return this._xAxisObj;
    },
    yAxisObj: function () {
        return this._yAxisObj;
    },
    isPolar: function () {
        return false;
    },
    mixableWith: function (axis) {
        return false;
    },
    disconnectFromAxis: function () {
        this._xAxisObj = this._yAxisObj = null;
    },
    connectToAxes: function (xAxes, yAxes) {
        var i, axis;
        if (this.xAxis()) {
            for (i = 0; i < xAxes.length; i++) {
                axis = xAxes[i];
                if (axis.name() == this.xAxis() && this._connectXAxis(axis)) {
                    break;
                }
            }
        }
        if (!this._xAxisObj && xAxes.length > 0) {
            this._connectXAxis(xAxes[0]);
        }
        if (this.yAxis()) {
            for (i = 0; i < yAxes.length; i++) {
                axis = yAxes[i];
                if (axis.name() == this.yAxis() && this._connectYAxis(axis)) {
                    break;
                }
            }
        }
        if (!this._yAxisObj && yAxes.length > 0) {
            this._connectYAxis(yAxes[0]);
        }
    },
    connectToAxis: function (xAxis, yAxis) {
        if (xAxis) {
            this.connectXAxis(xAxis);
        }
        if (yAxis) {
            this.connectYAxis(yAxis);
        }
    },
    connectableXAxis: function (axis) {
        return axis instanceof CartesianAxis;
    },
    connectableYAxis: function (axis) {
        return axis instanceof CartesianAxis;
    },
    getLegendColor: function () {
        return this.styles().background();
    },
    _connectXAxis: function (axis) {
        if (this.connectableXAxis(axis)) {
            this._xAxisObj = axis;
            axis.addSource(this);
            return true;
        }
    },
    _connectYAxis: function (axis) {
        if (this.connectableYAxis(axis)) {
            this._yAxisObj = axis;
            axis.addSource(this);
            return true;
        }
    },
    isClusterable: function () {
        return false;
    },
    clusteredAxis: function () {
        return null;
    }
});
var ChartSeriesItem = defineClass("ChartSeriesItem", null, {
    init: function (series, data) {
        this._super();
        this._series = series;
        this._index = -1;
        this._data = data;
        this._styles = null;
        this._labelStyles = null;
    },
    visible: true,
    data: null,
    styles: null,
    labelStyles: null,
    styles_: function () {
        this._series.$_prepareStyles(ChartSeriesItemRuntime.Default, this);
        return this._styles || this._series._runStyles;
    },
    setStyles: function (value) {
        var parent;
        if (value != this._styles && value != (parent = this._series._runStyles)) {
            if (value) {
                if (!this._styles) {
                    this._styles = new GridStyles("chartSeriesItem", null);
                    this._styles.setParent(parent, false);
                }
                this._styles.extend(value);
            } else {
                this._styles = null;
            }
        }
    },
    labelStyles_: function () {
        this._series._label.$_prepareStyles(ChartSeriesItemRuntime.Default, this);
        return this._labelStyles || this._series._label._runStyles;
    },
    setLabelStyles: function (value) {
        var parent;
        if (value != this._labelStyles && value != (parent = this._series._label._runStyles)) {
            if (value) {
                if (!this._labelStyles) {
                    this._labelStyles = new GridStyles("chartSeriesItemLabel", null);
                    this._labelStyles.setParent(parent, false);
                }
                this._labelStyles.extend(value);
            } else {
                this._labelStyles = null;
            }
        }
    },
    series: function () {
        return this._series;
    },
    index: function () {
        return this._index;
    },
    displayName: function () {
        return this._data.toString ? this._data.toString() : _toStr(this._data);
    },
    getProp: function (prop, defaultValue) {
        if (this._data.hasOwnProperty(prop)) {
            return this._data[prop];
        } else if (defaultValue !== UNDEFINED) {
            return defaultValue;
        } else {
            return this._data;
        }
    },
    setProp: function (prop, value) {
        this._data[prop] = value;
    },
    getDate: function (prop) {
        if (this._data.hasOwnProperty(prop)) {
            var v = this._data[prop];
            if (!(v instanceof Date)) {
                v = new Date(v);
                this._data[prop] = v;
            }
            return v;
        } else {
            return this._data;
        }
    }
});
var ChartLabel = defineClass("ChartLabel", ChartLabelBase, {
    init: function (owner, parentStyles) {
        this._super(owner, "chartLabel", parentStyles);
        this._runStyles = new GridStyles(this, "chartLabelRun");
        this._runStyles.setParent(this._styles, false);
        this._dynamicStyles = new DynamicStyleCollection();
        this._itemView = null; // for palette
    },
    getPaletteIndex: function (index) {
        return this._itemView ? this._itemView.index() : 0;
    },
    dynamicStyles: null,
    setDynamicStyles: function (value) {
        if (value != this._dynamicStyles) {
            this._dynamicStyles.setItems(value);
            this._changed();
        }
        return this;
    },
    $_prepareStyles: function (runtime, seriesItem) {
        var s = this._runStyles;
        s.clearValues();
        runtime.setItem(seriesItem);
        this._dynamicStyles.applyInternal(runtime, s);
    },
});
var ChartLegendItem = defineClass("ChartLegendItem", null, {
    init: function (owner, source) {
        this._super();
        this._owner = owner;
        this._source = source;
        this._styles = new GridStyles(owner, "legendItem");
    },
    styles: null,
    owner: function () {
        return this._owner;
    },
    source: function () {
        return this._source;
    },
    setStyles: function (value) {
        if (value !== this._styles) {
            this._styles.extend(value);
        }
    }
});
var ChartLegend = defineClass("ChartLegend", ChartObject, {
    init: function () {
        this._super();
        this._items = [];
        this.setVisible(false);
        this._styles.setPaddingTop(2);
        this._styles.setPaddingBottom(2);
        this._styles.setPaddingLeft(2);
        this._styles.setPaddingRight(2);
    },
    position: EnumProp(ChartItemPosition, ChartItemPosition.BOTTOM),
    direction: EnumProp(ChartLegendDirection, ChartLegendDirection.HORIZONTAL),
    markerWidth: 13,
    markerHeight: 11,
    itemGap: 8,
    marginLeft: 2,
    marginRight: 2,
    marginTop: 2,
    marginBottom: 2,
    source: null,
    items: function () {
        return this._items;
    },
    findItem: function (itemSource) {
        var i, cnt, items = this._items;
        for (i = 0, cnt = items.length; i < cnt; i++) {
            if (items[i].source == itemSource) {
                return items[i];
            }
        }
        return null;
    },
    _doUpdate: function (owner, force) {
        this._refreshItems();
    },
    _refreshItems: function() {
        var legendItems, styles, i, cnt, src, item,
            source = this._source,
            items = this._items = [];
        if (!source) {
            return;
        }
        legendItems = source.getLegendItems();
        if (!legendItems || (cnt = legendItems.length) < 1) {
            return;
        }
        styles = this._styles;
        for (i = 0; i < cnt; i++) {
            src = legendItems[i];
            item = this.findItem(src);
            if (item == null) {
                item = new ChartLegendItem(this, src);
            }
            item.styles().setParent(styles);
            items.push(item);
        }
        this._items = items;
    }
});
/** @abstract */
var ChartSeries = defineClass("ChartSeries", PlottingSource, {
    init: function (owner, name) {
        this._super(owner, name, "series");
        this._synchronizer = new ChartDataSynchronizer(owner._synchronizer);
        this._runStyles = new GridStyles(this, "seriesRun");
        this._runStyles.setParent(this._styles, false);
        this._dynamicStyles = new DynamicStyleCollection();
        this._label = new ChartLabel(this, this._styles);
        this._animations = [];
        this._filterNode = null;
        this._group = null;
        this._groupIndex = -1;
        this._itemsDirty = false;
        this._itemList = null;
        this._summary = null;
        this._itemView = null; // for palette
        this._styles.setBackground(SolidBrush.LTGRAY);
        this._styles.setBorder(SolidPen.GRAY);
        this._styles.setFontSize(10);
    },
    labelChanged: function (label) {
        this._changed();
    },
    dynamicStyles: null,
    label: null,
    dataDirection: EnumProp(ChartDataDirection, ChartDataDirection.DEFAULT),
    valueField: "value",
    filter: null, // 데이터를 가져오는 방향에 따라 rowFilter, columnFilter
    visibleOnly: false,//true면 화면에 표시된 데이터만 가져온다.
    itemsLegend: false,
    summaryMode: EnumProp(SummaryMode, SummaryMode.NONE),
    nanValue: 0,
    caption: null,
    items: null,
    animations: null,
    overflow: EnumProp(ChartOverflowPolicy, ChartOverflowPolicy.JUSTIFY),
    itemDisplayOrder: EnumProp(ChartItemDisplayOrder, ChartItemDisplayOrder.FIRST),
    setDynamicStyles: function (value) {
        if (value != this._dynamicStyles) {
            this._dynamicStyles.setItems(value);
            this._changed();
        }
        return this;
    },
    setLabel: function (value) {
        if (value !== this._label) {
            this._label.assign(value);
            this._changed();
        }
        return this;
    },
    setItems: function (value) {
        value = _asArray(value);
        if (value !== this._items) {
            this._items = value;
        }
    },
    setFilter: function (value) {
        if (value != this._filter) {
            this._filter = value;
            this._filterNode = value ? ExpressionParser.Default.parse(value, null) : null;
        }
    },
    group: function () {
        return this._group;
    },
    groupIndex: function () {
        return this._groupIndex;
    },
    itemCount: function () {
        return this._itemList ? this._itemList.length : 0;
    },
    displayCount: function () {
        return this.itemCount();
    },
    viewsPerItem: function () {
        return 1;
    },
    textsPerItem: function () {
        return 1;
    },
    isPolar: function () {
        return false;
    },
    displayName: function () {
        return this._caption || this._name;
    },
    getItem: function (index) {
        return this._itemList ? this._itemList[index] : 0;
    },
    loadItems: function (source) {
        if (this._items) {
            this._doLoadExplicitItems(this._items);
        } else if (source instanceof ChartCell || source instanceof MergedChartCell) {
            this._doLoadCellItems(source);
        } else if (source instanceof GridRow) {
            this._doLoadRowItems(source);
        } else if (source instanceof GridBase) {
            this._doLoadGridItems(source);
        }
        var mode = this._summaryMode;
        if (mode == SummaryMode.AGGREGATE || mode == SummaryMode.STATISTICAL) {
            this._summary = this._summarize(mode == SummaryMode.STATISTICAL)
        } else {
            this._summary = null;
        }
        return this;
    },
    setFocused: function (grid, index) {
        this._synchronizer.setFocused(grid, index);
    },
    getPaletteIndex: function (index) {
        return this._itemView ? this._itemView.index() : 0;
    },
    getValue: function (value) {
        return isNaN(value) ? this._nanValue : value;
    },
    $_prepareStyles: function (runtime, seriesItem) {
        var s = this._runStyles;
        s.clearValues();
        runtime.setItem(seriesItem);
        this._dynamicStyles.applyInternal(runtime, s);
    },
    $_setItemView: function (view) {
        this._itemView = view;
        this._label._itemView = view;
        return this;
    },
    _isDefaultOrVerticalData: function () {
        return this._dataDirection == ChartDataDirection.VERTICAL || this._dataDirection == ChartDataDirection.DEFAULT;
    },
    _createItem: function (data) {
        var flds, obj, i;
        if (isArray(data) && data.length > 0) {
            flds = this.fieldList();
            if (flds) {
                obj = {};
                for (i = flds.length; i--;) {
                    obj[flds[i]] = data[i];
                }
                data = obj;
            }
        }
        return new ChartSeriesItem(this, data);
    },
    _createItemFrom: function (index, row, props) {
        var i, p, item,
            data = {};
        for (i = props.length; i--;) {
            p = props[i];
            data[p] = row.getValue(p);
        }
        item = new ChartSeriesItem(this, data);
        item._index = index;
        return item;
    },
    _getItemProps: function () {
        return [this.labelField(), this.valueField()];
    },
    _doLoadExplicitItems: function (source) {
        var i, cnt, item;
        this._itemList = [];
        for (i = 0, cnt = source.length; i < cnt; i++) {
            item = this._createItem(source[i]);
            item._index = i;
            this._itemList.push(item);
        }
    },
    _doLoadCellItems: function (cell) {
        var i, item, row, grid, props, room, start, end, runtime, v, data, vals, labels,
            dir = this._dataDirection;
        if (dir == ChartDataDirection.VERTICAL || dir == ChartDataDirection.DEFAULT && cell.index().column.stateFor(ColumnMergeManager.MERGE_ROOMS)) {
            grid = cell.grid();
            props = this._getItemProps();
            room = cell instanceof MergedChartCell ? cell.room() : null;
            start = room ? room._head : cell.index().rowIndex;
            end = room ? room._tail : start;
            runtime = this._filterNode ? ChartSeriesFilterRuntime.Default() : null;
            if (runtime) {
                runtime.prepare(grid.dataSource(), this._synchronizer);
            }
            this._itemList = [];
            for (i = start, idx = 0; i <= end; i++) {
                row = grid.getRow(i);
                if (row.dataIndex() >= 0 && (!runtime || this._filterNode.evaluate(runtime.setRow(row)))) {
                    item = this._createItemFrom(idx++, row, props);
                    this._itemList.push(item);
                }
            }
        } else {
            vals = cell.value();
            labels = cell.labels();
            if (_isArray(vals)) {
                this._itemList = [];
                for (i = 0; i < vals.length; i++) {
                    v = isNaN(vals[i]) ? this._nanValue : vals[i];
                    data = {label: labels[i], value: v};
                    item = this._createItem(data);
                    item._index = i;
                    this._itemList.push(item);
                }
            } else {
                this._summary = /*this._values =*/ this._itemList = null;
            }
        }
    },
    _doLoadRowItems: function (row) {
        var props, runtime, rows, i, idx, cnt, item,
            group = _cast(row, GroupRow);
        if (group) {
            if (this._isDefaultOrVerticalData()) {
                props = this._getItemProps();
                runtime = this._filterNode ? ChartSeriesFilterRuntime.Default() : null;
                if (runtime) {
                    runtime.prepare(group.dataSource(), this._synchronizer);
                }
                this._itemList = [];
                rows = group.getDescendants(this._visibleOnly, true);
                for (i = 0, idx = 0, cnt = rows.length; i < cnt; i++) {
                    row = rows[i];
                    if (row.dataIndex() >= 0 && (!runtime || this._filterNode.evaluate(runtime.setRow(row)))) {
                        item = this._createItemFrom(idx++, row, props);
                        this._itemList.push(item);
                    }
                }
            } else {
            }
        }
    },
    _doLoadGridItems: function (grid) {
        var props, runtime, i, idx, cnt, row, item;
        if (this._isDefaultOrVerticalData()) {
            props = this._getItemProps();
            runtime = this._filterNode ? ChartSeriesFilterRuntime.Default() : null;
            if (runtime) {
                runtime.prepare(grid.dataSource(), this._synchronizer);
            }
            this._itemList = [];
            for (i = 0, idx = 0, cnt = grid.rowCount(); i < cnt; i++) {
                row = grid.getRow(i);
                if (row.dataIndex() >= 0 && (!runtime || this._filterNode.evaluate(runtime.setRow(row)))) {
                    item = this._createItemFrom(idx++, row, props);
                    this._itemList.push(item);
                }
            }
        } else {
        }
    },
    _summarize: function (calcVars) {
        var v, item, vars, avg, valueProp, sum, min, max, vals, i, n, summary,
            cnt = this.itemCount();
        if (cnt > 0) {
            valueProp = this.valueField();
            sum = 0;
            min = NaN;
            max = NaN;
            vals = calcVars ? [] : null;
            i = 0;
            n = 0;
            while (i < cnt) {
                item = this.getItem(i++);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    sum = min = max = v;
                    calcVars && vals.push(v);
                    n++;
                    break;
                }
            }
            for (; i < cnt; i++) {
                item = this.getItem(i);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    sum += v;
                    if (v < min) min = v;
                    if (v > max) max = v;
                    calcVars && vals.push(v);
                    n++;
                }
            }
            if (n > 0) {
                summary = {
                    sum: sum,
                    min: min,
                    max: max,
                    avg: sum / cnt
                }
                if (calcVars) {
                    vars = 0;
                    avg = summary.avg;
                    for (i = vals.length; i--;) {
                        vars += Math.pow(v - avg, 2);
                    }
                    summary.varsp = vars / cnt;
                    summary.vars = vars / (cnt - 1);
                } else {
                    summary.varsp = NaN;
                    summary.vars = NaN;
                }
            }
            return summary;
        }
    },
    collectValues: function (base, upper) {
        var i,  item, v,
            prop = this.valueField(),
            cnt = this.itemCount(),
            vals = [];
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                item = this.getItem(i++);
                v = item ? item.getProp(prop) : NaN;
                vals.push((upper && v > base || !upper && v < base) ? v : base);
            }
        }
        return vals;
    },
    getLowerValues: function (base) {
        return this.collectValues(base, false);
    },
    getUpperValues: function (base) {
        return this.collectValues(base, true);
    },
    calcMinValue: function (valueProp) {
        if (this._summary) {
            return this._summary.min;
        }
        var min, i, v, item,
            cnt = this.itemCount();
        if (cnt > 0) {
            min = NaN;
            i = 0;
            while (i < cnt) {
                item = this.getItem(i++);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    min = v;
                    break;
                }
            }
            for (; i < cnt; i++) {
                item = this.getItem(i);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    min = Math.min(min, v);
                }
            }
            return min;
        }
        return NaN;
    },
    calcMaxValue: function (valueProp) {
        if (this._summary) {
            return this._summary.max;
        }
        var max, i, v, item,
            cnt = this.itemCount();
        if (cnt > 0) {
            max = NaN;
            i = 0;
            while (i < cnt) {
                item = this.getItem(i++);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    max = v;
                    break;
                }
            }
            for (; i < cnt; i++) {
                item = this.getItem(i);
                v = item ? item.getProp(valueProp) : NaN;
                if (!isNaN(v)) {
                    max = Math.max(max, v);
                }
            }
            return max;
        }
        return NaN;
    }
});
/** @abstract */
var ChartSeriesGroup = defineClass("ChartSeriesGroup", PlottingSource, {
    init: function (owner, name) {
        this._super(owner, name);
        this._series = [];
    },
    stackMode: EnumProp(ChartStackMode, ChartStackMode.NONE),
    series: function () {
        return this._series.concat();
    },
    setSeries: function (value) {
        var i, cnt;
        this._series = [];
        if (value instanceof ChartSeries) {
            this.addSeries(value);
            this.invalidate();
        } else {
            for (i = 0, cnt = value.length; i < cnt; i++) {
                this.addSeries(value[i]);
            }
            this.invalidate();
        }
    },
    count: function () {
        return this._series.length;
    },
    addSeries: function (ser) {
        var i, cnt;
        if (ser) {
            if (this._series.length < 1) {
                this._series.push(ser);
                return true;
            } else {
                for (i = 0, cnt = this._series.length; i < cnt; i++) {
                    if (ser === this._series[i] || !this.containableWith(ser)) {
                        return false;
                    }
                }
                this._series.push(ser);
                return true;
            }
        }
        return false;
    },
    indexOf: function (series) {
        var i, cnt;
        for (i = 0, cnt = this._series.length; i < cnt; i++) {
            if (this._series[i] === series) {
                return i;
            }
        }
        return -1;
    },
    getItem: function (index) {
        if (index < 0 || index >= this._series.length) {
            throw "Invalid index: " + index;
        }
        return this._series[index];
    },
    seriesByName: function (seriesName) {
        var i, cnt;
        for (i = 0, cnt = this._series.length; i < cnt; i++) {
            if (this._series[i].name() === seriesName) {
                return this._series[i];
            }
        }
        return null;
    },
    collectValues: function (base, upper) {
        var ser, i, vals, j, len,
            cnt = this._series.length,
            sums = [];
        for (i = 0; i < cnt; i++) {
            ser = this._series[i];
            vals = upper ? ser.getUpperValues(base) : ser.getLowerValues(base);
            for (j = 0, len = vals.length; j < len; j++) {
                if (j >= sums.length) {
                    sums.push(vals[j]);
                } else {
                    sums[j] += vals[j];
                }
            }
        }
        return sums;
    },
    getLowerValues: function (base) {
        return this.collectValues(base, false);
    },
    getUpperValues: function (base) {
        return this.collectValues(base, true);
    },
    getMinValueAt: function (axis) {
        var i, ser, vals, len, base,
            v = NaN,
            cnt = this._series.length;
        if (cnt > 0) {
            if (this.stackMode() == ChartStackMode.NONE || this.stackMode() == ChartStackMode.OVERLAPPED) {
                i = 0;
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMinValueAt && ser.visible()) {
                        v = ser.getMinValueAt(axis);
                        break;
                    }
                }
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMinValueAt && ser.visible()) {
                        v = Math.min(v, ser.getMinValueAt(axis));
                    }
                }
            } else {
                base = axis.baseValue();
                vals = this.getLowerValues(base);
                v = base;
                for (i = 0, len = vals.length; i < len; i++) {
                    v = Math.min(vals[i], v);
                }
            }
        }
        return v;
    },
    getMaxValueAt: function (axis) {
        var i, ser, base, vals,
            v = NaN,
            cnt = this._series.length;
        if (cnt > 0) {
            if (this.stackMode() == ChartStackMode.NONE || this.stackMode() == ChartStackMode.OVERLAPPED) {
                i = 0;
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMaxValueAt && ser.visible()) {
                        v = ser.getMaxValueAt(axis);
                        break;
                    }
                }
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMaxValueAt && ser.visible()) {
                        v = Math.max(v, ser.getMaxValueAt(axis));
                    }
                }
            } else {
                base = axis.baseValue();
                vals = this.getUpperValues(base);
                v = base;
                for (i = 0, len = vals.length; i < len; i++) {
                    v = Math.max(vals[i], v);
                }
            }
        }
        return v;
    },
    getMinDateAt: function (axis) {
        var i, ser, vals, len, base,
            v = null,
            cnt = this._series.length;
        if (cnt > 0) {
            if (this.stackMode() == ChartStackMode.NONE || this.stackMode() == ChartStackMode.OVERLAPPED) {
                i = 0;
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMinDateAt && ser.visible()) {
                        v = ser.getMinDateAt(axis);
                        break;
                    }
                }
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMinDateAt && ser.visible()) {
                        v = _minDate(v, ser.getMinDateAt(axis));
                    }
                }
            } else {
                base = axis.baseValue();
                vals = this.getLowerValues(base);
                v = base;
                for (i = 0, len = vals.length; i < len; i++) {
                    v = _minDate(vals[i], v);
                }
            }
        }
        return v;
    },
    getMaxDateAt: function (axis) {
        var i, ser, len, base, vals,
            v = null,
            cnt = this._series.length;
        if (cnt > 0) {
            if (this.stackMode() == ChartStackMode.NONE || this.stackMode() == ChartStackMode.OVERLAPPED) {
                i = 0;
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMaxDateAt && ser.visible()) {
                        v = ser.getMaxDateAt(axis);
                        break;
                    }
                }
                while (i < cnt) {
                    ser = this._series[i++];
                    if (ser.getMaxDateAt && ser.visible()) {
                        v = _maxDate(v, ser.getMaxDateAt(axis));
                    }
                }
            } else {
                base = axis.baseValue();
                vals = this.getUpperValues(base);
                v = base;
                for (i = 0, len = vals.length; i < len; i++) {
                    v = _maxDate(vals[i], v);
                }
            }
        }
        return v;
    },
    loadItems: function (source) {
        var i, cnt;
        for (i = 0, cnt = this._series.length; i < cnt; i++) {
            this._series[i].loadItems(source);
        }
    }
});
var CartesianSeries = defineClass("CartesianSeries", ChartSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    locationRate: 1,
    xAxisObj: function () {
        return this.group() ? this.group().xAxisObj() : this._xAxisObj;
    },
    yAxisObj: function () {
        return this.group() ? this.group().yAxisObj() : this._yAxisObj;
    },
    mixableWith: function (other) {
        return (other instanceof CartesianSeries); //&&
    },
    isValueAxis: function (axis) {
        return axis === this.yAxisObj();
    }
});
var CartesianSeriesGroup = defineClass("CartesianSeriesGroup", ChartSeriesGroup, {
    init: function (owner, name) {
        this._super(owner, name);
    }
});
var LabeledValueSeries = defineClass("LabeledValueSeries", CartesianSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    labelField: "label",
    dateField: "date",
    getMinDate: function (axis) {
        var i, item, d,
            v = null,
            cnt = this.itemCount();
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                item = this.getItem(i);
                d = this.getDate(item);
                if (v == null) v = d;
                else if (d < v) v = d;
            }
        }
        return v;
    },
    getMaxDate: function (axis) {
        var i, item, d,
            v = null,
            cnt = this.itemCount();
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                item = this.getItem(i);
                d = this.getDate(item);
                if (v == null) v = d;
                else if (d > v) v = d;
            }
        }
        return v;
    },
    displayCount: function () {
        var count = this.itemCount(),
            axis = this.xAxisObj();
        if (!(axis instanceof CategorizedAxis)) {
            axis = this.yAxisObj();
        }
        return (axis instanceof CategorizedAxis) ? axis.categoryCount() : count;
    },
    getMinValueAt: function (axis) {
        return this.calcMinValue(this.valueField());
    },
    getMaxValueAt: function (axis) {
        return this.calcMaxValue(this.valueField());
    },
    getMinDateAt: function (axis) {
        return this.calcMinDate(this.dateField());
    },
    getMaxDateAt: function (axis) {
        return this.calcMaxDate(this.dateField());
    },
    getLabels: function (axis) {
        return this.extractLabels(this.labelField());
    },
    getDate: function (item) {
        var v = item.getProp(this.dateField());
        if (!(v instanceof Date)) {
            v = new Date(v);
            item.setProp(this.dateField(), v);
        }
        return v;
    }
});
var ClusterableSeries = defineClass("ClusterableSeries", LabeledValueSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    }
});
var ColumnSeries = defineClass("ColumnSeries", ClusterableSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    itemWidth: 0.7,
    itemShape: null,
    _createItem: function (data) {
        var item = this._super(data);
        item.setProp("shape", this._itemShape);
        return item;
    },
    isClusterable: function () {
        return true;
    },
    clusteredAxis: function () {
        return this.xAxisObj();
    }
});
var ColumnSeriesGroup = defineClass("ColumnSeriesGroup", CartesianSeriesGroup, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    isClusterable: function () {
        return true;
    },
    clusteredAxis: function () {
        return this.xAxisObj();
    },
    containableWith: function (series) {
        return series instanceof ColumnSeries;
    },
    mixableWith: function (other) {
        return true;// other instanceof ColumnSeriesGroup //
    }
});
var BarSeries = defineClass("BarSeries", ColumnSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    _styleSheetRegion: function () {
        return "barSeries";
    },
    clusteredAxis: function () {
        return this.yAxisObj();
    },
    isValueAxis: function (axis) {
        return axis === this.xAxisObj();
    }
});
var BarSeriesGroup = defineClass("BarSeriesGroup", ColumnSeriesGroup, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    clusteredAxis: function () {
        return this.yAxisObj();
    },
    containableWith: function (series) {
        return series instanceof BarSeries;
    },
    mixableWith: function (other) {
        return true;// other instanceof BarSeriesGroup //
    }
});
var LineSeries = defineClass("LineSeries", LabeledValueSeries, {
    init: function (owner, name) {
        this._super(owner, name);
        this._legendFill = new SolidBrush();
    },
    lineType: ChartLineType.STRAIGHT,
    _styleSheetRegion: function () {
        return "lineSeries";
    }
});
var AreaSeries = defineClass("AreaSeries", LineSeries, {
    init: function (owner, name) {
        this._super(owner, name);
        this._styles.setBackground("#10000000");
    }
});
var AreaSeriesGroup = defineClass("AreaSeriesGroup", CartesianSeriesGroup, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    containableWith: function (series) {
        return series instanceof AreaSeries;
    },
    mixableWith: function (other) {
        return true;//other instanceof AreaSeriesGroup ||
    }
});
/** @abstract */
var RadialSeries = defineClass("RadialSeries", ChartSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    startAngle: 0,
    totalAngle: 360,
    radius: 0.6,
    innerRadius: 0,
    offsetX: 0,
    offsetY: 0,
    radiusRate: 1,
    labelField: null,
    setTotalAngle: function (value) {
        this._totalAngle = isNaN(value) ? 360 : Math.max(0, Math.min(360, value));
    },
    startAngleRad: function () {
        return isNaN(this._startAngle) ? 0 : (this._startAngle / _RADIAN);
    },
    totalAngleRad: function () {
        return isNaN(this._totalAngle) ? _2PI : (this._totalAngle / _RADIAN);
    },
    labelField_: function () {
        return this._labelField || "label";
    },
    isPolar: function () {
        return true;
    },
    xAxisObj: function () {
        return this.group() ? this.group().xAxisObj() : this._xAxisObj;
    },
    yAxisObj: function () {
        return this.group() ? this.group().yAxisObj() : this._yAxisObj;
    },
    mixableWith: function (other) {
        return (other instanceof RadialSeries) && other.xAxisObj() == this.yAxisObj();
    },
    getItemProp: function (item, prop) {
        var axis;
        if (prop == "label" || prop == "category") {
            if ((axis = this.xAxisObj()).getCategory) {
                return axis.getCategory(item.index());
            } else {
                return item.index();
            }
        }
        return this._super(item, prop);
    },
    getMinValueAt: function (axis) {
        return this.calcMinValue(this.valueField());
    },
    getMaxValueAt: function (axis) {
        return this.calcMaxValue(this.valueField());
    },
    getLabels: function (axis) {
        return this.extractLabels(this.labelField());
    },
    getItemCaption: function (item) {
        var axis = this.xAxisObj();
        if (axis && axis.getCategory) {
            return axis.getCategory(item.index()) + "," + item.getProp(this._valueField);
        } else {
            return item.getProp(this._labelField);
        }
    },
    connectableXAxis: function (axis) {
        return axis instanceof PolarAxis;
    },
    connectableYAxis: function (axis) {
        return axis instanceof CartesianAxis;
    }
});
var PieSeries = defineClass("PieSeries", RadialSeries, {
    init: function (owner, name) {
        this._super(owner, name);
    },
    tickLength: 7,
    labelOffset: 7,
    slicedOffset: 10,
    slicedField: null,
    slicedAnimating: true,
    slicedField_: function () {
        return this._slicedField || "sliced";
    },
    assign: function (source) {
        this._super(source);
        /*
        var ani = new Animation();
        ani.property = ChartAnimationTypes.PROP_SLICE;
        ani.trigger = ChartAnimationTypes.TRIGGER_LOADED;
        ani.delay = 100;
        ani.duration = 500;
        this.addAnimation(ani);
        */
    },
    _styleSheetRegion: function () {
        return "pieSeries";
    },
    _doGetItemCases: function (item, cases) {
        if (item.getProp(this.slicedField())) {
            cases.push("sliced");
        }
    },
    _doUpdate: function (owner, force) {
        this._super(owner, force);
    }
});
var GridChartLoader = defineClass("GridChartLoader", null, {
    init: function () {
        this._super();
    },
    load: function (source, chart) {
        var s, ct, axes, groups, group, series, series2, i, cnt, j, ser, nSeries, found;
        if (source && source.type && GridChartLoader.ChartTypes.hasOwnProperty(s = source.type.trim())) {
            ct = GridChartLoader.ChartTypes[s];
            chart = chart || new GridChart();
            source.styles && chart.setStyles(source.styles);
            source.plotArea && chart.setPlotArea(source.plotArea);
            source.legend && chart.setLegend(source.legend);
            axes = this.$_loadAxes(source.xAxes, ct.xAxisType());
            if (axes.length < 1) {
                axes.push(this.$_loadAxis({}, ct.xAxisType()));
            }
            chart.setXAxes(axes);
            axes = this.$_loadAxes(source.yAxes, ct.yAxisType());
            if (axes.length < 1) {
                axes.push(this.$_loadAxis({}, ct.yAxisType()));
            }
            chart.setYAxes(axes);
            groups = this.$_loadSeriesGroups(chart, ct, source.seriesGroups);
            series = this.$_loadSeries(chart, ct, source.series);
            if (groups) {
                nSeries = series.length;
                for (i = 0, cnt = groups.length; i < cnt; i++) {
                    group = groups[i];
                    for (j = 0; j < nSeries; j++) {
                        ser = series[j];
                        if (ser instanceof ChartSeries && ser.source.group == group.name()) {
                            group.addSeries(ser);
                            ser._group = group;
                            ser._groupIndex = group.count() - 1;
                        }
                    }
                }
                series2 = [];
                for (i = 0; i < nSeries; i++) {
                    ser = series[i];
                    if (ser instanceof ChartSeries) {
                        group = ser._group;
                        if (group) {
                            if (series2.indexOf(group) < 0) {
                                series2.push(group);
                            }
                        } else {
                            series2.push(ser);
                        }
                    }
                }
                chart.setSeries(series2);
            } else {
                chart.setSeries(series);
            }
        }
        return chart;
    },
    $_loadAxis: function (source, defaultType) {
        var axis = null,
            type = source.type || defaultType;
        switch (type) {
            case "linear":
                axis = new LinearAxis();
                break;
            case "category":
                axis = new CategorizedAxis();
                break;
            case "datetime":
                axis = new DatetimeAxis();
                break;
            case "linearPolar":
                axis = new LinearPolarAxis();
                axis.setVisible(false);
                break;
            case "categoryPolar":
                axis = new CategorizedPolarAxis();
                break;
            default:
                throw "Invalid axis type: " + type;
        }
        if (axis) {
            axis.assign(source);
        }
        return axis;
    },
    $_loadAxes: function (source, defaultType) {
        var i, cnt, axis,
            axes = [],
            arr = _toArray(source);
        if (arr) {
            for (i = 0, cnt = arr.length; i < cnt; i++) {
                axis = this.$_loadAxis(arr[i], defaultType);
                axes.push(axis);
            }
        }
        return axes;
    },
    $_loadSeriesGroups: function (chart, chartType, source) {
        var i, cnt, src, group, polar, type,
            groups = null,
            sources = _toArray(source);
        if (sources) {
            for (i = 0, cnt = sources.length; i < cnt; i++) {
                src = sources[i];
                if (src.name) {
                    group = null;
                    polar = src.polar;
                    type = src.type && src.type.toLowerCase();
                    if (polar) {
                        switch (type) {
                            case "column":
                                group = new RadialColumnSeriesGroup();
                                break;
                            case "area":
                                group = new RadialAreaSeriesGroup();
                                break;
                        }
                    } else if (type) {
                        switch (type) {
                            case "column":
                                group = new ColumnSeriesGroup();
                                break;
                            case "bar":
                                group = new BarSeriesGroup();
                                break;
                            case "area":
                                group = new AreaSeriesGroup();
                                break;
                            case "barrange":
                                group = new BarRangeSeriesGroup();
                                break;
                            case "columnrange":
                                group = new ColumnRangeSeriesGroup();
                                break;
                        }
                    } else {
                        group = this._createDefaultSeriesGroup();
                    }
                    if (group) {
                        group.assign(src);
                        groups = groups || [];
                        groups.push(group);
                    }
                }
            }
        }
        return groups;
    },
    $_loadSeries: function (chart, chartType, source) {
        var i, cnt, src, ct, ser,
            series = [],
            arr = _toArray(source);
        if (arr) {
            for (i = 0, cnt = arr.length; i < cnt; i++) {
                src = arr[i];
                if (src.type) {
                    ct = GridChartLoader.ChartTypes[src.type];
                    if (ct) chartType = ct;
                }
                ser = chartType.createDefaultSeries(chart);
                if (ser) {
                    ser.assign(src);
                    ser.source = src;
                    series.push(ser);
                }
            }
        }
        if (series.length < 1) {
            series.push(chartType.createDefaultSeries(chart));
        }
        return series;
    }
}, {
    ChartTypes: {
        pie: {
            xAxisType: function () {
                return "linearPolar";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new PieSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        column: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new ColumnSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        line: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new LineSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        area: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new AreaSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        bar: {
            xAxisType: function () {
                return "linear";
            },
            yAxisType: function () {
                return "category";
            },
            createDefaultSeries: function (chart) {
                return new BarSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        }
        /*
        scatter: {
            xAxisType: function () {
                return "linear";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new ScatterSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        boxplot: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new BoxplotSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        candlestick: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new CandlestickSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        },
        ohlc: {
            xAxisType: function () {
                return "category";
            },
            yAxisType: function () {
                return "linear";
            },
            createDefaultSeries: function (chart) {
                return new OhlcSeries(chart);
            },
            createDefaultSeriesGroup: function () {
                return null;
            }
        }
        */
    }
}, function (f) {
    f.Default = new f();
});
var $_chartdrawing = 0;
var GridChartView = defineClass("GridChartView", GridElement, {
    init: function (dom, pool) {
        this._super(dom, "gridChartView");
        if (dom) {
            dom = this.$_svg = new SvgSprite(this, pool);
            this.$_svgElt = this.$_svg._svg;
        }
        this.addChild(this._plotAreaView = new ChartPlotAreaView(dom));
        this.addChild(this._leftAxisPanel = new OrthogonalAxisPanel(dom, "leftAxisPanel", ChartAxisOrientation.VERTICAL));
        this.addChild(this._rightAxisPanel = new OrthogonalAxisPanel(dom, "rightAxisPanel", ChartAxisOrientation.VERTICAL));
        this.addChild(this._bottomAxisPanel = new OrthogonalAxisPanel(dom, "bottomAxisPanel", ChartAxisOrientation.HORIZONTAL));
        this.addChild(this._topAxisPanel = new OrthogonalAxisPanel(dom, "topAxisPanel", ChartAxisOrientation.HORIZONTAL));
        this.addChild(this._legendView = new ChartLegendView(dom));
        this._model = null;
        this._loading = false;
        this._layoutNeeded = false;
        this._legendRect = new Rectangle();
        this._axesRects = new SideRectangles();
        this._plotAreaRect = new Rectangle();
        this._floatings = null;
    },
    model: function () {
        return this._model;
    },
    setModel: function (value) {
        if (value !== this._model) {
            /*
            if (this._model) {
                this._model.onItemChanged = null;
            }
            */
            this._model = value;
            /*
            if (this._model) {
                this._model.onItemChanged = this._modelChanged.bind(this);
            }
            */
            this.invalidateLayout();
            if (this._model) {
                this._loading = true;
                /*
                var series = this._model._series;
                if (series && series.length > 0) {
                    for (var i = series.length; i--;) {
                        this._animations.add(series[i]);
                    }
                    this._animations.setTrigger(ChartAnimationTypes.TRIGGER_LOAD);
                    this._animations.setActive(true);
                }
                */
            }
        }
    },
    isPolar: function () {
        return this._model.isPolar();
    },
    polarSize: function () {
        return this._model.plotArea().polarSize();
    },
    getSeriesView: function (series) {
        return this._plotAreaView.getSeriesView(series);
    },
    getAxisViews: function () {
        function collect(axes, views) {
            var i, axis, view;
            for (i = 0; i < axes.length; i++) {
                axis = axes[i];
                view = this._leftAxisPanel.findAxisView(axis)
                    || this._bottomAxisPanel.findAxisView(axis)
                    || this._rightAxisPanel.findAxisView(axis)
                    || this._topAxisPanel.findAxisView(axis);
                view && views.push(view);
            }
        }
        var views = [];
        collect.call(this, this._model.xAxes(), views);
        collect.call(this, this._model.yAxes(), views);
        return views;
    },
    getAxisViewOf: function (axis) {
        return this._leftAxisPanel.findAxisView(axis)
                || this._bottomAxisPane.findAxisView(axis)
                || this._rightAxisPanel.findAxisView(axis)
                || this._topAxisPanel.findAxisView(axis);
    },
    invalidateLayout: function () {
        if (!this._layoutNeeded) {
            this._layoutNeeded = true;
        }
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doLayoutContent: function (lm) {
        _dlog("## rendering chart: " + ++$_chartdrawing);
        if (this._layoutNeeded) {
            var m = this._model,
                r = this.getClientRect();
            m.styles().deflatePaddings(r);
            this.$_updateModels(m, r);
            this.$_measureItems(m, r);
            this.$_layoutItems(m, r);
        }
        if (this._loading) {
            this._loading = false;
        }
    },
    _doRefresh: function () {
    },
    _doDraw: function(g, needOpaque) {
        this._doRender(g, this._drawRect);
    },
    _doRender: function (g, r) {
    },
    _doRenderHtml: function (r) {
        this.$_svg.setBounds(0, 0, r.width, r.height);
        this.$_svg._graphics.clear();
    },
    $_updateModels: function (model, r) {
        var i, cnt, axis,
            resized = true,
            xAxes = model.xAxes(),
            yAxes = model.yAxes(),
            gridView = this._plotAreaView.gridView(),
            frontGridView = this._plotAreaView.frontGridView();
        model.$_updateModels(r, resized);
        gridView.clearSources();
        frontGridView.clearSources();
        if (xAxes && (cnt = xAxes.length) > 0) {
            for (i = 0; i < cnt; i++) {
                axis = xAxes[i];
                gridView.addSource(axis);
                frontGridView.addSource(axis);
            }
        }
        if (yAxes && (cnt = yAxes.length) > 0) {
            for (i = 0; i < cnt; i++) {
                axis = yAxes[i];
                gridView.addSource(axis);
                frontGridView.addSource(axis);
            }
        }
    },
    $_measureItems: function (model, r) {
        var view, legend,
            grid = this.grid();
        legend = model.legend();
        if (legend.visible()) {
            view = this._legendView;
            view.setModel(legend);
            size = view.measureI(grid, r.width, r.height);
            size.width += legend.marginLeft() + legend.marginRight();
            size.height += legend.marginTop() + legend.marginBottom();
            switch (legend.position()) {
                case ChartItemPosition.BOTTOM:
                    this._legendRect.set(r.x + _int((r.width - size.width) / 2), r.bottom() - size.height, size.width, size.height);
                    r.bottomBy(-size.height);
                    break;
                case ChartItemPosition.TOP:
                    this._legendRect.set(r.x + _int((r.width - size.width) / 2), r.y, size.width, size.height);
                    r.topBy(size.height);
                    break;
                case ChartItemPosition.RIGHT:
                    this._legendRect.set(r.right() - size.width, r.y, size.width, size.height);
                    r.rightBy(-size.width);
                    break;
                case ChartItemPosition.LEFT:
                    this._legendRect.set(r.x, r.y, size.width, size.height);
                    r.leftBy(size.width);
                    break;
                default: // bottom
                    this._legendRect.set(r.x, r.bottom() - size.height, size.width, size.height);
                    r.bottomBy(-size.height);
                    break;
                /*
                default: // ChartItemPosition.FLOATING:
                    this._legendRect.width = size.width;
                    this._legendRect.height = size.height;
                    this._floatings.set(view, this._legendRect);
                    break;
                */
            }
        } else {
            this._legendRect.setEmpty();
        }
        this._axesRects.clear();
        if (model.isPolar()) {
            axes = model.getAxes(null, null, true);
            this._plotAreaView.polarAxisPanel().setAxes(axes);
            this._plotAreaView.polarAxisPanel().measure(grid, r.width, r.height);
        } else {
            var axes = model.getAxes(ChartAxisOrientation.VERTICAL, ChartAxisLocation.NORMAL);
            axisPanel = this._leftAxisPanel;
            axisPanel.setAxes(axes);
            if (axes && axes.length > 0) {
                size = axisPanel.measureI(grid, r.width, r.height);
                this._axesRects.setLeft(r.x, r.y, size.width, r.height);
                r.leftBy(size.width);
            }
            axes = model.getAxes(ChartAxisOrientation.VERTICAL, ChartAxisLocation.OPPOSITE);
            axisPanel = this._rightAxisPanel;
            axisPanel.setAxes(axes);
            if (axes && axes.length > 0) {
                size = axisPanel.measureI(grid, r.width, r.height);
                this._axesRects.setRight(r.right() - size.width, r.y, size.width, r.height);
                r.rightBy(-size.width);
            }
            axes = model.getAxes(ChartAxisOrientation.HORIZONTAL, ChartAxisLocation.NORMAL);
            axisPanel = this._bottomAxisPanel;
            axisPanel.setAxes(axes);
            if (axes && axes.length > 0) {
                size = axisPanel.measureI(grid, r.width, r.height);
                this._axesRects.setBottom(r.x, r.bottom() - size.height, r.width, size.height);
                r.bottomBy(-size.height);
            }
            axes = model.getAxes(ChartAxisOrientation.HORIZONTAL, ChartAxisLocation.OPPOSITE);
            axisPanel = this._topAxisPanel;
            axisPanel.setAxes(axes);
            if (axes && axes.length > 0) {
                size = axisPanel.measureI(grid, r.width, r.height);
                this._axesRects.setTop(r.x, r.y, r.width, size.height);
                r.topBy(size.height);
            }
        }
        if (model.plotArea() && !r.isEmpty()) {
            view = this._plotAreaView;
            view.setModel(model.plotArea());
            this._plotAreaRect.set(r.x, r.y, r.width, r.height);
            /*
             tr = this._titleRect;
             if (!tr.isEmpty()) {
             tr.x = r.x;	
             tr.width = r.width;
             }
             tr = this._footerRect;
             if (!tr.isEmpty()) {
             tr.x = r.x;	
             tr.width = r.width;
             }
             tr = this._legendRect;
             if (!tr.isEmpty() && !legend.isFloating()) {
             if (legend.isVertical()) {
             tr.y = _floor(r.y + (r.height - tr.height) / 2);
             } else {
             tr.x = _floor(r.x + (r.width - tr.width) / 2);
             }
             }
             */
            tr = this._axesRects.left;
            if (!tr.isEmpty()) {
                tr.setRight(r.x);
                tr.setBottom(r.bottom());
            }
            tr = this._axesRects.right;
            if (!tr.isEmpty()) {
                tr.setBottom(r.bottom());
            }
            /*
             tr = this._seriesLegendRects.left;
             if (!tr.isEmpty()) {
             tr.setBottom(r.bottom());
             }
             tr = this._seriesLegendRects.right;
             if (!tr.isEmpty()) {
             tr.setBottom(r.bottom());
             }
             */
            /*
            adornments = model.adornments();
            this.floatingPanel().setAdornments(adornments);
            this.floatingPanel().measureElements(this, this._plotAreaRect);
            */
            /*
             this._floatings.each((function (view, r) {
             var pr, sz, p1, p2;
             item = view.model();
             if (item) {
             pr = this._plotAreaRect;
             p1 = p2 = NaN;
             if (sz = item.left()) {
             p1 = pr.x + sz.getSize(pr.width);
             }
             if (sz = item.right()) {
             p2 = pr.right() - sz.getSize(pr.width);
             }
             if (!isNaN(p1) && !isNaN(p2)) {
             r.x = p1;
             r.setRight(p2);
             } else if (!isNaN(p1)) {
             r.x = p1;
             } else if (!isNaN(p2)) {
             r.x = p2 - r.width;
             }
             p1 = p2 = NaN;
             if (sz = item.top()) {
             p1 = pr.y + sz.getSize(pr.height);
             }
             if (sz = item.bottom()) {
             p2 = pr.bottom() - sz.getSize(pr.height);
             }
             if (!isNaN(p1) && !isNaN(p2)) {
             r.y = p1;
             r.setBottom(p2);
             } else if (!isNaN(p1)) {
             r.y = p1;
             } else if (!isNaN(p2)) {
             r.y = p2 - r.height;
             }
             }
             }).bind(this));
             */
        } else {
            this._plotAreaRect.setEmpty();
        }
    },
    $_layoutItems: function (model, r) {
        var view;
        view = this._legendView;
        view.setVisible(!this._legendRect.isEmpty());
        if (view.visible()) {
            var l = model.legend();
            view.setRectI(this._legendRect.inflate(-l.marginLeft(), -l.marginTop(), -l.marginRight(), -l.marginBottom()));
            view.updateElements();
        }
        view = this._leftAxisPanel;
        view.setVisible(!this._axesRects.left.isEmpty());
        if (view.visible()) {
            view.setRectI(this._axesRects.left);
            view.updateElements();
        }
        view = this._rightAxisPanel;
        view.setVisible(!this._axesRects.right.isEmpty());
        if (view.visible()) {
            view.setRectI(this._axesRects.right);
            view.updateElements();
        }
        view = this._bottomAxisPanel;
        view.setVisible(!this._axesRects.bottom.isEmpty());
        if (view.visible()) {
            view.setRectI(this._axesRects.bottom);
            view.updateElements();
        }
        view = this._plotAreaView;
        view.setVisible(!this._plotAreaRect.isEmpty());
        if (view.visible()) {
            view.setRectI(this._plotAreaRect);
            view.updateElements();
        }
    }
});
var ChartElement = defineClass("ChartElement", GridElement, {
    init: function (dom, name) {
        this._super(dom, name);
    },
    model: null,
    renderer: null,
    chartView: function () {
        var p = this.parent();
        while (p) {
            if (p instanceof GridChartView) {
                return p;
            }
            p = p.parent();
        }
        return null;
    },
    chartModel: function () {
        return this.chartView().model();
    },
    renderer_: function () {
        return this._renderer || this.defaultRenderer();
    },
    defaultRenderer: function() {
        return null;
    },
    updateElements: function() {
        this._doUpdateElements.apply(this, arguments);
    },
    measureI: function (grid, hintWidth, hintHeight) {
        var size = this._doMeasure(grid, hintWidth, hintHeight);
        size.width = _floor(size.width);
        size.height = _floor(size.height);
        return size;
    },
    clip: function (g) {
        this.getClientRect(this._drawRect);
        this._doClip(g);
    },
    _doClip: function (g) {
        g.clipRect(this._clipBounds || this._drawRect);
    },
    _doUpdateElements: function () {
    },
    _doDraw: function(g, needOpaque) {
        this._doRender(g, this._drawRect);
    },
    _doRender: function (g, r) {
        var renderer;
        if (this._canDraw() && !r.isEmpty()) {
            if (this.model() && (renderer = this.renderer())) {
                renderer.render(this, g, r);
            }
        }
    },
    _doRenderHtml: function (r) {
        if (!r.isEmpty()) {
            this._doDraw(this.chartView().$_svg, r);
        }
    },
    _doDrawSvg: function (g) {
        this.getClientRect(this._drawRect);
        this._doDraw(g, false);
    },
    _canDraw: function () {
        return true;
    }
});
var ChartTextElement = defineClass("ChartTextElement", ChartElement, {
    init: function (dom, name) {
        this._super(dom, name || "chartTextView");
        this.setMouseEnabled(false);
        this._font = null;
        this._paddingLeft = 0;
        this._paddingRight = 0;
        this._paddingTop = 0;
        this._paddingBottom = 0;
    },
    text: null,
    setStyles: function (s) {
        this._background = s.background();
        this._color = s.color();
        this._border = s.border();
        this._font = s.font();
        this._textShadow = s.textShadow();
        this._paddingLeft = s.paddingLeft();
        this._paddingRight = s.paddingRight();
        this._paddingTop = s.paddingTop();
        this._paddingBottom = s.paddingBottom();
        this._prefix = s.prefix();
        this._suffix = s.suffix();
    },
    _doClip: function (g) {
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var font = this._font,
            sz = { width: 0, height: 0 };
        sz.width = this.container().measureText(font, this._text);
        sz.height = font.size;
        sz.width += this._paddingLeft + this._paddingRight;
        sz.height += this._paddingTop + this._paddingBottom;
        return sz;
    },
    _doDraw: function(g) {
        var r, s = this._text;
        if (s) {
            r = new Rectangle(0, 0, this.width(), this.height());
            g.drawRectI(this._background, this._border, r);
            g.drawTextSh(this._font, this._color, this._textShadow, s, _floor(r.x + r.width / 2), _floor(r.y + r.height / 2 - 1), Alignment.CENTER, "middle");
        }
    }
});
var ChartSeriesItemView = defineClass("ChartSeriesItemView", ChartElement, {
    init: function (dom) {
        this._super(dom, "seriesItemView");
        this._index = -1;
        this._dataPoint = { x: 0, y: 0 };
        this._dataPoint2 = { x: 0, y: 0 };
        this._dataPoint3 = { x: 0, y: 0 };
        this.$_childStyles = {};
    },
    toolTip: function () {
        var tip = this.series().toolTip();
        tip.setSingleton(this.seriesView().isSingleton());
        return tip;
    },
    toolTipRuntime: function () {
        return this.series().getToolTipRuntime(this.model());
    },
    series: function () {
        return this.parent().parent().model();
    },
    seriesView: function () {
        return this.parent().parent();
    },
    index: function () {
        return this._index;
    },
    setIndex: function (value) {
        this._index = value;
    },
    state: function () {
        return this._hovered ? "hovered" : null;
    },
    /*
    itemView: function () {
        return this._itemView;
    },
    */
    isSingleton: function () {
        return this.parent().childCount() == 1;
    },
    setDataPoint: function (x, y, x2, y2) {
        this._dataPoint.x = x;
        this._dataPoint.y = y;
        this._dataPoint2.x = x2;
        this._dataPoint2.y = y2;
        return this;
    },
    hoveredChanged: function () {
        this.invalidateLayout();
    },
    /*
     _doMeasure: function (w, h) {
     this._super(w, h);
     },
     */
    _doClip: function (g) {
    },
    _doDraw: function(g, needOpaque) {
        this.series().$_setItemView(this); // for palette index
        this._super(g, needOpaque);
    },
    hitTest: function (x, y) {
        var renderer = this.renderer();
        if (renderer && renderer.containsPoint) {
            return renderer.containsPoint(this, x, y);
        } else {
            return x >= 0 && x < this._width && y >= 0 && y < this._height;
        }
    }
});
var StackableSeriesItemView = defineClass("StackableSeriesItemView", ChartSeriesItemView, {
    init: function (dom) {
        this._super(dom);
        this._gindex = 0;
    },
    negative: false,
    separator: false
});
var ChartSeriesLabelView = defineClass("ChartSeriesLabelView", ChartTextElement, {
    init: function (dom, item) {
        this._super(dom, "itemLabelView");
        this._itemView = null;
        this._originX = 0;
        this._originY = 0;
    },
    itemView: function () {
        return this._itemView;
    },
    setLabel: function (itemView, text) {
        var s = text;
        if (this._prefix) s = this._prefix + s;
        if (this._suffix) s += this._suffix;
        this._itemView = itemView;
        this.setText(s);
    },
    setOrigin: function (x, y) {
        this._originX = x;
        this._originY = y;
    }
});
var ChartSeriesTextView = defineClass("ChartSeriesTextView", ChartElement, {
    init: function (dom, seriesView) {
        this._super(dom, "seriesTextView");
        this._seriesView = seriesView;
        this._textViews = [];
        this._textViewCount = 0;
    },
    isLayer: function () {
        return true;
    },
    _doDraw: function(g) {
        /*
         var seriesView = this._seriesView;
         var series = seriesView.model();
         if (series && seriesView.renderer()) {
         return seriesView.renderer().renderText(seriesView, g, seriesView.getClientRect());
         }
         */
    },
    _doClip: function (g) {
    },
    _doUpdateElements: function () {
        var renderer, itemCount, textsPerItem, cnt, i,
            seriesView = this._seriesView,
            series = seriesView.model();
        if (series && (renderer = seriesView.renderer())) {
            itemCount = series.displayCount();
            textsPerItem = series.textsPerItem();
            cnt = itemCount * textsPerItem;
            while ((i = this.childCount()) > cnt) {
                this.removeElementAt(i - 1);
            }
            while ((i = this.childCount()) < cnt) {
                if (this._textViews.length <= i) {
                    this._textViews.push(new ChartSeriesLabelView(this._dom));
                }
                this.addElement(this._textViews[i]);
            }
            this._textViewCount = cnt;
            return renderer.layoutLabels(seriesView, this._textViews, seriesView.getClientRect());
        }
    }
});
var ChartSeriesView = defineClass("ChartSeriesView", ChartElement, {
    init: function (dom) {
        this._super(dom, "seriesView");
        this._itemRenderer = null;
        this._itemLayer = new LayerElement(dom, "itemsView");
        this.addElement(this._itemLayer);
        this._separatorView = new UIElement(dom, "separatorLayer");
        this._separatorView.setRenderCallback(this.drawSeparators.bind(this));
        this._textView = new ChartSeriesTextView(dom, this);
        this._itemViews = [];
        this._itemViewCount = 0;
        this._plotView = null;
        this._mask = null;
        this._slideMask = null;
    },
    separatorView: function () {
        return this._separatorView;
    },
    textView: function () {
        return this._textView;
    },
    itemRenderer: function () {
        return this._itemRenderer;
    },
    setItemRenderer: function (value) {
        if (value !== this._itemRenderer) {
            this._itemRenderer = value;
            this.invalidate();
        }
    },
    itemCount: function () {
        return this._itemViewCount;
    },
    getItem: function (index) {
        return this._itemViews[index];
    },
    plotView: function () {
        this._plotView;
    },
    getInterpolation: function (property, defaultValue) {
        var run = this.chartView().animations().getInterpolation(this.model(), property);
        return run ? run.rate() : (defaultValue !== UNDEFINED ? defaultValue : 1.0);
    },
    getAnimationAttr: function (property, attr) {
        var run = this.chartView().animations().getInterpolation(this.model(), property);
        return run ? run.getAttribute(attr) : UNDEFINED;
    },
    getDataPoints: function (count) {
        var i, itemView, p,
            pts = null,
            cnt = (count !== UNDEFINED) ? count : this._itemViewCount;
        if (cnt > 0) {
            pts = [];
            for (i = 0; i < cnt; i++) {
                itemView = view.getItem(i);
                p = {
                    x: itemView._dataPoint.x,
                    y: itemView._dataPoint.y
                };
                pts.push(p);
            }
        }
        return pts;
    },
    setItemIndex: function (itemView, index, group, gindex, negative) {
        this._plotView.setItemIndex(itemView, index, group, gindex, negative);
        itemView._negative = negative;
        itemView._gindex = gindex;
    },
    isLayer: function () {
        return true;
    },
    _doClip: function (g) {
    },
    _doUpdateElements: function () {
        function getSlideRect(view, r, rate) {
            var sr = new Rectangle(),
                dir = view.getAnimationAttr(ChartAnimationTypes.PROP_SLIDE, "start");
            switch (dir) {
                case "left":
                    sr.set(r.x - r.width * (1 - rate), r.y, r.width, r.height);
                    break;
                case "bottom":
                    sr.set(r.x, r.y + r.height * (1 - rate), r.width, r.height);
                    break;
                case "top":
                    sr.set(r.x, r.y - r.height * (1 - rate), r.width, r.height);
                    break;
                case "topRight":
                    sr.set(r.x + r.width * (1 - rate), r.y - r.height * (1 - rate), r.width, r.height);
                    break;
                case "topLeft":
                    sr.set(r.x - r.width * (1 - rate), r.y - r.height * (1 - rate), r.width, r.height);
                    break;
                case "bottomRight":
                    sr.set(r.x + r.width * (1 - rate), r.y + r.height * (1 - rate), r.width, r.height);
                    break;
                case "bottomLeft":
                    sr.set(r.x - r.width * (1 - rate), r.y + r.height * (1 - rate), r.width, r.height);
                    break;
                case "right":
                default:
                    sr.set(r.x + r.width * (1 - rate), r.y, r.width, r.height);
                    break;
            }
            return sr;
        }
        function renderSlideMask(g, target) {
            var x = -target.getX(),
                y = -target.getY(),
                w = target.width(),
                h = target.height();
            g.drawBounds(null, null, x, y, w, h);
        }
        function renderMask(g, target) {
            var rate = target.getInterpolation(ChartAnimationTypes.PROP_MASK),
                x = 0,
                y = 0,
                w = target.width(),
                h = target.height(),
                dir = target.getAnimationAttr(ChartAnimationTypes.PROP_MASK, "start"),
                model = this.model(),
                renderer = this.renderer();
            if (dir == "ellipse") {
                x = x + w / 2;
                y = y + h / 2;
                w /= 3 / 2;
                h /= 3 / 2;
                w *= rate;
                h *= rate;
                g.drawEllipse(SolidBrush.Null, null, x - w, y - h, w * 2, h * 2);
            } else {
                switch (dir) {
                    case "hcenter":
                        w *= rate;
                        x += (target.width() - w) / 2;
                        break;
                    case "vcenter":
                        h *= rate;
                        y += (target.height() - h) / 2;
                        break;
                    case "center":
                        w *= rate;
                        x += (target.width() - w) / 2;
                        h *= rate;
                        y += (target.height() - h) / 2;
                        break;
                    case "top":
                        h *= rate;
                        break;
                    case "bottom":
                        h *= rate;
                        y += target.height() - h;
                        break;
                    case "right":
                        w *= rate;
                        x += target.width() - w;
                        break;
                    case "left":
                    default:
                        w *= rate;
                        break;
                }
                g.drawBounds(SolidBrush.Null, null, x, y, w, h);
            }
        }
        var i, j, k, cnt, view, rate, w, h, item, itemCount, viewsPerItem, stackable,
            model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            model.$_view = this;
            w = this.width();
            h = this.height();
            stackable = renderer.canStacked();
            itemCount = model.displayCount();
            viewsPerItem = model.viewsPerItem();
            cnt = itemCount * viewsPerItem;
            list = [];
            while ((i = this._itemLayer.childCount()) > cnt) {
                this._itemLayer.removeElementAt(i - 1);
            }
            while ((i = this._itemLayer.childCount()) < cnt) {
                if (this._itemViews.length <= i) {
                    this._itemViews.push(stackable ? new StackableSeriesItemView(this._dom) : new ChartSeriesItemView(this._dom));
                }
                this._itemLayer.addElement(this._itemViews[i]);
            }
            this._itemViewCount = cnt;
            switch (model.itemDisplayOrder()) {
                case ChartItemDisplayOrder.LAST:
                    for (i = itemCount; i--;) {
                        list.push(i);
                    }
                    break;
                default:
                    for (i = 0; i < itemCount; i++) {
                        list.push(i);
                    }
                    break;
            }
            for (i = 0; i < itemCount; i++) {
                k = list[i];
                for (j = 0; j < viewsPerItem; j++) {
                    view = this._itemViews[k * viewsPerItem + j];
                    item = model.getItem(i, true);
                    view.setModel(item);
                    view.setIndex(i);
                    view.setRenderer(this.itemRenderer());
                }
            }
            renderer.layoutItems(this);
            this._textView.setBounds(0, 0, w, h);
            this._textView.updateElements();
            /*
            rate = this.getInterpolation(ChartAnimationTypes.PROP_SLIDE);
            if (rate < 1) {
                if (!this._slideMask) {
                    this._slideMask = new MaskElement("slideMask", this._itemLayer, renderSlideMask);
                }
                var sr = new Rectangle(0, 0, w, h);
                sr = getSlideRect(this, sr, rate);
                this._itemLayer.setRectI(sr);
                this._itemLayer.setMask(this._slideMask);
            } else {
                this._itemLayer.setBoundsI(0, 0, w, h);
                this._itemLayer.setMask(null);
            }
            */
            /*
            rate = this.getInterpolation(ChartAnimationTypes.PROP_MASK);
            if (rate < 1) {
                if (!this._mask) {
                    this._mask = new MaskElement("mask", this, renderMask);
                }
                this.setMask(this._mask);
            } else {
                this.setMask(null);
            }
            */
        }
    },
    _doDraw: function (g) {
        var r = this.getClientRect(),
            renderer = this.renderer();
        if (renderer) {
            renderer.render(this, g, r);
        }
    },
    resetSeparators: function (indicies, negativeIndicies) {
        var i, cnt, view;
        if (indicies || negativeIndicies) {
            for (i = 0, cnt = this.itemCount(); i < cnt; i++) {
                view = this.getItem(i);
                if (view._negative) {
                    view._separator = view._gindex < negativeIndicies[i];
                } else {
                    view._separator = view._gindex < indicies[i];
                }
            }
        }
    },
    drawSeparators: function (g) {
        var model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            renderer.renderItemSeparators(this, g, new Rectangle(0, 0, this.width(), this.height()));
        }
    }
});
var ChartGridView = defineClass("ChartGridView", ChartElement, {
    init: function (dom, name, isFront) {
        this._super(dom, name);
        this._isFront = isFront;
        this._sources = [];
    },
    isFront: function () {
        return this._isFront;
    },
    sources: function () {
        return this._sources;
    },
    /*
     setSources: function (value) {
     var i, cnt;
     if (value === this._sources)
     return;
     for (i = this._sources.length - 1; i >= 0; i--) {
     this.removeSource(this._sources[i]);
     }
     if (value instanceof ChartAxis) {
     this.addSource(value);
     } else {
     for (i = 0, cnt = value.length; i < cnt; i++) {
     this.addSource(value[i]);
     }
     }
     },
     */
    indexOf: function (axis) {
        for (var i = this._sources.length; i--;) {
            if (this._sources[i] === axis) {
                return i;
            }
        }
        return -1;
    },
    clearSources: function () {
        this._sources = [];
    },
    addSource: function (axis) {
        if (this.indexOf(axis) < 0) {
            this._sources.push(axis);
            this.invalidate();
        }
    },
    removeSource: function (axis) {
        var idx = this.indexOf(axis);
        if (idx >= 0) {
            this._sources.splice(idx, 1);
            this.invalidate();
        }
    },
    isLayer: function () {
        return true;
    },
    defaultRenderer: function() {
        return ChartGridRenderer.Default;
    },
    _doDraw: function(g) {
        var i, renderer,
            needDraw = false;
        for (var i = this._sources.length; i--;) {
            if (this._sources[i].visible()) {
                needDraw = true;
                break;
            }
        }
        if (needDraw) {
            if (renderer = this.renderer()) {
                return renderer.render(this, g, this.clientRect());
            }
        }
    }
});
var ChartPlotAreaView = defineClass("ChartPlotAreaView", ChartElement, {
    init: function (dom, owner) {
        this._super(dom, "plotAreaView");
        this._owner = owner;
        this._gridView = new ChartGridView(dom, "gridView");
        this.addElement(this._gridView);
        this._indicatorLayer = new LayerElement(dom, "indicatorLayer");
        this.addElement(this._indicatorLayer);
        this._polarAxisPanel = new PolarAxisPanel(dom);
        this.addElement(this._polarAxisPanel);
        this._seriesLayer = new LayerElement(dom, "seriesLayer");
        this.addElement(this._seriesLayer);
        this._seriesSeparatorLayer = new LayerElement(dom, "seriesSeparatorLayer");
        this.addElement(this._seriesSeparatorLayer);
        this._labelLayer = new LayerElement(dom, "labelLayer");
        this.addElement(this._labelLayer);
        this._indicatorViews = [];
        this._seriesViews = [];
        this._frontIndicatorLayer = new LayerElement(dom, "frontIndicatorLayer");
        this.addElement(this._frontIndicatorLayer);
        this._frontGridView = new ChartGridView(dom, "frontGridView", true);
        this.addElement(this._frontGridView);
        this._itemIndicies = new Dictionary();
        this._negativeItemIndicies = new Dictionary();
    },
    gridView: function () {
        return this._gridView;
    },
    frontGridView: function () {
        return this._frontGridView;
    },
    polarAxisPanel: function () {
        return this._polarAxisPanel;
    },
    polarSize: function () {
        return this._model.polarSize();
    },
    polarAxis: function () {
        var axes = this.parent.model().xAxes();
        return (axes && axes.length > 0) ? axes[0] : null;
    },
    getSeriesViews: function () {
        var i, view,
            views = [];
        for (i = this._seriesLayer.childCount(); i--;) {
            view = this._seriesLayer.getChild(i);
            if (view instanceof ChartSeriesView) {
                views.push(view);
            }
        }
        return views;
    },
    getSeriesView: function (series) {
        var i, cnt, view;
        for (i = 0, cnt = this._seriesLayer.childCount(); i < cnt; i++) {
            view = this._seriesLayer.getChild(i);
            if (view instanceof ChartSeriesView && view.model() === series) {
                return view;
            }
        }
        return null;
    },
    isLayer: function () {
        return true;
    },
    defaultRenderer: function() {
        return ChartPlotAreaRenderer.Default;
    },
    _doClip: function (g) {
    },
    _doMeasure: function(grid, hintWidth, hintHeight) {
        var renderer;
        if (this.model() && (renderer = this.renderer())) {
            return renderer.measure(this, hintWidth, hintHeight);
        }
        return { width:hintWidth, height:hintHeight };
    },
    _doUpdateElements: function() {
        var model, group, layer, seriesView, i, cnt, polarAxisPanel, gridView, indicatorView, indicator;
            chartView = this.chartView(),
            chart = chartView.model(),
            delegate = GridChartDelegate.Default,
            w = this.width(),
            h = this.height();
        this.refreshSeries(chartView);
        this.refreshIndicators(chartView);
        polarAxisPanel = this.polarAxisPanel();
        if (polarAxisPanel.visible()) {
            polarAxisPanel.setBounds(0, 0, w, h);
            polarAxisPanel.updateElements();
        }
        gridView = this.gridView();
        gridView.setRenderer(delegate.getGridRenderer(chartView));
        gridView.setBounds(0, 0, w, h);
        gridView.updateElements();
        gridView = this.frontGridView();
        gridView.setRenderer(delegate.getGridRenderer(chartView));
        gridView.setBounds(0, 0, w, h);
        gridView.updateElements();
        layer = this._indicatorLayer;
        for (i = 0, cnt = layer.childCount(); i < cnt; i++) {
            indicatorView = layer.getChild(i);
            indicator = indicatorView.model();
            indicatorView.setRenderer(delegate.getAxisIndicatorRenderer(indicator));
            indicatorView.setBounds(0, 0, w, h);
            indicatorView.updateElements(indicatorView._axisView);
        }
        layer = this._frontIndicatorLayer;
        for (i = 0, cnt = layer.childCount(); i < cnt; i++) {
            indicatorView = layer.getChild(i);
            indicator = indicatorView.model();
            indicatorView.setRenderer(delegate.getAxisIndicatorRenderer(indicator));
            indicatorView.setBounds(0, 0, w, h);
            indicatorView.updateElements(indicatorView._axisView);
        }
        layer = this._seriesLayer;
        for (i = 0, cnt = layer.childCount(); i < cnt; i++) {
            seriesView = layer.getChild(i);
            if (seriesView instanceof ChartSeriesView) {
                model = seriesView.model();
                seriesView._plotView = this;
                seriesView.setRenderer(delegate.getSeriesRenderer(model));
                seriesView.setItemRenderer(delegate.getSeriesItemRenderer(model));
                seriesView.setBounds(0, 0, w, h);
                seriesView.updateElements();
                /*
                if (chartView.animations().isAnimating(model)) {
                    seriesView.invalidate(true, true);
                }
                */
            }
        }
        for (i = 0, cnt = layer.childCount(); i < cnt; i++) {
            seriesView = layer.getChild(i);
            if (seriesView instanceof ChartSeriesView) {
                group = seriesView.model().group();
                seriesView.resetSeparators(this._itemIndicies.get(group), this._negativeItemIndicies.get(group));
            }
        }
    },
    _doDraw: function (g) {
        var styles = this.chartModel().plotArea().styles(),
            fill = styles.background(),
            stroke = styles.border();
        if (fill || stroke) {
            g.drawRect(fill, stroke, this.clientRect());
        }
    },
    refreshSeries: function (chartView) {
        function $_getView(dom, views, series) {
            var i, len,
                view = null;
            for (i = 0, len = views.length; i < len; i++) {
                if (views[i] instanceof ChartSeriesView && views[i].model() === series) {
                    view = views[i];
                    views.splice(i, 1);
                    break;
                }
            }
            if (!view) {
                view = new ChartSeriesView(dom);
                view.setModel(series);
            }
            return view;
        }
        function sorter(s1, s2) {
            return s1.zindex() - s2.zindex();
        }
        var model = chartView.model();
        if (!model) {
            return;
        }
        var i, j, cnt, seriesView, labelView, series, series2, ser,
            serViews = this._seriesViews,
            layer = this._seriesLayer;
        for (i = layer.childCount() - 1; i >= 0; i--) {
            seriesView = layer.getChild(i);
            if (seriesView instanceof ChartSeriesView) {
                layer.removeElement(seriesView);
                serViews.push(seriesView);
            }
        }
        layer = this._labelLayer;
        for (i = layer.childCount() - 1; i >= 0; i--) {
            labelView = layer.getChild(i);
            if (labelView instanceof ChartSeriesTextView) {
                layer.removeElement(labelView);
            }
        }
        layer = this._seriesSeparatorLayer;
        for (i = layer.childCount() - 1; i >= 0; i--) {
            labelView = layer.getChild(i);
            layer.removeElement(labelView);
        }
        /*if (this._owner instanceof SimpleChartView) {
            series = this._owner.model().series();
            if (series) {
                seriesView = $_getView(this._seriesViews, series);
                this._seriesLayer.addElement(seriesView);
                this._seriesSeparatorLayer.addElement(seriesView.separatorView());
                this._labelLayer.addElement(seriesView.textView());
            }
        } else*/ {
            layer = this._seriesLayer;
            series = model.$_getSeries().sort(sorter);
            for (i = 0, cnt = series.length; i < cnt; i++) {
                ser = series[i];
                if (ser instanceof ChartSeries) {
                    seriesView = $_getView(this._dom, serViews, ser);
                    layer.addElement(seriesView);
                    this._seriesSeparatorLayer.addElement(seriesView.separatorView());
                    this._labelLayer.addElement(seriesView.textView());
                } else { // ChartSeriesGroup
                    series2 = ser.series().sort(sorter);
                    for (j = 0; j < series2.length; j++) {
                        seriesView = $_getView(this._dom, serViews, series2[j]);
                        layer.addElement(seriesView);
                        this._seriesSeparatorLayer.addElement(seriesView.separatorView());
                        this._labelLayer.addElement(seriesView.textView());
                    }
                }
            }
        }
    },
    refreshIndicators: function (chartView) {
        function getView(views, indicator) {
            var i, len,
                view = null;
            for (i = 0, len = views.length; i < len; i++) {
                if (views[i].model() === indicator) {
                    view = views[i];
                    views.splice(i, 1);
                    break;
                }
            }
            if (!view) {
                view = new AxisIndicatorView(chartView._dom);
                view.setModel(indicator);
            }
            return view;
        }
        var quad = chartView.model();
        if (!quad) return;
        var i, j, cnt, len, axisView, axis, view, indicatorView, indicators, indicator, axisViews,
            layer = this._indicatorLayer;
        for (i = layer.childCount() - 1; i >= 0; i--) {
            indicatorView = layer.getChild(i);
            layer.removeElement(indicatorView);
            this._indicatorViews.push(indicatorView);
        }
        layer = this._frontIndicatorLayer;
        for (i = layer.childCount() - 1; i >= 0; i--) {
            indicatorView = layer.getChild(i);
            layer.removeElement(indicatorView);
            this._indicatorViews.push(indicatorView);
        }
        axisViews = chartView.getAxisViews();
        for (i = 0, cnt = axisViews.length; i < cnt; i++) {
            axisView = axisViews[i];
            axis = axisView.model();
            indicators = axis.indicators();
            if (indicators) {
                for (j = 0, len = indicators.length; j < len; j++) {
                    indicator = indicators[j];
                    view = getView(this._indicatorViews, indicator);
                    view._axisView = axisView;
                    if (indicator.front()) {
                        this._frontIndicatorLayer.addElement(view);
                    } else {
                        this._indicatorLayer.addElement(view);
                    }
                }
            }
        }
    },
    setItemIndex: function (itemView, index, group, gindex, negative) {
        var idx,
            dic = negative ? this._negativeItemIndicies : this._itemIndicies,
            indicies = dic.get(group);
        if (!indicies) {
            indicies = [];
            dic.set(group, indicies);
        }
        idx = indicies[index];
        if (idx === UNDEFINED || gindex > idx) {
            indicies[index] = gindex;
        }
    }
});
var ChartAxisTicksView = defineClass("ChartAxisTicksView", ChartElement, {
    init : function(dom, axisView) {
        this._super(dom, "chartAxisTicksView");
        this._axisView = axisView;
        this._tickViews = [];
        this._tickCount = 0;
    },
    axisView: function () {
        return this._axisView;
    },
    tickCount: function () {
        return this._tickCount;
    },
    tickViews: function () {
        return this._tickViews;
    },
    _doClip: function (g) {
    },
    _prepareTicks: function () {
        var i, tickView, scale,
            axisView = this._axisView,
            axis = axisView.model(),
            renderer = axisView.renderer(),
            styles = axis.tickStyles(),
            cnt = axis.getTickNumber();
        while ((i = this.childCount()) > cnt) {
            this.removeElementAt(i - 1);
        }
        while ((i = this.childCount()) < cnt) {
            if (this._tickViews.length <= i) {
                this._tickViews.push(renderer.createTickView(this._dom));
            }
            this.addElement(this._tickViews[i]);
        }
        this._tickCount = cnt;
        scale = axis instanceof LinearAxis && axis.useNumberSymbols() ? NumberScales.Default : null;
        for (i = 0; i < cnt; i++) {
            tickView = this._tickViews[i];
            tickView.setStyles(styles);
            tickView.setTick(axis.getTick(i), scale);
            tickView.measure(10000, 10000);
        }
    }
});
var ChartAxisTitleView = defineClass("ChartAxisTitleView", ChartElement, {
    init: function (dom, axisView) {
        this._super(dom, "axisTitleView");
        this._axisView = axisView;
    },
    orientation: function () {
        return this._axisView.model().orientation();
    },
    location: function () {
        return this._axisView.model().location();
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var sz = this._renderer.measure(this, hintWidth, hintHeight);
        return sz;
    }
});
var AxisIndicatorView = defineClass("AxisIndicatorView", ChartElement, {
    init: function (dom) {
        this._super(dom, "axisIndicatorView");
        this._axisView = null;
        this.addElement(this._textView = new ChartTextElement(dom, 'axisIndicatorText'));
    },
    axisView: function () {
        return this._axisView;
    },
    textView: function () {
        return this._textView;
    },
    axis: function () {
        return this._axisView.model();
    },
    _doClip: function () {
    },
    _doUpdateElements: function (axisView) {
        this._axisView = axisView;
    },
    canDraw: function () {
        return true;// !this.chartView().isAnimating();
    }
});
var ChartAxisLabelView = defineClass("ChartAxisLabelView", ChartTextElement, {
    init: function (dom, name) {
        this._super(dom, name || "axisLabelView");
        this._measuredWidth = NaN;
        this._measuredHeight = NaN;
    },
    setTick: function (tick) {
        this._tick = tick;
        this.setText(String(tick));
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var sz = this._super(grid, hintWidth, hintHeight);
        this._measuredWidth = sz.width;
        this._measuredHeight = sz.height;
        return sz;
    }
});
var ChartNumericAxisLabelView = defineClass("ChartNumericAxisLabelView", ChartAxisLabelView, {
    init : function(dom) {
        this._super(dom, "numericAxisLabelView");
    },
    setTick: function(tick, scales) {
        var s = scales ? scales.getText(tick) : String(tick);
        this._tick = tick;
        this.setText(s);
    }
});
var ChartAxisView = defineClass("ChartAxisView", ChartElement, {
    init: function (dom) {
        this._super(dom, "axisView");
        this._titleView = new ChartAxisTitleView(dom, this);
        this.addElement(this._titleView);
        this._ticksView = new ChartAxisTicksView(dom, this);
        this.addElement(this._ticksView);
        this._titleSize = 0;
        this._measuredTicks = null;
        this._focusView = null;
    },
    titleRenderer: null,
    titleView: function () {
        return this._titleView;
    },
    titleRenderer: function () {
        return this._titleRenderer ? this._titleRenderer : ChartAxisTitleRenderer.Default;
    },
    isVertical: function() {
        return this.model().orientation() == ChartAxisOrientation.VERTICAL;
    },
    isNear: function() {
        return this.model().location() == ChartAxisLocation.NORMAL;
    },
    showFocus: function (series, x, y) {
        var styles = this.model().styles().findSub("tick").findState("crossed");
        if (!this._focusView) {
            this._focusView = new ChartAxisLabelView(this._dom);
            this.addElement(this._focusView);
        }
        this._focusView.setVisible(true);
        this._focusView.updateStyles(styles);
        this._doUpdateFocus(series || this.model().getSeriesAt(0), this._focusView, x, y);
    },
    hideFocus: function () {
        if (this._focusView) {
            this._focusView.setVisible(false);
        }
    },
    isLayer: function () {
        return true;
    },
    _doClip: function (g) {
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var vertical, w, h, size, title, titleView, text,
            model  = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            vertical = this.isVertical();
            w = vertical ? 0 : hintWidth;
            h = vertical ? hintHeight : 0;
            this._titleSize = 0;
            title = model.title();
            if (title && (text = _trim(title.caption()))) {
                titleView = this.titleView();
                titleView.setModel(title);
                titleView.setRenderer(this.titleRenderer());
                size = titleView.measure(grid, hintWidth, hintHeight);
                if (this.isVertical()) {
                    this._titleSize = w = size.width;
                } else {
                    this._titleSize = h = size.height;
                }
            }
            size = renderer.measure(this, hintWidth, hintHeight);
            if (vertical) {
                w += size.width;
            } else {
                h += size.height;
            }
            return { width: w, height: h };
        } else {
            return { width: 30, height: 30 };
        }
    },
    _doUpdateElements: function() {
        var titleView = this.titleView();
        titleView.setVisible(this._titleSize > 0);
        if (titleView.visible()) {
            if (this.isVertical()) {
                if (this.isNear()) {
                    titleView.setBoundsI(0, 0, this._titleSize, this.height());
                } else {
                    titleView.setBoundsI(this.width() - this._titleSize, 0, this._titleSize, this.height());
                }
            } else {
                titleView.setBoundsI(0, this.height() - this._titleSize, this.width(), this._titleSize);
            }
        }
    },
    _doUpdateFocus: function (series, focusView, x, y) {
        var renderer;
        if (series && focusView) {
            renderer = this.renderer();
            if (renderer) {
                renderer.locateFocusView(this, focusView, this.clientRect(), x, y);
            }
        }
    },
    _doDraw: function (g) {
        this._super(g);
    }
});
/** @abstract */
var ChartAxisPanel = defineClass("ChartAxisPanel", ChartElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._axisViews = [];
    },
    setAxes: function (value) {
        var i, cnt, axis, view;
        this.clear();
        this._axisCount = 0;
        cnt = value ? value.length : 0;
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                axis = value[i];
                if (axis && axis.visible()) {
                    if (this._axisViews.length <= this._axisCount) {
                        this._axisViews.push(new ChartAxisView(this._dom));
                    }
                    view = this._axisViews[this._axisCount];
                    view.setModel(value[i]);
                    this.addElement(view);
                    this._axisCount++;
                }
            }
        }
    },
    axisCount: function () {
        return this._axisCount;
    },
    getAxisView: function (index) {
        if (index < 0 || index >= this._axisCount) {
            throw "Invalid axis index: " + index;
        }
        return this._axisViews[index];
    },
    findAxisView: function (axis) {
        var i, cnt;
        for (i = 0, cnt = this._axisCount; i < cnt; i++) {
            if (this._axisViews[i].model() === axis) {
                return this._axisViews[i];
            }
        }
        return null;
    },
    isLayer: function () {
        return true;
    },
    _doClip: function (g) {
    }
});
var OrthogonalAxisPanel = defineClass("OrthogonalAxisPanel", ChartAxisPanel, {
    init: function (dom, name, orientation) {
        this._super(dom, name);
        this._orientation = orientation ? orientation : ChartAxisOrientation.HORIZONTAL;
        this._axisSizes = [];
    },
    orientation: function () {
        return this._orientation;
    },
    isVertical: function() {
        return this.orientation() == ChartAxisOrientation.VERTICAL;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var i, cnt, view, model, renderer, sz, w, h,
            size = { width: hintWidth, height: hintHeight},
            vertical = this.isVertical();
        if (vertical) size.width = 0;
        if (!vertical) size.height = 0;
        this._axisSizes = [];
        cnt = this.axisCount();
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                view = this.getAxisView(i);
                model = view.model();
                renderer = GridChartDelegate.Default.getAxisRenderer(model);
                view.setRenderer(renderer);
                sz = view.measure(grid, hintWidth, hintHeight);
                if (vertical) {
                    w = sz.width;
                    this._axisSizes.push(w);
                    size.width += w;
                } else {
                    h = sz.height;
                    this._axisSizes.push(h);
                    size.height += h;
                }
            }
        }
        return size;
    },
    _doUpdateElements: function() {
        var h, x, i, view, w, y,
            cnt = this.axisCount();
        if (this.isVertical()) {
            h = this.height();
            x = 0;
            for (i = 0; i < cnt; i++) {
                view = this.getAxisView(i);
                view.setBounds(x, 0, this._axisSizes[i], h);
                if (view.model().setSize)
                    view.model().setSize(h);
                x += this._axisSizes[i];
            }
        } else {
            w = this.width();
            y = 0;
            for (i = 0; i < cnt; i++) {
                view = this.getAxisView(i);
                view.setBounds(0, y, w, this._axisSizes[i]);
                y += this._axisSizes[i];
            }
        }
        for (i = 0; i < cnt; i++) {
            view = this.getAxisView(i);
            view.updateElements();
        }
    },
    _doDraw: function (g) {
    }
});
var PolarAxisPanel = defineClass("PolarAxisPanel", ChartAxisPanel, {
    init: function (dom, name, orientation) {
        this._super(dom, "polarAxisPanel");
    },
    _doUpdateElements: function() {
        var view, renderer,
            x, y, h2, i, cnt, view,
            chartView = this._parent,
            w = this.width(),
            h = this.height(),
            polarSize = chartView.polarSize();
        for (i = 0, cnt = this.axisCount(); i < cnt; i++) {
            view = this.getAxisView(i);
            if (view.visible()) {
                renderer = GridChartDelegate.Default.getAxisRenderer(view.model());
                view.setRenderer(renderer);
                if (view.model() instanceof PolarAxis) {
                    view.setBounds(0, 0, w, h);
                } else {
                    x = w / 2;
                    y = h / 2;
                    h2 = h / 2 * polarSize;
                    view.setBounds(x - 100, y - h2, 100, h2);
                }
                view.updateElements();
            }
        }
    }
});
var ChartLegendItemView = defineClass("ChartLegendItemView", ChartElement, {
    init: function (dom) {
        this._super(dom, "legendItemView");
        this.addElement(this._markerView = new ChartLegendMarkerView(dom));
    },
    setMarkerRenderer: function (value) {
        this._markerView.setRenderer(value);
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var legend, styles, size, w, h,
            model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            legend = model.owner();
            styles = model.styles();
            this._markerView.setModel(model);
            size = this._markerView.measure(grid, legend.markerWidth(), legend.markerHeight());
            w = size.width;
            h = size.height;
            if (renderer) {
                size = renderer.measure(this, hintWidth, hintHeight);
                size.width += 5;
                size.height = Math.max(h, size.height);;
            }
            size.marker = { width: w, height: h };
            return size;
        }
        return { width: hintWidth, height: hintHeight, markerWidth: 0 };
    },
    _doUpdateElements: function (updateHint) {
        var markerWidth = updateHint.width,
            markerHeight = updateHint.height;
        this._markerView.setBounds(0, (this.height() - markerHeight) / 2, markerWidth, markerHeight);
    },
    _doDraw: function (g) {
        var styles, x, y, r,
            model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            styles = this.model().styles();
            x = this._markerView.width() + 5;
            y = 0;
            r = new Rectangle(x, y, this.width() - x, this.height());
            renderer.render(this, g, r, Text);
        }
    }
});
var ChartLegendMarkerView = defineClass("ChartLegendMarkerView", ChartElement, {
    init: function (dom) {
        this._super(dom, "legendMarkerView");
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var styles,
            model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            styles = model.styles();// this.updateStyles(model.styles().findSub("marker"));
            return renderer.measure(this, hintWidth, hintHeight);
        }
        return { width: hintWidth, height: hintHeight };
    },
    _doDraw: function (g) {
        var styles, r,
            model = this.model(),
            renderer = this.renderer();
        if (model && renderer) {
            styles = model.styles();
            r = this.clientRect();
            renderer.render(this, g, r);
        }
    }
});
var ChartLegendView = defineClass("ChartLegendView", ChartElement, {
    init: function (dom) {
        this._super(dom, "legendView");
        this._itemRenderer = null;
        this._itemViews = [];
        this._itemElements = [];
        this._itemBounds = [];
        this._markerWidth = 0;
    },
    itemRenderer: function () {
        return this._itemRenderer ? this._itemRenderer : this.defaultItemRenderer();
    },
    setItemRenderer: function (value) {
        if (value !== this._itemRenderer) {
            this._itemRenderer = value;
            this.invalidate();
        }
    },
    defaultRenderer: function() {
        return ChartLegendRenderer.Default;
    },
    defaultItemRenderer: function () {
        return ChartLegendItemRenderer.Default;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        var i, item, itemView, r, size, bw, x, y, w, h, gap,
            grid = this.grid(),
            model = this.model(),
            styles = model.styles(),// this.updateStyles(model.styles()),
            items = model.items(),
            cnt = items ? items.length : 0;
        while (this._itemElements.length > cnt) {
            itemView = this.removeElement(this._itemElements.pop());
            this._itemViews.push(itemView);
        }
        while (this._itemElements.length < cnt) {
            if (this._itemViews.length > 0) {
                itemView = this._itemViews.pop();
            } else {
                itemView = new ChartLegendItemView(this._dom);
            }
            this._itemElements.push(itemView);
            this.addElement(itemView);
            this._itemBounds.push(new Rectangle());
        }
        this._markerWidth = 0;
        this._markerHeight = 0;
        if (cnt > 0) {
            for (i = 0; i < cnt; i++) {
                item = items[i];
                itemView = this._itemElements[i];
                itemView.setModel(item);
                itemView.setRenderer(ChartLegendItemRenderer.Default);//  this._itemRenderer);
                itemView.setMarkerRenderer(ChartLegendMarkerRenderer.Default);//delegate.getLegendMarkerRenderer(item.source()));
                size = itemView.measure(grid, hintWidth, hintHeight);
                this._markerWidth = Math.max(this._markerWidth, size.marker.width);
                this._markerHeight = Math.max(this._markerHeight, size.marker.height);
                r = this._itemBounds[i];
                r.width = size.width;
                r.height = size.height;
            }
            bw = styles.borderWidth();
            x = styles.paddingLeft() + bw;
            y = styles.paddingTop() + bw;
            w = 0;
            h = this._markerHeight;
            gap = model.itemGap();
            if (model.direction() == ChartLegendDirection.VERTICAL) {
                for (i = 0; i < cnt; i++) {
                    r = this._itemBounds[i];
                    r.x = x;
                    r.y = y;
                    r.width += this._markerWidth;
                    w = Math.max(w, r.width);
                    h += r.height;
                    y += r.height + gap;
                }
                h += gap * (cnt - 1);
                for (i = 0; i < cnt; i++) {
                    this._itemBounds[i].width = w;
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    r = this._itemBounds[i];
                    r.x = x;
                    r.y = y;
                    r.width += this._markerWidth;
                    w += r.width;
                    h = Math.max(h, r.height);
                    x += r.width + gap;
                }
                w += gap * (cnt - 1);
                for (i = 0; i < cnt; i++) {
                    this._itemBounds[i].height = h;
                }
            }
            return {
                width: w + styles.paddingHorz() + styles.borderWidth() * 2,
                height: h + styles.paddingVert() + styles.borderWidth() * 2
            };
        } else {
            return {
                width: 200,
                height: 13 + styles.paddingVert()
            };
        }
    },
    _doUpdateElements: function () {
        var i, cnt, itemView;
        for (i = 0, cnt = this._itemElements.length; i < cnt; i++) {
            itemView = this._itemElements[i];
            itemView.setRect(this._itemBounds[i]);
            itemView.updateElements({ width: this._markerWidth, height: this._markerHeight });
        }
    },
    /*
     _doDraw: function (g) {
     this.$_drawTestRect(g, 0x1100ff00, this);
     }
     */
});
var GridChartDelegate = defineClass("GridChartDelegate", null, {
    init: function () {
        this._super();
        this._axisRenderers = {};
        this._axisIndicatorRenderers = {};
        this._seriesRenderers = {};
        this._seriesItemRenderers = {};
        this._polarGridRenderer = null;
        this._gridRenderer = null;
    },
    getAxisRenderer: function (axis) {
        var clazz = axis.constructor,
            renderer = this._axisRenderers[clazz.prototype.$name];
        if (!renderer) {
            if (axis instanceof LinearAxis) {
                renderer = new LinearAxisRenderer();
            } else if (axis instanceof PolarAxis) {
                renderer = new PolarAxisRenderer();
            } else if (axis instanceof DatetimeAxis) {
                renderer = new DateTimeAxisRenderer();
            } else {
                renderer = new CategorizedAxisRenderer();
            }
            if (renderer) {
                this._axisRenderers[clazz.prototype.$name] = renderer;
            }
        }
        return renderer;
    },
    getAxisIndicatorRenderer: function (indicator) {
        var clazz = indicator.constructor,
            renderer = this._axisIndicatorRenderers[clazz.prototype.$name];
        if (!renderer) {
            if (indicator instanceof ChartAxisLineIndicator) {
                renderer = new AxisIndicatorLineRenderer();
            } else if (indicator instanceof ChartAxisBandIndicator) {
                renderer = new AxisIndicatorBandRenderer();
            }
            if (renderer) {
                this._axisIndicatorRenderers[clazz.prototype.$name] = renderer;
            }
        }
        return renderer;
    },
    getSeriesRenderer: function (series) {
        var clazz = series.constructor,
            renderer = this._seriesRenderers[clazz.prototype.$name];
        if (!renderer) {
            if (series instanceof BarSeries) {
                renderer = new BarSeriesRenderer();
            } else if (series instanceof ColumnSeries) {
                renderer = new ColumnSeriesRenderer();
            } else if (series instanceof PieSeries) {
                renderer = new PieSeriesRenderer();
            } else if (series instanceof AreaSeries) {
                renderer = new AreaSeriesRenderer();
            } else if (series instanceof LineSeries) {
                renderer = new LineSeriesRenderer();
            }
            if (renderer) {
                this._seriesRenderers[clazz.prototype.$name] = renderer;
            }
        }
        return renderer;
    },
    getSeriesItemRenderer: function (series) {
        var clazz = series.constructor,
            renderer = this._seriesItemRenderers[clazz.prototype.$name];
        if (!renderer) {
            if (series instanceof BarSeries) {
                renderer = new BarSeriesItemRenderer();
            } else if (series instanceof ColumnSeries) {
                renderer = new ColumnSeriesItemRenderer();
            } else if (series instanceof PieSeries) {
                renderer = new PieSeriesItemRenderer();
            } else if (series instanceof LineSeries) {
                renderer = new LineSeriesItemRenderer();
            }
            if (renderer) {
                this._seriesItemRenderers[clazz.prototype.$name] = renderer;
            }
        }
        return renderer;
    },
    getGridRenderer: function (chartView) {
        if (chartView.isPolar()) {
            return null;
        } else {
            return this._gridRenderer || (this._gridRenderer = new ChartGridRenderer());
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var ChartObjectRenderer = defineClass("ChartObjectRenderer", null, {
    init: function (config) {
        this._super();
        this._initProps(config);
    },
    measure: function(view, hintWidth, hintHeight) {
        return { width: hintWidth, height: hintHeight };
    },
    render: function (view, g, r) {
    }
});
var ChartGridRenderer = defineClass("ChartGridRenderer", ChartObjectRenderer, {
    init : function(config) {
        this._super(config);
    },
    render : function(view, g, r) {
        if (view.isFront()) {
            this.renderFront(view, g, r);
        } else {
            this.renderBack(view, g, r);
        }
    },
    renderBack : function(view, g, r) {
        var axis, grid, styles, cnt, reversed, vertical, i, j, k, x, y, count, xOrg, yOrg, rBand, line,
            axes = view.sources(),
            w = r.width,
            h = r.height;
        for (i = 0; i < axes.length; i++) {
            axis = axes[i];
            if (!axis.isValueAxis()) {
                continue;
            }
            grid = axis.grid();
            if (!grid.visible()) {
                continue;
            }
            styles = grid.styles();
            cnt = axis.getTickNumber() + 1;
            if (cnt > 1) {
                reversed = axis.reversed();
                vertical = axis.orientation() == ChartAxisOrientation.VERTICAL;
                if (reversed) {
                    yOrg = r.y;
                    xOrg = r.right();
                } else {
                    yOrg = r.bottom();
                    xOrg = r.x;
                }
                /*
                 var fill = gridStyles.background();
                 if (fill) {
                 rBand = r.clone();
                 for (k = 0; k < cnt - 1; k++) {
                 if (vertical) {
                 rBand.y = yOrg - axis.getGridPosition(k + 1) * h;
                 rBand.setBottom(yOrg - axis.getGridPosition(k) * h);
                 } else {
                 rBand.x = xOrg + axis.getGridPosition(k) * w;
                 rBand.setRight(xOrg + axis.getGridPosition(k + 1) * w);
                 }
                 fills.setCurrent(gridStyles, k % count);
                 g.drawRect(fills, null, rBand);
                 }
                 }
                 */
                for (j = 1; j < cnt; j++) {
                    if (axis.isContinuous() && (axis.calcedBaseValue() == axis.measuredMinimum() || axis.getTick(j) != axis.calcedBaseValue())) {
                        line = styles.line();
                        if (line) {
                            if (vertical) {
                                y = yOrg - (reversed ? -1 : 1) * _floor(axis.getGridPosition(j) * h);
                                g.drawLineI(line, r.x, y, r.right(), y);
                            } else {
                                x = xOrg + (reversed ? -1 : 1) * _floor(axis.getGridPosition(j) * w);
                                g.drawLineI(line, x, r.y, x, r.bottom());
                            }
                        }
                    }
                }
            }
        }
    },
    renderFront : function(view, g, r) {
        var i, j, axis, cnt, styles, x, y, line, vertical, baseLine, baseValue, minValue, grid,
            axes = view.sources(),
            yOrg = r.bottom(),
            xOrg = r.x;
        for (i = 0; i < axes.length; i++) {
            axis = axes[i];
            if (!(axis instanceof LinearAxis)) {
                continue;
            }
            grid = axis.frontGrid();
            if (!grid.visible()) {
                continue;
            }
            styles = grid.baseStyles();
            line = styles.line();
            if (line) {
                vertical = axis.orientation() == ChartAxisOrientation.VERTICAL;
                cnt = axis.getTickNumber();
                baseValue = axis.calcedBaseValue();
                minValue = axis.measuredMinimum();
                baseLine = false;
                if (baseValue != minValue && cnt > 1) {
                    for (j = 1; j < cnt; j++) {
                        if (axis.getTick(j) == baseValue) {
                            if (vertical) {
                                y = yOrg - _floor(axis.getGridPosition(j) * r.height);
                                g.drawLineI(line, r.x, y, r.right(), y);
                            } else {
                                x = xOrg + _floor(axis.getGridPosition(j) * r.width);
                                g.drawLineI(line, x, r.y, x, r.bottom());
                            }
                            baseLine = true;
                            break;
                        }
                    }
                    if (!baseLine) {
                        if (vertical) {
                            y = yOrg - _floor(axis.getPositionOf(baseValue) * r.height);
                            g.drawLineI(line, r.x, y, r.right(), y);
                        } else {
                            x = xOrg + _floor(axis.getPositionOf(baseValue) * r.width);
                            g.drawLineI(line, x, r.y, x, r.bottom());
                        }
                    }
                }
            }
        }
    }
});
var ChartAxisRenderer = defineClass("ChartAxisRenderer", ChartObjectRenderer, {
    init: function (config) {
        this._super(config);
    },
    createTickView: function (dom) {
        return new ChartAxisLabelView(dom);
    },
    measure: function(view, hintWidth, hintHeight) {
        var i, cnt, w, h, ticks,
            size = { width: hintWidth, height: hintHeight },
            model = view.model(),
            ticksView = view._ticksView,
            container = view.container();
        view._measuredTicks = model.getTickList();
        ticksView._prepareTicks();
        sz = this._doMeasureTicksView(model, ticksView, hintWidth, hintHeight);
        if (model.orientation() === ChartAxisOrientation.HORIZONTAL) {
            size.height = 0;// tickStyles.spaceVert();
            if (model.location() == ChartAxisLocation.NORMAL) {
                size.height += 0;// tickStyles.spaceBottom();
            } else {
                size.height += 0;//tickStyles.spaceTop();
            }
            h = sz.height;// this._doMeasureTicksView(model, ticksView, hintWidth, hintHeight).height;
            size.height += 5 + 1 + h;// tickStyles.tickLength() + 1 + h;//  tickStyles.fontSize();
        } else {
            /*
            w = 0;
            ticks = view._measuredTicks;
            for (i = 0, cnt = ticks.length; i < cnt; i++) {
                w = Math.max(w, container.measureText(null/*styles.font()*//*, ticks[i]) + 1);
            }
            */
            w = sz.width;
            w += 0;
            if (model.location() == ChartAxisLocation.NORMAL) {
                w += 0;//tickStyles.spaceLeft();
            } else {
                w += 0;//tickStyles.spaceRight();
            }
            w += 5 + 1;// tickStyles.tickLength() + 1;
            size.width = w;
        }
        return size;
    },
    locateFocusView: function (axisView, focusView, r, x, y) {
        if (focusView) {
            focusView.setBounds(0, 0, 100, 20);
        }
    },
    _doMeasureTicksView: function (ticksView, hintWidth, hintHeight) {
    },
    _doUpdateTicksView: function (ticksView) {
    }
});
var ChartAxisTitleRenderer = defineClass("ChartAxisTitleRenderer", ChartObjectRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function (view, hintWidth, hintHeight) {
        var size = { width: hintWidth, height: hintHeight },
            model = view.model(),
            styles = model.styles(),
            s = model.caption(),
            v = s ? styles.fontSize() + 2 : 0;
        if (view.orientation() === ChartAxisOrientation.VERTICAL) {
            v += styles.spaceHorz();
            size.width = v;
        } else {
            v += styles.spaceVert();
            size.height = v;
        }
        return size;
    },
    render: function (view, g, bounds) {
        var angle,
            model = view.model(),
            styles = model.styles(),
            font = styles.font(),
            fill = styles.background(),
            text = model.caption(),
            r = bounds.clone();
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        styles.deflateSpaces(r);
        if (view.orientation() == ChartAxisOrientation.VERTICAL) {
            angle = view.location() == ChartAxisLocation.OPPOSITE ? Math.PI / 2 : Math.PI * 3 / 2;
            g.drawTextRectA(font, styles.color(), text, r, angle);
        } else {
            g.drawTextRect(font, styles.color(), text, r, styles.textAlignment(), styles.lineAlignment());
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var AxisIndicatorRenderer = defineClass("AxisIndicatorRenderer", ChartObjectRenderer, {
    init: function () {
        this._super();
    },
    measure: function (view, hintWidth, hintHeight) {
    },
    render: function (view, g, bounds) {
        var axis = view.axisView().model();
        if (axis.getPositionOf) {
            this._renderContinuous(view, axis, g, bounds);
        } else if (axis instanceof CategorizedAxis) {
            this._renderCategorized(view, axis, g, bounds);
        }
    },
    _renderContinuous: function (view, axis, g, bounds) {
    },
    _renderCategorized: function (view, axis, g, bounds) {
    }
});
var AxisIndicatorLineRenderer = defineClass("AxisIndicatorLineRenderer", AxisIndicatorRenderer, {
    init: function () {
        this._super();
    },
    _renderContinuous: function (view, axis, g, r) {
        var model = view.model(),
            v = model.getValue(axis);
        if (isNaN(v)) return;
        var x, y, sz, bnear,
            tv = view.textView(),
            label = model.label(),
            xoff = label.offsetX(),
            yoff = label.offsetY(),
            styles = model.styles(),
            line = styles.line(),
            s = label.getText();
        tv.setVisible(s);
        if (tv.visible()) {
            tv.setText(s);
            tv.setStyles(label.styles());
            sz = tv.measureI(100000, 100000);
        }
        if (axis.isVertical()) {
            y = r.bottom() - (r.y + axis.getPositionOf(v) * r.height) - 1;
            if (line) {
                g.drawLineI(line, r.x, y, r.right(), y);
            }
            if (tv.visible()) {
                switch (label.position()) {
                    case ChartLabelPosition.FAR:
                        x = r.right() - sz.width - xoff;
                        break;
                    case ChartLabelPosition.CENTER:
                        x = r.x + (r.width - sz.width) / 2 + xoff;
                        break;
                    case ChartLabelPosition.NEAR:
                    case ChartLabelPosition.DEFAULT:
                    default:
                        x = r.x + xoff;
                        break;
                }
                switch (label.verticalAlign()) {
                    case ChartVerticalAlign.BOTTOM:
                        y += yoff;
                        break;
                    case ChartVerticalAlign.MIDDLE:
                        y -= sz.height /  2 + yoff;
                        break;
                    case ChartVerticalAlign.TOP:
                    case ChartVerticalAlign.DEFAULT:
                    default:
                        y -= sz.height + yoff;
                        break;
                }
                tv.setBoundsI(x, y, sz.width, sz.height);
            }
        } else {
            x = r.x + (r.x + axis.getPositionOf(v) * r.width);
            if (line) {
                g.drawLineI(line, x, r.y, x, r.bottom());
            }
            if (tv.visible()) {
                switch (label.position()) {
                    case ChartLabelPosition.CENTER:
                        y = r.y + (r.height - sz.height) / 2 - yoff;
                        break;
                    case ChartLabelPosition.FAR:
                        y = r.y + yoff;
                        break;
                    case ChartLabelPosition.NEAR:
                    case ChartLabelPosition.DEFAULT:
                    default:
                        y = r.bottom() - sz.height - 1 - yoff;
                        break;
                }
                switch (label.horizontalAlign()) {
                    case ChartHorizontalAlign.LEFT:
                        x -= sz.width + xoff;
                        break;
                    case ChartHorizontalAlign.CENTER:
                        x -= sz.width /  2 - xoff;
                        break;
                    case ChartHorizontalAlign.RIGHT:
                    case ChartHorizontalAlign.DEFAULT:
                    default:
                        x += xoff;
                        break;
                }
                tv.setBoundsI(x, y, sz.width, sz.height);
            }
        }
    },
    _renderCategorized: function (view, axis, g, bounds) {
    }
});
var AxisIndicatorBandRenderer = defineClass("AxisIndicatorBandRenderer", AxisIndicatorRenderer, {
    init: function (config) {
        this._super(config);
    },
    _renderContinuous: function (view, axis, g, r) {
        var yOrg, y1, y2, xOrg, x1, x2, font, bd,
            tv = view.textView(),
            model = view.model(),
            label = model.label(),
            xoff = label.offsetX(),
            yoff = label.offsetY(),
            styles = model.styles(),
            vTo = model.getEndValue(),
            vFrom = model.getStartValue(),
            h = r.height,
            w = r.width,
            v = model.getValue(),
            s = label.getText(),
            fill = styles.background();
        tv.setVisible(s);
        if (tv.visible()) {
            tv.setText(s);
            tv.setStyles(label.styles());
            sz = tv.measureI(100000, 100000);
        }
        if (axis.isVertical()) {
            yOrg = r.bottom();
            y1 = yOrg - (axis.getPositionOf(Math.min(vFrom, vTo)) * h);
            y2 = yOrg - (axis.getPositionOf(Math.max(vFrom, vTo)) * h);
            if (fill) {
                g.drawBounds(fill, null, r.x, y1, w, y2 - y1);
            }
            if (bd = styles.borderTop()) {
                g.drawHLineI(bd, _int(y2), r.x, r.right());
            }
            if (bd = styles.borderBottom()) {
                g.drawHLineI(bd, _int(y1), r.x, r.right());
            }
            if (tv.visible()) {
                switch (label.position()) {
                    case ChartLabelPosition.FAR:
                        x1 = r.right() - sz.width - xoff;
                        break;
                    case ChartLabelPosition.CENTER:
                        x1 = r.x + (r.width - sz.width) / 2 + xoff;
                        break;
                    case ChartLabelPosition.NEAR:
                    case ChartLabelPosition.DEFAULT:
                    default:
                        x1 = r.x + xoff;
                        break;
                }
                switch (label.verticalAlign()) {
                    case ChartVerticalAlign.BOTTOM:
                        y1 -= sz.height  + yoff;
                        break;
                    case ChartVerticalAlign.TOP:
                        y1 = y2 + yoff;
                        break;
                    case ChartVerticalAlign.DEFAULT:
                    case ChartVerticalAlign.MIDDLE:
                        y1 = y2 + (y1 - y2 - sz.height) /  2 - yoff;
                        break;
                    default:
                }
                tv.setBoundsI(x1, y1, sz.width, sz.height);
            }
        } else {
            xOrg = r.x;
            x1 = xOrg + (axis.getPositionOf(Math.min(vFrom, vTo)) * w);
            x2 = xOrg + (axis.getPositionOf(Math.max(vFrom, vTo)) * w);
            if (fill) {
                g.drawBounds(fill, null, x1, r.y, x2 - x1, h);
            }
            if (bd = styles.borderLeft()) {
                g.drawVLineI(bd, _int(x1), r.y, r.bottom());
            }
            if (bd = styles.borderRight()) {
                g.drawVLineI(bd, _int(x2), r.y, r.bottom());
            }
            if (tv.visible()) {
                switch (label.position()) {
                    case ChartLabelPosition.FAR:
                        y1 = r.y + yoff;
                        break;
                    case ChartLabelPosition.CENTER:
                        y1 = r.y + (r.height - sz.height) / 2 + yoff;
                        break;
                    case ChartLabelPosition.NEAR:
                    case ChartLabelPosition.DEFAULT:
                    default:
                        y1 = r.bottom() - sz.height - yoff;
                        break;
                }
                switch (label.horizontalAlign()) {
                    case ChartHorizontalAlign.LEFT:
                        x1 += xoff;
                        break;
                    case ChartHorizontalAlign.RIGHT:
                        x1 = x2 - sz.width - xoff;
                        break;
                    case ChartHorizontalAlign.DEFAULT:
                    case ChartHorizontalAlign.CENTER:
                        x1 += (x2 - x1 - sz.width) /  2 + xoff;
                        break;
                    default:
                }
                tv.setBoundsI(x1, y1, sz.width, sz.height);
            }
        }
    },
    _renderCategorized: function (view, axis, g, bounds) {
    }
});
var CategorizedAxisRenderer = defineClass("CategorizedAxisRenderer", ChartAxisRenderer, {
    init: function (config) {
        this._super(config);
    },
    render: function(view, g, r) {
        var x, y, y2, i, xOrg, yOrg, w, h, line, tickLine, font,
            model = view.model(),
            reversed = model.reversed(),
            styles = model.styles(),
            tickStyles = model.tickStyles(),
            tickLen = model.tickLength(),
            ticks = view._measuredTicks,
            labelInterval = Math.max(1, model.labelInterval()),
            ticksView = view._ticksView,
            cnt = ticks ? ticks.length : 0;
        if (cnt > 0) {
            w = r.width;
            h = r.height;
            line = styles.line();
            tickLine = tickStyles.line();
            font = tickStyles.font();
            if (model.orientation() === ChartAxisOrientation.HORIZONTAL) {
                if (model.location() === ChartAxisLocation.BETWEEN) {
                }  else if (model.location() === ChartAxisLocation.OPPOSITE) {
                    y = r.bottom();
                    if (line) {
                        g.drawLineI(line, r.x, y, r.right(), y);
                    }
                    if (tickLine) {
                        g.drawLineI(tickLine, r.x, y, r.x, y - tickLen);
                        for (i = 0; i < cnt; i++) {
                            x = r.x + _floor(model.getTickPosition(i + 1) * w);//  (model.getDisplayPosition(i) + model.getDisplayWidth(i)) * w);
                            g.drawLineI(tickLine, x, y, x, y - tickLen);
                        }
                    }
                    y -= tickLen + 1;
                    /*
                    for (i = 0; i < cnt; i += labelInterval) {
                        x = r.x + _floor((model.getDisplayPosition(i) + model.getDisplayWidth(i)) * w);
                        g.drawText(font, tickStyles.textFill(), ticks[i], x - w * model.getDisplayWidth(i) / 2, y,
                            TextAlign.CENTER, TextLayout.BOTTOM);
                    }
                    */
                    ticksView.setBounds(r.x, y, r.width, r.height - y);
                } else {
                    y = r.y;
                    if (line) {
                        g.drawLineI(line, r.x, y, r.right(), y);
                    }
                    if (tickLine) {
                        y2 = y + tickLen;
                        x = r.x + _floor(model.getTickPosition(0) * w);
                        g.drawLineI(tickLine, x, y, x, y2);
                        for (i = 0; i < cnt; i++) {
                            x = r.x + _floor(model.getTickPosition(i + 1) * w);//  (model.getDisplayPosition(i) + model.getDisplayWidth(i)) * w);
                            if (x >= r.x && x <= r.right()) {
                                g.drawLineI(tickLine, x, y, x, y2);
                            }
                        }
                    }
                    y += tickLen + 1;
                    ticksView.setBounds(r.x, y, r.width, r.height - y);
                }
            } else {
                /*if (model.location() === ChartAxisLocation.BETWEEN) {
                    xOrg = r.x;
                    xOrg2 = r.right();
                    yOrg = r.bottom();
                    if (line) {
                        g.drawLineI(line, xOrg, r.y, xOrg, yOrg + 1);
                        g.drawLineI(line, xOrg2, r.y, xOrg2, yOrg + 1);
                    }
                    if (tickLine) {
                        g.drawLineI(tickLine, xOrg, r.y, xOrg + tickLen, r.y);
                        g.drawLineI(tickLine, xOrg2 - tickLen, r.y, xOrg2, r.y);
                        for (i = 0; i < cnt; i++) {
                            y = r.y + _floor((model.getDisplayPosition(i) + model.getDisplayWidth(i)) * h);
                            g.drawLineI(tickLine, xOrg, y, xOrg + tickLen, y);
                            g.drawLineI(tickLine, xOrg2 - tickLen, y, xOrg2, y);
                        }
                    }
                    w = tickLen + 1;
                    ticksView.setBounds(r.x + w, r.y, r.width - w, r.height);
                } else*/ if (model.location() === ChartAxisLocation.OPPOSITE) {
                    xOrg = r.x;
                    yOrg = r.bottom();
                    if (line) {
                        g.drawLineI(line, xOrg, r.y, xOrg, yOrg + 1);
                    }
                    if (tickLine) {
                        g.drawLineI(tickLine, xOrg, r.y, xOrg + tickLen, r.y);
                        for (i = 0; i < cnt; i++) {
                            y = r.y + _floor((model.getDisplayPosition(i) + model.getDisplayWidth(i)) * h);
                            g.drawLineI(tickLine, xOrg, y, xOrg + tickLen, y);
                        }
                    }
                    w = tickLen + 1;
                    ticksView.setBounds(r.x + w, r.y, r.width - w, r.height);
                } else {
                    xOrg = r.right();
                    yOrg = r.bottom();
                    if (line) {
                        g.drawLineI(line, r.right(), r.y, r.right(), yOrg + 1);
                    }
                    x = r.right();
                    if (tickLine) {
                        g.drawLineI(tickLine, xOrg, r.y, xOrg - tickLen, r.y);
                        for (i = 0; i < cnt; i++) {
                            y = r.y + _floor((model.getDisplayPosition(i) + model.getDisplayWidth(i)) * h);
                            if (y >= r.y && y <= r.bottom()) {
                                g.drawLineI(tickLine, x, y, x - tickLen, y);
                            }
                        }
                    }
                    ticksView.setBounds(0, 0, r.width - tickLen - 1, r.height);
                }
            }
            this._doUpdateTicksView(model, ticksView);
        }
    },
    _doMeasureTicksView: function (axis, ticksView, hintWidth, hintHeight) {
        var cnt, i, view, w, h,
            size = { width: hintWidth, height: hintHeight},
            views = ticksView._tickViews;
        if (views && (cnt = views.length) > 0) {
            if (axis.orientation() === ChartAxisOrientation.HORIZONTAL) {
                if (axis.location() === ChartAxisLocation.OPPOSITE) {
                } else {
                    h = 0;
                    for (i = 0; i < cnt; i++) {
                        view = views[i];
                        h = Math.max(h, view._measuredHeight);
                    }
                    size.height = h;
                }
            } else {
                if (axis.location() === ChartAxisLocation.OPPOSITE) {
                } else {
                    w = 0;
                    for (i = 0; i < cnt; i++) {
                        view = views[i];
                        w = Math.max(w, view._measuredWidth);
                    }
                    size.width = w;
                }
            }
        }
        return size;
    },
    _doUpdateTicksView: function (axis, ticksView) {
        var i, view, x, y,
            w = ticksView.width(),
            h = ticksView.height(),
            views = ticksView._tickViews,
            cnt = ticksView.tickCount(),
            labelInterval = Math.max(1, axis.labelInterval()),
            reversed = axis.reversed();
        if (axis.orientation() === ChartAxisOrientation.HORIZONTAL) {
            if (axis.location() === ChartAxisLocation.OPPOSITE) {
            } else {
                for (i = 0; i < cnt; i += labelInterval) {
                    view = views[i];
                    x = (axis.getDisplayPosition(i) + axis.getDisplayWidth(i) / 2) * w;
                    view.setBounds(x - view._measuredWidth / 2, 0, view._measuredWidth, view._measuredHeight);
                }
            }
        } else {
            if (axis.location() === ChartAxisLocation.OPPOSITE) {
                for (i = 0; i < cnt; i += labelInterval) {
                    view = views[i];
                    y = axis.getDisplayPosition(i) + axis.getDisplayWidth(i) / 2;
                    if (!reversed) {
                        y = 1 - y;
                    }
                    y *= h;
                    view.setBounds(0, y - view._measuredHeight / 2, view._measuredWidth, view._measuredHeight);
                }
            } else {
                for (i = 0; i < cnt; i += labelInterval) {
                    view = views[i];
                    y = axis.getDisplayPosition(i) + axis.getDisplayWidth(i) / 2;
                    if (!reversed) {
                        y = 1 - y;
                    }
                    y *= h;
                    view.setBounds(w - view._measuredWidth, y - view._measuredHeight / 2, view._measuredWidth, view._measuredHeight);
                }
            }
        }
    },
    locateFocusView: function (axisView, focusView, r, x, y) {
        if (!focusView) {
            return;
        }
        var s, sz, tickLen,
            model = axisView.model(),
            styles = model.styles(),
            tickStyles = styles.findSub("tick");
        focusView.updateStyles(tickStyles, model, null, "crossed");
        tickLen = focusView.$_styles.tickLength();
        if (model.orientation() === ChartAxisOrientation.HORIZONTAL) {
            if (model.location() === ChartAxisLocation.OPPOSITE) {
            } else {
                s = String(model.getCategoryAt(r.width, x));
                focusView.setText(s);
                sz = focusView.measure(r.width, r.height);
                focusView.setBounds(x - sz.width / 2, r.y + tickLen + 1, sz.width, sz.height);
            }
        } else {
            if (model.location() === ChartAxisLocation.OPPOSITE) {
            } else {
            }
        }
    }
});
var LinearAxisRenderer = defineClass("LinearAxisRenderer", ChartAxisRenderer, {
    init: function (config) {
        this._super(config);
    },
    render: function(view, g, r) {
        var i, x, y, line, xOrg, yOrg, tick,
            h = r.height,
            w = r.width,
            model = view.model(),
            valid = model.isValid(),
            styles = model.styles(),
            tickStyles = model.tickStyles(),
            tickLine = tickStyles.line(),
            font = tickStyles.font(),
            tickLen = model.tickLength(),
            ticks = model.getTickList(),
            ticksView = view._ticksView,
            cnt = ticks ? ticks.length : 0;
        if (cnt > 0) {
            if (model.orientation() === ChartAxisOrientation.VERTICAL) {
                if (model.location() === ChartAxisLocation.OPPOSITE) {
                    yOrg = r.bottom();
                    xOrg = r.x;
                    line = styles.line();
                    if (line) {
                        g.drawLineI(line, xOrg, yOrg, xOrg, r.y);
                    }
                    if (valid) {
                        if (tickLine) {
                            for (i = 0; i < cnt; i++) {
                                tick = ticks[i];
                                y = yOrg - _floor(model.getPositionOf(tick) * h);
                                g.drawLineI(tickLine, xOrg, y, xOrg + tickLen, y);
                            }
                        }
                        w = tickLen + 1;
                        ticksView.setBounds(xOrg + w, r.y, r.width - w, r.height);
                    }
                } else {
                    yOrg = r.bottom();
                    xOrg = r.right();
                    line = styles.line();
                    if (line) {
                        g.drawLineI(line, xOrg, yOrg, xOrg, r.y);
                    }
                    if (valid) {
                        if (tickLine) {
                            for (i = 0; i < cnt; i++) {
                                tick = ticks[i];
                                y = yOrg - _floor(model.getPositionOf(tick) * h);
                                g.drawLineI(tickLine, xOrg, y, xOrg - tickLen, y);
                            }
                        }
                        ticksView.setBounds(0, y, r.width - tickLen - 1, r.height);
                    }
                }
            } else {
                if (model.location() === ChartAxisLocation.OPPOSITE) {
                } else {
                    if (model.reversed()) {
                        xOrg = r.right();
                        yOrg = r.y;
                        line = styles.line();
                        if (line) {
                            g.drawLineI(line, r.x, yOrg, xOrg, yOrg);
                        }
                        if (valid) {
                            if (tickLine) {
                                for (i = 0; i < cnt; i++) {
                                    tick = ticks[i];
                                    x = xOrg - _floor(model.getPositionOf(tick) * w);
                                    g.drawLineI(tickLine, x, yOrg, x, yOrg + tickLen);
                                }
                            }
                            ticksView.setBounds(r.x, tickLen + 1, r.width, r.height - tickLen - 1);
                        }
                    } else {
                        xOrg = r.x;
                        yOrg = r.y;
                        line = styles.line();
                        if (line) {
                            g.drawLineI(line, xOrg, yOrg, r.right(), yOrg);
                        }
                        if (valid) {
                            if (tickLine) {
                                for (i = 0; i < cnt; i++) {
                                    tick = ticks[i];
                                    x = xOrg + _floor(model.getPositionOf(tick) * w);
                                    g.drawLineI(tickLine, x, yOrg, x, yOrg + tickLen);
                                }
                            }
                            ticksView.setBounds(r.x, tickLen + 1, r.width, r.height - tickLen - 1);
                        }
                    }
                }
            }
            this._doUpdateTicksView(model, ticksView);
        }
    },
    createTickView: function (dom) {
        return new ChartNumericAxisLabelView(dom);
    },
    _doMeasureTicksView: function (axis, ticksView, hintWidth, hintHeight) {
        var cnt, i, view, w, h,
            size = { width: hintWidth, height: hintHeight },
            views = ticksView._tickViews;
        if (views && (cnt = views.length) > 0) {
            if (axis.orientation() === ChartAxisOrientation.VERTICAL) {
                w = 0;
                for (i = 0; i < cnt; i++) {
                    view = views[i];
                    w = Math.max(w, view._measuredWidth);
                }
                size.width = w;
            } else {
                h = 0;
                for (i = 0; i < cnt; i++) {
                    view = views[i];
                    h = Math.max(h, view._measuredHeight);
                }
                size.height = h;
            }
        }
        return size;
    },
    _doUpdateTicksView: function (axis, ticksView) {
        if (!axis.isValid()) return;
        var i, view, x, y,
            yOrg = ticksView.bottom(),
            w = ticksView.width(),
            h = ticksView.height(),
            views = ticksView._tickViews,
            cnt = ticksView.tickCount(),
            labelInterval = Math.max(1, axis.labelInterval());
        if (axis.orientation() === ChartAxisOrientation.VERTICAL) {
            if (axis.location() === ChartAxisLocation.OPPOSITE) {
                for (i = 0; i < cnt; i += labelInterval) {
                    view = views[i];
                    y = yOrg - axis.getPositionOf(view._tick) * h;
                    view.setBounds(0, y - view._measuredHeight / 2, view._measuredWidth, view._measuredHeight);
                }
            } else {
                for (i = 0; i < cnt; i += labelInterval) {
                    view = views[i];
                    y = yOrg - axis.getPositionOf(view._tick) * h;
                    view.setBounds(w - view._measuredWidth, y - view._measuredHeight / 2, view._measuredWidth, view._measuredHeight);
                }
            }
        } else {
            if (axis.location() === ChartAxisLocation.OPPOSITE) {
            } else {
                if (axis.reversed()) {
                    for (i = 0; i < cnt; i += labelInterval) {
                        view = views[i];
                        x = w - axis.getPositionOf(view._tick) * w;
                        view.setBounds(x - view._measuredWidth / 2, 0, view._measuredWidth, view._measuredHeight);
                    }
                } else {
                    for (i = 0; i < cnt; i += labelInterval) {
                        view = views[i];
                        x = axis.getPositionOf(view._tick) * w;
                        view.setBounds(x - view._measuredWidth / 2, 0, view._measuredWidth, view._measuredHeight);
                    }
                }
            }
        }
    },
    locateFocusView: function (axisView, focusView, r, x, y) {
        if (!focusView) {
            return;
        }
        var v, s, sz, tickLen, formatter,
            model = axisView.model(),
            styles = model.styles(),
            tickStyles = styles.findSub("tick");
        focusView.updateStyles(tickStyles, model, null, "crossed");
        tickLen = focusView.$_styles.tickLength();
        formatter = focusView.$_styles.numberFormatter();
        if (model.orientation() === ChartAxisOrientation.VERTICAL) {
            v = model.getValueAt(1 - y / r.height);
            s = formatter ? formatter.format(v) : v;
            focusView.setText(s);
            sz = focusView.measure(r.width, r.height);
            if (model.location() === ChartAxisLocation.OPPOSITE) {
                focusView.setBounds(r.x + tickLen + 1, y - sz.height / 2, sz.width, sz.height);
            } else {
                focusView.setBounds(r.right() - tickLen - 1 - sz.width, y - sz.height / 2, sz.width, sz.height);
            }
        } else {
            if (model.location() === ChartAxisLocation.OPPOSITE) {
            } else {
            }
        }
    }
});
var DateTimeAxisRenderer = defineClass("DateTimeAxisRenderer", ChartAxisRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function(view, hintWidth, hintHeight) {
        var size = { width: hintWidth, height: hintHeight},
            model = view.model();
        if (model.orientation() === AxisOrientation.VERTICAL) {
            size.width = 30;
        } else {
            size.height = 30;
        }
        return size;
    },
    render: function(view, g, r) {
        var stroke, i, s, y, x,
            model = view.model(),
            styles = model.styles(),
            tickStyles = styles.findSub("tick"),
            ticks = model.getTickList(),
            cnt = ticks ? ticks.length : 0;
        if (cnt > 0) {
            stroke = tickStyles.line();
            if (model.orientation() === AxisOrientation.VERTICAL) {
                for (i = 0; i < cnt; i++) {
                    s = dateToStr(ticks[i]);
                    y = (r.y + model.getPositionOf(ticks[i]) * r.height) >>> 0;
                    g.drawLine(stroke, r.right() - 5, y + 0.5, r.right(), y + 0.5);
                    g.drawText(styles.font(), SolidBrush.BLACK, s, r.right() - 5 - 1, y, TextAlign.RIHGT, TextLayout.MIDDLE);
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    s = dateToStr(ticks[i]);
                    x = (r.x + model.getPositionOf(ticks[i]) * r.width) >>> 0;
                    g.drawLine(stroke, x + 0.5, 0, x + 0.5, 5);
                    g.drawText(styles.font(), styles.textFill(), s, x, r.y + 5, TextAlign.CENTER);
                }
            }
        }
        function dateToStr(date) {
            return pad(date.getMonth() + 1) + "." + pad(date.getDate());
        }
    }
});
var PolarAxisRenderer = defineClass("PolarAxisRenderer", ChartAxisRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function(view, hintWidth, hintHeight) {
        var size = { width:hintWidth, height:hintHeight };
        return size;
    },
    render: function(view, g, r) {
        /*
         return;
         var axis = view.model();
         var styles = axis.styles();
         var polarSize = view.chartView().polarSize();
         var border = styles.border();
         if (border) {
         var rd = Math.min(r.width, r.height) / 2;
         rd *= polarSize;
         var cx = r.x + r.width / 2;
         var cy = r.y + r.height / 2;
         g.drawCircle(null, border, cx, cy, rd);
         }
         */
        var border, pts, rd, i, cnt, cx, cy, tick, x, y, halign, valign,
            axis = view.model(),
            styles = axis.styles(),
            polarSize = view.chartView().polarSize();
        cx = r.x + r.width / 2;
        cy = r.y + r.height / 2;
        rd = Math.min(r.width, r.height) * polarSize;
        pts = axis.getTickPoints(r, polarSize);
        border = styles.border();
        if (border) {
            if (axis._curved) {
                g.drawCircle(null, border, cx, cy, rd / 2);
            } else {
                g.drawPolygon(null, border, pts);
            }
        }
        rd = (rd + styles.offset()) * polarSize / rd;
        pts = axis.getTickPoints(r, rd);
        ticks = axis.getTickList();
        cnt = pts.length;
        for (i = 0; i < cnt; i++) {
            tick = axis.getTick(i);
            x = pts[i].x;
            y = pts[i].y;
            halign = TextAlign.CENTER;
            valign = TextLayout.MIDDLE;
            if (Math.abs(x - cx) <= 4) {
                valign = (y < cy) ? TextLayout.BOTTOM : TextLayout.TOP;
            } else if (x < cx) {
                halign = TextAlign.RIGHT;
            } else {
                halign = TextAlign.LEFT;
            }
            g.drawText(styles.font(), styles.textFill(), tick, x, y, halign, valign);
        }
    }
});
var ChartSeriesRenderer = defineClass("ChartSeriesRenderer", null, {
    init: function (config) {
        this._super(config);
    },
    canStacked: function () {
        return false;
    },
    measure: function(view, hintWidth, hintHeight) {
        return this._doMeasure(view, hintWidth, hintHeight);
    },
    layoutItems: function(view) {
        if (this._checkAxes(view)) {
            var i, cnt, itemView, r,
                itemViews = [];
            for (i = 0, cnt = view.itemCount(); i < cnt; i++) {
                itemView = view.getItem(i);
                if (itemView) {
                    itemViews.push(itemView);
                }
            }
            r = new Rectangle(0, 0, view.width(), view.height());
            this._doLayoutItems(view, itemViews, r);
        }
    },
    render: function(view, g, r) {
        this._doRender(view, g, r);
    },
    renderItemSeparators: function (view, g, bounds) {
        this._doRenderItemSeparators(view, g, bounds);
    },
    renderText: function(view, g, r) {
        if (!this.animating(view)) {
            this._doRenderText(view, g, r);
        }
    },
    layoutLabels: function (view, textViews, r) {
        if (this._checkAxes(view)) {
            if (textViews) {
                if (!this.animating(view)) {
                    this._doLayoutLabels(view, textViews, r);
                } else {
                    for (var i = textViews.length; i--;) {
                        textViews[i].setVisible(false);
                    }
                }
            }
        }
    },
    drawLegend: function (view, g, r) {
        return false;
    },
    _checkAxes: function (view) {
        var series = view.model();
        return series && series.xAxisObj() && series.yAxisObj();
    },
    _doMeasure: function (view, hintWidth, hintHeight) {
        return { width: hintWidth, height: hintHeight };
    },
    _doRender: function (view, g, r) {
    },
    _doRenderItemSeparators: function (view, g, bounds) {
    },
    _doRenderText: function (view, g, r) {
    },
    _doLayoutLabels: function (view, textViews, r) {
    },
    _doLayoutItems: function (view, itemViews, r) {
    },
    getInterpolation: function(view, property) {
        var run = view.chartView().animations().getInterpolation(view.model(), property);
        return run ? run.rate() : 1.0;
    },
    animating: function(view) {
        return false;
    }
});
var ChartSeriesItemRenderer = defineClass("ChartSeriesItemRenderer", null, {
    init: function (config) {
        this._super(config);
    },
    seriesView: function (view) {
        do {
            if (view instanceof ChartSeriesView) {
                return view;
            }
            view = view.parent();
        } while (view);
        return null;
    },
    measure: function(view, hintWidth, hintHeight) {
        return this._doMaesure(model, hintWidth, hintHeight);
    },
    render: function(view, g, r) {
        this._doRender(view, g, r);
    },
    getInterpolation: function(view, property) {
        var run = view.chartView().animations().getInterpolation(this.seriesView(view).model(), property);
        return run ? run.rate() : 1.0;
    },
    isAnimating: function(view) {
        return view.chartView().animations().isAnimating(this.seriesView(view).model());
    }
});
var ColumnSeriesRenderer = defineClass("ColumnSeriesRenderer", ChartSeriesRenderer, {
    init: function (config) {
        this._super(config);
    },
    canStacked: function () {
        return true;
    },
    _doRender: function(view, g, bounds) {
    },
    _doRenderItemSeparators: function (view, g, bounds) {
        /*
        if (this.animating(view))
            return;
        var series = view.model();
        var group = series.group();
        if (group && (group.stackMode() == ChartStackMode.FILL || group.stackMode() == Chart.StackMode.NORMAL)) {
            var itemView;
            var i;
            var cnt = view.itemCount();
            var styles = group.styles().findSub("separator");
            var stroke = styles.line();
            if (stroke) {
                for (i = 0; i < cnt; i++) {
                    itemView = view.getItem(i);
                    if (itemView.isSeparator()) {
                        var x = itemView.x();
                        var y = itemView.isNegative() ? itemView.y() + itemView.height() - 1 : itemView.y();
                        g.drawLineI(stroke, x, y, x + itemView.width(), y);
                    }
                }
            }
        }
        */
    },
    _getDefaultAlign: function (pos) {
        if (pos == ChartLabelPosition.CENTER) {
            return ChartVerticalAlign.MIDDLE;
        }
        return ChartVerticalAlign.TOP;
    },
    _layoutLabel: function (lm, series, bounds, itemView, textView, value, pos) {
        return lm.layoutVert2(series, bounds, itemView, textView, value, pos, this._getDefaultAlign);
    },
    _labelAxis: function (series) {
        return series.yAxisObj();
    },
    _doLayoutLabels: function (view, textViews, bounds) {
        var cnt = view.itemCount();
        if (cnt < 1) return;
        var i, iv, item, tv, v, pos, align, r,
            series = view.model(),
            label = series.label(),
            axis = this._labelAxis(series),
            base = axis.calcedBaseValue(),
            valueFld = series.valueField(),
            lm = CartesianSeriesLabelLayout.Default;
        if (label.visible()) {
            for (i = 0; i < cnt; i++) {
                iv = view.getItem(i);
                item = iv.model();
                tv = textViews[i];
                tv.setVisible(item != null);
                if (tv.visible()) {
                    tv.setStyles(item.labelStyles());
                    tv.$_model = label;
                    v = series.getValue(item.getProp(valueFld));
                    pos = v < base ? ChartLabelPosition.NEAR : ChartLabelPosition.FAR;
                    r = this._layoutLabel(lm, series, bounds, iv, tv, String(v), pos)
                    tv.setRect(r);
                }
            }
        } else {
            for (i = 0; i < cnt; i++) {
                textViews[i].setVisible(false);
            }
        }
    },
    _doLayoutItems: function(view, itemViews, bounds) {
        var cnt = view.itemCount();
        if (cnt < 1) {
            return;
        }
        var j, series2, item2, v, v2, wCat, wBar, yStart, xOrg,
            vStart, x, x1, y, y1, y2, sum, sum2, scale, i, itemView, item, gnegative, gitemindex, i, itemView, item,
            series = view.model(),
            labelAxis = series.xAxisObj(),
            valueAxis = series.yAxisObj(),
            validAxis = valueAxis.isValid(),
            visCount = labelAxis.visibleCount ? labelAxis.visibleCount() : 0,
            valueFld = series.valueField(),
            group = series.group(),
            stackMode = group && group.stackMode(),
            cinfo = series.clusterInfo,
            h = bounds.height,
            w = bounds.width,
            base = valueAxis.calcedBaseValue(),
            yOrg = bounds.bottom(),
            yBase = valueAxis.getPositionOf(base),
            locRate = series.locationRate(),//this.getInterpolation(view, ChartAnimationTypes.PROP_POSITION),
            widthRate = 1,//this.getInterpolation(view, ChartAnimationTypes.PROP_WIDTH),
            itemWidth = series.itemWidth();
        for (i = 0; i < cnt; i++) {
            itemView = itemViews[i];
            item = itemView.model();
            itemView.setVisible(item && item.visible() && item._category && item._category.index < visCount);
            if (itemView.visible()) {
                v = series.getValue(item.getProp(valueFld));
                vStart = base;
                wCat = labelAxis.getDisplayWidth(item);
                x = labelAxis.getDisplayPosition(item) + wCat * (cinfo ? cinfo.position : 0);
                wBar = wCat * (cinfo ? cinfo.width : 1);
                if (group == null) {
                } else if (stackMode == ChartStackMode.NONE || stackMode == ChartStackMode.OVERLAPPED) {
                } else if (stackMode == ChartStackMode.NORMAL) {
                    gnegative = v < base;
                    gitemindex = 0;
                    for (j = 0; j < series.groupIndex(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof ColumnSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            if ((v2 - base) * (v - base) >= 0) {
                                vStart += v2;
                                gitemindex++;
                            }
                        }
                    }
                    v += vStart;
                    view.setItemIndex(itemView, i, group, gitemindex, gnegative);
                } else {	// ChartStackMode.FILL
                    sum = sum2 = 0;
                    for (j = 0; j < group.count(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof ColumnSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            sum += Math.abs(v2);
                        }
                    }
                    scale = (valueAxis.measuredMaximum() - base) / (v >= base ? sum : sum2);
                    gnegative = v < base;
                    gitemindex = 0;
                    for (j = 0; j < series.groupIndex(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof ColumnSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            if ((v2 - base) * (v - base) >= 0) {
                                vStart += v2;
                                gitemindex++;
                            }
                        }
                    }
                    v = (v + vStart) * scale;
                    vStart *= scale;
                    view.setItemIndex(itemView, i, group, gitemindex, gnegative);
                }
                xOrg = bounds.x + 1;
                x1 = x += wBar / 2;
                x1 = xOrg + x1 * w;
                wBar *= itemWidth * widthRate;
                x -= wBar / 2;
                x = xOrg + x * w;
                wBar = wBar * w;
                if (validAxis) {
                    yStart = valueAxis.getPositionOf(vStart);
                    y = valueAxis.getPositionOf(v);
                    if (v >= base) {
                        y2 = yBase;
                        if (vStart > base) {
                            y2 = yBase + (yStart - yBase) * locRate;
                        }
                        y2 = yOrg - y2 * h;
                        y = y1 = yOrg - y * h;
                        y1 = y2 - (y2 - y1) * locRate;
                        itemView._reversed = false;
                    } else {
                        y1 = yBase;
                        if (vStart < base) {
                            y1 = yBase + (yStart - yBase) * locRate;
                        }
                        y1 = yOrg - y1 * h + 1;
                        y = y2 = yOrg - y * h;
                        y2 = y1 + (y2 - y1) * locRate;
                        itemView._reversed = true;
                    }
                    x -= 0;//(x - bounds.x) * (1 - posRate);
                    x = _floor(x);
                    y = _floor(y);
                    x1 = _floor(x1);
                    y1 = _floor(y1);
                    y2 = _floor(y2);
                    y2 = Math.abs(y2 - y1) + 1;
                } else {
                    y1 = yOrg;
                    y2 = 0;
                }
                wBar = _floor(wBar);
                itemView.setDataPoint(x1, y);
                itemView.setBounds(x, y1, wBar, y2);
            }
        }
    }
});
var ColumnSeriesItemRenderer = defineClass("ColumnSeriesItemRenderer", ChartSeriesItemRenderer, {
    init: function (config) {
        this._super(config);
    },
    _doRender: function(view, g, r) {
        var model = view.model(),
            styles = model.styles(),
            shape = model.getProp("shape"),
            border = styles.border(),
            fill = styles.background();
        if (fill || border) {
            switch (shape) {
                case "triangle":
                    g.drawPolygonArray(fill, border, [
                        r.x, r.bottom() - 1, r.x + r.width / 2, r.y, r.right() - 1, r.bottom() - 1
                    ]);
                    break;
                default:
                    if (fill) {
                        g.drawRectI(fill, null, r);
                    }
                    if (border) {
                        if (view._reversed) {
                            g.drawLinesI(border, r.x, r.y, r.x, r.bottom() - 1, r.right() - 1, r.bottom() - 1, r.right() - 1, r.x);
                        } else {
                            g.drawLinesI(border, r.x, r.bottom() - 1, r.x, r.y, r.right() - 1, r.y, r.right() - 1, r.bottom() - 1);
                        }
                    }
                    break;
            }
        }
    }
});
var BarSeriesRenderer = defineClass("BarSeriesRenderer", ColumnSeriesRenderer, {
    init: function (config) {
        this._super(config);
    },
    _doRenderItemSeparators: function (view, g, bounds) {
        /*
        if (this.animating(view))
            return;
        var series = view.model();
        var group = series.group();
        if (group && (group.stackMode() == ChartStackMode.FILL || group.stackMode() == ChartStackMode.NORMAL)) {
            var itemView;
            var i;
            var cnt = view.itemCount();
            var gstyles = group.styles().findSub("separator");
            var stroke = gstyles.line();
            if (stroke) {
                for (i = 0; i < cnt; i++) {
                    itemView = view.getItem(i);
                    if (itemView.isSeparator()) {
                        var y = itemView.y();
                        var x = itemView.isNegative() ? itemView.x() : itemView.x() + itemView.width() - 1;
                        g.drawLineI(stroke, x, y, x, y + itemView.height());
                    }
                }
            }
        }
        */
    },
    _getDefaultAlign: function (pos) {
        if (pos == ChartLabelPosition.CENTER) {
            return ChartHorizontalAlign.CENTER;
        }
        return ChartHorizontalAlign.RIGHT;
    },
    _layoutLabel: function (lm, series, bounds, itemView, textView, value, pos) {
        return lm.layoutHorz2(series, bounds, itemView, textView, value, pos, this._getDefaultAlign);
    },
    _labelAxis: function (series) {
        return series.xAxisObj();
    },
    /*
    _doLayoutLabels: function (view, textViews, bounds) {
        var cnt = view.itemCount();
        if (cnt < 1) return;
        var i, item, itemView, textView, v, r, styles, itemStyles, labelStyles, pos,
            series = view.model(),
            label = series.label(),
            axis = this._labelAxis(),
            base = axis.calcedBaseValue(),
            valueFld = series.valueField(),
            lm = CartesianSeriesLabelLayout.Default;
        if (label.visible()) {
            for (i = 0; i < cnt; i++) {
                itemView = view.getItem(i);
                item = itemView.model();
                textView = textViews[i];
                textView.setVisible(item != null);
                if (textView.visible()) {
                    labelStyles = item.labelStyles();
                    textView.setStyles(labelStyles);
                    textView.$_model = label;
                    v = series.getValue(item.getProp(valueFld));
                    pos = v < base ? ChartLabelPosition.NEAR : ChartLabelPosition.FAR;
                    r = this._layoutItem(lm, bounds, itemView, textView, String(v), pos)
                    r = lm.layoutHorz2(series, bounds, itemView, textView, String(v), pos);
                    textView.setRect(r);
                }
            }
        } else {
            for (i = 0; i < cnt; i++) {
                textViews[i].setVisible(false);
            }
        }
    },
    */
    _doLayoutItems: function (view, itemViews, bounds) {
        var cnt = view.itemCount();
        if (cnt < 1) {
            return;
        }
        var gnegative, gitemindex,
            x, x1, x2, y, y1, sum, sum2, scale,
            j, series2, item2, v, v2, wCat, wBar, xStart, i, itemView, item,
            series = view.model(),
            labelAxis = series.yAxisObj(),
            visCount = labelAxis.visibleCount ? labelAxis.visibleCount() : 0,
            labelReversed = labelAxis.reversed(),
            labelOpposite = labelAxis.isOppositeOf(series),
            valueAxis = series.xAxisObj(),
            validAxis = valueAxis.isValid(),
            valueReversed = valueAxis.reversed(),
            valueOpposite = valueAxis.isOppositeOf(series),
            valueFld = series.valueField(),
            group = series.group(),
            stackMode = group && group.stackMode(),
            cinfo = series.clusterInfo,
            h = bounds.height,
            w = bounds.width,
            base = valueAxis.calcedBaseValue(),
            xOrg = valueReversed ? bounds.right() : bounds.x,
            xBase = valueAxis.getPositionOf(base),
            vStart = base,
            itemWidth = series.itemWidth(),
            locRate = series.locationRate();
        for (i = 0; i < cnt; i++) {
            itemView = itemViews[i];
            item = itemView.model();
            itemView.setVisible(item && item.visible() && item._category && item._category.index < visCount);
            if (itemView.visible()) {
                v = series.getValue(item.getProp(valueFld));
                vStart = base;
                wCat = labelAxis.getDisplayWidth(item);
                y = labelAxis.getDisplayPosition(item) + wCat * (cinfo ? cinfo.position : 0);
                wBar = wCat * (cinfo ? cinfo.width : 1);
                if (group == null) {
                } else if (stackMode == ChartStackMode.NONE || stackMode == ChartStackMode.OVERLAPPED) {
                } else if (stackMode == ChartStackMode.NORMAL) {
                    gnegative = v < base;
                    gitemindex = 0;
                    for (j = 0; j < series.groupIndex(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof BarSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            if ((v2 - base) * (v - base) >= 0) {
                                vStart += v2;
                                gitemindex++;
                            }
                        }
                    }
                    v += vStart;
                    view.setItemIndex(itemView, i, group, gitemindex, gnegative);
                } else { // ChartStackMode.FILL
                    sum = sum2 = 0;
                    for (j = 0; j < group.count(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof BarSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            sum += Math.abs(v2);
                        }
                    }
                    scale = (valueAxis.measuredMaximum() - base) / (v >= base ? sum : sum2);
                    gnegative = v < base;
                    gitemindex = 0;
                    for (j = 0; j < series.groupIndex(); j++) {
                        series2 = group.getItem(j);
                        if (series2 instanceof BarSeries) {
                            item2 = series2.getItem(i);
                            v2 = item2.getProp(series2.valueField());
                            if ((v2 - base) * (v - base) >= 0) {
                                vStart += v2;
                                gitemindex++;
                            }
                        }
                    }
                    v = (v + vStart) * scale;
                    vStart *= scale;
                    view.setItemIndex(itemView, i, group, gitemindex, gnegative);
                }
                y1 = y += wBar / 2;
                if (labelReversed) {
                    y1 = bounds.y + y1 * h;
                } else {
                    y1 = bounds.bottom() - y1 * h;
                }
                wBar *= itemWidth;
                if (labelReversed) {
                    y -= wBar / 2;
                    y = bounds.x + y * h;
                } else {
                    y += wBar / 2;
                    y = bounds.bottom() - y * h;
                }
                wBar = wBar * h;
                if (validAxis) {
                    xStart = valueAxis.getPositionOf(vStart);
                    x = valueAxis.getPositionOf(v);
                    if (v >= base) {
                        x1 = xBase;
                        if (vStart > base) {
                            x1 = xBase + (xStart - xBase) * locRate;
                        }
                        x2 = x1 + (x - x1) * locRate;
                        itemView._reversed = false;
                    } else {
                        x2 = xBase;
                        if (vStart < base) {
                            x2 = xBase - (xBase - xStart) * locRate;
                        }
                        x1 = x2 - (x2 - x) * locRate;
                        itemView._reversed = true;
                    }
                    x = _floor(x * w);
                    x1 = _floor(x1 * w);
                    x2 = _floor(x2 * w);
                    y = _floor(y);
                    y1 = _floor(y1);
                    wBar = _floor(wBar);
                    if (valueReversed) {
                        x = xOrg - x;
                        x1 = xOrg - x1;
                        x2 = xOrg - x2;
                    } else {
                        x += xOrg;
                        x1 += xOrg;
                        x2 += xOrg;
                    }
                } else {
                    x1 = xOrg;
                    x2 = 0;
                }
                v = Math.abs(x2 - x1) + 1;
                if (valueReversed) {
                    itemView.setBounds(x1 - v + 1, y, v, wBar);
                    itemView.setDataPoint(x - v + 1, y1);
                } else {
                    itemView.setBounds(x1, y, v, wBar);
                    itemView.setDataPoint(x, y1);
                }
            }
        }
    }
});
var BarSeriesItemRenderer = defineClass("BarSeriesItemRenderer", ChartSeriesItemRenderer, {
    init: function (config) {
        this._super(config);
    },
    _doRender: function(view, g, r) {
        var model = view.model(),
            styles = model.styles(),
            shape = model.getProp("shape"),
            fill = styles.background(),
            border = styles.border();
        if (fill || border) {
            switch (shape) {
                case "triangle":
                    g.drawPolygonArray(fill, border, [
                        r.x, r.y, r.right() - 1, r.y + r.height / 2, r.x, r.bottom() - 1
                    ]);
                    break;
                default:
                    if (fill) {
                        g.drawRectI(fill, null, r);
                    }
                    if (border) {
                        if (view._reversed) {
                            g.drawLinesI(border, r.right() - 1, r.y, r.x, r.y, r.x, r.bottom() - 1, r.right() - 1, r.bottom() - 1);
                        } else {
                            g.drawLinesI(border, r.x, r.y, r.right() - 1, r.y, r.right() - 1, r.bottom() - 1, r.x, r.bottom() - 1);
                        }
                    }
            }
        }
    }
});
var LineSeriesRenderer = defineClass("LineSeriesRenderer", ChartSeriesRenderer, {
    init: function (config) {
        this._super(config);
    },
    _doRender: function(view, g, bounds) {
        var cnt = view.itemCount();
        if (cnt > 1) {
            var lineType, stepped, i, itemView, p,
                series = view.model(),
                styles = series.styles(),
                line = styles.line();
            if (line) {
                lineType = series.lineType();
                stepped = lineType == ChartLineType.STEPPED;
                i = 0;
                while (i < cnt) {
                    for (; i < cnt; i++) {
                        itemView = view.getItem(i);
                        if (itemView.visible()) {
                            break;
                        }
                    }
                    pts = [];
                    for (; i < cnt; i++) {
                        itemView = view.getItem(i);
                        if (!itemView.visible()) {
                            break;
                        }
                        pts.push(p = {
                            x: itemView.x() + itemView.width() / 2,
                            y: itemView.y() + itemView.height() / 2
                        });
                        if (stepped && i < cnt - 1 && (itemView = view.getItem(i + 1)).visible()) {
                            pts.push({
                                x: itemView.x() + itemView.width() / 2,
                                y: p.y
                            });
                        }
                    }
                    if (pts.length > 1) {
                        if (lineType == ChartLineType.CURVED) {
                            g.drawCurve(line, pts);
                        } else {
                            g.drawLines(line, pts);
                        }
                    }
                }
            }
        }
    },
    _getDefaultAlign: function (pos) {
        if (pos == ChartLabelPosition.CENTER) {
            return ChartVerticalAlign.MIDDLE;
        }
        return ChartVerticalAlign.TOP;
    },
    _doLayoutLabels: function (view, textViews, bounds) {
        var i, cnt, itemView, item, textView, styles, v, r,
            series = view.model(),
            label = series.label(),
            labelStyles = label.styles(),
            valueFld = series.valueField(),
            labelVisible = label.visible();
            lm = CartesianSeriesLabelLayout.Default;
        for (i = 0, cnt = view.itemCount(); i < cnt; i++) {
            itemView = view.getItem(i);
            item = itemView.model();
            textView = textViews[i];
            textView.setVisible(item != null && labelVisible);
            if (textView.visible()) {
                textView.$_model = label;
                textView.setStyles(labelStyles);
                v = item.getProp(valueFld);
                r = lm.layoutVert2(series, bounds, itemView, textView, String(v), ChartLabelPosition.FAR, this._getDefaultAlign);
                textView.setRect(r);
            }
        }
    },
    _doLayoutItems: function(view, itemViews, r) {
        var cnt = view.itemCount();
        if (cnt < 1) {
            return;
        }
        var x, y, v, i, itemView, item, itemStyles, itemCases, styles, sz, markerWidth, markerHeight,
            series = view.model(),
            xAxisObj = series.xAxisObj(),
            yAxisObj = series.yAxisObj(),
            labelAxis = xAxisObj instanceof LinearAxis ? yAxisObj : xAxisObj,
            valueAxis = yAxisObj instanceof LinearAxis ? yAxisObj : xAxisObj,
            labelFld = series.labelField(),
            valueFld = series.valueField(),
            visCount = labelAxis.visibleCount ? labelAxis.visibleCount() : 0,
            h = r.height,
            w = r.width,
            yOrg = r.bottom(),
            sizeRate = 1,// this.getInterpolation(view, ChartAnimationTypes.PROP_SIZE),
            locRate = series.locationRate();//this.getInterpolation(view, ChartAnimationTypes.PROP_LOCATION);
        for (i = 0; i < cnt; i++) {
            itemView = itemViews[i];
            item = itemView.model();
            itemView.setVisible(item && item.visible() && item._category && item._category.index < visCount);
            if (itemView.visible()) {
                /*
                styles = series.styles().findSub("marker");
                itemStyles = series.getItemSubStyles(item, "marker");
                itemCases = series.getItemCases(item);
                styles = itemView.updateStyles(styles, series, itemCases, itemView.state(), itemStyles);
                */
                /*
                var markerScale = itemView.$_styles.markerScale();
                var markerWidth = itemView.$_styles.width() * markerScale;
                var markerHeight = itemView.$_styles.height() * markerScale;
                */
                styles = item.styles();
                sz = styles.shapeSize();
                markerWidth = sz ? sz.getDimension(9) : 9;
                markerHeight = markerWidth;
                v = series.getValue(item.getProp(valueFld));
                if (labelAxis == series.xAxisObj()) {
                    if (labelAxis.getCategoryPosition) {
                        x = (labelAxis.getDisplayPosition(item) + labelAxis.getDisplayWidth(item) / 2) * w;
                    } else if (labelAxis instanceof DateTimeAxis) {
                        x = labelAxis.getPositionOf(series.getDate(item)) * w;
                    } else {
                        x = labelAxis.getPositionOf(item.getProp(labelFld)) * w;
                    }
                    y = yOrg - valueAxis.getPositionOf(v) * h * locRate;
                } else {
                    x = valueAxis.getPositionOf(v) * w * locRate;
                    if (labelAxis.getCategoryPosition) {
                        y = (labelAxis.getDisplayPosition(item) + labelAxis.getDisplayWidth(item) / 2) * h;
                        y += r.y;
                    } else {
                        y = labelAxis.getPositionOf(item.getProp(labelFld)) * h;
                        y = r.bottom() - y;
                    }
                }
                itemView.setDataPoint(x, y);
                itemView.setBounds(x - markerWidth / 2, y - markerHeight / 2, markerWidth * sizeRate, markerHeight * sizeRate);
            }
        }
    },
    drawLegend: function (view, g, r) {
        var model = view.model(),
            styles = model.styles(),
            line = styles.line(),
            shapeType = styles.shapeName(),// || "ellipse",
            shape = ShapeDrawing.getShape(this, shapeType);
        g.drawHLineI(line, r.y + (r.height / 2), r.x, r.right());
        r.x += (r.width - 7) / 2;
        r.width = 7;
        r.y += (r.height - 7) / 2;
        r.height = 7;
        shape && shape.draw(g, r, styles.shapeColor(), styles.shapeBorder(), styles.shapeRotate());
        return true;
    }
});
var LineSeriesItemRenderer = defineClass("LineSeriesItemRenderer", ChartSeriesItemRenderer, {
    init: function (config) {
        this._super(config);
        this._ellipse = null;
        this._polygon = null;
    },
    _doRender: function(view, g, r) {
        var model, styles, shape, ishape, sz;
        if (view.visible() && (model = view.model()).visible()) {
            styles = model.styles();
            shape = ShapeDrawing.getShape(this, styles.shapeName());
            if (shape) {
                shape.draw(g, r, styles.shapeColor(), styles.shapeBorder(), styles.shapeRotate());
                ishape = ShapeDrawing.getShape(this, styles.shapeInnerName());
                if (ishape) {
                    sz = (1 - styles.shapeInnerSize()) / 2;
                    r.inflate(-r.width * sz, -r.height * sz);
                    shape.draw(g, r, styles.shapeInnerColor(), null, styles.shapeInnerRotate());
                }
            }
        }
    }
});
var AreaSeriesRenderer = defineClass("AreaSeriesRenderer", LineSeriesRenderer, {
    init: function (config) {
        this._super(config);
    },
    _doRender: function(view, g, r) {
        var series, group, styles,
            pts, pts2, i, j, gindex, view2, cnt2, series2, styles2, fill, stroke, p1, p2,
            chartView = view.chartView(),
            cnt = view.itemCount();
        if (cnt > 1) {
            series = view.model();
            group = series.group();
            styles = series.styles();
            i = j = 0;
            while (i < cnt) {
                for (; i < cnt; i++) {
                    itemView = view.getItem(i);
                    if (itemView.visible()) {
                        break;
                    }
                }
                pts = [];
                for (; i < cnt; i++) {
                    itemView = view.getItem(i);
                    if (!itemView.visible()) {
                        break;
                    }
                    pts.push({
                        x: itemView._dataPoint.x,
                        y: itemView._dataPoint.y
                    });
                }
                pts2 = null;
                styles2 = null;
                gindex = series.groupIndex();
                if (group && group.stackMode() != ChartStackMode.NONE && gindex > 0) {
                    series2 = group.getItem(gindex - 1);
                    view2 = chartView.getSeriesView(series2);
                    styles2 = view2.$_styles;
                    cnt2 = view2.itemCount();
                    for (; j < cnt2; j++) {
                        itemView = view2.getItem(j);
                        if (itemView.visible())
                            break;
                    }
                    pts2 = [];
                    for (; j < cnt2; j++) {
                        itemView = view2.getItem(j);
                        if (!itemView.visible())
                            break;
                        pts2.push({
                            x: itemView._dataPoint.x,
                            y: itemView._dataPoint.y
                        });
                    }
                }
                fill = styles.background();
                stroke = styles.line();
                if (pts2 && pts2.length > 0) {
                    if (series2.lineType() === ChartLineType.CURVED) {
                        if (fill) {
                            if (series2.lineType() === ChartLineType.CURVED) {
                                g.drawCurvedRange(fill, null, pts, pts2);
                            } else {
                                g.drawCurvedStraightRange(fill, null, pts, pts2);
                            }
                        }
                        if (stroke) {
                            g.drawCurve(stroke, pts);
                        }
                    } else {
                        if (fill) {
                            if (series2.lineType() === ChartLineType.CURVED) {
                                g.drawStraightCurvedRange(fill, null, pts, pts2);
                            } else {
                                g.drawRange(fill, null, pts, pts2);
                            }
                        }
                        if (stroke) {
                            g.drawLines(stroke, pts);
                        }
                    }
                } else if (pts && pts.length > 0) {
                    p1 = { x:pts[0].x, y:r.bottom() };
                    p2 = { x:pts[pts.length - 1].x, y:r.bottom() };
                    if (series.lineType() === ChartLineType.CURVED) {
                        if (fill) {
                            g.drawCurvedRange(fill, null, pts, [p1, p2]);
                        }
                        if (stroke) {
                            g.drawCurve(stroke, pts);
                        }
                    } else {
                        if (fill) {
                            pts.unshift(p1);
                            pts.push(p2);
                            g.drawPolygon(fill, null, pts);
                            pts.shift();
                            pts.pop();
                        }
                        if (stroke) {
                            g.drawLines(stroke, pts);
                        }
                    }
                };
            }
        }
    },
    _doRenderText: function(view, g, r) {
    },
});
var PieSeriesRenderer = defineClass("PieSeriesRenderer", ChartSeriesRenderer, {
    init: function (config) {
        this._super(config);
    },
    _checkAxes: function (view) {
        var series = view.model();
        return series && series.xAxisObj();// && series.yAxisObj();
    },
    _doRender: function(view, g, bounds) {
        if (this.animating(view)) {
            return;
        }
        var cnt, cx, i, itemView, item, labelOffset, stroke, p1, p2, p3,
            series = view.model(),
            label = series.label(),
            tickLen = series.tickLength();
        if (!label.visible()) return;
        if ((cnt = view.itemCount()) > 0) {
            cx = bounds.x + bounds.width / 2;
            for (i = 0; i < cnt; i++) {
                itemView = view.getItem(i);
                item = itemView.model();
                labelOffset = series.labelOffset();
                stroke = SolidPen.GRAY;// labelStyles.line();
                if (stroke) {
                    if (labelOffset >= 0) {
                        p1 = itemView._dataPoint;
                        p2 = itemView._dataPoint2;
                        p3 = itemView._dataPoint3;
                        g.drawQuadratic(stroke, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                    } else {
                    }
                }
            }
        }
    },
    _doRenderItemSeparators: function (view, g, bounds) {
        /*
        if (this.animating(view))
            return;
        var series = view.model();
        var itemView, item;
        var i;
        var cnt = view.itemCount();
        var styles = series.styles().findSub("separator");
        var stroke = styles.line();
        if (stroke) {
            var w = Math.min(bounds.width, bounds.height) * series.radius();
            var rd = w / 2;
            var cx = bounds.x + (bounds.width - w) / 2 + rd;
            var cy = bounds.y + (bounds.height - w) / 2 + rd;
            for (i = 0; i < cnt; i++) {
                itemView = view.getItem(i);
                item = itemView.model();
                if (item.separator) {
                    var p = Graphics.getArcPoint(cx, cy, rd, rd, item.startAngle, item.angle, 0, true, 1);
                    g.drawLine(stroke, cx, cy, p.x, p.y);
                }
            }
        }
        */
    },
    _doLayoutLabels: function (view, textViews, bounds) {
        var i, item, itemView, textView, sz, s, p1, p2, x, cx2, cy2, sliced, rd2, slicedOffset, labelOffset,
            leftCount, rightCount, leftLabels, rightLabels,
            series = view.model(),
            label = series.label(),
            axis = series.xAxisObj(),
            labelFld = series.labelField(),
            valueFld = series.valueField(),
            sliceFld = series.slicedField(),
            startAngle = series.startAngleRad(),
            styles = series.styles(),
            w = Math.min(bounds.width, bounds.height) * series.radius() * series.radiusRate(),
            rd = w / 2,
            cx = bounds.x + (bounds.width - w) / 2 + bounds.width / 2 * series.offsetX() + rd,
            cy = bounds.y + (bounds.height - w) / 2 + bounds.height / 2 * series.offsetY() + rd,
            cnt = view.itemCount(),
            tickLen = series.tickLength();
        if (!label.visible()) return;
        for (i = 0; i < cnt; i++) {
            itemView = view.getItem(i);
            item = itemView.model();
            textView = textViews[i];
            sliced = item.getProp(sliceFld, false);
            /*
            styles = series.styles().findSub("label");
            itemStyles = series.getItemSubStyles(item, "label");
            itemCases = series.getItemCases(item);
            */
            textView.setStyles(item.labelStyles());
            textView.setVisible(item != null);// &&  textView.$_styles.visible());
            slicedOffset = series.slicedOffset();
            labelOffset = series.labelOffset();
            font = textView._font,
            rd2 = (w + labelOffset * 2) / 2; /// w,// * (Math.min(bounds.width, bounds.height) / 2),
            s = item.getProp(labelFld, null) || (axis ? axis.getCategory(i) : null);
            if (s) {
                s += ", ";
            }
            s += item.getProp(valueFld);
            textView.setLabel(itemView, s);
            sz = textView.measure(0, 0);
            cx2 = cx;
            cy2 = cy;
            if (sliced) {
                p1 = Graphics.getArcPoint(cx, cy, slicedOffset, slicedOffset, item.startAngle, item.angle, startAngle, true);
                cx2 = p1.x;
                cy2 = p1.y;
            }
            p1 = Graphics.getArcPoint(cx2, cy2, rd, rd, item.startAngle, item.angle, startAngle, true);
            p2 = Graphics.getArcPoint(cx2, cy2, rd2, rd2, item.startAngle, item.angle, startAngle, true);
            itemView.setDataPoint(p1.x, p1.y, p2.x, p2.y);
            x = p2.x;
            if (labelOffset > 0) {
                if (p2.x >= cx) {
                    x += tickLen;
                    itemView._x1 = x;
                } else {
                    x -= tickLen;
                    itemView._x1 = x;
                    x -= sz.width;
                }
            } else {
                if (p2.x >= cx) {
                    itemView._x1 = x;
                } else {
                    itemView._x1 = x;
                    x -= sz.width;
                }
            }
            textView.setBoundsI(x, p2.y - sz.height / 2, sz.width, sz.height);
        }
        leftCount = 0;
        rightCount = 0;
        leftLabels = [];
        rightLabels = [];
        for (i = 0; i < cnt; i++) {
            textView = textViews[i];
            itemView = textView.itemView();
            if (itemView._dataPoint2.x <= cx) {
                leftLabels.push(textView);
                leftCount++;
            } else {
                rightLabels.push(textView);
                rightCount++;
            }
        }
        if (leftCount > 0) {
            leftCount > 1&& leftLabels.sort(this.sortLabels);
            PieSeriesLabelArranger.Default.arrange(view, bounds, leftLabels, leftCount, rd2);
        }
        if (rightCount > 0) {
            rightCount > 1 && rightLabels.sort(this.sortLabels);
            PieSeriesLabelArranger.Default.arrange(view, bounds, rightLabels, rightCount, rd2);
        }
    },
    sortLabels: function (view1, view2) {
        return view1.y() - view2.y();
    },
    _doLayoutItems: function(view, itemViews, bounds) {
        if (!itemViews || itemViews.length < 1) {
            return;
        }
        var sliced, slicedOffset, angle, p, i, item, itemView,
            series = view.model(),
            radius = series.radius(),
            innerRadius = series.innerRadius(),
            styles = series.styles(),
            valueFld = series.valueField(),
            sliceFld = series.slicedField(),
            cnt = view.itemCount(),
            sum = 0,
            startAngle = series.startAngleRad(),
            totalAngle = series.totalAngleRad(),
            radiusRate = series.radiusRate(),//view.getInterpolation(ChartAnimationTypes.PROP_RADIUS),
            sliceRate = 1,//view.getInterpolation(ChartAnimationTypes.PROP_SLICE, NaN),
            w = Math.min(bounds.width, bounds.height) * series.radius() * radiusRate,
            x = bounds.x + (bounds.width - w) / 2 + bounds.width / 2 * series.offsetX(),
            y = bounds.y + (bounds.height - w) / 2 + bounds.height / 2 * series.offsetY(),
            axis = series.xAxisObj(),
            start = 0 * 2 * Math.PI / 360,
            prevItem = null,
            prevSliced = false;
        if (totalAngle <= 0) return;
        for (i = 0; i < cnt; i++) {
            itemView = itemViews[i];
            item = itemView.model();
            sum += Number(item.getProp(valueFld));
        }
        for (i = 0; i < cnt; i++) {
            itemView = itemViews[i];
            item = itemView.model();
            item.radius = radius;
            item.innerRadius = innerRadius;
            sliced = item.getProp(sliceFld, false);
            slicedOffset = series.slicedOffset();
            angle = series.getValue(item.getProp(valueFld)) * totalAngle / sum;
            item.startAngle = start;
            item.angle = angle;
            if (sliced) {
                if (!this.animating(view)) {
                    p = Graphics.getArcPoint(x, y, slicedOffset, slicedOffset, item.startAngle, item.angle, startAngle, true);
                    itemView.setBounds(p.x, p.y, w, w);
                } else if (!isNaN(sliceRate)) {
                    p = Graphics.getArcPoint(x, y, slicedOffset * sliceRate, slicedOffset * sliceRate, item.startAngle, item.angle, startAngle, true);
                    itemView.setBounds(p.x, p.y, w, w);
                } else {
                    itemView.setBounds(x, y, w, w);
                }
            } else {
                itemView.setBounds(x, y, w, w);
            }
            start += angle;
            if (prevItem) {
                prevItem.separator = !prevSliced && !sliced;
            }
            prevItem = item;
            prevSliced = sliced;
        }
        itemView = itemViews[0];
        item = itemView.model();
        sliced = item.getProp(sliceFld, false);
        if (prevItem) {
            prevItem.separator = !prevSliced && !sliced;
        }
    }
});
var PieSeriesItemRenderer = defineClass("PieSeriesItemRenderer", ChartSeriesItemRenderer, {
    init: function (config) {
        this._super(config);
    },
    containsPoint: function (view, x, y) {
        if (view._dom) return false;
        if (this.$_g) {
            var g = this.$_g,
                r = view.clientRect(),
                series = view.series(),
                org = series.startAngleRad(),
                model = view.model(),
                rd = r.width / 2,
                p = r.x + rd,
                startAngle = model.startAngle,
                angle = model.angle;
            if (model.innerRadius > 0) {
                var rd2 = rd * model.innerRadius;// / model.radius;
                g.drawArcSector2(SolidBrush.Null, null, p, p, rd2, rd2, rd, rd, startAngle, angle, org);
            } else {
                g.drawArcSector(SolidBrush.Null, null, p, p, rd, rd, startAngle, angle, org);
            }
            return g.containsPoint(x, y);
        }
        return false;
    },
    _doRender: function (view, g, r) {
        this.$_g = g;
        var rd, p, sizeRate, locRate, startAngle, angle, rd2,
            series = view.series(),
            model = view.model(),
            styles = model.styles(),
            org = series.startAngleRad(),
            fill = styles.background(),
            border = styles.border();
        if (fill || border) {
            rd = r.width / 2;
            p = r.x + rd;
            sizeRate = 1;// this.getInterpolation(view, ChartAnimationTypes.PROP_SIZE);
            locRate = 1;//this.getInterpolation(view, ChartAnimationTypes.PROP_LOCATION);
            startAngle = model.startAngle * locRate;
            angle = model.angle * sizeRate;
            if (model.innerRadius > 0) {
                rd2 = rd * model.innerRadius;// / model.radius;
                g.drawArcSector2(fill, border, p, p, rd2, rd2, rd, rd, startAngle, angle, org);
            } else {
                g.drawArcSector(fill, border, p, p, rd, rd, startAngle, angle, org);
            }
        }
    }
});
var CartesianSeriesLabelLayout = defineClass("CartesianSeriesLabelLayout", null, {
    init: function () {
        this._super();
        this._rect = new Rectangle();
    },
    layoutVert2: function (series, bounds, itemView, textView, text, defaultPos, defaultAlign, yFrom, yTo) {
        var sz, x, y, w, h, position, halign, valign, offsetX, offsetY,
            model = textView.$_model,
            hItem = itemView.height(),
            y1 = itemView.y(),
            y2 = y1 + hItem,
            r = this._rect;
        if (yFrom !== UNDEFINED) {
            y1 += hItem * yFrom;
            if (yTo !== UNDEFINED) {
                y2 += hItem * yTo;
            } else {
                y2 = y1;
            }
        }
        x = itemView._dataPoint.x;
        textView.setLabel(itemView, text);
        sz = textView.measure(0, 0);
        w = r.width = sz.width;// Math.max(sz.width, itemView.width());// sz.width;
        h = r.height = sz.height;
        /*
        position = styles.position();
        if (position == ChartLabelPosition.DEFAULT) {
            position = (defaultPos !== UNDEFINED) && defaultPos ? defaultPos : ChartLabelPosition.CENTER;
        }
        */
        position = model.position();
        valign = model.verticalAlign();
        halign = model.horizontalAlign();
        if (position === ChartLabelPosition.DEFAULT && defaultPos) {
            position = (defaultPos !== UNDEFINED) && defaultPos ? defaultPos : ChartLabelPosition.CENTER;
        }
        if (valign === ChartVerticalAlign.DEFAULT && defaultAlign) {
            valign = defaultAlign(position);
        }
        offsetX = model.offsetX();
        offsetY = model.offsetY();
        switch (position) {
            case ChartLabelPosition.FAR:
                y = y1;
                break;
            case ChartLabelPosition.NEAR:
                y = y2;
                break;
            case ChartLabelPosition.CENTER:
            default:
                y = y1 + itemView.height() / 2;
                break;
        }
        switch (valign) {
            case ChartVerticalAlign.TOP:
                y -= h + offsetY;
                break;
            case ChartVerticalAlign.BOTTOM:
                y += offsetY;
                break;
            default:
                y -= h / 2 + offsetY;
                break;
        }
        r.y = y;
        if (r.y < 0) {
        } else if (r.bottom() > bounds.height) {
            if (series.overflow() == ChartOverflowPolicy.JUSTIFY) {
                r.y = bounds.height - h;
            }
        }
        switch (halign) {
            case ChartHorizontalAlign.LEFT:
                x -= w + offsetX;
                break;
            case ChartHorizontalAlign.RIGHT:
                x += offsetX;
                break;
            default:
                x -= w / 2 + offsetX;
                break;
        }
        r.x = x;
        r.x += bounds.x;
        r.y += bounds.y;
        return r;
    },
    layoutHorz2: function (series, bounds, itemView, textView, text, defaultPos, defaultAlign, reversed) {
        var sz, x, y, x1, x2, w, h, position, halign, valign, offsetX, offsetY,
            model = textView.$_model,
            wItem = itemView.width(),
            r = this._rect,
            styles = textView.$_styles;
        if (reversed) {
            x1 = itemView.x() + wItem;
            x2 = itemView.x();
        } else {
            x1 = itemView.x();
            x2 = itemView.x() + wItem;
        }
        y = itemView._dataPoint.y;
        textView.setLabel(itemView, text);
        sz = textView.measure(10000, 10000);
        w = r.width = sz.width;
        h = r.height = sz.height;
        position = model.position();
        valign = model.verticalAlign();
        halign = model.horizontalAlign();
        if (position == ChartLabelPosition.DEFAULT) {
            position = (defaultPos !== UNDEFINED) && defaultPos ? defaultPos : ChartLabelPosition.CENTER;
        }
        if (halign === ChartHorizontalAlign.DEFAULT && defaultAlign) {
            halign = defaultAlign(position);
        }
        offsetX = model.offsetX() * (reversed ? -1 : 1);
        offsetY = model.offsetY();
        switch (position) {
            case ChartLabelPosition.FAR:
                x = x2;
                break;
            case ChartLabelPosition.NEAR:
                x = x1;
                break;
            case ChartLabelPosition.CENTER:
            default:
                x = Math.min(x1, x2) + wItem / 2;
                break;
        }
        switch (halign) {
            case ChartHorizontalAlign.RIGHT:
                x += offsetX;
                break;
            case ChartHorizontalAlign.LEFT:
                x -= w + offsetX;
                break;
            default:
                x -= w / 2 + offsetX;
                break;
        }
        r.x = x;
        if (r.x < 0) {
            if (series.overflow() == ChartOverflowPolicy.JUSTIFY) {
                r.x = Math.max(0, x1);
            }
        } else if (r.right() > bounds.width) {
        }
        switch (valign) {
            case ChartVerticalAlign.TOP:
                y -= h + offsetY;
                break;
            case ChartVerticalAlign.BOTTOM:
                y += offsetY;
                break;
            default:
                y -= h / 2 + offsetY;
                break;
        }
        r.y = y;
        r.x += bounds.x;
        r.y += bounds.y;
        return r;
    }
}, null, function (f) {
    f.Default = new f();
});
var PieSeriesLabelArranger = defineClass("PieSeriesLabelArranger", null, {
    init: function (config) {
        this._super(config);
    },
    arrange: function (seriesView, bounds, labelViews, count, rd, lowered) {
        if (count <= 0) return;
        var i, y, h,
            cx = bounds.x + bounds.width / 2,
            cy = bounds.y + bounds.height / 2,
            tickLen = seriesView.model().tickLength(),
            gap = 2,
            tview = labelViews[0],
            xPrev = tview.x() + tview.width(),
            yPrev = tview.y() + tview.height() + gap;
        for (i = 1; i < count; i++) {
            tview = labelViews[i];
            y = tview.y();
            if (y < yPrev) {
                var ty = cy - (yPrev + tview.height() / 2);
                var a = Math.asin(Math.max(-1, Math.min(1, ty / rd)));
                var tx = Math.cos(a) * rd;
                var dy = yPrev - y;
                tview.setY(tview.y() + dy);
                if (tview.x() < cx) {
                    tview.setX(cx - tx - tview.width() - tickLen);
                } else {
                    tview.setX(cx + tx + tickLen);
                }
            }
            yPrev = tview.y() + tview.height() + gap;
            xPrev = tview.x() + tview.width();
        }
        for(i = 0; i < count; i++) {
            tview = labelViews[i];
            var iv = tview.itemView();
            iv._dataPoint3.y = tview.y() + tview.height() / 2;
            lowered && (iv._dataPoint2.y = iv._dataPoint3.y);
            if (tview.x() < cx) {
                iv._dataPoint3.x = tview.x() + tview.width() + 2;
                lowered && (iv._dataPoint2.x = iv._dataPoint3.x + tickLen);
            } else {
                iv._dataPoint3.x = tview.x() - 2;
                lowered && (iv._dataPoint2.x = iv._dataPoint3.x - tickLen);
            }
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var ChartLegendItemRenderer = defineClass("ChartLegendItemRenderer", ChartObjectRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function(view, hintWidth, hintHeight) {
        var model = view.model(),
            styles = model.styles(),
            source = model.source(),
            font = styles.font(),
            s = source.displayName(),
            w = view.container().measureText(font, s) + 2;
        return {
            width: w,
            height: font.size + 1
        };
    },
    render: function(view, g, r) {
        var tr = new Rectangle(r.x, r.y, r.width, r.height),
            model = view.model(),
            styles = model.styles(),
            source = model.source(),
            s = source.displayName(),
            font = styles.font(),
            fill = styles.background();
        if (fill) {
            g.drawRectI(fill, null, tr);
        }
        fill = styles.color();
        if (fill) {
            g.drawText(font, fill, s, tr.x, tr.y + tr.height / 2, TextAlign.LEFT, TextLayout.MIDDLE);
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var ChartLegendMarkerRenderer = defineClass("ChartLegendMarkerRenderer", ChartObjectRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function (view, hintWidth, hintHeight) {
        var model = view.model();
        var size = this._doMeasureSource(model.source(), hintWidth, hintHeight);
        return size;
    },
    render: function (view, g, bounds) {
        var r,
            model = view.model(),
            styles = model.styles(),
            border = styles.border(),
            fill = styles.background();
        if (border || fill) {
            g.drawRectI(fill, border, bounds);
        }
        r = bounds.clone();
        this._doDrawSource(model.source(), g, r);
    },
    _doMeasureSource: function (model, hintWidth, hintHeight) {
        return { width: hintWidth, height: hintHeight };
    },
    _doDrawSource: function (model, g, r) {
        var styles, fill, border,
            view = model.$_view;
        if (view && !view.renderer().drawLegend(view, g, r)){
            styles = model.styles();
            fill = model.getLegendColor();////styles.background();
            border = null;// styles.border();
            if (fill || border) {
                g.drawRectI(fill, border, r);
            }
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var ChartLegendRenderer = defineClass("ChartLegendRenderer", ChartObjectRenderer, {
    init: function (config) {
        this._super(config);
    },
    measure: function(view, hintWidth, hintHeight, itemBounds) {
    },
    render: function(view, g, r) {
        var w,
            model = view.model(),
            styles = model.styles(),
            fill = styles.background(),
            border = styles.border();
        if (fill || border) {
            if (border) {
                w = border.width();
                r.x += _int(w / 2);
                r.y += _int(w / 2);
                r.width -= _int(w / 2) + _int((w + 1) / 2);
                r.height -= _int(w / 2) + _int((w + 1) / 2);
            }
            g.drawRectI(fill, border, r);
            /*
            r = r.clone();
            styles.deflateMargin(r);
            g.drawRoundRectI(fill.shadowed(), border, r,
                styles.borderRadiusTopLeft(), styles.borderRadiusTopRight(),
                styles.borderRadiusBottomLeft(), styles.borderRadiusBottomRight());
            */
        }
    }
}, null, function (f) {
    f.Default = new f();
});
var GroupChartItem = defineClass("GroupChartItem", CustomGroupItem, {
    init: function (owner, config) {
        this._super(owner, config);
    },
    async: false,
    chart: null,
    setChart: function (value) {
        if (value !== this._chart) {
            this._chart = value;
            this._changed();
        }
    },
    $_type: function () { return 'chart'; },
    createRow: function (model) {
        return new GroupChartRow(model);
    },
    createRowView: function (dom) {
        return new GroupChartRowElement(dom);
    }
});
var GroupChartRow = defineClass("GroupChartRow", CustomGroupItemRow, {
    init: function (model) {
        this._super(model);
        this._chart = model.chart();
    }
});
var GroupChartRowElement = defineClass("GroupChartRowElement", GroupRowElement, {
    init: function (dom, name) {
        this._super(dom, name || "groupChartRowView");
    },
    _doUpdateElement: function (styles) {
        this._super(styles);
        var config = this.item().model().chart();
        if (config) {
            if (!this._chartView) {
                this._chartView = new GridChartView(this._dom, this.container());
                this.addChild(this._chartView);
            }
            if (!this._chart) {
                this._chart = new GridChart(this.grid()).loadChart(config);
                this._chartView.setModel(this._chart);
            }
            this._chart.setItemSource(this.item().parent());
            this._styles = styles;
        } else if (this._chartView) {
            this.removeChild(this._chartView);
            this._chartView = null;
            this._chart = null;
        }
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return { width: hintWidth, height: this.item().model().minHeight() };
    },
    _doLayoutContent: function (lm) {
        if (this._chartView) {
            var r = this.getClientRect(this._drawRect);
            this._styles.deflatePaddings(r);
            this._chartView.setRectI(this._drawRect);
            this._chartView.layoutContent(lm);
        }
        this._styles = null;
    }
});
var GridChartItem = defineClass("GridChartItem", CustomGridItem, {
    init: function (owner, config) {
        this._super(owner, config);
    },
    async: false,
    chart: null,
    setChart: function (value) {
        if (value !== this._chart) {
            this._chart = value;
            this._changed();
        }
    },
    $_type: function () {
        return "chart";
    },
    createItemView: function (dom) {
        return new GridChartItemElement(dom);
    }
});
var GridChartItemElement = defineClass("GridChartItemElement", CustomGridItemElement, {
    init: function (owner, item) {
        this._super(owner, "gridChartItemView", item);
    },
    _doLayoutItem: function (lm, r) {
        this.$_prepareChart();
        this.$_layoutChart(lm, r);
    },
    _doRender: function(g, r) {
         var r = this._drawRect,
             st = this._model.styles();
         g.drawRectI(st.background(), null, r);
         GridElement.drawStyledBorders(g, r, st);
    },
    _doRenderHtml: function (r) {
        var css = this._css,
            r = this._drawRect,
            st = this._model.styles();
        this.getClientRect(r);
        css.background = st.background().css();
        GridElement.drawStyledHtmlBorders(css, st);
    },
    $_prepareChart: function () {
        var grid = this.grid(),
            model = this.model(),
            config = model.chart();
        if (config) {
            if (!this._chartView) {
                this._chartView = new GridChartView(this._dom, this.container());
                this.addChild(this._chartView);
            }
            if (!this._chart) {
                this._chart = new GridChart(grid).loadChart(config);
                this._chartView.setModel(this._chart);
            }
            this._chart.setItemSource(grid);
            this._styles = model.styles();
        } else if (this._chartView) {
            this.removeChild(this._chartView);
            this._chartView = null;
            this._chart = null;
        }
    },
    $_layoutChart: function (lm, r) {
        if (this._chartView) {
            this._styles.deflatePaddings(r);
            this._chartView.setRectI(this._drawRect);
            this._chartView.layoutContent(lm);
        }
        this._styles = null;
    }
});
var ColumnArrayItem = function (column) {
    this.column = column;
    this.dataColumn = _cast(column, DataColumn);
    this.colIndex = 0;
    this.colSpan = 0;
    this.rowIndex = 0;
    this.rowSpan = 0;
    this.width = 0;
    this.tag = undefined;
    this.data = undefined;
};
var ExcelIndex = defineClass('ExcelIndex', CellIndex, {
    init: function (rowIndex, column) {
        this._super(rowIndex, column);
    },
    getRow: function (grid) {
        return this.$_row;// || this._super(grid);
    }
}, {
    tempExcel: function (row, column) {
        var t = ExcelIndex.$_xlstemp;
        t.$_row = row;
        t.rowIndex = row.index();
        t.column = column;
        return t;
    }
}, function (f) {
    f.$_xlstemp = new f();
});
/** @internal */
var ColumnArray = defineClass("ColumnArray", null, {
    init: function (grid, linearize) {
        this._super();
        this._grid = grid;
        this._headerRows = [];
        this._dataRows = [];
        this._footerRows = [];
        this._groupFooterRows = [];
        this._summaryRows = [];
        this.$_parse(grid, linearize);
    },
    grid: function () {
        return this._grid;
    },
    colCount: function () {
        return this._headerRows.length && this._headerRows[0].length;
    },
    headerRowCount: function () {
        return this._headerRows.length;
    },
    dataRowCount: function () {
        return this._dataRows.length;
    },
    footerRowCount: function () {
        return this._footerRows.length;
    },
    groupFooterRowCount: function () {
        return this._groupFooterRows.length;
    },
    summaryRowCount: function () {
        return this._summaryRows.length;
    },
    getHeader: function (row, col)/*ColumnArrayItem*/ {
        return this._headerRows[row][col];
    },
    getItem: function (row, col) {
        return this._dataRows[row][col];
    },
    setItem: function (row, col, item) {
        this._dataRows[row][col] = item;
    },
    getFooter: function (row, col) {
        return this._footerRows[row][col];
    },
    getGroupFooter: function (row, col) {
        return this._groupFooterRows[row][col];
    },
    getSummary: function (row, col) {
        return this._summaryRows[row][col];
    },
    $_parse: function (grid, linearize) {
        var i, col,
            headerLevels = 1,
            dataLevels = 1,
            footerLevels = 1,
            groupFooterLevels = 1,
            summaryLevels = 1,
            cnt = grid.visibleColumnCount();
        if (!linearize) {
            for (i = 0; i < cnt; i++) {
                col = grid.getVisibleColumn(i);
                if (col instanceof ColumnGroup) {
                    headerLevels = Math.max(headerLevels, col.calcHeaderLevels(true));
                    dataLevels = Math.max(dataLevels, col.calcDataLevels(true));
                    footerLevels = Math.max(footerLevels, col.calcFooterLevels(true));
                    groupFooterLevels = Math.max(groupFooterLevels, col.calcGroupFooterLevels(true));
                    summaryLevels = Math.max(summaryLevels, col.calcHeaderSummaryLevels(true));
                }
            }
        }
        try {
            for (i = 0; i < headerLevels; i++) {
                this._headerRows.push([]);
            }
            for (i = 0; i < dataLevels; i++) {
                this._dataRows.push([]);
            }
            for (i = 0; i < footerLevels; i++) {
                this._footerRows.push([]);
            }
            for (i = 0; i < groupFooterLevels; i++) {
                this._groupFooterRows.push([]);
            }
            for (i = 0; i < summaryLevels; i++) {
                this._summaryRows.push([]);
            }
            this.$_parseRows(grid, "h", this._headerRows, linearize);
            this.$_parseRows(grid, "d", this._dataRows, linearize);
            this.$_parseRows(grid, "f", this._footerRows, linearize);
            this.$_parseRows(grid, "g", this._groupFooterRows, linearize);
            this.$_parseRows(grid, "s", this._summaryRows, linearize);
        } finally {
            if (!linearize) {
                grid.$_calcGroupLevels();
            }
        }
    },
    $_parseRows: function (grid, region, rows, linearize) {
        var i, col, h, w, x, y, spans, column,
            cnt = grid.visibleColumnCount();
        if (cnt < 1) return;
        h = rows.length;
        w = 0;
        x = 0;
        y = 0;
        spans = null;
        column = grid.getVisibleColumn(0).parent();
        switch (region) {
            case "f":
                spans = column.$_footerSpanned ? column.$_footerSpans : null;
                break;
            case "g":
                spans = column.$_groupFooterSpanned ? column.$_groupFooterSpans : null;
                break;
            case "s":
                spans = column.$_summarySpanned ? column.$_summarySpans : null;
                break;
        }
        if (spans && !linearize) {
            i = 0;
            while (i < cnt) {
                column = spans[i++];
                w = column instanceof ColumnGroup ? column.calcHorz() : 1;
                for (; i < cnt; i++) {
                    col = spans[i];
                    if (col !== column) break;
                    w += col instanceof ColumnGroup ? col.calcHorz() : 1;
                }
                if (column instanceof ColumnGroup) {
                    switch (region) {
                        case "h":
                            this.$_addHeaderGroup(x, y, w, h, column, rows);
                            break;
                        case "f":
                            this.$_addFooterGroup(x, y, w, h, column, rows);
                            break;
                        case "g":
                            this.$_addGroupFooterGroup(x, y, w, h, column, rows);
                            break;
                        case "s":
                            this.$_addSummaryGroup(x, y, w, h, column, rows);
                            break;
                        default:
                            this.$_addDataGroup(x, y, w, h, column, rows);
                            break;
                    }
                } else {
                    this.$_addColumn(x, y, w, h, column, rows);
                }
                x += w;
            }
        } else {
            for (i = 0; i < cnt; i++) {
                column = grid.getVisibleColumn(i);
                if (column instanceof ColumnGroup) {
                    if (linearize) {
                        var columns = column.getLeafColumns(true);
                        w = columns.length;
                        for (var c = 0; c < w; c++) {
                            this.$_addColumn(x + c, y, 1, 1, columns[c], rows);
                        }
                    } else {
                        w = column.calcHorz();
                        switch (region) {
                            case "h":
                                this.$_addHeaderGroup(x, y, w, h, column, rows);
                                break;
                            case "f":
                                this.$_addFooterGroup(x, y, w, h, column, rows);
                                break;
                            case "g":
                                this.$_addGroupFooterGroup(x, y, w, h, column, rows);
                                break;
                            case "s":
                                this.$_addSummaryGroup(x, y, w, h, column, rows);
                                break;
                            default:
                                this.$_addDataGroup(x, y, w, h, column, rows);
                                break;
                        }
                    }
                } else {
                    w = 1;
                    this.$_addColumn(x, y, w, h, column, rows);
                }
                x += w;
            }
        }
    },
    $_addColumn: function (x, y, w, h, column, rows) {
        var r, c, item/*ColumnArrayItem*/;
        for (r = 0; r < h; r++) {
            for (c = 0; c < w; c++) {
                item = new ColumnArrayItem(column);
                item.colIndex = c;
                item.colSpan = w;
                item.rowIndex = r;
                item.rowSpan = h;
                rows[y + r][x + c] = item;
            }
        }
    },
    $_addHeaderGroup: function (x, y, w, h, group, rows) {
        var i, column, hh, ww,
            cnt = group.visibleCount(),
            delegate = group.$_headerColumn;
        if (delegate) {
            if (delegate instanceof ColumnGroup) {
                this.$_addHeaderGroup(x, y, w, h, group.$_headerColumn, rows);
            } else {
                this.$_addColumn(x, y, w, h, group.$_headerColumn, rows);
            }
        } else if (group.childHeadersVisible()) {
            if (group.header().visible()) {
                this.$_addColumn(x, y, w, 1, group.header(), rows);
                y++;
                h--;
            }
            if (group.vertical()) {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    if (column instanceof ColumnGroup) {
                        if (i < cnt - 1) {
                            hh = column.calcHeaderLevels();
                        } else {
                            hh = h;
                        }
                        this.$_addHeaderGroup(x, y, w, hh, column, rows);
                        y += hh;
                        h -= hh;
                    } else if (i < cnt - 1) {
                        this.$_addColumn(x, y, w, 1, column, rows);
                        y++;
                        h--;
                    } else {
                        this.$_addColumn(x, y, w, h, column, rows);
                    }
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    if (column instanceof ColumnGroup) {
                        if (i < cnt - 1) {
                            ww = column.calcHorz();
                        } else {
                            ww = w;
                        }
                        this.$_addHeaderGroup(x, y, ww, h, column, rows);
                        x += ww;
                        w -= ww;
                    } else if (i < cnt - 1) {
                        this.$_addColumn(x, y, 1, h, column, rows);
                        x++;
                        w--;
                    } else {
                        this.$_addColumn(x, y, w, h, column, rows);
                    }
                }
            }
        } else if (h > 0) {
            this.$_addColumn(x, y, w, h, group, rows);
        }
    },
    $_addDataGroup: function (x, y, w, h, group, rows) {
        var i, column, hh, ww,
            cnt = group.visibleCount();
        if (cnt < 1) {
            this.$_addColumn(x, y, w, h, group, rows);
            return;
        }
        if (group.vertical()) {
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                if (column instanceof ColumnGroup) {
                    if (i < cnt - 1) {
                        hh = column.calcDataLevels();
                    } else {
                        hh = h;
                    }
                    this.$_addDataGroup(x, y, w, hh, column, rows);
                    y += hh;
                    h -= hh;
                } else if (i < cnt - 1) {
                    this.$_addColumn(x, y, w, 1, column, rows);
                    y++;
                    h--;
                } else {
                    this.$_addColumn(x, y, w, h, column, rows);
                }
            }
        } else {
            for (i = 0; i < cnt; i++) {
                column = group.getVisibleItem(i);
                if (column instanceof ColumnGroup) {
                    if (i < cnt - 1) {
                        ww = column.calcHorz();
                    } else {
                        ww = w;
                    }
                    this.$_addDataGroup(x, y, ww, h, column, rows);
                    x += ww;
                    w -= ww;
                } else if (i < cnt - 1) {
                    this.$_addColumn(x, y, 1, h, column, rows);
                    x++;
                    w--;
                } else {
                    this.$_addColumn(x, y, w, h, column, rows);
                }
            }
        }
    },
    $$_addFooterGroup: function (t, x, y, w, h, group, rows) {
        var i, column, spans, col, hh, ww,
            cnt = group.visibleCount();
        if (cnt < 1) {
            this.$_addColumn(x, y, w, h, group, rows);
            return;
        }
        switch (t) {
            case 'f': column = group.$_footerColumn; break;
            case 'g': column = group.$_groupFooterColumn; break;
            case 's': column = group.$_summaryColumn; break;
        }
        if (column) {
            if (column instanceof ColumnGroup) {
                this.$_addFooterGroup(x, y, w, h, column, rows);
            } else {
                this.$_addColumn(x, y, w, h, column, rows);
            }
            return;
        }
        switch (t) {
            case 'f': i = group.childFootersVisible(); break;
            case 'g': i = group.childGroupFootersVisible(); break;
            case 's': i = group.childSummariesVisible(); break;
        }
        if (!i) {
            this.$_addColumn(x, y, w, h, group, rows);
            return;
        }
        switch (t) {
            case 'f': spans = group.$_footerSpanned ? group.$_footerSpans : null; break;
            case 'g': spans = group.$_groupFooterSpanned ? group.$_groupFooterSpans : null; break;
            case 's': spans = group.$_summarySpanned ? group.$_summarySpans : null; break;
        }
        if (group.vertical()) {
            if (spans) {
                i = 0;
                while (i < cnt) {
                    column = group.getVisibleItem(i++);
                    if (i == cnt) {
                        if (column instanceof ColumnGroup) {
                            this.$$_addFooterGroup(t, x, y, w, h, column, rows);
                        } else {
                            this.$_addColumn(x, y, w, h, column, rows);
                        }
                    } else {
                        hh = column instanceof ColumnGroup ? column.footerLevel() : 1;
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            if (i == cnt - 1) {
                                hh = h;
                            } else {
                                col = group.getVisibleItem(i);
                                hh += col instanceof ColumnGroup ? col.footerLevel() : 1;
                            }
                        }
                        if (column instanceof ColumnGroup) {
                            this.$$_addFooterGroup(t, x, y, w, hh, column, rows);
                        } else {
                            this.$_addColumn(x, y, w, hh, column, rows);
                        }
                        h -= hh;
                        y += hh;
                    }
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    if (column instanceof ColumnGroup) {
                        if (i < cnt - 1) {
                            hh = column.footerLevel();
                        } else {
                            hh = h;
                        }
                        this.$$_addFooterGroup(t, x, y, w, hh, column, rows);
                        y += hh;
                        h -= hh;
                    } else if (i < cnt - 1) {
                        this.$_addColumn(x, y, w, 1, column, rows);
                        y++;
                        h--;
                    } else {
                        this.$_addColumn(x, y, w, h, column, rows);
                    }
                }
            }
        } else {
            if (spans) {
                i = 0;
                while (i < cnt) {
                    col = group.getVisibleItem(i);
                    column = spans[i++];
                    if (i == cnt) {
                        if (column instanceof ColumnGroup) {
                            this.$$_addFooterGroup(t, x, y, w, h, column, rows);
                        } else {
                            this.$_addColumn(x, y, w, h, column, rows);
                        }
                    } else {
                        ww = col instanceof ColumnGroup ? col.calcHorz() : 1;
                        for (; i < cnt; i++) {
                            col = spans[i];
                            if (col !== column) break;
                            col = group.getVisibleItem(i);
                            if (i == cnt - 1) {
                                ww = w;
                            } else {
                                ww += col instanceof ColumnGroup ? col.calcHorz() : 1;
                            }
                        }
                        if (column instanceof ColumnGroup) {
                            this.$$_addFooterGroup(t, x, y, ww, h, column, rows);
                        } else {
                            this.$_addColumn(x, y, ww, h, column, rows);
                        }
                        w -= ww;
                        x += ww;
                    }
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    column = group.getVisibleItem(i);
                    if (column instanceof ColumnGroup) {
                        if (i < cnt - 1) {
                            ww = column.calcHorz();
                        } else {
                            ww = w;
                        }
                        this.$$_addFooterGroup(t, x, y, ww, h, column, rows);
                        x += ww;
                        w -= ww;
                    } else if (i < cnt - 1) {
                        this.$_addColumn(x, y, 1, h, column, rows);
                        x++;
                        w--;
                    } else {
                        this.$_addColumn(x, y, w, h, column, rows);
                    }
                }
            }
        }
    },
    $_addFooterGroup: function (x, y, w, h, group, rows) {
        this.$$_addFooterGroup('f', x, y, w, h, group, rows);
    },
    $_addGroupFooterGroup: function (x, y, w, h, group, rows) {
        this.$$_addFooterGroup('g', x, y, w, h, group, rows);
    },
    $_addSummaryGroup: function (x, y, w, h, group, rows) {
        this.$$_addFooterGroup('s', x, y, w, h, group, rows);
    }
});
var VIS_DEFAULT = "default";
var VIS_HIDDEN = "hidden";
var VIS_VISIBLE = "visible";
var INDICATOR_DEFAULT = "default";
var INDICATOR_ROWINDEX = "rowIndex";
var INDICATOR_DATAINDEX = "dataIndex";
var PIXELS_PER_CHAR = 7;
var GridExportOptions = defineClass("GridExportOptions", null, {
    init: function (source) {
        Base.init.call(this);
        this._datetimeWriter = null;
        this._textFormatter = null;
        source && this.assign(source);
    },
    target: "remote", 	// "remote" | "local"
    legacy: false,  // 2007: true, 2010 이후: false
    noSave: false,
    url: undefined,
    fileName: null,
    linear: false,
    allItems: true,
    rowIndicator: VIS_DEFAULT,
    header: VIS_DEFAULT,
    footer: VIS_DEFAULT,
    indicatorValue: INDICATOR_DEFAULT,
    indenting: true,
    checkNumber: false,
    datetimeFormat: undefined,
    nullDateText: "",
    datetimeCallback: null,
    numberFormat: undefined,
    numberCallback: null,
    booleanFormat: null,
    booleanCallback: null,
    textFormat: undefined,
    textCallback: null,
    objectCallback: null,
    separateRows: false,
    lookupDisplay: false,
    cachedStyle: true,
    applyDynamicStyles: false,
    styledText: false,
    async: false,
    title: undefined,
    showProgress: true,
    modal: false,
    cancelable: true,
    onStart: null,
    onFinished: null,
    onProgress: null,
    setFileName: function (value) {
        value = _trim(value);
        if (value && value.indexOf(".") < 0) {
            value = value + ".xlsx";
        }
        this._fileName = value;
    },
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
        }
    },
    setTextFormat: function (value) {
        if (value != this._textFormat) {
            this._textFormat = value;
            if (value) {
                this._textFormatter = new TextFormatter(value);
            } else {
                this._textFormatter = null;
            }
        }
    },
    isIndicatorVisible: function (grid) {
        if (grid) {
            switch (this._rowIndicator) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.rowIndicator().visible();
            }
        }
        return false;
    },
    isHeaderVisible: function (grid) {
        if (grid) {
            switch (this._header) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.header().visible();
            }
        }
        return false;
    },
    isFooterVisible: function (grid) {
        if (grid) {
            switch (this._footer) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.footer().visible();
            }
        }
        return false;
    },
    isIndicatorDataRow: function (grid) {
        if (grid) {
            switch (this._indicatorValue) {
                case INDICATOR_ROWINDEX:
                    return false;
                case INDICATOR_DATAINDEX:
                    return true;
                case INDICATOR_DEFAULT:
                default:
                    return grid.rowIndicator().displayValue() == RowIndicatorValue.DATA_INDEX;
            }
        }
        return false;
    }
});
var ExportCanceled = _createError('DataLudi.ExportCanceled', "Exporting canceled.");
var GridExcelExporter = defineClass("GridExcelExporter", null, {
    init: function () {
        this._super();
    },
    "export": function (grid, options, testing) {
        if (grid) {
            options = options instanceof GridExportOptions ? options : new GridExportOptions(options);
            var ctx = {
                grid: grid,
                book: new ExcelWorkbook(options.legacy()),
                options: options,
                indicator: options.isIndicatorVisible(grid) ? grid.rowIndicator() : null,
                header: options.isHeaderVisible(grid) ? grid.header() : null,
                summary: options.isHeaderVisible(grid) && grid.header().summary().visible() ? grid.header().summary() : null,
                footer: options.isFooterVisible(grid) ? grid.footer() : null,
                colArr: new ColumnArray(grid, options.linear()),
                numberFormatId: 0,
                dateFormatId: 14, //22, // 14 는 날짜만
                columnStyles: {},
                columnWrapStyles: {},
                allItems: null,
                indicatorHead: "No",
                indicatorFoot: "",
                rowGrouped: false,
                rowLevels: 0,
                indents: 0,
                indentWidth: 3,
                indentHeadStyle: undefined,
                indentSummaryStyle: undefined,
                indentFootStyle: undefined,
                columnMerged: false,
                mergeHeads: {}
            };
            this._runStyles = new GridStyles();
            this._seriesCell = new SeriesCell();
            this._dataCell = new DataCellElement();
            this._current = 0;
            this._canceled = false;
            this._state = 'ready';
            this._curRow = 0;
            this._curCol = 0;
            if (testing != '$$testing' && ctx.options.async()) {
                this.$_exportAsync(ctx);
                var self = this;
                return {
                    state: function () {
                        return self._state;
                    },
                    cancel: function () {
                        self.cancel();
                    }
                };
            } else {
                return this.$_export(ctx, testing);
            }
        }
    },
    $_export: function (ctx, testing) {
        var parts, data, p,
            grid = ctx.grid,
            options = ctx.options;
        if (grid instanceof TreeView) {
            if (options.allItems()) {
                ctx.allItems = grid.getAllRows();
            }
            this.$_buildTreeBook(ctx);
        } else {
            if (options.allItems() && grid.rowGrouped()) {
                ctx.allItems = grid.getAllRows();
            }
            this.$_buildBook(ctx);
        }
        parts = ctx.book.createParts();
        data = [];
        for (p in parts) {
            data.push({key: p, body: parts[p]});
        }
        return testing == '$$testing' ? data : this.$_buildZip(data, ctx);
        /*
        var t1 = getTimer();
        t = t1 - t;
        _console && _trace("E X C E L: " + "buildBook " + t);
        t = t1;
        var parts = context.book.createParts();
        t1 = getTimer();
        t = t1 - t;
        _console && _trace("E X C E L: " + "createParts " + t);
        t = t1;
        var data = [];
        for (var p in parts) {
            data.push({key: p, body: parts[p]});
        }
        this.$_export(data, options);
        t1 = getTimer();
        t = t1 - t;
        _console && _trace("E X C E L: " + "zip " + t);
        t = t1;
        */
    },
    $_asyncZip: function (ctx) {
        var p,
            parts = ctx.book.createParts(),
            data = [];
        for (p in parts) {
            data.push({key: p, body: parts[p]});
        }
        if (!this._monitor(ctx, 'createParts')) {
        }
        _setTimeout(function () {
            this.$_buildZip(data, ctx);
        }.bind(this));
    },
    $_exportAsync: function (ctx) {
        var parts, data, p,
            grid = ctx.grid,
            options = ctx.options;
        this._echo = getTimer();
        this._elapsed = 0;
        this._canceled = false;
        this._state = 'running';
        this._doStart(ctx);
        try {
            ctx.allItems = options.allItems() ? grid.getAllRows() : grid.getRows();
            if (grid instanceof TreeView) {
                this.$_buildTreeBookAsync(ctx, this.$_asyncZip);
            } else {
                this.$_buildBookAsync(ctx, this.$_asyncZip);
            }
        } catch (err) {
            this._doFinished(ctx, err);
        }
    },
    $_getCanceler: function (ctx) {
        if (ctx.options.cancelable()) {
            var self = this;
            return function () {
                self.cancel();
            };
        }
    },
    _doStart: function (ctx) {
        var grid = ctx.grid,
            options = ctx.options,
            fn = options._onStart;
        fn && fn(grid);
        options.showProgress() && grid.showProgress(_pickStr(options.title(), GridLocale._default.exporting), options.modal(), this.$_getCanceler(ctx));
    },
    _doFinished: function (ctx, error) {
        var grid = ctx.grid,
            options = ctx.options,
            fn = options._onFinished;
        this._state = error ? 'failed': 'completed';
        grid.closeProgress();
        fn && fn(grid, error, _getTimer() - this._echo);
    },
    _doProgress: function (ctx, current, elapsed, message) {
        var grid = ctx.grid,
            options = ctx.options,
            fn = options._onProgress;
        fn && fn(ctx.grid, current, elapsed, message);
        options.showProgress() && grid.setProgress(0, 100, current, message + ' in ' + elapsed.toLocaleString() + ' ms');
    },
    cancel: function () {
        if (this._canceled && this._state == 'failied' || this._state == 'completed') {
            grid.closeProgress();
        } else {
            this._canceled = true;
        }
    },
    $_throwCancel: function () {
        throw new ExportCanceled('Exporting canceled');
    },
    _monitor: function (ctx, message) {
        var e, t, s;
        if (this._canceled) {
            this.$_throwCancel();
        } else {
            e = this._elapsed;
            t = this._elapsed = _getTimer() - this._echo;
            s = '#XLS ' + message + ' at ' + t + ', ' + (t - e) + ', ' + this._current.toFixed(2);
            this._doProgress(ctx, this._current, t, message);
            return true;
        }
    },
    $_buildBook: function (ctx) {
        var grid = ctx.grid,
            book = ctx.book;
        ctx.rowGrouped = grid.rowGrouped();
        if (ctx.rowGrouped && !grid.rowGroup().mergeMode()) {
            ctx.rowLevels += grid.rowGroupLevels();
        }
        book.setCachedStyle(ctx.options.cachedStyle());
        this.$_prepareFormats(ctx);
        this.$_prepareStyles(ctx);
        this.$_buildColumns(ctx);
        ctx.header && this.$_buildHeader(ctx);
        ctx.summary && this.$_buildSummary(ctx);
        this.$_buildItems(ctx);
        ctx.footer && this.$_buildFooter(ctx);
    },
    $_buildBookAsync: function (ctx, callback) {
        var book = ctx.book,
            grid = ctx.grid,
            self = this,
            actions = [{
                label: 'prepareFormats',
                length: 1,
                func: this.$_prepareFormats,
                param1: ctx
            }, {
                label: 'prepareStyles',
                length: 1,
                func: this.$_prepareStyles,
                param1: ctx
            }, {
                label: 'buildColumns',
                length: 1,
                func: this.$_buildColumns,
                param1: ctx
            }, {
                label: 'buildHeader',
                length: 1,
                func: ctx.header ? this.$_buildHeader : null,
                param1: ctx
            }, {
                label: 'buildSummary',
                length: 1,
                func: ctx.summary ? this.$_buildSummary : null,
                param1: ctx
            }, {
                label: 'buildItems',
                length: 0,
                func: this.$_buildItemsAsync,
                param1: ctx,
                param2: 74,
                param3: callback
            }];
        function progress(index) {
            var action = actions[index];
            try {
                if (action.func) {
                    action.func.call(self, action.param1, action.param2, action.param3);
                    if (action.length > 0) {
                        self._current += action.length;
                        self._monitor(ctx, action.label);
                    }
                }
                if (index + 1 < actions.length) {
                    _setTimeout(progress, 0, index + 1);
                }
            } catch (err) {
                self._doFinished(ctx, err);
            }
        }
        ctx.rowGrouped = grid.rowGrouped();
        if (ctx.rowGrouped && !grid.rowGroup().mergeMode()) {
            ctx.rowLevels += grid.rowGroupLevels();
        }
        book.setCachedStyle(ctx.options.cachedStyle());
        progress(0);
    },
    $_buildTreeBook: function (ctx) {
        ctx.rowLevels = ctx.grid.getLevels();
        ctx.book.setCachedStyle(ctx.options.cachedStyle());
        this.$_prepareFormats(ctx);
        this.$_prepareStyles(ctx);
        this.$_buildColumns(ctx);
        ctx.header && this.$_buildTreeHeader(ctx);
        ctx.summary && this.$_buildTreeSummary(ctx);
        this.$_buildTreeItems(ctx);
        ctx.footer && this.$_buildTreeFooter(ctx);
    },
    $_buildTreeBookAsync: function (ctx, callback) {
        var book = ctx.book,
            grid = ctx.grid,
            self = this,
            actions = [{
                label: 'prepareFormats',
                length: 1,
                func: this.$_prepareFormats,
                param1: ctx
            }, {
                label: 'prepareStyles',
                length: 1,
                func: this.$_prepareStyles,
                param1: ctx
            }, {
                label: 'buildColumns',
                length: 1,
                func: this.$_buildColumns,
                param1: ctx
            }, {
                label: 'buildTreeHeader',
                length: 1,
                func: ctx.header ? this.$_buildTreeHeader : null,
                param1: ctx
            }, {
                label: 'buildTreeSummary',
                length: 1,
                func: ctx.summary ? this.$_buildTreeSummary : null,
                param1: ctx
            }, {
                label: 'buildItems',
                length: 0,
                func: this.$_buildTreeItemsAsync,
                param1: ctx,
                param2: 74,
                param3: callback
            }];
        function progress(index) {
            try {
                var action = actions[index];
                if (action.func) {
                    action.func.call(self, action.param1, action.param2, action.param3);
                    if (action.length > 0) {
                        self._current += action.length;
                        self._monitor(ctx, action.label);
                    }
                }
                if (index + 1 < actions.length) {
                    _setTimeout(progress, 0, index + 1);
                }
            } catch (err) {
                self._doFinished(ctx, err);
            }
        }
        ctx.rowLevels = ctx.grid.getLevels();
        book.setCachedStyle(ctx.options.cachedStyle());
        progress(0);
    },
    $_prepareFormats: function (ctx) {
        var f,
            options = ctx.options,
            book = ctx.book;
        f = options.numberFormat();
        if (typeof f == "number" || _int(f) > 0)  {
            ctx.numberFormatId = _int(f);
        } else if (f) {
            ctx.numberFormatId = book.addNumberFormat(f);
        }
        f = options.datetimeFormat();
        if (typeof f == "number" || _int(f) > 0)  {
            ctx.dateFormatId = _int(f);
        } else if (f) {
            ctx.dateFormatId = book.addNumberFormat(f);
        }
    },
    $_createStyles: function (book, styles, borders, fonts) {
        var fill, background, border, font, es;
        borders = arguments.length > 2 ? borders : true;
        fonts = arguments.length > 3 ? fonts : true;
        fill = new ExcelFill();
        background = styles.background() || SolidBrush.WHITE;
        if (background instanceof LinearGradient) {
            fill.gradient = "linear";
            fill.color = background._colors[0].toColorHex();
            fill.color2 = background._colors[1].toColorHex();
            fill.tint = 1 - background._colors[0]._a;
            switch (background._angle) {
                case 180:
                    fill.degree = "0";
                    break;
                case 90:
                    fill.degree = "90";
                    break;
                case 0:
                    fill.degree = "180";
                    break;
                case 270:
                    fill.degree = "270";
                    break;
            }
        } else {
            fill.patternType = "solid";
            fill.color = background._color.toColorHex();
            fill.tint = 1 - background._color._a;
        }
        fill = book.addFill(fill);
        border = null;
        if (borders) {
            border = new ExcelBorder();
            border.right = styles.borderRight();
            border.bottom = styles.borderBottom();
            border.left = styles.borderLeft();
            border.top = styles.borderTop();
            border = book.addBorder(border);
        }
        font = null;
        if (fonts) {
            font = new ExcelFont();
            font.name = styles.fontName();
            font.size = styles.fontSize() * 72 / 96;
            font.color = styles.color()._color.toColorHex();
            font.bold = styles.fontBold();
            font.italic = styles.fontItalic();
            font = book.addFont(font);
        }
        es = new ExcelStyle();
        es.fill = fill;
        border && (es.border = border);
        font && (es.font = font);
        switch (styles.textAlignment()) {
            case Alignment.CENTER:
                es.horzAlign = ExcelStyle.ALIGN_CENTER;
                break;
            case Alignment.FAR:
                es.horzAlign = ExcelStyle.ALIGN_FAR;
                break;
            default:
                es.horzAlign = ExcelStyle.ALIGN_NEAR;
                break;
        }
        switch (styles.lineAlignment()) {
            case Alignment.CENTER:
                es.vertAlign = ExcelStyle.VALIGN_CENTER;
                break;
            case Alignment.FAR:
                es.vertAlign = ExcelStyle.VALIGN_FAR;
                break;
            default:
                es.vertAlign = ExcelStyle.VALIGN_NEAR;
                break;
        }
        return es;
    },
    $_addStyle: function (book, styles, borders) {
        borders = arguments.length > 2 ? borders : true;
        var es = this.$_createStyles(book, styles, borders);
        es = book.addStyle(es);
        return es;
    },
    $_addStyleWithColumn: function (ctx, column, styles, wrapText) {
        var book = ctx.book,
            es = this.$_createStyles(book, styles);
        if (column instanceof DataColumn || column instanceof CalculatedColumn) {
            var fmt = column.excelFormat();
            switch (column.valueType()) {
                case ValueType.TEXT:
                    break;
                case ValueType.NUMBER:
                    es.formatId = fmt ? book.addNumberFormat(fmt) : ctx.numberFormatId;
                    break;
                case ValueType.DATETIME:
                    es.formatId = fmt ? book.addNumberFormat(fmt) : ctx.dateFormatId;
                    break;
            }
        }
        (wrapText !== undefined) && (es.wrapText = wrapText);
        return book.addStyle(es);
    },
    $_prepareStyles: function (ctx) {
        var r, rows, c, item, column, es, merges, rowGroup,
            colArr = ctx.colArr,
            columnMerged = false,
            cols = colArr.colCount(),
            columnStyles = ctx.columnStyles,
            wrapStyles = ctx.columnWrapStyles,
            grid = ctx.grid,
            ds = grid.dataSource(),
            options = ctx.options,
            book = ctx.book;
        for (r = 0, rows = colArr.dataRowCount(); r < rows; r++) {
            for (c = 0; c < cols; c++) {
                item = colArr.getItem(r, c);
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    column = item.column;
                    if (column && !columnStyles[column.$_hash]) {
                        es = this.$_addStyleWithColumn(ctx, column, column.styles());
                        columnStyles[column.$_hash] = es;
                        if (options.applyDynamicStyles()) {
                            es.$_dynamicStyles = column.$_hasDynamicStyles();
                        }
                        es = this.$_addStyleWithColumn(ctx, column, column.styles(), true);
                        wrapStyles[column.$_hash] = es;
                        if (!options.separateRows()) {
                            merges/*ColumnMergeManager*/ = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
                            if (merges) {
                                merges.refresh(0, grid.rowCount() - 1);
                                columnMerged = true;
                            }
                        }
                    }
                }
            }
        }
        ctx.columnMerged = columnMerged;
        if (grid instanceof GridView && grid.rowGrouped()) {
            rowGroup = grid.rowGroup();
            ctx.rowGroupHeadStyle = this.$_addStyle(book, rowGroup.headStyles());
            ctx.headerBarStyle = this.$_addStyle(book, rowGroup.headerBarStyles(), false);
            ctx.groupBarStyle = this.$_addStyle(book, rowGroup.headerStyles(), false);
            ctx.rowGroupHeaderStyle = this.$_addStyle(book, rowGroup.headerStyles(), false);
            ctx.rowGroupFooterStyles = {};
        } else if (grid instanceof TreeView) {
            ctx.rowFooterStyles = {};
        }
    },
    $_buildColumns: function (ctx) {
        var i, es, ec, item, column, cols,
            grid = ctx.grid,
            options = ctx.options,
            book = ctx.book,
            colArr = ctx.colArr,
            index = 1, // 0이면 에러다.
            columns = [];
        book.setStylePivot();
        if (ctx.indicator) {
            es = ctx.indicatorStyle = this.$_addStyle(book, ctx.indicator.styles());
            ec = new ExcelColumn();
            ec.index = index++;
            ec.width = _round(Math.max(grid.rowIndicator().minWidth(), grid.rowIndicatorView().width()) / PIXELS_PER_CHAR);
            columns.push(ec);
        }
        if (options.indenting()) {
            if (ctx.rowGrouped && !ctx.columnMerged) {
                ctx.indents = ctx.rowLevels - 1;
            } else if (grid instanceof TreeView) {
                ctx.indents = ctx.rowLevels - 1;
            }
            if (ctx.indents) {
                for (i = 0; i < ctx.indents; i++) {
                    ec = new ExcelColumn();
                    ec.width = Math.max(ctx.indentWidth, 1);
                    ec.index = index++;
                    columns.push(ec);
                }
                ctx.indentHeadStyle = this.$_addStyle(book, grid.header().styles());
                ctx.indentSummaryStyle = this.$_addStyle(book, grid.header().summary().styles());
                ctx.indentFootStyle = this.$_addStyle(book, grid.footer().styles());
            }
        }
        /*
         if (grid instanceof TreeView) {
         for (i = 0; i < ctx.treeLevels; i++) {
         es = this.$_addStyle(book, grid.header().head().styles());
         ec = new ExcelColumn();
         ec.index = index++;
         ec.width = _round(21 / PIXELS_PER_CHAR);
         columns.push(ec);
         }
         } else {
         for (i = 0; i < ctx.groupLevels; i++) {
         es = this.$_addStyle(book, grid.rowGroup().headStyles());
         ec = new ExcelColumn();
         ec.index = index++;
         ec.width = _round(20 / PIXELS_PER_CHAR);
         columns.push(ec);
         }
         }
         */
        cols = colArr.colCount();
        for (i = 0; i < cols; i++) {
            item = colArr.getItem(0, i);
            column = item.column;
            /*
            es = ctx.columnStyles[column.$_hash];
            if (!es) {
                es = this.$_addStyle(book, column.styles());
            }
            */
            ec = new ExcelColumn();
            ec.index = index++;
            ec.width = _round(column.displayWidth() / PIXELS_PER_CHAR);
            columns.push(ec);
        }
        ctx.book.sheet().setColumns(columns);
    },
    $_buildHeader: function (ctx) {
        var i, es, row, c, s, item, column, col, h,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            rows = colArr.headerRowCount(),
            indents = ctx.indents;
        book.setStylePivot();
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.header().head().styles());
            sheet.addText(startRow, startCol, ctx.indicatorHead, es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentHeadStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            for (c = 0; c < cols; c++) {
                item = colArr.getHeader(i, c);
                column = item.column;
                col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    h = column instanceof ColumnHeader ? column : column.header();
                    es = this.$_addStyle(book, h.styles());
                    s = h.displayText();
                    es = this.$_checkTextEs(s, es);
                    sheet.addText(row, col, s, es);
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        this._curRow += rows;
        return rows;
    },
    $_buildSummary: function (ctx) {
        var i, es, c, row, item, column, col, h, cell, v,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            rows = colArr.summaryRowCount(),
            indents = ctx.indents;
        book.setStylePivot();
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.header().summary().head().styles());
            sheet.addText(startRow, startCol, grid.header().summary().head().text(), es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentSummaryStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            for (c = 0; c < cols; c++) {
                item = colArr.getSummary(i, c);
                column = item.column;
                col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    h = column.header().summary();
                    cell = grid.header().summary().getCell(new CellIndex(null, column));
                    v = cell.value();
                    es = this.$_addStyle(book, h.styles());
                    if (!isNaN(v)) {
                        sheet.addNumber(row, col, v, es);
                    } else {
                        sheet.addText(row, col, cell.displayText() || "", es);
                    }
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        if (ctx.rowGrouped) {
            sheet.setRowLevel(row, 1);
        }
        this._curRow += rows;
        return rows;
    },
    $_buildFooter: function (ctx) {
        var i, es, c, row, item, column, col, h, cell, v,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            rows = colArr.footerRowCount(),
            indents = ctx.indents;
        book.setStylePivot();
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.footer().head().styles());
            sheet.addText(startRow, startCol, grid.footer().head().text(), es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentFootStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            for (c = 0; c < cols; c++) {
                item = colArr.getFooter(i, c);
                column = item.column;
                col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    h = column.footer();
                    cell = grid.footer().getCell(new CellIndex(null, column));
                    v = cell.value();
                    es = this.$_addStyle(book, h.styles());
                    if (!isNaN(v)) {
                        sheet.addNumber(row, col, v, es);
                    } else {
                        v = cell.displayText() || "";
                        if ($_linereg.test(v)) {
                            es.wrapText = true;
                        }
                        sheet.addText(row, col, v, es);
                    }
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        if (ctx.rowGrouped) {
            sheet.setRowLevel(row, 1);
        }
        this._curRow += rows;
        return rows;
    },
    $_buildIndicatorCell: function (ctx, no, startRow, startCol, rows) {
        var i,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            es = this.$_addStyle(book, grid.rowIndicator().styles());
        sheet.addNumber(startRow, startCol, no, es);
        if (rows > 1) {
            for (i = 1; i < rows; i++) {
                sheet.addBlank(startRow + i, startCol, es);
            }
            sheet.addMerge(startRow, startCol, rows, 1);
        }
        return 1;
    },
    $_checkTextEs: function (s, es, ctx, column) {
        if ($_linereg.test(s)) {
            if (es.dynamic || !column) {
                if (!es.wrapText) {
                    if (es.$_ref > 0) {
                        es = es.clone();
                        es.wrapText = true;
                        es = ctx.book.addStyle(es);
                    } else {
                        es.wrapText = true;
                    }
                }
            } else {
                es = ctx.columnWrapStyles[column.$_hash];
            }
        }
        return es;
    },
    $_addCell: function (ctx, row, col, item, column, v, sheet, options, es) {
        var v2, vt = column.valueType();
        if (vt == ValueType.OBJECT) {
            v2 = v;
            if (options._objectCallback) {
                v = options._objectCallback(item, column, v);
            }
            if (v === v2) {
                v = column._keyFn ? column._keyFn(column.$_field, v) : DataPath.extractJson(v, column._keyPath, true);
            }
                if (column instanceof DataColumn || column instanceof CalculatedColumn) {
                    var fmt = column.excelFormat();
                    if (typeof v == "number") {
                        es.formatId = fmt ? book.addNumberFormat(fmt) : ctx.numberFormatId;
                    } else if (v instanceof Date) {
                        es.formatId = fmt ? book.addNumberFormat(fmt) : ctx.dateFormatId;
                    }
                }
        } else if (vt == ValueType.TEXT && options._checkNumber) {
            v2 = Number(v);
            if (!isNaN(v2)) v = v2;
        }
        if (vt == ValueType.NUMBER || _isNumber(v)) {
            if (isNaN(v)) {
                sheet.addText(row, col, "", es);
            } else if (options._numberCallback) {
                v = options._numberCallback(item, column, v);
                if (typeof v == "number") {
                    sheet.addNumber(row, col, v, es);
                } else {
                    sheet.addText(row, col, v, es);
                }
            } else {
                sheet.addNumber(row, col, v, es);
            }
        } else if (vt == ValueType.DATETIME || _isDate(v)) {
            if (v) {
                if (options._datetimeCallback) {
                    v = options._datetimeCallback(item, column, v);
                    if (v instanceof Date) {
                        sheet.addDate(row, col, v, es);
                    } else {
                        sheet.addText(row, col, v, es);
                    }
                } else {
                    sheet.addDate(row, col, v, es);
                }
            } else if (options._nullText) {
                sheet.addText(row, col, options._nullText, es);
            } else {
                sheet.addText(row, col, "", es);
            }
        } else if (vt == ValueType.DATETIME || _isBoolean(v)) {
            if (options._booleanCallback) {
                v = options._booleanCallback(item, column, v);
                if (typeof v == "boolean") {
                    sheet.addBool(row, col, v, es);
                } else {
                    sheet.addText(row, col, v, es);
                }
            } else if (options._booleanFormatter) {
                v = options._booleanFormatter.formatValue(v);
                sheet.addText(row, col, v, es);
            } else {
                sheet.addBool(row, col, v, es);
            }
        } else if (vt == ValueType.TEXT || _isString(v)) {
            if (options._lookupDisplay && (column.labelField() || column.lookupDisplay())) {
                var gcell = body.getCellSimple(ExcelIndex.tempExcel(item, column));
                v = gcell.getTextFromItem(item);
                es = this.$_checkTextEs(v, es, ctx, column);
                sheet.addText(row, col, v, es);
            } else {
                if (options._textCallback) {
                    v = options._textCallback(item, column, v);
                } else if (options._textFormatter) {
                    v = options._textFormatter.format(v);
                }
                es = this.$_checkTextEs(v, es, ctx, column);
                sheet.addText(row, col, v, es);
            }
        } else {
            sheet.addText(row, col, "", es);
        }
    },
    $_getStyledText: function (options, item, column, dcell, body) {
        var s, callback, styles, prefix, suffix, cv, st;
        if (options.styledText()) {
            dcell = dcell|| body.getCell(ExcelIndex.tempExcel(item, column));
            callback = column._displayCallback;
            styles = dcell.styles();
            prefix = styles.prefix();
            suffix = styles.suffix();
            if (callback) {
                this._dataCell._index.set(item.index(), column);
                this._dataCell._doPrepareValue(dcell);
                s = this._dataCell.text();
            } else {
                cv = this._dataCell;
                st = dcell.styles();
                cv._index.set(item.index(), column);
                cv.setNumberFormat(st.numberFormat());
                cv.setDatetimeFormat(st.datetimeFormat());
                cv.setBooleanFormat(st.booleanFormat());
                cv.setTextFormat(st.textFormat())
                cv._doPrepareValue(dcell);
                s = this._dataCell.text();
            }
            if (s !== undefined && (prefix || suffix)) {
                s = s || "";
                if (s) {
                    if (prefix) {
                        s = prefix + s;
                    }
                    if (suffix) {
                        s += suffix;
                    }
                }
            }
        }
        return s;
    },
    $_buildValueCell: function (ctx, row, col, item, column) {
        var dcell, v, st, st2, f, s, fld, vals,
            grid = ctx.grid,
            body = grid.body(),
            options = ctx.options,
            book = ctx.book,
            sheet = book.sheet(),
            es = ctx.columnStyles[column.$_hash];
        if (options.applyDynamicStyles() && (es.$_dynamicStyles || body.$_hasDynamicStyles(item, column) || (st2 = body.rowRangeStyles().getRow(item.index())))) {
            dcell = body.getCell(ExcelIndex.tempExcel(item, column));
            st = dcell.styles();
            if (st2) {
                f = st.background();
                if (!f) {
                    f = st2.background();
                }
                f && st.setBackground(f);
                f = st.borderBottom();
                if (!f) {
                    f = st2.borderBottom();
                }
                f && st.setBorderBottom(f);
            }
            es = this.$_addStyleWithColumn(ctx, column, st);
            es.dynamic = true;
        }
        if (column._blankWhenExport) {
            sheet.addText(row, col, "", es);
        }  else if (column instanceof DataColumn) {
            fld = column.dataIndex();
            if (fld >= 0) {
                s = this.$_getStyledText(options, item, column, dcell, body)
                if (s !== undefined) {
                    es = this.$_checkTextEs(s, es, ctx, column);
                    sheet.addText(row, col, s, es);
                } else {
                    v = item.getValue(fld);
                    this.$_addCell(ctx, row, col, item, column, v, sheet, options, es);
                }
            } else {
                sheet.addBlank(row, col, es);
            }
        } else if (column instanceof SeriesColumn) {
            vals = this._seriesCell.getValue(column, item);
            if (vals) {
                s = SeriesCell.getText(vals);
                es = this.$_checkTextEs(s, es, ctx, column);
                sheet.addText(row, col, s, es);
            } else {
                sheet.addBlank(row, col, es);
            }
        } else if (column instanceof CalculatedColumn) {
            s = this.$_getStyledText(options, item, column, dcell, body)
            if (s !== undefined) {
                es = this.$_checkTextEs(s, es, ctx, column);
                sheet.addText(row, col, s, es);
            } else {
                v = column.getValue(item);
                if (v !== undefined) {
                    this.$_addCell(ctx, row, col, item, column, v, sheet, options, es);
                } else {
                    sheet.addBlank(row, col, es);
                }
            }
        } else if (column instanceof LabelColumn) {
            s = column.text();
            es = this.$_checkTextEs(s, es, ctx, column);
            sheet.addText(row, col, s, es);
        }
    },
    $_buildRow: function (ctx, item, startRow, startCol, no) {
        var c, r, row, start, col, colItem, column, es, rowSpan, colSpan, celled, index, room,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            rows = colArr.dataRowCount(),
            cols = colArr.colCount(),
            colStyles = ctx.columnStyles,
            lm = grid.layoutManager(),
            columnMerged = ctx.columnMerged,
            mergeHeads = ctx.mergeHeads,
            rowGroup = grid.rowGroup(),
            indents = ctx.indents;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, rows);
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            start = startCol;
            for (c = 0; c < indents; c++) {
                start++;
            }
            for (c = 0; c < cols; c++) {
                col = c + start;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                es = colStyles[column.$_hash];
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    rowSpan = colItem.rowSpan;
                    colSpan = colItem.colSpan;
                    celled = false;
                    if (columnMerged) {
                        index = ExcelIndex.tempExcel(item, column);
                        room = lm.getMergedCell(index);
                        if (room) {
                            if (room.isHead(index) && r == 0) {
                                this.$_buildValueCell(ctx, row, col, item, column);
                                mergeHeads[column.$_hash] = row;
                                celled = true;
                            } else {
                                sheet.addBlank(row, col, es);
                                if (room.isTail(index)) {
                                    rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                    sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                }
                                celled = true;
                            }
                        } else if (ctx.allItems && !item.visible()) {
                            if (!RowGroupAdornments.isHeader(rowGroup.expandedAdornments()) && item == item.parent().firstLeaf()) {
                                this.$_buildValueCell(ctx, row, col, item, column);
                                mergeHeads[column.$_hash] = row;
                                celled = true;
                            } else if (grid.isGroupedColumn(column) && grid.mergedRowGrouped()) {
                                if (!RowGroupAdornments.isFooter(rowGroup.expandedAdornments()) && item == item.parent().lastLeaf()) {
                                    rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                    sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                }
                                celled = true;
                            }
                        }
                    }
                    if (!celled) {
                        this.$_buildValueCell(ctx, row, col, item, column);
                        if (rowSpan > 1 || colSpan > 1) {
                            sheet.addMerge(row, col, rowSpan, colSpan);
                        }
                    }
                }
            }
            if (ctx.rowGrouped) {
                sheet.setRowLevel(row, item.level());
            }
        }
        return rows;
    },
    $_buildGroupRow: function (ctx, item, startRow, startCol, no) {
        var grid = ctx.grid, s, i,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            level = item.level() - 1;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, 1);
        }
        /*
         for (c = 0; c < level; c++) {
         var cell:ICell = m_doc.addBlank(r, c + startCol);
         cell.style = m_headerBarStyle;
         }
         cell = (m_allItems || item.expanded) ? m_doc.addBlank(r, c + startCol) : m_doc.addText(r, c + startCol, "+");
         cell.style = m_rowGroupHeaderStyle;
         c++;
         */
        if (ctx.indents > 0) {
            startCol += item.level() - 1;
        }
        s = grid.rowGroup().getHeaderText(item);//.getHeadCell(level).displayText;
        sheet.addText(startRow, startCol, s, ctx.rowGroupHeaderStyle);
        if (ctx.indents > 0) {
            cols += ctx.indents - (item.level() - 1);
        }
        for (i = 1; i < cols; i++) {
            sheet.addBlank(startRow, i + startCol, ctx.rowGroupHeaderStyle);
        }
        sheet.addMerge(startRow, startCol, 1, cols);
        sheet.setRowLevel(startRow, item.level());
        return 1;
    },
    $_buildGroupFooter: function (ctx, item, startRow, startCol, no) {
        var c, col, colItem, column, es, r, row, start,
            grid = ctx.grid,
            rowGroup = grid.rowGroup(),
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            rows = colArr.groupFooterRowCount(),
            cols = colArr.colCount(),
            srcStyles = grid.rowGroup().footerStyles(),
            footerStyles = ctx.rowGroupFooterStyles,
            indents = ctx.indents,
            level = item.level(),
            lm = grid.layoutManager();
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, rows);
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            start = startCol;
            if (indents > 0) {
                colItem = colArr.getGroupFooter(r, 0);
                column = colItem.column;
                es = footerStyles[column.$_hash];
                if (!es) {
                    this._runStyles.clearValues();
                    this._runStyles.extend(column.groupFooter().styles());
                    this._runStyles.setParent(srcStyles);
                    es = this.$_addStyle(book, this._runStyles);//, false)
                    footerStyles[column.$_hash] = es;
                }
                for (c = 0; c < level - 2; c++) {
                    start++;
                }
                for (; c < indents; c++) {
                    sheet.addBlank(row, start, es);
                    start++;
                }
            }
            for (c = 0; c < cols; c++) {
                col = c + start;
                colItem = colArr.getGroupFooter(r, c);
                column = colItem.column;
                es = footerStyles[column.$_hash];
                if (!es) {
                    this._runStyles.clearValues();
                    this._runStyles.extend(column.groupFooter().styles());
                    this._runStyles.setParent(srcStyles);
                    es = this.$_addStyle(book, this._runStyles);//, false);
                    footerStyles[column.$_hash] = es;
                }
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var v = RowGroupFooterCell.getValue(item, column);
                    if (isNaN(v)) {
                        v = _isString(v) ? v : column.groupFooter().text();
                        sheet.addText(row, col, v, es);
                    } else {
                        sheet.addNumber(row, col, v, es);
                    }
                    if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                        sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                    }
                }
                /*
                 if (cell) {
                 var es:ExcelStyle = m_rowGroupFooterStyles[column];
                 if (!es) {
                 m_runStyles.assign(column.footer.styles);
                 m_runStyles.parent = m_grid.rowGroup.footerStyles;
                 es = addStyle(m_runStyles, false);
                 m_rowGroupFooterStyles[column] = es;
                 }
                 cell.style = es;
                 }
                 */
                if (ctx.rowGrouped) {
                    sheet.setRowLevel(row, item.level());
                }
            }
        }
        /*
         if (item.level() < ctx.rowLevels + 1) {
         es = m_rowGroupFooterStyles[m_colArr.getItem(0, 0).column];
         for (c = 1; c <= m_groupLevels + 1 - item.level; c++) {
         col = startCol - c;
         for (r = 0; r < rows; r++) {
         row = startRow + r;
         cell = m_doc.addBlank(row, col);
         cell.style = es;
         }
         m_doc.addMerge(startRow, col, startRow + rows - 1, col);
         }
         }
         */
        return rows;
    },
    $_buildMergedGroupHeader: function (ctx, item, startRow, startCol, no) {
        var col, column, s, c,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            level = item.level();
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, 1);
        }
        if (ctx.columnMerged) {
            col = level - 1;
            column = colArr.getItem(0, col).column;
            this.$_buildValueCell(ctx, startRow, startCol + col, item.firstLeaf(), column);
            ctx.mergeHeads[column.$_hash] = startRow;
        }
        s = grid.rowGroup().getHeaderText(item);
        c = startCol + level;
        sheet.addText(startRow, c++, s, ctx.rowGroupHeaderStyle);
        for (; c < cols + startCol; c++) {
            sheet.addBlank(startRow, c/* + startCol*/, ctx.rowGroupHeaderStyle);
        }
        sheet.addMerge(startRow, level + startCol, 1, cols - level);
        /*
         var column:Column = m_colArr.getItem(0, level - 1).column;
         c = header.level + startCol - 1;
         cell = createValueCell(r, c, header.firstLeaf, column);
         cell.style = m_columnStyles[column];
         if (m_columnMerged) {
         if (m_allItems || header.expanded) {
         m_mergeHeads[column] = startRow;
         }
         }
         */
        return 1;
    },
    $_buildMergedGroupFooter: function (ctx, item, startRow, startCol, no) {
        var r, c, column, es, row, col, colItem,
            grid = ctx.grid,
            rowGroup = grid.rowGroup(),
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            rows = colArr.dataRowCount(),
            cols = colArr.colCount(),
            srcStyles = grid.rowGroup().footerStyles(),
            footerStyles = ctx.rowGroupFooterStyles,
            colStyles = ctx.columnStyles,
            showRow = ctx.options.isIndicatorDataRow(grid),
            level = item.level() - 1,
            lm = grid.layoutManager();
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, rows);
        }
        for (c = 0; c < level; c++) {
            column = colArr.getItem(0, c).column;
            es = colStyles[column.$_hash];
            if (ctx.allItems || item.parent().expanded()) {
                for (r = 0; r < rows; r++) {
                    sheet.addBlank(startRow + r, startCol + c, es);
                }
            } else {
                for (r = 0; r < rows; r++) {
                    this.$_buildValueCell(ctx, startRow + r, startCol + c, item.parent().firstLeaf(), column);
                }
            }
        }
        if (ctx.columnMerged) {
            if (ctx.allItems || item.parent().expanded()) {
                r = ctx.mergeHeads[column.$_hash];
                sheet.addMerge(r, startCol + level - 1, startRow + rows - r, 1);
            }
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            for (c = level; c < cols; c++) {
                col = c + startCol;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                es = footerStyles[column.$_hash];
                if (!es) {
                    this._runStyles.clearValues();
                    this._runStyles.extend(column.footer().styles());
                    this._runStyles.setParent(srcStyles);
                    es = this.$_addStyle(book, this._runStyles);//, false);
                    footerStyles[column.$_hash] = es;
                }
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var v = RowGroupFooterCell.getValue(item, column);
                    if (isNaN(v)) {
                        v = _isString(v) ? v : column.groupFooter().text();
                        sheet.addText(row, col, v, es);
                    } else {
                        sheet.addNumber(row, col, v, es);
                    }
                    if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                        sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                    }
                }
                /*
                 if (cell) {
                 var es:ExcelStyle = m_rowGroupFooterStyles[column];
                 if (!es) {
                 m_runStyles.assign(column.footer.styles);
                 m_runStyles.parent = m_grid.rowGroup.footerStyles;
                 es = addStyle(m_runStyles, false);
                 m_rowGroupFooterStyles[column] = es;
                 }
                 cell.style = es;
                 }
                 */
                if (ctx.rowGrouped) {
                    sheet.setRowLevel(row, level);
                }
            }
        }
        return rows;
    },
    $_buildGroupChartRow: function (ctx, item, startRow, startCol, no) {
        var s, i,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            cols = colArr.colCount(),
            level = item.level() - 1;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, 1);
        }
        /*
         for (c = 0; c < level; c++) {
         var cell:ICell = m_doc.addBlank(r, c + startCol);
         cell.style = m_headerBarStyle;
         }
         cell = (m_allItems || item.expanded) ? m_doc.addBlank(r, c + startCol) : m_doc.addText(r, c + startCol, "+");
         cell.style = m_rowGroupHeaderStyle;
         c++;
         */
        if (ctx.indents > 0) {
            startCol += item.level() - 1;
        }
        s =  item.displayText();
        sheet.addText(startRow, startCol, s, null);//ctx.rowGroupHeaderStyle);
        if (ctx.indents > 0) {
            cols += ctx.indents - (item.level() - 1);
        }
        for (i = 1; i < cols; i++) {
            sheet.addBlank(startRow, i + startCol, null);//ctx.rowGroupHeaderStyle);
        }
        sheet.addMerge(startRow, startCol, 1, cols);
        sheet.setRowLevel(startRow, item.level());
        return 1;
    },
    $_buildItem: function (ctx, row, col, i, showRow) {
        var cnt = 0,
            grid = ctx.grid,
            allItems = ctx.allItems,
            item = allItems ? allItems[i] : grid.getRow(i);
        if (item instanceof DataRow) {
            cnt = this.$_buildRow(ctx, item, row, col, (showRow ? item.dataIndex() : i) + 1);
        } else if (item instanceof GroupRowImpl) {
            cnt = this.$_buildGroupRow(ctx, item, row, col, i + 1);
        } else if (item instanceof MergedGroupHeader) {
            cnt = this.$_buildMergedGroupHeader(ctx, item, row, col, i + 1);
        } else if (item instanceof MergedGroupFooter) {
            cnt = this.$_buildMergedGroupFooter(ctx, item, row, col, i + 1);
        } else if (item instanceof GroupFooter) {
            cnt = this.$_buildGroupFooter(ctx, item, row, col, i + 1);
        } else if (item instanceof GroupChartRow) {
        } else {
            throw "Unkonw item type";
        }
        return cnt;
    },
    $_buildItems: function (ctx) {
        var i,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            showRow = ctx.options.isIndicatorDataRow(grid),
            allItems = ctx.allItems,
            cnt = allItems ? allItems.length : grid.rowCount(),
            row = startRow;
        ctx.book.setStylePivot();
        for (i = 0; i < cnt; i++) {
            row += this.$_buildItem(ctx, row, startCol, i, showRow);
        }
        this._curRow = row;
        return row - startRow;
    },
    $_buildItemsAsync: function (ctx, length, callback) {
        function buildItems(row, start, count) {
            var i,
                end = Math.min(start + count, allCount);
            try {
                for (i = start; i < end; i++) {
                    row += self.$_buildItem(ctx, row, startCol, i, showRow);
                }
                self._curRow = row;
                self._current += length * (end - start) / allCount;
                self._monitor(ctx, 'buildItems[' + i + ']');
                if (i < allCount) {
                    _setTimeout(function () {
                        buildItems(row, i, 200);
                    });
                } else {
                    ctx.footer && self.$_buildFooter(ctx);
                    self._monitor(ctx, 'buildFooter');
                    callback.call(self, ctx);
                }
            } catch (err) {
                self._doFinished(ctx, err);
            }
        }
        var self = this,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            showRow = ctx.options.isIndicatorDataRow(grid),
            allItems = ctx.allItems,
            allCount = allItems ? allItems.length : grid.rowCount();
        this._monitor(ctx, 'buildItems[0]');
        if (allCount > 0) {
            buildItems(startRow, 0, 200);
        }
    },
    $_buildTreeHeader: function (ctx) {
        return this.$_buildHeader(ctx);
        /*
        var grid = ctx.grid;
        var book = ctx.book;
        var sheet = book.sheet();
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.headerRowCount();
        var indents = ctx.indents;
        var i, es, row;
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.header().head().styles());
            sheet.addText(startRow, startCol, ctx.indicatorHead, es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentHeadStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            for (var c = 0; c < cols; c++) {
                var item = colArr.getHeader(i, c);
                var column = item.column;
                var col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var h = column instanceof ColumnHeader ? column : column.header();
                    es = this.$_addStyle(book, h.styles());
                    sheet.addText(row, col, h.displayText(), es);
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        return rows;
        */
    },
    $_buildTreeSummary: function (ctx) {
        this.$_buildSummary(ctx);
    },
    $_buildTreeFooter: function (ctx) {
        var startRow = this._curRow,
            rows = this.$_buildFooter(ctx);
        ctx.book.sheet().setRowLevel(startRow, 1);
        return rows;
        /*
        var grid = ctx.grid;
        var book = ctx.book;
        var sheet = book.sheet();
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.footerRowCount();
        var indents = ctx.indents;
        var i, es;
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.footer().head().styles());
            sheet.addText(startRow, startCol, grid.footer().head().text(), es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentFootStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            var row = startRow + i;
            for (var c = 0; c < cols; c++) {
                var item = colArr.getFooter(i, c);
                var column = item.column;
                var col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var h = column.footer();
                    var cell = grid.footer().getCell(new CellIndex(null, column));
                    var v = cell.value();
                    es = this.$_addStyle(book, h.styles());
                    if (!isNaN(v)) {
                        sheet.addNumber(row, col, v, es);
                    } else {
                        sheet.addText(row, col, cell.displayText() || "", es);
                    }
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        sheet.setRowLevel(startRow, 1);
        return rows;
        */
    },
    $_buildTreeRow: function (ctx, item, startRow, startCol, no) {
        var c, r, row, start, colItem, column, es, ind, col,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            rows = colArr.dataRowCount(),
            cols = colArr.colCount(),
            colStyles = ctx.columnStyles,
            indents = ctx.indents,
            level = item.level();
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, rows);
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            start = indents > 0 ? startCol + level - 1 : startCol;
            colItem = colArr.getItem(r, 0);
            column = colItem.column;
            es = colStyles[column.$_hash];
            ind = indents > 0 ? indents - level + 1 : 0;
            if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                sheet.addBlank(row, start, es);
                for (c = 0; c < ind; c++) {
                    sheet.addBlank(row, 1 + c + start, es);
                }
            } else {
                this.$_buildValueCell(ctx, row, start, item, column);
                for (c = 0; c < ind; c++) {
                    sheet.addBlank(row, 1 + c + start, es);
                }
                sheet.addMerge(row, start, colItem.rowSpan, colItem.colSpan + ind);
            }
            if (indents > 0) {
                start = startCol + indents;
            } else {
                start = startCol;
            }
            for (c = 1; c < cols; c++) {
                col = c + start;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                es = colStyles[column.$_hash];
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    this.$_buildValueCell(ctx, row, col, item, column);
                    if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                        sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                    }
                }
            }
            sheet.setRowLevel(startRow, item.level());
        }
        return rows;
    },
    $_buildTreeRowFooter: function (ctx, item, startRow, startCol, no) {
        var c, col, colItem, column, es, r, row, start, v,
            grid = ctx.grid,
            book = ctx.book,
            sheet = book.sheet(),
            colArr = ctx.colArr,
            rows = colArr.groupFooterRowCount(),
            cols = colArr.colCount(),
            srcStyles = grid.treeOptions().footerStyles(),
            footerStyles = ctx.rowFooterStyles,
            indents = ctx.indents,
            level = item.level(),
            lm = grid.layoutManager();
        book.setStylePivot();
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(ctx, no, startRow, startCol, rows);
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            start = startCol;
            if (indents > 0) {
                colItem = colArr.getGroupFooter(r, 0);
                column = colItem.column;
                es = footerStyles[column.$_hash];
                if (!es) {
                    this._runStyles.clearValues();
                    this._runStyles.extend(column.groupFooter().styles());
                    this._runStyles.setParent(srcStyles);
                    es = this.$_addStyle(book, this._runStyles);//, false)
                    footerStyles[column.$_hash] = es;
                }
                for (c = 0; c < level - 2; c++) {
                    start++;
                }
                for (; c < indents; c++) {
                    sheet.addBlank(row, start, es);
                    start++;
                }
            }
            for (c = 0; c < cols; c++) {
                col = c + start;
                colItem = colArr.getGroupFooter(r, c);
                column = colItem.column;
                es = footerStyles[column.$_hash];
                if (!es) {
                    this._runStyles.clearValues();
                    this._runStyles.extend(column.groupFooter().styles());
                    this._runStyles.setParent(srcStyles);
                    es = this.$_addStyle(book, this._runStyles);//, false);
                    footerStyles[column.$_hash] = es;
                }
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    v = RowGroupFooterCell.getValue(item, column);
                    if (isNaN(v)) {
                        v = _isString(v) ? v : column.groupFooter().text();
                        sheet.addText(row, col, v, es);
                    } else {
                        sheet.addNumber(row, col, v, es);
                    }
                    if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                        sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                    }
                }
                    sheet.setRowLevel(row, item.level());
            }
        }
        return rows;
    },
    $_buildTreeItem: function (ctx, row, col, i, showRow) {
        var cnt = 0,
            grid = ctx.grid,
            allItems = ctx.allItems,
            item = allItems ? allItems[i] : grid.getRow(i);
        if (item instanceof TreeRow) {
            cnt = this.$_buildTreeRow(ctx, item, row, col, (showRow ? item.dataIndex() : i) + 1);
        } else if (item instanceof TreeRowFooter) {
            cnt = this.$_buildTreeRowFooter(ctx, item, row, col, (showRow ? item.dataIndex() : i) + 1);
        } else if (item instanceof GroupChartRow) {
        } else {
            throw "Unkonw tree item type";
        }
        return cnt;
    },
    $_buildTreeItems: function (ctx) {
        var i, item,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            showRow = ctx.options.isIndicatorDataRow(grid),
            allItems = ctx.allItems,
            cnt = allItems ? allItems.length : grid.rowCount(),
            row = startRow;
        ctx.book.setStylePivot();
        for (i = 0; i < cnt; i++) {
            row += this.$_buildTreeItem(ctx, row, startCol, i, showRow);
        }
        this._curRow = row;
        return row - startRow;
    },
    $_buildTreeItemsAsync: function (ctx, length, callback) {
        function buildItems(row, start, count) {
            var i,
                end = Math.min(start + count, allCount);
            try {
                for (i = start; i < end; i++) {
                    row += self.$_buildTreeItem(ctx, row, startCol, i, showRow);
                }
                self._curRow = row;
                self._current += length * (end - start) / allCount;
                self._monitor(ctx, 'buildItems[' + i + ']');
                if (i < allCount) {
                    _setTimeout(function () {
                        buildItems(row, i, 100);
                    });
                } else {
                    ctx.footer && self.$_buildTreeFooter(ctx);
                    self._monitor(ctx, 'buildFooter');
                    callback.call(self, ctx);
                }
            } catch (err) {
                self._doFinished(ctx, err);
            }
        }
        var self = this,
            startRow = this._curRow,
            startCol = this._curCol,
            grid = ctx.grid,
            showRow = ctx.options.isIndicatorDataRow(grid),
            allItems = ctx.allItems,
            allCount = allItems ? allItems.length : grid.rowCount();
        this._monitor(ctx, 'buildItems[0]');
        if (allCount > 0) {
            buildItems(startRow, 0, 100);
        }
    },
    $_buildZip: function (parts, ctx) {
        var chrome, zip, i, s, data, url, formtag, msg, div, self, curr, total, promise,
            options = ctx.options,
            async = options.async(),
            filename = options.fileName() || "dataludi.xlsx",
            local = options.target() == "local";
        if (JSZip.support.blob || !local) {
            chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
            zip = new JSZip();
            for (i = 0; i < parts.length; i++) {
                s = parts[i].body;
                if (!chrome) {
                    s = s.replace(/xmlns=""/g, '');
                }
                zip.file(parts[i].key, s);
            }
            if (async) {
                self = this;
                curr = this._current;
                total = 100 - curr - 2;
                if (zip.generateAsync) {
                    if (local) {
                        promise = zip.generateAsync({type: "blob", compression: "DEFLATE"}, function (meta) {
                            self._current = curr + total * meta.percent / 100;
                            self._monitor(ctx, 'zipping[' + meta.percent.toFixed(0) + ']');
                        })
                            .then(function (data) {
                                _saveToFile(data, filename);
                                self._current += 2;
                                self._monitor(ctx, 'save to ' + filename);
                                self._doFinished(ctx);
                            });
                    } else {
                        promise = zip.generateAsync({type: "base64", compression: "DEFLATE"}, function (meta) {
                            self._current = curr + total * meta.percent / 100;
                            self._monitor(ctx, 'zipping[' + meta.percent.toFixed(0) + ']');
                        })
                            .then(function (data) {
                                _uploadFile(options.url(), filename, data);
                                self._current += 2;
                                self._monitor(ctx, 'save to ' + filename);
                                self._doFinished(ctx);
                            });
                    }
                    promise.catch(function (reason) {
                        self._doFinished(ctx, reason);
                    })
                } else {
                    if (local) {
                        data = zip.generate({type: "blob", compression: "DEFLATE"});
                        if (options.noSave()) return data;
                        _saveToFile(data, filename);
                        this._doFinished(ctx);
                    } else {
                        data = zip.generate({type: "base64", compression: "DEFLATE"});
                        if (options.noSave()) return data;
                        _uploadFile(options.url(), filename, data);
                        this._doFinished(ctx);
                    }
                }
            } else {
                if (zip.generateAsync) {
                    if (local) {
                        zip.generateAsync({type: "blob", compression: "DEFLATE"})
                            .then(function (blob) {
                                _saveToFile(blob, filename);
                            });
                    } else {
                        zip.generateAsync({type: "base64", compression: "DEFLATE"})
                            .then(function (data) {
                                _uploadFile(options.url(), filename, data);
                            });
                    }
                } else {
                    if (local) {
                        data = zip.generate({type: "blob", compression: "DEFLATE"});
                        if (options.noSave()) return data;
                        _saveToFile(data, filename);
                    } else {
                        data = zip.generate({type: "base64", compression: "DEFLATE"});
                        if (options.noSave()) return data;
                        _uploadFile(options.url(), filename, data);
                    }
                }
            }
            return true;
        } else {
            this._doFinished(ctx);
            msg = "not supported on this browser";
            _alert(msg);
            _throwDebug(msg);
            return false;
        }
    }
});
var TreeSummaryScope = _enum('TreeSummaryScope', {
	DESCENDTANT: "descendant",
	ALL: "all",
	CHILD: "child",
	PARENT_CHILD: "parentChild",
	GROUP: "group",
	LEAF: "leaf"
});
/** @internal */
var TreeItemsSorter = function () {
	var _items, _dataSource, _parent, _field, _comparer;
	var _sort = function (left, right, ascending, checkRow) {
		var i, j, m, mi, mr, r, v;
		do {
			i = left;
			j = right;
			m = _floor((i + j) / 2);
			mi = _parent.getItem(m).dataIndex();
			mr = _parent.getItem(m).dataRow();
			do {
				if (ascending) {
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(i).dataRow());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(i).dataIndex();
						}
						if (v <= 0) {	
							break;
						}
						i++;
					}
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(j).dataRow());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(j).dataIndex();
						}
						if (v >= 0) {	
							break;
						}
						j--;
					}
				} else {
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(i).dataRow());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(i).dataIndex();
						}
						if (v >= 0) { 
							break;
						}
						i++;
					}
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(j).dataRow());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(j).dataIndex();
						}
						if (v <= 0) {	
							break;
						}
						j--;
					}
				}
				if (i <= j) {
					if (i != j) {
						_parent._exchangeItems(i, j);
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				_sort(left, j, ascending, checkRow);
			}
			left = i;
		} while (left < right);
	};
	this.run = function (parent, field, dir, ignoreCase, left, right, checkRow) {
		_items = parent.provider();
		_dataSource = _items.dataSource();
		_parent = parent;
		_field = field;
		_comparer = _dataSource.$_getComparer(_dataSource.getField(field).dataType(), ignoreCase);
		_sort(left, right, dir == SortDirection.ASCENDING, checkRow);
	};
};
var TreeDataTag = defineClass("TreeDataTag", DataTag, {
	init: function() {
		this._super();
	},
	addRow: function (index, row) {
	},
	addRows: function (index, rows) {
	},
    insertRows: function (rows) {
    }
});
var TreeDataTagCollection = defineClass("TreeDataTagCollection", DataTagCollection, {
	init: function(owner) {
		this._super();
		this._owner = owner;
		this._items = null;
		this._tag = null;
	},
	addRow: function (index, row) {
		if (this._tag) {
			this._tag.addRow(index, row);
		} else if (this._tags) {
			var i, items = this._tags;
			for (i = items.length - 1; i >= 0; i--) {
				items[i].addRow(index, row);
			}
		}
	},
	addRows: function (index, rows) {
		if (this._tag) {
			this._tag.addRows(index, rows);
		} else if (this._tags) {
			var i, items = this._tags;
			for (i = items.length - 1; i >= 0; i--) {
				items[i].addRows(index, rows);
			}
		}
	},
    insertRows: function (rows) {
        if (this._tag) {
            this._tag.insertRows(rows);
        } else if (this._tags) {
            var i, items = this._tags;
            for (i = items.length - 1; i >= 0; i--) {
                items[i].insertRows(rows);
            }
        }
    }
});
var TreeDataSource = defineClass("TreeDataSource", null, {
	init : function(provider, rootRow) {
		Base.init.call(this, provider, rootRow);
		this._provider = provider;
		this._rootRow = rootRow;
		this._rows = null;
		this._rowCount = 0;
	},
	provider: function () {
		return this._provider;
	},
	rootRow: function () {
		return this._rootRow;
	},
	insertedRows: function () {
		return this._rows;
	},
	insertedCount: function () {
		return this._rowCount;
	},
	_prepareLoad: function (parent) {
		this._rowCount = 0;
		this._rows = [];
	},
	_objectToArray: function (row, provider) {
		var vals = new Array(flds);
		for (var c = 0, flds = provider.fieldCount(); c < flds; c++) {
			var fld = provider.getFieldName(c);
			if (row.hasOwnProperty(fld)) {
				vals[c] = row[fld];
			}
		}
		return vals;
	},
	_createRow: function (values, treeFld) {
		return this._provider._doCreateRow(values, treeFld);
	},
	_rowAdded: function (root, row) {
		this._rowCount++;
		if (row.parent() === root) {
			this._rows.push(row);
		}
	},
	_insertRow: function (root, parent, index, values, setState) {
		var row = this._createRow(values);
		parent.$$_insertChild(null, index, row, !setState);
		this._rowAdded(root, row);
		return row;
	},
	_addRow: function (root, parent, values) {
		var row = this._createRow(values);
		parent.$$_insertChild(null, parent.count(), row, true);
		this._rowAdded(root, row);
		return row;
	}
});
var ArrayTreeSource = defineClass("ArrayTreeSource", TreeDataSource, {
	init : function(provider, rootRow) {
		ArrayTreeSource.Base.init.call(this, provider, rootRow);
		this.checkParentProc = null;
	},
    load: function (parent, source, treeField, useTreeField, needSorting, filter) {
        return this._loadData(source, parent, treeField, useTreeField, needSorting, filter);
    },
	_loadData: function (source, parent, treeField, useTreeField, needSorting, filter) {
		var ds, rows, i, cnt;
		this._prepareLoad(parent);
		if (!source || source.length < 1) {
			return this._rowCount;
		}
		ds = this.provider();
		rows = [];
		if (treeField >= ds.fieldCount()) {
			treeField = -1;
		}
		for (i = 0, cnt = source.length; i < cnt; i++) {
			rows[i] = i;
			if (!_isArray(source[i])) {
				source[i] = this._objectToArray(source[i], ds);
			}
		}
		if (needSorting && treeField >= 0) {
			this.$_sortRows(rows, source, treeField, 0, cnt - 1);
		}
		ds.beginUpdate();
		try {
			if (filter instanceof TreeDataFilter) {
				filter.prepare(ds.filterRuntime().prepare(ds));
			} else {
				filter = null;
			}
			this.$_buildTree(parent || this.rootRow(), rows, source, treeField, useTreeField, filter);
		} finally {
			ds.endUpdate(false);
		}
		return this.insertedCount();
	},
	$_sortRows: function (rows, values, field, left, right) {
		function compare(r1, r2) {
			var s1 = values[r1][field];
			var s2 = values[r2][field];
			if (s1 == s2) {
				return 0;
			}
			if (s1 < s2) {
				return -1;
			}
			return 1;
		}
		var i, j, m, t, r, v;
		do {
			i = left;
			j = right;
			m = rows[_floor((left + right) / 2)];
			do {
				while (true) {
					r = rows[i];
					v = compare(m, r);
					if (v <= 0)
						break;
					i++;
				}
				while (true) {
					r = rows[j];
					v = compare(m, r);
					if (v >= 0)
						break;
					j--;
				}
				if (i <= j) {
					if (i != j) {
						t = rows[i];
						rows[i] = rows[j];
						rows[j] = t;
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				this.$_sortRows(rows, values, field, left, j);
			}
			left = i;
		} while (left < right);
	},
	$_buildTree: function (parent, rows, values, treeField, useTreeField, filter) {
		function getParent(prev, values, parentProc) {
			var tree = values[treeField];
            if (tree) {
                while (prev != parent) {
                    var s = useTreeField ? prev.getValue(treeField) : prev.$$_tree;
                    if (parentProc) {
                        if (parentProc(s, tree)) {
                            return prev;
                        }
                    } else if (tree.indexOf(s) == 0) {
                        return prev;
                    }
                    prev = prev.parent();
                }
            }
			return parent;
		}
		function insertChild(self, root, parent, vals) {
			var row = self._createRow(vals, treeFld);
			if (!useTreeField && treeField >= 0) {
				row.$$_tree = vals[treeField];
			}
			parent.$$_insertChild(null, parent.count(), row, true);
			self._rowAdded(root, row);
			return row;
		}
		var r, vals, prev, p, cnt,
			treeFld = useTreeField ? -1 : treeField,
			i = 0;
		if (filter) {
			while (i < rows.length) {
				r = rows[i++];
				vals = values[r];
				p = getParent(parent, vals);
				if (filter.select(i, p, p.count(), vals)) {
					prev = insertChild(this, parent, p, vals);
					break;
				}
			}
		} else {
			r = rows[i];
			vals = values[r];
			p = getParent(parent, vals);
			prev = insertChild(this, parent, p, vals);
            i++;
		}
		if (rows.length > i) {
			cnt = rows.length;
			for (; i < cnt; i++) {
				r = rows[i];
				vals = values[r];
				p = getParent(prev, vals);
				if (p && (!filter || filter.select(i, p, p.count(), vals))) {
					prev = insertChild(this, parent, p, vals);
				}
			}
		}
		if (treeField >= 0) {
			parent.visitAll(function (row) {
				delete row.$$_tree;
			})
		}
	}
});
var JsonTreeSource = defineClass("JsonTreeSource", TreeDataSource, {
	init: function (provider, rootRow) {
		JsonTreeSource.Base.init.call(this, provider, rootRow);
	},
	load: function (parent, index, source, rowsProp, childRowsProp, currency, setState, filter) {
		return this._loadData(source, parent, index, rowsProp, childRowsProp, currency, setState, filter)
	},
	_loadData: function (source, parent, index, rowsProp, childRowsProp, currency, setState, filter) {
		this._prepareLoad(parent);
		if (typeof source === "string") {
			source = JSON.parse(source);
		}
		if (source) {
			var rows = DataPath.extractJson(source, rowsProp);
			if (rows && rows.length > 0) {
				var ds = this.provider();
				ds.beginUpdate();
				try {
					if (filter instanceof TreeDataFilter) {
						filter.prepare(ds.filterRuntime().prepare(ds));
					} else {
						filter = null;
					}
					this.$_buildTree(ds, parent ? parent : this.rootRow(), index, rows, childRowsProp, currency, setState, filter);
				} finally {
					this.provider().endUpdate(false);
				}
			}
		}
		return this._rowCount;
	},
	$_buildTree: function (dataset, parent/*TreeDataRow*/, index, source, rowsProp, currency, setState, filter) {
		function build(self, p, index, rows, fldNames) {
			var flds = fldNames.length;
            var n = 0;
			for (var i = 0, cnt = rows.length; i < cnt; i++) {
				var obj = rows[i];
				var vals = new Array(flds);
				for (var c = 0; c < flds; c++) {
					var fld = fldNames[c];
					if (obj.hasOwnProperty(fld)) {
                        var v = obj[fld];
                        if (v && nflds[c] && v.length > 0) {
                            v = v.replace($_currencyreg, '');
                        }
						vals[c] = v;
					}
				}
				if (!filter || filter.select(i, parent, index + n, vals)) {
					var row = self._insertRow(parent, p, index + n, vals, setState);
                    n++;
					if (obj.hasOwnProperty(rowsProp)) {
						var arr = obj[rowsProp];
						if (_isArray(arr) && arr.length > 0)
							build(self, row, 0, arr, fldNames);
					}
				}
			}
		}
        var fields = dataset.fields();
		var fldNames = dataset.getFieldNames();
        var fldCnt = fields.length;
        var nflds = new Array(fldCnt);
        if (currency) {
            for (var i = 0; i < fldCnt; i++) {
                nflds[i] = fields[i].dataType() == ValueType.NUMBER;
            }
        }
		build(this, parent, index, source, fldNames);
	}
});
var XmlTreeSource = defineClass("XmlTreeSource", TreeDataSource, {
	init: function(dataset, rootRow) {
		XmlTreeSource.Base.init.call(this, dataset, rootRow);
	},
	load: function (parent, index, source, rowsProp, childRowsProp, currency, setState, filter, save) {
		return this._loadData(source, parent, index, rowsProp, childRowsProp, currency, setState, filter, save)
	},
	_loadData: function (source, parent, index, rowsProp, childRowsProp, currency, setState, filter, save) {
		this._prepareLoad(parent);
		if (source) {
			var xml = typeof source === "string" ? _parseXml(source) : source;
			if (xml && xml.documentElement) {
				var rows = DataPath.extractXml(xml.documentElement, rowsProp);
				if (rows && rows.length > 0) {
					var ds = this.provider();
					ds.beginUpdate();
					try {
						if (filter instanceof TreeDataFilter) {
							filter.prepare(ds.filterRuntime().prepare(ds));
						} else {
							filter = null;
						}
						this.$_buildTree(ds, parent ? parent : this.rootRow(), index, rows, childRowsProp, rowsProp, currency, setState, filter);
					} finally {
						this.provider().endUpdate(false);
					}
				}
			}
		}
		return this._rowCount;
	},
	$_buildTree: function (dataset, parent/*TreeDataRow*/, index, source, childrenProp, rowProp, currency, setState, filter) {
		function build(self, p, index, rows, fields) {
            var i, cnt, xml, vals, c, v, row, elt, elts,
				n = 0;
			for (i = 0, cnt = rows.length; i < cnt; i++) {
				xml = rows[i];
				vals = DataHelper.xmlToRow(xml, fields, fieldNames);
                for (c = 0; c < fldCnt; c++) {
                    v = vals[c];
                    if (v && nflds[c] && v.length > 0) {
                        v = v.replace($_currencyreg, '');
                    }
                    vals[c] = v;
                }
				if (!filter || filter.select(i, parent, index + n, vals)) {
					row = self._insertRow(parent, p, index + n, vals, setState);
                    n++;
					if (childrenProp) {
						elt = DataPath.extractXml(xml, childrenProp);
						if (elt && elt.length > 0) {
							xml = elt[0];
						}
					}
					elts = DataPath.extractXml(xml, rowProp);
					if (elts && elts.length > 0) {
						build(self, row, 0, elts, fields);
					}
				}
			}
		}
		var i,
        	fields = dataset.fields(),
        	fieldNames = dataset.getFieldNames(),
        	fldCnt = fields.length,
        	nflds = new Array(fldCnt);
        if (currency) {
            for (i = 0; i < fldCnt; i++) {
                nflds[i] = fields[i].dataType() == ValueType.NUMBER;
            }
        }
		build(this, parent, index, source, fields);
	}
});
var TreeDataActionGroup = defineClass("TreeDataActionGroup", DataActionGroup, {
    init: function (ds, immediately) {
        this._super(ds, immediately);
    },
    clearRows: function () {
        return this.add(new TreeDataClearRowsCommand(this.ds));
    },
    setRows: function (rows, treeField, useTreeField, needSorting, filter) {
        return this.add(new TreeDataSetRowsCommand(this.ds, rows, treeField, useTreeField, needSorting, filter));
    },
    setXmlRows: function (rows, rowsProp, childRowsProp, currency, filter) {
        return this.add(new TreeDataSetXmlRowsCommand(this.ds, rows, rowsProp, childRowsProp, currency, filter));
    },
    setJsonRows: function (rows, rowsProp, childRowsProp, currency, filter) {
        return this.add(new TreeDataSetJsonRowsCommand(this.ds, rows, rowsProp, childRowsProp, currency, filter));
    },
    insertDataRows: function (parent, index, rows, treeField, useTreeField, needSorting, filter) {
        return this.add(new TreeDataInsertDataRowsCommand(this.ds, parent, index, rows, treeField, useTreeField, needSorting, filter));
    },
    appendDataRows: function (parent, rows, treeField, useTreeField, needSorting, filter) {
        var index = parent ? parent.count() : this.ds._rootRow.count();
        return this.add(new TreeDataInsertDataRowsCommand(this.ds, parent, index, rows, treeField, useTreeField, needSorting, filter));
    },
    insertXmlRows: function (parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        return this.add(new TreeDataInsertXmlRowsCommand(this.ds, parent, index, rows, rowsProp, childRowsProp, currency, filter));
    },
    appendXmlRows: function (parent, rows, rowsProp, childRowsProp, currency, filter) {
        var index = parent ? parent.count() : this.ds._rootRow.count();
        return this.add(new TreeDataInsertXmlRowsCommand(this.ds, parent, index, rows, rowsProp, childRowsProp, currency, filter));
    },
    insertJsonRows: function (parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        return this.add(new TreeDataInsertJsonRowsCommand(this.ds, parent, index, rows, rowsProp, childRowsProp, currency, filter));
    },
    appendJsonRows: function (parent, rows, rowsProp, childRowsProp, currency, filter) {
        var index = parent ? parent.count() : this.ds._rootRow.count();
        return this.add(new TreeDataInsertJsonRowsCommand(this.ds, parent, index, rows, rowsProp, childRowsProp, currency, filter));
    },
    setValue: function (row, field, newValue) {
        return this.add(new TreeDataSetValueCommand(this.ds, row, field, newValue, true, true, false));
    },
    setValueEx: function (row, field, newValue, checkDiff, strictDiff, noEvent) {
        return this.add(new TreeDataSetValueCommand(this.ds, row, field, newValue, checkDiff, strictDiff, noEvent));
    },
    updateRow: function (row, values, checkDiff, strictDiff, checkEmpty, noState) {
        return this.add(new TreeDataUpdateRowCommand(this.ds, row, values, checkDiff, strictDiff, checkEmpty, noState));
    },
    insertRow: function (parent, index, values, noState, field) {
        return this.add(new TreeDataInsertRowCommand(this.ds, parent, index, values, noState, field));
    },
    addRow: function (parent, values, noState, field) {
        var ds = this.ds;
        var p = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        return p && this.add(new TreeDataInsertRowCommand(ds, p, p.count(), values, noState, field));
    },
    insertRows: function (parent, index, rows, rowEvents, noState) {
        return this.add(new TreeDataInsertRowsCommand(this.ds, parent, index, rows, rowEvents, noState));
    },
    addRows: function (parent, rows, rowEvents, noState) {
        var ds = this.ds;
        var p = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        return p && this.add(new TreeDataInsertRowsCommand(ds, p, p.count(), rows, rowEvents, noState));
    },
    deleteRow: function (row) {
        return this.add(new TreeDataDeleteRowCommand(this.ds, row));
    },
    deleteRows: function (rows) {
        return this.add(new TreeDataDeleteRowsCommand(this.ds, rows));
    },
    setRowState: function (row, newState, force) {
        return this.add(new TreeDataSetRowStateCommand(this.ds, row, newState, force));
    },
    setRowStates: function (rows, newState, force, rowEvents) {
        return this.add(new TreeDataSetRowStatesCommand(this.ds, rows, newState, force, rowEvents));
    },
    clearRowStates: function (states, deleteRows, rowEvents) {
        return this.add(new TreeDataClearRowStatesCommand(this.ds, states, deleteRows, rowEvents));
    },
    restoreUpdatedStates: function (rows) {
        return this.add(new TreeDataRestoreUpdatedStatesCommand(this.ds, rows));
    },
    restoreUpdatedRows: function (rows) {
        return this.add(new TreeDataRestoreUpdatedRowsCommand(this.ds, rows));
    },
    setRowTag: function (row, tag) {
        return this.add(new TreeDataSetRowTagCommand(this.ds, row, tag));
    },
    setRowTags: function (rows, tag) {
        return this.add(new TreeDataSetRowTagsCommand(this.ds, rows, tag));
    },
    unsetRowTags: function (rows, tags) {
        rows = (rows && rows.length > 0) ? rows : null;
        tags = (tags && tags.length > 0) ? tags : null;
        if (!rows && !tags) {
            return this.add(new TreeDataClearRowTagsCommand(this.ds));
        } else {
            return this.add(new TreeDataUnsetRowTagsCommand(this.ds, rows, tags));
        }
    },
    clearRowTags: function () {
        return this.add(new TreeDataClearRowTagsCommand(this.ds));
    }
});
var TreeDataClearRowsCommand = defineClass("TreeDataClearRowsCommand", DataSetEditCommand, {
    init: function (ds) {
        this._super(ds);
    },
    _doUndo: function (ds, save) {
        ds.$_restoreAll(this, save, true);
    },
    _doPostUndo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        return ds.$_saveAll(this, {}, false);
    },
    _doRun: function (ds, save) {
        if (ds.rowCount() > 0 && ds.isDeletable()) {
            if (save) {
                ds.$_saveAll(this, save, true);
                this._setReady();
            }
            ds.$_clearRows();
            !save && this._doPostRun(ds);
            return true;
        }
        this.throwEmpty();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, false);
        return true;
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var TreeDataSetRowsCommand = defineClass("TreeDataSetRowsCommand", DataSetEditCommand, {
    init: function (ds, rows, treeField, useTreeField, needSorting, filter) {
        this._super(ds);
        this.rows = rows;
        this.treeField = treeField;
        this.useTreeField = useTreeField;
        this.needSorting = needSorting;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var cnt = ds.rowCount();
        ds.$_clearRows();
        ds.$_restoreAll(this, save, true);
        post.cnt = cnt;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRefresh(this);
        post.cnt > 0 && ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        return ds.$_saveAll(this, {}, false);
    },
    _doRun: function (ds, save) {
        var source, count,
            rows = this.rows,
            treeField = this.treeField,
            useTreeField = this.useTreeField,
            needSorting = this.needSorting,
            filter = this.filter;
        if (!ds.isAppendable()) {
            return this.throwEmpty(0);
        }
        if (ds.rowCount() > 0 && !ds.isDeletable()) {
            return this.throwEmpty(0);
        }
        ds.refreshFieldFormats();
        if (save) {
            ds.$_saveAll(this, save, true);
            this._setReady();
        }
        ds.beginUpdate();
        try {
            ds.$_clearRows();
            if (rows && rows.length > 0) {
                source = new ArrayTreeSource(ds, ds._rootRow);
                source.checkParentProc = ds.checkParentProc;
                count = source.load(null, rows, treeField, useTreeField, needSorting, filter);
                ds._checkSum(count);
            }
        } finally {
            ds.endUpdate(false);
        }
        ds.setDataInited(true);
        ds._tags.setRows();
        !save && this._doPostRun(ds);
        return ds.rowCount();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, true);
        ds._tags.setRows();
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var TreeDataSetXmlRowsCommand = defineClass("TreeDataSetXmlRowsCommand", DataSetEditCommand, {
    init: function (ds, rows, rowsProp, childRowsProp, currency, filter) {
        this._super(ds);
        this.rows = rows;
        this.rowsProp = rowsProp;
        this.childRowsProp = childRowsProp;
        this.currency = currency;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var cnt = ds.rowCount();
        ds.$_clearRows();
        ds.$_restoreAll(this, save, true);
        post.cnt = cnt;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRefresh(this);
        post.cnt > 0 && ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        return ds.$_saveAll(this, {}, false);
    },
    _doRun: function (ds, save) {
        var source, count,
            rows = this.rows,
            rowsProp = this.rowsProp,
            childRowsProp = this.childRowsProp,
            currency = this.currency,
            filter = this.filter;
        if (!ds.isAppendable()) {
            return this.throwEmpty(0);
        }
        if (ds.rowCount() > 0 && !ds.isDeletable()) {
            return this.throwEmpty(0);
        }
        ds.refreshFieldFormats();
        if (save) {
            ds.$_saveAll(this, save, true);
            this._setReady();
        }
        ds.beginUpdate();
        try {
            ds.$_clearRows();
            if (rows) {
                source = new XmlTreeSource(ds, ds._rootRow);
                count = source.load(null, 0, rows, rowsProp, childRowsProp, currency, filter);
                ds._checkSum(count);
            }
        } finally {
            ds.endUpdate(false);
        }
        ds.setDataInited(true);
        ds._tags.setRows();
        !save && this._doPostRun(ds);
        return ds.rowCount();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, true);
        ds._tags.setRows();
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var TreeDataSetJsonRowsCommand = defineClass("TreeDataSetJsonRowsCommand", DataSetEditCommand, {
    init: function (ds, rows, rowsProp, childRowsProp, currency, filter) {
        this._super(ds);
        this.rows = rows;
        this.rowsProp = rowsProp;
        this.childRowsProp = childRowsProp;
        this.currency = currency;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var cnt = ds.rowCount();
        ds.$_clearRows();
        ds.$_restoreAll(this, save, true);
        post.cnt = cnt;
    },
    _doPostUndo: function (ds, post) {
        ds._fireRefresh(this);
        post.cnt > 0 && ds._fireRowCountChanged(this);
    },
    _doKeep: function (ds, save) {
        return ds.$_saveAll(this, {}, false);
    },
    _doRun: function (ds, save) {
        var source, count,
            rows = this.rows,
            rowsProp = this.rowsProp,
            childRowsProp = this.childRowsProp,
            currency = this.currency,
            filter = this.filter;
        if (!ds.isAppendable()) {
            return this.throwEmpty(0);
        }
        if (ds.rowCount() > 0 && !ds.isDeletable()) {
            return this.throwEmpty(0);
        }
        ds.refreshFieldFormats();
        if (save) {
            ds.$_saveAll(this, save, true);
            this._setReady();
        }
        ds.beginUpdate();
        try {
            ds.$_clearRows();
            if (rows) {
                source = new JsonTreeSource(ds, ds._rootRow);
                count = source.load(null, 0, rows, rowsProp, childRowsProp, currency, filter);
                ds._checkSum(count);
            }
        } finally {
            ds.endUpdate(false);
        }
        ds.setDataInited(true);
        ds._tags.setRows();
        !save && this._doPostRun(ds);
        return ds.rowCount();
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireRefresh(cmd);
        ds._fireRowCountChanged(cmd);
    },
    _doRedo: function (ds, keep) {
        ds.$_restoreAll(this, keep, true);
        ds._tags.setRows();
    },
    _doPostRedo: function (ds) {
        ds._fireRefresh(this);
        ds._fireRowCountChanged(this);
    }
});
var TreeDataSetValueCommand = defineClass("TreeDataSetValueCommand", DataSetEditCommand, {
    init: function (ds, row, field, newValue, checkDiff, strictDiff, noEvent) {
        this._super(ds);
        this.row = row;
        this.field = field;
        this.newValue = newValue;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.noEvent = noEvent;
    },
    $_updating: function () {
        return true;
    },
    _doUndo: function (ds, save) {
        var row = this.row,
            field = this.field;
        row._values = save.values;
        row._state = save.state;
        row._orgValues = save.orgValues;
    },
    _doPostUndo: function (ds) {
        ds._valueChanged(this, this.row, this.field);
    },
    _doKeep: function (ds, save) {
        var row = this.row,
            keep = {};
        keep.values = row._values.concat();
        keep.state = row._state;
        keep.orgVals = row._orgValues;
        return keep;
    },
    _doRun: function (ds, save) {
        var row = this.row,
            field = this.field,
            newValue = this.newValue;
        this.row = row = ds.$_getRow(row);
        if (row) {
            if (row.$_setValue(field, newValue, false, this.checkDiff, this.strictDiff, this.noEvent, save, ds.$_cmd(this))) {
                !save && this._doPostRun(ds);
                return true;
            }
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        if (!this.noEvent) {
            var cmd = ds.$_cmd(this);
            ds._valueChanged(cmd, this.row, this.field);
        }
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            field = this.field;
        row._values = keep.values;
        row._state = keep.state;
        row._orgValues = keep.orgVals;
    },
    _doPostRedo: function (ds) {
        ds._valueChanged(this, this.row, this.field);
    }
});
var TreeDataUpdateRowCommand = defineClass("TreeDataUpdateRowCommand", DataSetEditCommand, {
    init: function (ds, row, values, checkDiff, strictDiff, checkEmpty, noState) {
        this._super(ds);
        this.row = row;
        this.values = values;
        this.checkDiff = checkDiff;
        this.strictDiff = strictDiff;
        this.checkEmpty = checkEmpty;
        this.noState = noState;
    },
    $_updating: function () {
        return true;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        row._values = save.values;
        row._state = save.state;
        row._orgValues = save.orgValues;
        ds._tags.$_restoreRow(this, row);
    },
    _doPostUndo: function (ds) {
        ds._rowUpdated(this, this.row);
    },
    _doKeep: function (ds, save) {
        var row = this.row,
            keep = {};
        keep.values = row._values.concat();
        keep.state = row._state;
        keep.orgValues = row._orgValues;
        return keep;
    },
    _doRun: function (ds, save) {
        var row = this.row,
            values = this.values,
            checkDiff = this.checkDiff,
            strictDiff = this.strictDiff,
            checkEmpty = this.checkEmpty,
            noState = this.noState;
        this.row = row = ds.$_getRow(row);
        if (row) {
            if (row.$_update(values, checkDiff, strictDiff, checkEmpty, false, !noState, save, ds.$_cmd(this))) {
                if (save) {
                    ds._tags.$_saveRow(this, row);
                }
                !save && this._doPostRun(ds);
                return true;
            }
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._rowUpdated(cmd, this.row);
    },
    _doRedo: function (ds, keep) {
        var row = this.row;
        ds._tags.$_saveRow(this, row);
        row._values = keep.values;
        row._state = keep.state;
        row._orgValues = keep.orgVals;
    },
    _doPostRedo: function (ds) {
        ds._rowUpdated(this, this.row);
    }
});
var TreeDataInsertRowCommand = defineClass("TreeDataInsertRowCommand", DataSetEditCommand, {
    init: function (ds, parent, index, values, noState, field) {
        this._super(ds);
        this.parent = parent;
        this.index = index;
        this.values = values;
        this.noState = noState;
        this.field = field === undefined ? -1 : field;
    },
    _doUndo: function (ds, save) {
        var parent = this.parent,
            index = this.index,
            child = this.child;
        parent.$$_removeChild(child, index);
    },
    _doPostUndo: function (ds) {
        ds._rowRemoved(this, this.child);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var cmd = ds.$_cmd(this),
            parent = this.parent,
            index = this.index,
            values = this.values,
            noState = this.noState;
        this.parent = parent = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        if (!parent) {
            return this.throwEmpty(null);
        }
        if (index < 0 || index > parent.count()) {
            throw new RangeError("'index' is invalid: " + index);
        }
        ds._fireRowCreating(cmd, parent, index, values);
        var child = this.child = ds.createRow(values, this.field);
        if (child && ds._rowAdding(cmd, parent, index, child, this.field)) {
            this._setReady();
            parent.$$_insertChild(cmd, index, child, noState);
            !save && this._doPostRun(ds);
            ds.setDataInited(true);
            return child;
        }
        return this.throwEmpty(null);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._rowAdded(cmd, this.index, this.child, this.field);
    },
    _doRedo: function (ds, keep) {
        var parent = this.parent,
            index = this.index,
            child = this.child,
            noState = this.noState;
        parent.$$_insertChild(this, index, child, noState)
        return child;
    },
    _doPostRedo: function (ds) {
        ds._rowAdded(this, this.index, this.child, this.field);
    }
});
var TreeDataInsertRowsCommand = defineClass("TreeDataInsertRowsCommand", DataSetEditCommand, {
    init: function (ds, parent, index, rows, rowEvents, noState) {
        this._super(ds);
        this.parent = parent;
        this.index = index;
        this.rows = rows;
        this.rowEvents = rowEvents;
        this.noState = noState;
    },
    _doUndo: function (ds, save, post) {
        var parent = this.parent,
            index = this.index;
        parent.$_removeChildren(index, save.rows);
        post.rows = save.rows;
    },
    _doPostUndo: function (ds, post) {
        ds._rowsRemoved(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            children: save.rows.slice()
        };
    },
    _doRun: function (ds, save, post) {
        var children, i, cnt, values, child, rows,
            cmd = ds.$_cmd(this),
            parent = this.parent,
            index = this.index,
            rows = this.rows,
            rowEvents = this.rowEvents && !save, // undoable일 때 rowEvents를 사용할 수 없다.
            noState = this.noState;
        this.parent = parent = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        if (!parent) {
            return this.throwEmpty(null);
        }
        if (index < 0 || index > parent.count()) {
            throw new RangeError("'index' is invalid: " + index);
        }
        if (save) {
            save.rows = [];
        }
        ds._fireRowsCreating(cmd, parent, index, rows);
        children = [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            values = rows[i];
            child = ds.createRow(values);
            child && children.push(child);
        }
        if (children.length > 0) {
            rows = parent._insertChildren(index, children, rowEvents, noState, save, cmd);
            if (rows.length > 0) {
                post.rows = rows;
                !save && this._doPostRun(ds, post);
                ds.setDataInited(true);
                return rows;
            }
        }
        return this.throwEmpty(null);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._rowsAdded(cmd, this.parent, this.index, post.rows, this.rowEvents);
    },
    _doRedo: function (ds, keep, post) {
        var rows,
            parent = this.parent,
            index = this.index,
            noState = this.noState;
        rows = parent.$_insertChildren(this, index, keep.children, noState);
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._rowsAdded(this, this.parent, this.index, post.rows);
    }
});
var TreeDataInsertDataRowsCommand = defineClass("TreeDataInsertDataRowsCommand", DataSetEditCommand, {
    init: function (ds, parent, index, rows, treeField, useTreeField, needSorting, filter) {
        this._super(ds);
        this.parent = parent;
        this.index = index;
        this.rows = rows;
        this.treeField = treeField;
        this.useTreeField = useTreeField;
        this.needSorting = needSorting;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var parent = this.parent,
            index = this.index;
        parent.$_removeChildren(index, save.rows);
        post.rows = save.rows;
    },
    _doPostUndo: function (ds, post) {
        ds._rowsRemoved(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            children: save.rows.slice()
        };
    },
    _doRun: function (ds, save, post) {
        var cnt, source, root,
            parent = this.parent,
            index = this.index,
            rows = this.rows,
            treeField = this.treeField,
            useTreeField = this.useTreeField,
            needSorting = this.needSorting,
            filter = this.filter;
        parent = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        if (!parent) {
            return this.throwEmpty(null);
        }
        if (index < 0 || index > parent.count()) {
            throw new RangeError("'index' is invalid: " + index);
        }
        if (rows) {
            ds.refreshFieldFormats();
            source = new ArrayTreeSource(ds, ds._rootRow);
            source.checkParentProc = ds.checkParentProc;
            try {
                root = new ds._rowClass();
                source._loadData(rows, root, treeField, useTreeField, needSorting, filter);
                rows = root.children();
                root._children = null;
                if (rows && rows.length > 0) {
                    this.parent = parent = parent || this._rootRow;
                    rows = parent._insertChildren(index, rows, false, false, save, ds.$_cmd(this));
                    if (rows.length > 0) {
                        post.rows = rows;
                        !save && this._doPostRun(ds, post);
                        ds.setDataInited(true);
                        return rows;
                    }
                }
            } finally {
                source = null;
            }
        }
        return this.throwEmpty(null);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._rowsAdded(cmd, this.parent, this.index, post.rows);
    },
    _doRedo: function (ds, keep, post) {
        var rows,
            parent = this.parent,
            index = this.index;
        post.rows = parent.$_insertChildren(this, index, keep.children, false);
    },
    _doPostRedo: function (ds, post) {
        ds._rowsAdded(this, this.parent, this.index, post.rows);
    }
});
var TreeDataInsertXmlRowsCommand = defineClass("TreeDataInsertXmlRowsCommand", DataSetEditCommand, {
    init: function (ds, parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        this._super(ds);
        this.parent = parent;
        this.index = index;
        this.rows = rows;
        this.rowsProp = rowsProp;
        this.childRowsProp = childRowsProp;
        this.currency = currency;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var parent = this.parent,
            index = this.index;
        parent.$_removeChildren(index, save.rows);
        post.rows = save.rows;
    },
    _doPostUndo: function (ds, post) {
        ds._rowsRemoved(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            children: save.rows.slice()
        };
    },
    _doRun: function (ds, save, post) {
        var cnt, source, root, newRows,
            parent = this.parent,
            index = this.index,
            rows = this.rows,
            rowsProp = this.rowsProp,
            childRowsProp = this.childRowsProp,
            currency = this.currency,
            filter = this.filter;
        parent = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        if (!parent) {
            return this.throwEmpty(null);
        }
        if (index < 0 || index > parent.count()) {
            throw new RangeError("'index' is invalid: " + index);
        }
        if (rows) {
            ds.refreshFieldFormats();
            source = new XmlTreeSource(ds, ds._rootRow);
            try {
                root = new ds._rowClass();
                source._loadData(rows, root, 0, rowsProp, childRowsProp, currency, true, filter, save);
                newRows = root.children();
                root_children = null;
                if (newRows && newRows.length > 0) {
                    this.parent = parent = parent || this._rootRow;
                    rows = parent._insertChildren(index, newRows, false, false, save, ds.$_cmd(this));
                    if (rows.length > 0) {
                        post.rows = rows;
                        !save && this._doPostRun(ds, post);
                        ds.setDataInited(true);
                        return rows;
                    }
                }
            } finally {
                source = null;
            }
        }
        return this.throwEmpty(null);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._rowsAdded(cmd, this.parent, this.index, post.rows);
    },
    _doRedo: function (ds, keep, post) {
        var rows,
            parent = this.parent,
            index = this.index;
        post.rows = parent.$_insertChildren(this, index, keep.children, false);
    },
    _doPostRedo: function (ds, post) {
        ds._rowsAdded(this, this.parent, this.index, post.rows);
    }
});
var TreeDataInsertJsonRowsCommand = defineClass("TreeDataInsertJsonRowsCommand", DataSetEditCommand, {
    init: function (ds, parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        this._super(ds);
        this.parent = parent;
        this.index = index;
        this.rows = rows;
        this.rowsProp = rowsProp;
        this.childRowsProp = childRowsProp;
        this.currency = currency;
        this.filter = filter;
    },
    _doUndo: function (ds, save, post) {
        var parent = this.parent,
            index = this.index;
        parent.$_removeChildren(index, save.rows);
        post.rows = save.rows;
    },
    _doPostUndo: function (ds, post) {
        ds._rowsRemoved(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            children: save.rows.slice()
        };
    },
    _doRun: function (ds, save, post) {
        var cnt, source, newRows,
            parent = this.parent,
            index = this.index,
            rows = this.rows,
            rowsProp = this.rowsProp,
            childRowsProp = this.childRowsProp,
            currency = this.currency,
            filter = this.filter;
        parent = (parent === null || parent === undefined) ? ds._rootRow : ds.$_getRow(parent);
        if (!parent) {
            return this.throwEmpty(null);
        }
        if (index < 0 || index > parent.count()) {
            throw new RangeError("'index' is invalid: " + index);
        }
        if (rows) {
            ds.refreshFieldFormats();
            source = new JsonTreeSource(ds, ds._rootRow);
            try {
                root = new ds._rowClass();
                source._loadData(rows, root, 0, rowsProp, childRowsProp, currency, true, filter);
                newRows = root.children();
                root_children = null;
                if (newRows && newRows.length > 0) {
                    this.parent = parent = parent || this._rootRow;
                    newRows = parent._insertChildren(index, newRows, false, false, save, ds.$_cmd(this));
                    if (newRows.length > 0) {
                        post.rows = newRows;
                        !save && this._doPostRun(ds, post);
                        ds.setDataInited(true);
                        return newRows;
                    }
                }
            } finally {
                source = null;
            }
        }
        return this.throwEmpty(null);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._rowsAdded(cmd, this.parent, this.index, post.rows);
    },
    _doRedo: function (ds, keep, post) {
        var rows,
            parent = this.parent,
            index = this.index;
        post.rows = parent.$_insertChildren(this, index, keep.children, false);
    },
    _doPostRedo: function (ds, post) {
        ds._rowsAdded(this, this.parent, this.index, post.rows);
    }
});
var TreeDataDeleteRowCommand = defineClass("TreeDataDeleteRowCommand", DataSetEditCommand, {
    init: function (ds, row) {
        this._super(ds);
        this.row = row;
    },
    _doUndo: function (ds, save, post) {
        var i, parent, index, state, states, stateRows, r,
            ds = this.ds,
            row = this.row;
        parent = save.parent;
        index = save.index;
        state = save.state;
        states = save.states;
        if (ds.softDelete() && ds.checkStates()) {
            stateRows = [row];
            row._changeRowState(this, state, false, true);
            for (i = states.children.length; i--;) {
                r = states.children[i];
                r._changeRowState(this, states.states[i], false);
                stateRows.push(r);
            }
            ds._tags.$_restoreRow(this, row);
            post.states = stateRows;
        } else {
            parent.$_insertChild(this, index, row, true, true);
            ds._tags.$_restoreRow(this, row, true);
            post.parent = parent;
            post.index = index;
        }
    },
    _doPostUndo: function (ds, post) {
        if (post.states) {
            ds._statesChanged(this, post.states);
        } else {
            ds._rowAdded(this, post.index, this.row)
        }
    },
    _doKeep: function (ds, save) {
        var i, r, rows, states,
            keep = {},
            saveRows = save.states.children,
            saveStates = save.states.states;
        if (ds.softDelete() && ds.checkStates()) {
            rows = keep.rows = [];
            states = keep.states = [];
            rows.push(this.row);
            states.push(this.row._state);
            for (i = saveRows.length; i--;) {
                rows.push(r = saveRows[i]);
                states.push(r._state);
            }
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var states, p, sv,
            row = this.row;
        this.row = row = ds.$_getRow(row);
        if (row && row.dataSet() === ds) {
            this.parent = p = row.parent();
            if (p) {
                if (ds._rowRemoving(this, row)) {
                    sv = save || {};
                    sv.parent = p;
                    sv.index = p._children.indexOf(row);
                    sv.state = row.rowState();
                    sv.states = states = {children: [], states: []};
                    this._setReady();
                    ds._tags.$_saveRow(this, row, true);
                    if (p._removeChild(row, false, states, ds.$_cmd(this))) {
                        if (ds.softDelete() && ds.checkStates()) {
                            post.states = sv.states.children.concat(row);
                        }
                        !save && this._doPostRun(ds, post);
                        return true;
                    }
                }
            }
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.states) {
            ds._statesChanged(cmd, post.states);
        } else {
            ds._rowRemoved(cmd, this.row);
        }
    },
    _doRedo: function (ds, keep, post) {
        var i, rows, states,
            row = this.row;
        states = keep.states;
        if (states) {
            rows = keep.rows;
            for (i = rows.length; i--;) {
                rows[i]._changeRowState(this, states[i], false);
            }
            post.rows = rows;
        } else {
            this.parent._removeChild(row, false, states, ds.$_cmd(this));
        }
        ds._tags.$_saveRow(this, row, true);
    },
    _doPostRedo: function (ds, post) {
        if (post.rows) {
            ds._statesChanged(this, post.rows);
        } else {
            ds._rowRemoved(this, this.row);
        }
    }
});
var TreeDataDeleteRowsCommand = defineClass("TreeDataDeleteRowsCommand", DataSetEditCommand, {
    init: function (ds, rows) {
        this._super(ds);
        this.rows = rows;
    },
    _doUndo: function (ds, save, post) {
        var rows, ids, stateRows, states,
            i, row, changed, countChanged;
        parents = save.parents;
        rows = save.rows;
        ids = save.ids;
        stateRows = save.states.children;
        states = save.states.states;
        if (rows && rows.length > 0) {
            for (i = 0; i < rows.length; i++) {
                row = rows[i];
                parents[i].$$_insertChild(this, ids[i], row, true)
            }
            ds._tags.$_restoreRows(this, rows, true);
            post.rows = rows;
        }
        if (stateRows && stateRows.length > 0) {
            for (i = stateRows.length; i--;) {
                row = stateRows[i];
                row._changeRowState(this, states[i], false, true);
            }
            ds._tags.$_restoreRows(this, stateRows, true);
            post.states = stateRows;
        }
    },
    _doPostUndo: function (ds, post) {
        if (post.rows) {
            ds._rowsInserted(this, post.rows);
        }
        if (post.states) {
            ds._statesChanged(this, post.states);
        }
    },
    _doKeep: function (ds, save) {
        var i, len, keep = {};
        if (save.rows && save.rows.length > 0) {
            keep.rows = save.rows;
        }
        if (save.states.children && (len = save.states.children.length) > 0) {
            keep.stateRows = save.states.children;
            keep.states = new Array(len);
            for (i = 0; i < len; i++) {
                keep.states[i] = keep.stateRows[i]._state;
            }
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var i, cnt, //row, st, changed, stateRows,
            sv = save || {},
            rows = this.rows;
        if (!rows || rows.length < 1) {
            return this.throwEmpty(0);
        }
        for (i = rows.length; i--;) {
            rows[i] = ds.$_getRow(rows[i]);
        }
        rows = ds.arrangeRows(rows);
        if (rows.length < 1 || !ds._rowsRemoving(this, rows)) {
            return this.throwEmpty(0);
        }
        this.rows = rows.slice();
        sv.states = { children: [], states: [] };
        this._setReady();
        cnt = ds.$_removeRows(this, rows, sv, this);
        post.rows = sv.rows;
        post.states = sv.states.children;
        !save && this._doPostRun(ds, post);
        return cnt;
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        if (post.states) {
            ds._statesChanged(cmd, post.states);
        }
        if (post.rows) {
            ds._rowsRemoved(cmd, post.rows);
        }
    },
    _doRedo: function (ds, keep, post) {
        var i;
        var rows = keep.rows;
        var stateRows = keep.stateRows;
        var states = keep.states;
        if (rows) {
            ds.$_removeRows(this, rows, null, this);
        }
        if (stateRows) {
            for (i = stateRows.length; i--;) {
                stateRows[i]._changeRowState(this, states[i], false);
            }
        }
        post.rows = rows;
        post.states = stateRows;
    },
    _doPostRedo: function (ds, post) {
        if (post.states) {
            ds._statesChanged(this, post.states);
        }
        if (post.rows) {
            ds._rowsRemoved(this, post.rows);
        }
    }
});
var TreeDataSetRowStateCommand = defineClass("TreeDataSetRowStateCommand", DataSetEditCommand, {
    init: function (ds, row, newState, force) {
        this._super(ds);
        this.row = row;
        this.newState = newState;
        this.force = force;
    },
    _doUndo: function (ds, save) {
        var row = this.row,
            state = save.state;
        row._changeRowState(this, state, false, true);
    },
    _doPostUndo: function (ds) {
        ds._stateChanged(this, this.row);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var state,
            row = this.row,
            newState = this.newState,
            force = this.force;
        this.row = row = ds.$_getRow(row);
        if (row) {
            save && (save.state = row.rowState());
            this._setReady();
            if (row._changeRowState(this, newState, false, force)) {
                !save && this._doPostRun(ds);
                return true;
            }
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._stateChanged(cmd, this.row);
    },
    _doRedo: function (ds, keep) {
        this.row._changeRowState(this, this.newState, false, true);
    },
    _doPostRedo: function (ds) {
        ds._stateChanged(this, this.row);
    }
});
var TreeDataSetRowStatesCommand = defineClass("TreeDataSetRowStatesCommand", DataSetEditCommand, {
    init: function (ds, rows, newState, force, rowEvents) {
        this._super(ds);
        this.rows = rows;
        this.newState = newState;
        this.force = force;
        this.rowEvents = rowEvents;
    },
    _doUndo: function (ds, save, post) {
        var i, row, states, rows;
        rows = save.rows;
        states = save.states;
        for (i = rows.length; i--;) {
            row = rows[i];
            row && row._changeRowState(this, states[i], false);
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._statesChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        var i, r,
            cnt = save.rows.length,
            keep = {},
            rows = keep.rows = new Array(cnt),
            states = keep.states = new Array(cnt);
        for (i = 0; i < cnt; i++) {
            rows[i] = r = save.rows[i];
            states[i] = r._state;
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows, i, cnt, row, changedRows, states, oldState,
            rows = this.rows,
            newState = this.newState,
            force = this.force,
            rowEvents = this.rowEvents && !save; // undoable일 때 rowEvents를 사용할 수 없다.
        if (!ds._checkStates && !force) {
            return this.throwEmpty(false);
        }
        if (save) {
            save = this.save = {};
            states = save.states = [];
            saveRows = save.rows = [];
            this._setReady();
        }
        changedRows = rowEvents ? null : [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            rows[i] = row = ds.$_getRow(rows[i]);
            if (row) {
                oldState = row.rowState();
                if (row._changeRowState(this, newState, rowEvents)) {
                    !rowEvents && changedRows.push(row);
                    if (save) {
                        saveRows.push(row);
                        states.push(oldState);
                    }
                }
            }
        }
        if (changedRows && changedRows.length > 0) {
            post.rows = changedRows;
            !save && this._doPostRun(ds, post);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._statesChanged(cmd, post.rows);
    },
    _doRedo: function (ds, keep, post) {
        var i, cnt, row,
            states = keep.states,
            rows = keep.rows;
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = rows[i];
            row && row._changeRowState(this, states[i]);
        }
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._statesChanged(this, post.rows);
    }
});
var TreeDataClearRowStatesCommand = defineClass("TreeDataClearRowStatesCommand", DataSetEditCommand, {
    init: function (ds, states, deleteRows, rowEvents) {
        this._super(ds);
        this.states = states;
        this.deleteRows = deleteRows;
        this.rowEvents = rowEvents;
    },
    _doUndo: function (ds, save, post) {
        var deletes, rows, states, i, row, p;
        deletes = save.deletes;
        parents = save.parents;
        rows = save.rows;
        states = save.states;
        if (deletes) {
            for (i = deletes.length; i--;) {
                p = parents[i];
                row = deletes[i];
                p.$$_insertChild(this, ids[i], row);
            }
            post.deletes = deletes;
        }
        if (rows.length > 0) {
            for (i = rows.length; i--;) {
                row = rows[i];
                row._changeRowState(this, states[i], false);
            }
            post.rows = rows;
        }
    },
    _doPostUndo: function (ds, post) {
        if (post.rows && post.rows.length > 0) {
            ds._statesChanged(this, post.rows);
        }
        if (post.deletes && post.deletes.length > 0) {
            ds._rowsInserted(this, post.deletes);
        }
    },
    _doKeep: function (ds, save) {
        var keep = {};
        return keep;
    },
    _doRun: function (ds, save) {
        var states = this.states,
            deleteRows = this.deleteRows,
            rowEvents = this.rowEvents && !save; // undoable일 때 rowEvents를 사용할 수 없다.
        this._setReady();
        if (ds._rootRow.$_clearRowStates(ds.$_cmd(this), states, deleteRows, rowEvents, true, save)) {
            if (!rowEvents) {
                !save && this._doPostRun(ds);
            }
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireStatesCleared(cmd);
    },
    _doRedo: function (ds, keep) {
        var states = this.states,
            deleteRows = this.deleteRows;
        ds._rootRow.$_clearRowStates(this, states, deleteRows, false, true);
    },
    _doPostRedo: function (ds) {
        ds._fireStatesCleared(this);
    }
});
var TreeDataRestoreUpdatedStatesCommand = defineClass("TreeDataRestoreUpdatedStatesCommand", DataSetEditCommand, {
    init: function (ds, rows) {
        this._super(ds);
        this.rows = rows;
    },
    _doUndo: function (ds, save, post) {
        var i, row;
        if (_isArray(save.rows)) {
            for (i = save.rows.length; i--;) {
                save.rows[i]._changeRowState(this, DataRowState.UPDATED, false);
                save.rows[i]._orgValues = save.orgs[i];
            }
            post.rows = save.rows;
        } else {
            save.rows._orgValues = save.orgs;
            save.rows._changeRowState(this, DataRowState.UPDATED, false, true);
            post.row = save.rows;
        }
    },
    _doPostUndo: function (ds, post) {
        if (post.rows) {
            ds._statesChanged(this, post.rows);
        } else if (post.row) {
            ds._stateChanged(this, post.row);
        }
    },
    _doKeep: function (ds, save) {
        var keep = {};
        keep.rows = _isArray(save.rows) ? save.rows.concat() : save.rows;
        return keep;
    },
    _doRun: function (ds, save, post) {
        var row, list, orgVals,
            rows = this.rows;
        list = [];
        save && (vals = []);
        this._setReady();
        if (rows === undefined || rows === null) {
            ds._rootRow.$_restoreState(true, list, vals);
        } else if (_isArray(rows)) {
            for (var i = rows.length; i--;) {
                rows[i] = row = ds.$_getRow(rows[i]);
                if (row) {
                    save && (orgVals = row._orgValues);
                    if (row.$_restoreState(false)) {
                        list.push(row);
                        save && vals.push(orgVals);
                    }
                }
            }
        } else if (row = rows) {
            row = ds.$_getRow(row);
            if (row) {
                save && (orgVals = row._orgValues);
                if (row.$_restoreState(false)) {
                    list.push(row);
                    save && vals.push(orgVals);
                }
            }
        }
        post.list = list;
        if (list.length == 1) {
            if (save) {
                save.rows = list[0];
                save.orgs = vals[0];
            }
            !save && this._doPostRun(ds, post);
            return true;
        } else if (list.length > 1) {
            if (save) {
                save.rows = list;
                save.orgs = vals;
            }
            !save && this._doPostRun(ds, post);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        var list = post.list;
        if (list.length == 1) {
            ds._stateChanged(cmd, list[0]);
        } else if (list.length > 1) {
            ds._statesChanged(cmd, list);
        }
    },
    _doRedo: function (ds, keep, post) {
        var i, rows = keep.rows;
        if (_isArray(rows)) {
            for (i = rows.length; i--;) {
                rows[i]._state = DataRowState.NONE;
                delete rows[i]._orgValues;
            }
            post.rows = rows;
        } else {
            keep.rows._state = DataRowState.NONE;
            delete keep.rows._orgValues;
            post.row = rows;
        }
    },
    _doPostRedo: function (ds, post) {
        if (post.rows) {
            ds._statesChanged(this, rows);
        } else {
            ds._stateChanged(this, post.row);
        }
    }
});
var TreeDataRestoreUpdatedRowsCommand = defineClass("TreeDataRestoreUpdatedRowsCommand", DataSetEditCommand, {
    init: function (ds, rows) {
        this._super(ds);
        this.rows = rows;
    },
    _doUndo: function (ds, save, post) {
        var rows, vals, orgs, i, row;
        rows = save.rows;
        vals = save.vals;
        orgs = save.orgs;
        for (i = rows.length; i--;) {
            row = rows[i];
            row._values = vals[i];
            row._orgValues = orgs[i];
            row._changeRowState(this, DataRowState.UPDATED, false);
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._rowsUpdated(this, post.rows);
    },
    _doKeep: function (ds, save) {
        var i,
            rows = save.rows,
            vals = save.vals,
            keep = {};
        keep.rows = rows && rows.concat();
        keep.vals = [];
        for (i = 0; i < rows.length; i--) {
            keep.vals.push(vals[i].concat());
        }
        return keep;
    },
    _doRun: function (ds, save, post) {
        var saveRows, saveVals, orgVals,
            row, oldVals, list,
            rows = this.rows;
        if (save) {
            saveVals = save.vals = [];
            orgVals = save.orgs = [];
            this._setReady();
        }
        list = [];
        if (rows === undefined || rows === null) {
            ds._rootRow.$_restoreRow(true, list, saveVals, orgVals);
        } else if (_isArray(rows)) {
            for (var i = rows.length; i--;) {
                rows[i] = row = ds.$_getRow(rows[i]);
                if (row) {
                    row.$_restoreRow(false, list, saveVals, orgVals);
                }
            }
        } else if (row = rows) {
            row = ds.$_getRow(row);
            if (row) {
                row.$_restoreRow(false, list, saveVals, orgVals);
            }
        }
        if (list.length > 0) {
            save && (save.rows = list.concat());
            post.list = list;
            !save && this._doPostRun(ds, post);
        } else {
            return this.throwEmpty(false);
        }
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._statesChanged(cmd, post.list);
    },
    _doRedo: function (ds, keep, post) {
        var i, row, list,
            rows = keep.rows,
            vals = keep.vals;
        list = [];
        for (i = 0; i < rows.length; i++) {
            row = rows[i];
            row._values = vals[i];
            delete row._orgValues;
            row._state = DataRowState.NONE;
            list.push(row);
        }
        post.list = list;
    },
    _doPostRedo: function (ds, post) {
        ds._statesChanged(this, post.list);
    }
});
var TreeDataSetRowTagCommand = defineClass("TreeDataSetRowTagCommand", DataSetEditCommand, {
    init: function (ds, row, tag) {
        this._super(ds);
        this.row = row;
        this.tag = tag;
    },
    _doUndo: function (ds, save) {
        var row = this.row;
        row._tag = save.tag;
    },
    _doPostUndo: function (ds) {
        ds._fireTagChanged(this, this.row);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var oldTag,
            row = this.row,
            tag = this.tag;
        row = this.row = ds.$_getRow(row);
        if (row && tag !== (oldTag = row._tag)) {
            save && (save.tag = oldTag);
            this._setReady();
            row._tag = tag;
            !save && this._doPostRun(ds);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireTagChanged(cmd, this.row);
    },
    _doRedo: function (ds, keep) {
        var row = this.row,
            tag = this.tag;
        row._tag = tag;
    },
    _doPostRedo: function (ds) {
        ds._fireTagChanged(this, this.row);
    }
});
var TreeDataSetRowTagsCommand = defineClass("TreeDataSetRowTagsCommand", DataSetEditCommand, {
    init: function (ds, rows, tag) {
        this._super(ds);
        this.rows = rows;
        this.tag = tag;
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            rows[i]._tag = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            rows: save.rows
        };
    },
    _doRun: function (ds, save, post) {
        var save, row,
            list = [],
            rows = this.rows,
            tag = this.tag;
        if (save) {
            save.rows = [];
            save.tags = [];
            this._setReady();
        }
        if ((rows === null || rows === undefined) && (cnt = ds.rowCount()) > 0) {
            ds._rootRow.visitAll(function (row) {
                if (tag !== row._tag) {
                    save && save.tags.push(row._tag);
                    row._tag = tag;
                    list.push(row);
                }
            });
        } else if (rows && (cnt = rows.length) > 0) {
            for (i = 0; i < cnt; i++) {
                row = ds.$_getRow(rows[i]);
                if (row && tag !== row._tag) {
                    save && save.tags.push(row._tag);
                    row._tag = tag;
                    list.push(row);
                }
            }
        }
        if (list.length > 0) {
            save && (save.rows = list);
            post.list = list;
            !save && this._doPostRun(ds, post);
            return list.length;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireTagsChanged(cmd, post.list);
    },
    _doRedo: function (ds, keep, post) {
        var i,
            rows = keep.rows;
        for (i = rows.length; i--;) {
            rows[i]._tag = this.tag;
        }
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    }
});
var TreeDataUnsetRowTagsCommand = defineClass("TreeDataUnsetRowTagsCommand", DataSetEditCommand, {
    init: function (ds, rows, tags) {
        this._super(ds);
        this.rows = rows;
        this.tags = tags;
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            rows[i]._tag = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return {
            rows: save.rows
        }
    },
    _doRun: function (ds, save, post) {
        var row, t,
            list = [],
            rows = this.rows,
            tags = this.tags;
        if (save) {
            save.tags = [];
            this._setReady();
        }
        if (rows && tags) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                row = ds.$_getRow(rows[i]);
                if (row) {
                    t = row._tag;
                    if (tags.indexOf(t) >= 0) {
                        save && save.tags.push(t);
                        row._tag = undefined;
                        list.push(row);
                    }
                }
            }
        } else if (rows) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                row = ds.$_getRow(rows[i]);
                if (row) {
                    t = row._tag;
                    if (t !== undefined) {
                        save && save.tags.push(t);
                        row._tag = undefined;
                        list.push(row);
                    }
                }
            }
        } else if (tags) {
            ds._rootRow.visitAll(function (row) {
                t = row._tag;
                if (tags.indexOf(t) >= 0) {
                    save && save.tags.push(t);
                    row._tag = undefined;
                    list.push(row);
                }
            })
        }
        if (list.length > 0) {
            save && (save.rows = list);
            post.list = list;
            !save && this._doPostRun(ds, post);
            return true;
        }
        return this.throwEmpty(false);
    },
    _doPostRun: function (ds, post) {
        var cmd = ds.$_cmd(this);
        ds._fireTagsChanged(cmd, post.list);
    },
    _doRedo: function (ds, keep, post) {
        var i,
            rows = keep.rows;
        for (i = rows.length; i--;) {
            rows[i]._tag = undefined;
        }
        post.rows = rows;
    },
    _doPostRedo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    }
});
var TreeDataClearRowTagsCommand = defineClass("TreeDataClearRowTagsCommand", DataSetEditCommand, {
    init: function (ds) {
        this._super(ds);
    },
    _doUndo: function (ds, save, post) {
        var i,
            rows = save.rows,
            tags = save.tags;
        for (i = rows.length; i--;) {
            rows[i]._tag = tags[i];
        }
        post.rows = rows;
    },
    _doPostUndo: function (ds, post) {
        ds._fireTagsChanged(this, post.rows);
    },
    _doKeep: function (ds, save) {
        return this.Empty();
    },
    _doRun: function (ds, save) {
        var t, list = [];
        if (save) {
            save.rows = [];
            save.tags = [];
            this._setReady();
        }
        ds._rootRow.visitAll(function (row) {
            t = row._tag;
            if (t !== undefined) {
                save && save.rows.push(row);
                list.push(t);
                row._tag = undefined;
            }
        });
        if (list.length < 1) {
            return this.throwEmpty(false);
        }
        if (save) {
            save.tags = list;
        }
        !save && this._doPostRun(ds);
        return true;
    },
    _doPostRun: function (ds) {
        var cmd = ds.$_cmd(this);
        ds._fireTagsCleared(cmd);
    },
    _doRedo: function (ds, keep) {
        ds._rootRow.visitAll(function (row) {
            row._tag = undefined;
        });
    },
    _doPostRedo: function (ds) {
        ds._fireTagsCleared(this);
    }
});
/** @internal */
var TreeDataFilterRuntime = defineClass("TreeDataFilterRuntime", ExpressionRuntime, {
	init: function () {
		TreeDataFilterRuntime.Base.init.call(this);
		this._provider = null;
		this._fieldCount = 0;
		this._no = -1;
		this._parent = null;
		this._index = -1;
		this._values = null;
	},
	prepare: function (provider) {
		this._provider = provider;
		this._fieldCount = provider ? provider.fieldCount() : 0;
		return this;
	},
	setRow: function (no, parent, index, values) {
		this._no = no;
		this._parent = parent;
		this._index = index;
		this._values = values;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (TreeDataFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return TreeDataFilterRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case TreeDataFilterRuntime.ID_NO:
				return this._no;
			case TreeDataFilterRuntime.ID_PARENT:
				return this._parent.rowId();
			case TreeDataFilterRuntime.ID_INDEX:
				return this._index;
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
			case TreeDataFilterRuntime.ID_VALUES:
				return this._values[index];
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index) {
		switch (idKey) {
			case TreeDataFilterRuntime.ID_VALUES:
				var field = this.$_getField(index);
				return this._values[field];
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	$_getField: function (index) {
		var	fld = this._provider.getFieldIndex(index);
		if (fld < 0 || fld >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field is not exits:" + index);
		}
		return fld;
	}
}, {
	ID_NO: 0,
	ID_PARENT: 1,
	ID_INDEX: 2,
	ID_VALUES: 3
}, function (f) {
	f.IDENTS = {
		no: f.ID_NO,
		row: f.ID_ROW,
		values: f.ID_VALUES
	};
});
var TreeDataFilter = defineClass("TreeDataFilter", null, {
	init: function (criteria) {
		this._super();
		this._runtime = null;
		this._exprNode = null;
		this.setCriteria(criteria);
	},
	criteria: null,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			if (value) {
				this._exprNode = ExpressionParser.Default.parse(value);
			} else {
				this._exprNode = null;
			}
		}
	},
	prepare: function (runtime) {
		this._runtime = runtime;
	},
	select: function (no, parent, index, values) {
		if (this._exprNode) {
			this._runtime.setRow(no, parent, index, values);
			return this._exprNode.evaluate(this._runtime);
		} else {
			return true;
		}
	}
});
/** @abstract */
var TreeDataRow = defineClass("TreeDataRow", null, {
	init : function(id) {
		this._super();
		this._rowId = id;
		this._tag = undefined;
		this._children = null;
		this._descendantCount = 0;
	},
	tag: undefined,
	setTag: function (value) {
		var ds = this.dataSet();
		ds && ds.setRowTag(this, value);
	},
	rowId: function () {
		return this._rowId;
	},
	rowState: function () {
		return DataRowState.NONE;
	},
    oldState: function () {
        return DataRowState.NONE;
    },
	setRowState: function (value) {
		var ds = this.dataSet();
		ds && ds.setRowState(this, value);
	},
	dataSet: function () {
		return null;
	},
	parent: function () {
		return null;
	},
	index: function () {
		return -1;
	},
	level: function () {
		return -1;
	},
	count: function () {
		return this._children ? this._children.length : 0;
	},
	descendantCount: function () {
		return this._descendantCount;
	},
	children: function () {
		return this._children ? this._children.concat() : [];
	},
	visitAll: function (callback) {
		if (callback) {
            var i, cnt, child,
			    children = this._children;
            if (children && (cnt = children.length) > 0) {
				for (i = 0; i < cnt; i++) {
					child = children[i];
					if (callback(child, cnt, i) === false) {
                        return false;
                    }
					if (child.visitAll(callback) === false) {
                        return false;
                    }
				}
			}
		}
	},
	visit: function (callback, level) {
		level = level === undefined ? 0 : level;
		if (callback && level >= 0) {
			var i, cnt, child,
                children = this._children;
			if (children && (cnt = children.length) > 0) {
				for (i = 0; i < cnt; i++) {
					child = children[i];
					if (callback(child, cnt, i) === false) {
                        return false;
                    }
					if (level > 0) {
						if (child.visit(callback, level - 1) === false) {
                            return false;
                        }
					}
				}
			}
		}
	},
	getDescendants: function (level) {
		if (this._children) {
			var rows = [];
			this.visit(function (row) {
				rows.push(row);
			},  level > 0 ? this.level() + level : 10000);
			return rows;
		}
		return null;
	},
	getAncestors: function (level) {
		var rows = null;
		var	p = this.parent();
		if (p) {
			rows = [];
			while (p && p.rowId() >= 0) {
				rows.push(p);
				if (level > 0 && rows.length == level) break;
				p = p.parent();
			}
		}
		return rows;
	},
	getChild: function (index) {
		if (index >= 0) {
			if (!this._children || index >= this._children.length) {
				throw new RangeError("Index is invalid: " + index);
			}
			return this._children[index];
		}
		throw new RangeError("Index is invalid: " + index);
	},
	getChildObjects: function (recursive, childrenProp, emptyValue, dataSet) {
		var children = this._children;
		if (children) {
			var objects = [],
                ds = dataSet || this.dataSet();
            if (ds) {
                childrenProp = childrenProp || "rows";
                (!dataSet) && (emptyValue = ds.$_getEmptyValue(emptyValue));
                for (var i = 0, cnt = children.length; i < cnt; i++) {
                    var child = children[i];
                    var obj = child.$_getObject(ds, emptyValue);
                    if (recursive) {
                        obj[childrenProp] = child.getChildObjects(true, childrenProp, emptyValue, ds);
                    }
                    objects.push(obj);
                }
            }
			return objects;
		}
		return null;
	},
    $_createOutputs: function (rows, childrenProp, ds, options) {
        var i, children,
            cnt = rows.length;
        if (cnt > 0) {
            ds.$_createOutputRows(rows, options);
            for (i = 0; i < cnt; i++) {
                children = rows[i][childrenProp];
                if (children) {
                    this.$_createOutputs(children, childrenProp, ds, options);
                }
            }
        }
    },
    getChildOutputObjects: function (options, recursive, childrenProp, emptyValue) {
        var ds = this.dataSet(),
            rows = this.getChildObjects(recursive, childrenProp = childrenProp || 'rows', emptyValue);
        if (ds) {
            if (!(options instanceof DataOutputOptions)) {
                options = new DataOutputOptions(options);
            }
            if (recursive) {
                this.$_createOutputs(rows, childrenProp, ds, options);
            } else {
                ds.$_createOutputRows(rows, options);
            }
        }
        return rows;
    },
	findById: function (rowId) {
		if (this._children) {
			var i, child, c,
				cnt = this._children.length;
			for (i = 0; i < cnt; i++) {
				child = this._children[i];
				if (child.rowId() == rowId) {
					return child;
				}
				c = child.findById(rowId);
				if (c) {
					return c;
				}
			}
		}
		return null;
	},
	indexOf: function (childRow) {
		return this._children ? this._children.indexOf(childRow) : -1;
	},
    $$_insertChild: function (cmd, index, child, noState) {
        this._children = this._children || [];
        this._children.splice(index, 0, child);
        this._descendantCountChanged(1 + child.descendantCount());
        this._attach(child);
        if (!noState) {
            child._changeRowState(cmd, DataRowState.CREATED, false);
        }
    },
    $_insertChild: function (cmd, index, child, noState, noEvent) {
        this.$$_insertChild(cmd, index, child, noState);
        if (!noEvent) {
            this._doChildAdded(cmd, index, child);
        }
    },
	_insertChild: function (cmd, index, child, force, noState, noEvent, scope) {
		var ds = this.dataSet();
        if (!child) {
            throw new Error("child is null");
        }
        if (index < 0 || index > this._children.length) {
            throw new RangeError("Insert index is invalid: " + index);
        }
        if (force || this._doChildAdding(cmd, index, child)) {
            scope && scope._setReady();
            this.$_insertChild(cmd, index, child, noState, noEvent);
            return true;
        }
		return false;
	},
	_addChild: function (cmd, child, force, noState) {
		return this._insertChild(cmd, this.count(), child, force, noState);
	},
	_insertChildren: function (index, children, rowEvents, noState, save, scope) {
		if (!children || children.length  == 0) return;
        this._children = this._children || [];
        if (index < 0 || index > this._children.length) {
            throw new RangeError("Insert index is invalid: " + index);
        }
        var i, child,
            ds = this.dataSet(),
            rows = [];
            cnt = children.length;
        if (ds._rowsAdding(scope, this, index, children)) {
            if (rowEvents) {
                for (i = 0; i < cnt; i++) {
                    child = children[i];
                    if (child instanceof TreeDataRow && this._doChildAdding(scope, index + i, child)) {
                        this._children.splice(index + i, 0, child);
                        this._descendantCountChanged(1 + child.descendantCount());
                        this._attach(child);
                        rows.push(child);
                        save && save.rows.push(child);
                        if (!noState) {
                            child._changeRowState(scope, DataRowState.CREATED, true);
                        }
                        this._doChildAdded(scope, index, child);
                    }
                }
            } else {
                scope && scope._setReady();
                for (i = 0; i < cnt; i++) {
                    child = children[i];
                    if (child instanceof TreeDataRow) {
                        this._children.splice(index + i, 0, child);
                        this._descendantCountChanged(1 + child.descendantCount());
                        this._attach(child);
                        rows.push(child);
                    }
                }
                if (rows.length > 0) {
                    save && (save.rows = rows.concat());
                    if (ds) {
                        if (!noState) {
                            ds.$_changeRowStates(scope, rows, DataRowState.CREATED, true, true);
                        }
                    }
                }
            }
        }
        return rows;
	},
    $_insertChildren: function (cmd, index, children, noState) {
        var i, child,
            ds = this.dataSet(),
            cnt = children.length,
            rows = [];
        for (i = 0; i < cnt; i++) {
            child = children[i];
            if (child instanceof TreeDataRow) {
                this._children.splice(index + i, 0, child);
                this._descendantCountChanged(1 + child.descendantCount());
                this._attach(child);
                rows.push(child);
            }
        }
        if ((len = rows.length) > 0) {
            if (!noState) {
                ds.$_changeRowStates(cmd, rows, DataRowState.CREATED, true, true);
            }
        }
        return rows;
    },
    $$_removeChild: function (child, index) {
        this._children.splice(index, 1);
        this._descendantCountChanged(-1 - child.descendantCount());
        this._detach(child);
    },
	_removeChild: function (child, force, save, scope) {
		var ds = this.dataSet();
		if (child && this._children) {
            var i = this._children.indexOf(child);
            if (i >= 0) {
                ds = this.dataSet();
                if (ds.softDelete() && ds.checkStates()) {
                    scope && scope._setReady();
                    switch (child.rowState()) {
                        case DataRowState.CREATED:
                            if (ds.deleteCreated()) {
                                this.$$_removeChild(child, i);
                            } else {
                                child._changeRowState(scope, DataRowState.CREATE_AND_DELETED, false);
                                child.$_setChildrenDeleted(DataRowState.CREATE_AND_DELETED, save);
                            }
                            break;
                        case DataRowState.DELETED:
                        case DataRowState.CREATE_AND_DELETED:
                            break;
                        default:
                            child._changeRowState(scope, DataRowState.DELETED, false);
                            child.$_setChildrenDeleted(DataRowState.DELETED, save);
                            break;
                    }
                } else {
                    this.$$_removeChild(child, i);
                }
                return true;
			}
		}
		return false;
	},
    $_removeChildren: function (index, children) {
        var i, child,
            ds = this.dataSet(),
            cnt = 0,
            len = children.length;
        this._children.splice(index, len);
        for (i = 0; i < len; i++) {
            child = children[i];
            cnt += 1 + child.descendantCount();
            this._detach(child);
        }
        this._descendantCountChanged(-cnt);
    },
    $$_clearChildren: function () {
        if (this._children && this._children.length > 0) {
            this._children.splice(0, this._children.length);
        }
    },
	_setChildren: function (children) {
		var cnt,
            dcount = -this._descendantCount;
        this.$$_clearChildren();
		if (children && (cnt = children.length) > 0) {
			if (!this._children) {
				this._children = [];
			}
			for (var i = 0; i < cnt; i++) {
				var child = children[i];
				this._children.push(child);
				dcount += 1 + child.descendantCount();
				this._attach(child);
			}
		}
		this._descendantCountChanged(dcount);
	},
    findChildren: function (fields, values, recursive, strict, rows, maxCount) {
        var i, c, cnt, len, flds, flds2, vals,
            ds = this.dataSet();
        if (!ds || !fields || fields.length < 1 || !values || values.length < fields.length) {
            return null;
        }
        rows = rows || [];
        maxCount = isNaN(maxCount) || maxCount <= 0 ? MAX_INT : maxCount;
        if (rows.length < maxCount) {
            flds = [];
            flds2 = [];
            vals = [];
            cnt = fields.length;
            for (i = 0; i < cnt; i++) {
                if (typeof fields[i] === "string") {
                    c = ds.getFieldIndexEx(fields[i]);
                } else {
                    c = Number(fields[i]);
                }
                if (c >= 0 && c < ds.fieldCount() && flds.indexOf(c) < 0) {
                    flds.push(c);
                    flds2.push(ds.getField(c));
                    vals.push(values[i]);
                }
            }
            this.$_findChildren(flds2, flds, vals, recursive, strict, rows, maxCount);
        }
        return rows;
    },
    $_findChildren: function (flds2, flds, vals, recursive, strict, rows, maxCount) {
        var i, c, child, found,
            len = flds2.length,
            cnt = this.count();
        for (i = 0; i < cnt && rows.length < maxCount; i++) {
            child = this._children[i];
            found = true;
            for (c = 0; c < len; c++) {
                if (strict && !flds2[c].equalValues(vals[c], child.getValue(flds[c]))) {
                    found = false;
                    break;
                } else if (!strict && !flds2[c].sameValues(vals[c], child.getValue(flds[c]))) {
                    found = false;
                    break;
                }
            }
            found && rows.push(child);
        }
        if (recursive) {
            for (i = 0; i < cnt && rows.length < maxCount; i++) {
                this._children[i].$_findChildren(flds2, flds, vals, true, strict, rows, maxCount);
            }
        }
        return null;
    },
	isAncestorOf: function (row) {
		if (row && row !== this) {
			var p = row.parent();
			while (p && p !== this) {
				p = p.parent();
			}
			return p === this;
		}
		return false;
	},
	_descendantCountChanged: function (count) {
		this._descendantCount += count;
		var p = this.parent();
		if (p) {
			p._descendantCountChanged(count);
		}
	},
	$_clearRowStates: function (cmd, states, deleteRows, rowEvents, noEvents, save) {
		var rows, deletes, nState, nDelete, i, cnt,
            ds = this.dataSet();
		if (ds) {
            rows = [];
            deletes = deleteRows ? [] : null;
            this.$_collectStateRows(states, rows, deletes);
            nState = rows.length;
            nDelete = deletes ? deletes.length : 0;
            if (nState == 0 && nDelete == 0) {
                return false;
            }
            if (save) {
                save.deletes = deletes;
                save.parents = [];
                save.ids = [];
                save.rows = rows;
                save.states = [];
                if (deletes) {
                    for (i = 0, cnt = deletes.length; i < cnt; i++) {
                        save.parents.push(delets[i].parent());
                        save.ids.push(delets[i].index());
                    }
                }
                for (i = 0, cnt = rows.length; i < cnt; i++) {
                    save.states.push(rows[i].rowState());
                }
            }
            if (rowEvents && !noEvents) {
                for (i = 0, cnt = rows.length; i < cnt; i++) {
                    rows[i]._changeRowState(cmd, DataRowState.NONE, true);
                }
            } else if (nState) {
                ds.$_changeRowStates(cmd, rows, DataRowState.NONE, false, noEvents);
            }
            if (nDelete) {
                ds.deleteRows(deletes);
            }
            return true;
        }
	},
	$_collectStateRows: function (states, rows, deletes) {
		for (var i = 0, cnt = this.count(); i < cnt; i++) {
			var row = this.getChild(i);
			var state = row.rowState();
            if (!states || states.indexOf(state) >= 0) {
                if (deletes && (state == DataRowState.DELETED || state == DataRowState.CREATE_AND_DELETED)) {
                    deletes.push(row);
                } else {
                    if (state != DataRowState.NONE) {
                        rows.push(row);
                    }
                    row.$_collectStateRows(states, rows, deletes);
                }
            }
		}
	},
	$_clearOrgValues: function () {
		for (var i = this.count(); i--;) {
			this.getChild(i).$_clearOrgValues();
		}
	},
    $_restoreState: function (recursive, restoredRows, orgValues) {
		if (recursive) {
			for (var i = this.count(); i--;) {
				this.getChild(i).$_restoreState(true, restoredRows, orgValues);
			}
		}
		return false;
	},
	$_restoreRow: function (recursive, restoredRows, oldValues, orgValues) {
		if (recursive) {
			for (var i = this.count(); i--;) {
				this.getChild(i).$_restoreRow(true, restoredRows, oldValues, orgValues);
			}
		}
		return false;
	},
	toTreeString: function () {
		var s = this.rowId();
		var indent = new Array(this.level() + 1).join("  ");
		for (var i = 0; i < this.count(); i++) {
			s += "\n" + indent + this.getChild(i).toTreeString();
		}
		return s;
	},
	_attach: function (child) {
		_throwAbstractError();
	},
	_deatach: function (child) {
		_throwAbstractError();
	},
    $_fieldInserted: function (index, field) {
    },
	_checkFieldIndex: function (field) {
		this.dataSet()._checkFieldIndex(field);
	},
	_doChildAdding: function (cmd, index, child) {
		var ds = this.dataSet();
		if (ds) {
			return ds._rowAdding(cmd, this, index, child);
		}
		return true;
	},
	_doChildAdded: function (cmd, index, child) {
		var ds = this.dataSet();
		ds && ds._rowAdded(cmd, index, child);
	},
	_doCleared: function (cmd, noEvent) {
		var ds = this.dataSet();
        ds && ds._rowCleared(cmd, this, noEvent);
	}
});
var TreeDataRowImpl = defineClass("TreeDataRowImpl", TreeDataRow, {
	init : function(dataSet, id, values, treeFld, srcFld) {
		this._super(id);
		this._parent = null;
		this._values = null;
		this._orgValues = null;
		this._state = DataRowState.NONE;
		if (dataSet && values) {
			var	flds = dataSet.fieldCount();
			var	cnt = Math.min(values.length, flds);
            var i;
			var vals = this._values = new Array(flds);
			if (typeof treeFld === "number" && treeFld >= 0) {
				for (i = 0; i < treeFld; i++) {
					vals[i] = dataSet.getField(i).loadValue(values[i]);
				}
				for (i = treeFld; i < cnt; i++) {
					vals[i] = dataSet.getField(i).loadValue(values[i + 1]);
				}
			} else {
				for (i = 0; i < cnt; i++) {
					vals[i] = dataSet.getField(i).loadValue(values[i]);
				}
			}
            dataSet._derivedFieldCount && dataSet.$_deriveValues(this._rowId, vals, srcFld >= 0 ? srcFld : -1);
        }
	},
	dataSet: function () {
		return this._parent ? this._parent.dataSet() : null;
	},
	parent: function () {
		return this._parent;
	},
	index: function () {
		return this._parent ? this._parent.indexOf(this) : -1;
	},
	level: function () {
		return this._parent ? this._parent.level() + 1 : 0;
	},
	values: function () {
		return this._values ? this._values.concat() : [];
	},
	rowState: function () {
		return this._state;
	},
    oldState: function () {
        return this._oldState || DataRowState.NONE;
    },
    $_fieldInserted: function (index, field) {
        this._values && this._values.length > index && this._values.splice(index, 0, undefined);
    },
	_changeRowState: function (cmd, newState, fireEvent, force) {
		var ds = this.dataSet();
		if (ds && (force || ds.checkStates()) && newState != this._state) {
			var oldState = this._oldState = this._state;
			this._state = newState;
			if (newState == DataRowState.UPDATED && ds._needOrgValues) {
				this._orgValues = this._values.concat();
			} else if (oldState == DataRowState.updated) {
				if (this._orgValues) {
					this._orgValues = null;
				}
			}
			if (fireEvent) {
				ds._stateChanged(cmd, this);
			}
			return true;
		}
		return false;
	},
    $_setChildrenDeleted: function (state, save) {
        this.visitAll(function (child) {
            var state = child.rowState();
            switch (state) {
                case DataRowState.CREATED:
                    if (save) {
                        save.children.push(child);
                        save.states.push(state);
                    }
                    child._changeRowState(null, DataRowState.CREATE_AND_DELETED, false);
                    break;
                case DataRowState.DELETED:
                case DataRowState.CREATE_AND_DELETED:
                    break;
                default:
                    if (save) {
                        save.children.push(child);
                        save.states.push(state);
                    }
                    child._changeRowState(null, DataRowState.DELETED, false);
                    break;
            }
        });
    },
	getValue: function (field) {
        if (this._values) {
            var ds = this.dataSet();
            if (ds) {
                if (typeof field == "string") {
                    var s = field;
                    field = ds.getFieldIndex(s);
                    if (field < 0) {
                        field = Number(s);
                    }
                }
                ds._checkFieldIndex(field);
                return this._values[field];
            }
        }
		return undefined;
	},
    $_setValue: function (field, value, noState, checkDiff, strictDiff, noEvent, save, scope) {
        var s, fld, vals, newVal, oldVals, needState,
		    ds = this.dataSet();
		if (ds) {
			if (DataRowState.isDeleted(this._state)) {
				return false;
			}
			if (typeof field == "string") {
				s = field;
				field = ds.getFieldIndex(s);
				if (field < 0) {
					field = parseInt(s);
				}
			}
			this._checkFieldIndex(field);
            fld = ds._fields[field];
            if (!fld._updatable && (state == DataRowState.NONE || state == DataRowState.UPDATED)) {
                return false;
            }
            vals = this._values;
			if (vals) {
                newVal = fld.readValue(value);
                if (checkDiff) {
                    if (strictDiff) {
                        if (fld.equalValues(newVal, vals[field])) {
                            return false;
                        }
                    } else if (fld.sameValues(newVal, vals[field])) {
                        return false;
                    }
                }
                ds.refreshFieldFormats();
                if (ds._valueChanging(scope, this, field, newVal)) {
                    needState = ds.checkStates() && (this._state == DataRowState.NONE || !this._state);
                    if (save) {
                        save.values = vals.concat();
                        save.state = this._state;
                        save.rowTag = this._rowTag;
                        save.orgValues = this._orgValues;
                        scope && scope._setReady();
                    }
					if (!noState && needState && ds._needOrgValues) {
						oldVals = save ? save.values : vals.concat();
					}
					vals[field] = newVal;
                    ds._derivedFieldCount && ds.$_deriveValues(this._rowId, vals, field);
					if (!noState && needState) {
						if (ds._needOrgValues) {
							this._orgValues = oldVals;
						}
						this._state = DataRowState.UPDATED;
						!noEvent && ds._stateChanged(scope, this);
					} else if (ds._needAutoRestore) {
						if (this.$$_restoreState(ds) && !noEvent) {
                            ds._stateChanged(scope, this);
                        }
					}
                    return true;
				}
			}
            return false;
		}
	},
    getValues: function () {
        return this._values.slice();
    },
	$_getObject: function (ds, ev) {
		var i, cnt, v, vals, flds, names, n,
            row = {};
        flds = ds._fields;
        names = ds._fieldNames;
        vals = this._values;
        cnt = names.length;
        for (i = 0; i < cnt; i++) {
            v = vals[i];
            n = names[i]
            row[n] = v === UNDEFINED
                ? (ev !== UNDEFINED ? (ev.hasOwnProperty(n) ? ev[n] : ev) : flds[i]._emptyValue)  : v;
        }
        return row;
	},
    getObject: function (emptyValue) {
        var ds = this.dataSet();
        if (ds) {
            return this.$_getObject(ds, ds.$_getEmptyValue(emptyValue));
        }
        return null;
    },
    _getObject: function () {
        var i, cnt, vals, names,
            row = {},
            ds = this.dataSet();
        if (ds) {
            names = ds._fieldNames;
            vals = this._values;
            cnt = names.length;
            for (i = 0; i < cnt; i++) {
                row[names[i]] = vals[i];
            }
        }
        return row;
    },
    copyToObject: function (obj) {
        var ds = this.dataSet();
        if (ds) {
            var	cnt = ds.fieldCount();
            for (var i = 0; i < cnt; i++) {
                var fld = ds.getFieldName(i);
                obj[fld] = this._values[i];
            }
        }
    },
    $_getProps: function (ds, props, ev) {
        var i, p, f, v, flds, vals,
            row = {};
        flds = ds._fields;
        vals = this._values;
        for (i = props.length; i--;) {
            p = props[i];
            f = ds.getFieldIndex(p);
            if (f >= 0) {
                v = vals[f];
                row[p] = v === UNDEFINED
                    ? (ev !== UNDEFINED ? (ev.hasOwnProperty(p) ? ev[p] : ev) : flds[f]._emptyValue)  : v;
            }
        }
        return row;
    },
    getProps: function (props, emptyValue) {
        var ds = this.dataSet();
        if (ds) {
            return this.$_getProps(ds, props, ds.$_getEmptyValue(emptyValue));
        }
        return null;
    },
    _getProps: function (props) {
        var i, p, f, vals,
            row = {},
            ds = this.dataSet();
        if (ds) {
            vals = this._values;
            for (i = props.length; i--;) {
                p = props[i];
                f = ds.getFieldIndex(p);
                if (f >= 0) {
                    row[p] = vals[f];
                }
            }
        }
        return row;
    },
	$_update: function (values, checkDiff, strictDiff, checkEmpty, force, stateEvent, save, scope) {
		var changed, ds = this.dataSet();
		if (ds) {
			if (!force) {
				if (DataRowState.isDeleted(this._state)) {
					return false;
				}
			}
            ds.refreshFieldFormats();
			if (values && (force || ds._rowUpdating(scope, this, values))) {
                scope && scope._setReady();
                changed = false;
				if (_isArray(values)) {
					changed = this._internalUpdate(scope, values, checkDiff, strictDiff, checkEmpty, stateEvent, save);
				} else {
					changed = this._internalUpdateObject(scope, values, checkDiff, strictDiff, checkEmpty, stateEvent, save);
				}
                return changed;
			}
		}
		return false;
	},
	_attach: function (child) {
		child._parent = this;
	},
	_detach: function (child) {
		if (child._parent === this) {
			child._parent = null;
		}
	},
	$_clearOrgValues: function () {
		if (this._orgValues) {
			this._orgValues.length = 0;
			this._orgValues = null;
		}
		this._super();
	},
	$_restoreState: function (recursive, restoredRows, orgValues) {
        var orgVals = this._orgValues;
		var restored = this.$$_restoreState(this.dataSet());
		if (restored && restoredRows) {
			restoredRows.push(this);
            orgValues.push(orgVals);
		}
		this._super(recursive, restoredRows, orgValues);
		return restored;
	},
	$_restoreRow: function (recursive, restoredRows, oldValues, orgValues) {
		var restored = false;
		if (this._state === DataRowState.UPDATED) {
			var orgs = this._orgValues;
			if (orgs) {
                var ds = this.dataSet();
				var vals = this._values;
                oldValues && oldValues.push(vals);
				for (var i = 0, cnt = Math.min(orgs.length, ds.fieldCount()); i < cnt; i++) {
					vals[i] = orgs[i];
				}
                ds._derivedFieldCount && ds.$_deriveValues(this._rowId, vals, -1);
				this._state = DataRowState.NONE;
				restoredRows && restoredRows.push(this);
                orgValues && orgValues.push(orgs);
                delete this._orgValues;
				restored = true;
			}
		}
		this._super(true, restoredRows, oldValues, orgValues);
		return restored;
	},
	$$_restoreState: function (ds) {
		if (this._state == DataRowState.UPDATED && this._orgValues) {
            var i, cnt, v1, v2,
			    orgs = this._orgValues,
			    vals = this._values,
                ds = this.dataSet(),
                strict = ds.strictRestore();
            for (i = 0, cnt = ds.fieldCount(); i < cnt; i++) {
                v1 = vals.length > i ? vals[i] : UNDEFINED;
                v2 = orgs.length > i ? orgs[i] : UNDEFINED;
                if (strict) {
                    if (!ds.getField(i).equalValues(v1, v2)) {
                        return false;
                    }
                } else {
                    if (!ds.getField(i).sameValues(v1, v2)) {
                        return false;
                    }
                }
            }
            this._state = DataRowState.NONE;
            delete this._orgValues;
            return true;
		}
		return false;
	},
	_internalUpdate: function (cmd, values, checkDiff, strictDiff, checkEmpty, stateEvent, save) {
		var ds = this.dataSet();
		if (ds) {
            var i, fld, v, diff, oldVals,
			    cnt = Math.min(ds.fieldCount(), values.length),
			    oldState = this._state,
                created = oldState == DataRowState.CREATED || oldState == DataRowState.CREATE_AND_DELETED,
			    needState = ds.checkStates() && (oldState == DataRowState.NONE || !oldState),
			    changed = false;
            if (save) {
                save.values = this._values.concat();
                save.state = oldState;
                save.orgValues = this._orgValues && this._orgValues.concat();
            }
			if (needState && ds._needOrgValues) {
				oldVals = save ? save.values : this._values.concat();
			}
			for (i = 0; i < cnt; i++) {
				fld = ds.getField(i);
				if (fld._updatable || created) {
					v = values[i];
					if (!checkEmpty || v !== undefined) {
						v = fld.readValue(v);
                        diff = !checkDiff;
                        if (!diff) {
                            if (strictDiff) {
                                diff = !fld.equalValues(v, this._values[fld._index]);
                            } else {
                                diff = !fld.sameValues(v, this._values[fld._index]);
                            }
                        }
						if (diff) {
							this._values[i] = v;
							changed = true;
						}
					}
				}
			}
			if (changed) {
                ds._derivedFieldCount && ds.$_deriveValues(this._rowId, this._values, -1);
				if (needState) {
					if (oldVals) {
						this._orgValues = oldVals;
					}
					this._state = DataRowState.UPDATED;
					if (stateEvent) {
						ds._stateChanged(cmd, this);
					}
				} else if (ds._needAutoRestore && oldState == DataRowState.UPDATED) {
                    if (this.$$_restoreState(ds) && stateEvent) {
                        ds._stateChanged(cmd, this);
                    }
				}
                return true;
			}
		}
        return false;
	},
	_internalUpdateObject: function (cmd, values, checkDiff, strictDiff, checkEmpty, stateEvent, save) {
		var ds = this.dataSet();
		if (ds) {
            var i, fld, fname, v, diff, oldVals,
			    cnt = ds.fieldCount(),
                oldState = this._state,
                created = oldState == DataRowState.CREATED || oldState == DataRowState.CREATE_AND_DELETED,
			    needState = ds.checkStates() && (oldState == DataRowState.NONE || !oldState),
                changed = false;
            if (save) {
                save.values = this._values.concat();
                save.state = oldState;
                save.orgValues = this._orgValues && this._orgValues.concat();
            }
			if (needState && ds._needOrgValues) {
				oldVals = save ? save.values : this._values.concat();
			}
			for (var i = 0; i < cnt; i++) {
                var fld = ds.getField(i);
                if (fld._updatable || created) {
                    var fname = fld.fieldName(i);
                    if (values.hasOwnProperty(fname)) {
                        var v = values[fname];
                        if (!checkEmpty || v !== undefined) {
                            v = fld.readValue(v);
                            var diff = !checkDiff;
                            if (!diff) {
                                if (strictDiff) {
                                    diff = !fld.equalValues(v, this._values[fld._index]);
                                } else {
                                    diff = !fld.sameValues(v, this._values[fld._index]);
                                }
                            }
                            if (diff) {
                                this._values[i] = v;
                                changed = true;
                            }
                        }
                    }
                }
			}
            if (changed) {
                ds._derivedFieldCount && ds.$_deriveValues(this._rowId, this._values, -1);
                if (needState) {
                    if (oldVals) {
                        this._orgValues = oldVals;
                    }
                    this._state = DataRowState.UPDATED;
                    if (stateEvent) {
                        ds._stateChanged(cmd, this);
                    }
                } else if (ds._needAutoRestore && oldState == DataRowState.UPDATED) {
                    if (this.$$_restoreState(ds) && stateEvent) {
                        ds._stateChanged(cmd, this);
                    }
                }
                return true;
            }
		}
        return false;
	}
});
/** @internal */
var RootTreeDataRow = defineClass("RootTreeDataRow", TreeDataRow, {
	init: function(dataSet) {
		this._super();
		this._dataSet = dataSet;
	},
	dataSet: function () {
		return this._dataSet;
	},
	rowId: function () {
		return -1;
	},
	parent: function () {
		return null;
	},
	level: function () {
		return 0;
	},
	index: function () {
		return 0;
	},
	values: function () {
		return null;
	},
	rowState: function () {
		return DataRowState.NONE;
	},
	_changeRowState: function (newState, fireEvent) {
		return false;
	},
	getValue: function (field) {
		return UNDEFINED;
	},
	_setValue: function (field, value, noState) {
	},
	getObject: function () {
		return null;
	},
    _update: function (cmd, values, checkDiff, checkEmpty, force) {
        return false;
    },
    _updateStrict: function (cmd, values, checkDiff, checkEmpty, force) {
        return false;
    },
	/*
	_clearRowStates: function (deleteRows, fireStateEvents) {
		var i, row;
		for (i = this.count() - 1; i >= 0; i--) {
			row = this.getChild(i);
			if (deleteRows && (row.rowState() == RowState.DELETED || RowState.CREATE_AND_DELETED)) {
				this._removeChild(row, false);
			} else {
				row._clearRowStates(deleteRows, fireStateEvents);
			}
		}
	},
	*/
	_attach: function (child) {
		child._parent = this;
	},
	_detach: function (child) {
		if (child._parent === this) {
			child._parent = null;
		}
	},
    getObject: function () {
        return {};
    }
});
var TreeDataSet = defineClass("TreeDataSet", DataSet, {
	init : function(fields, derivedFields) {
        this._super(fields, derivedFields);
        this._rowClass = TreeDataRowImpl;
		this._rootRow = this._createRootRow();
		this._rowMap = [];
		this._tags = new TreeDataTagCollection(this);
        this._tagLock = false;
		this._filterRuntime = new DataFilterRuntime();
		this._needOrgValues = false;
		this._needAutoRestore = false;
		this._nextRowId = 0;
		this.checkParentProc = null;
	},
	onCleared: DLCallback,
	onRowCreating: DLCallback,
	onRowAdding: DLCallback,
	onRowAdded: DLCallback,
	onRowsCreating: DLCallback,
	onRowsAdding: DLCallback,
	onRowsAdded: DLCallback,
    onRowsInserted: DLCallback,
	onRowDeleting: DLCallback,
	onRowDeleted: DLCallback,
	onRowsDeleting: DLCallback,
	onRowsDeleted: DLCallback,
	onRowUpdating: DLCallback,
	onRowUpdated: DLCallback,
    onRowsUpdated: DLCallback,
	onValueChanging: DLCallback,
	onValueChanged: DLCallback,
	onChanged: DLCallback,
	onStateChanged: DLCallback,
	onStatesChanged: DLCallback,
    onTagChanged: DLCallback,
    onTagsChanged: DLCallback,
	filterRuntime: function () {
		return this._filterRuntime;
	},
	rootRow: function () {
		return this._rootRow;
	},
	needOrgValues: function () {
		return this._needOrgValues;
	},
	needRestore: function () {
		return this._needAutoRestore;
	},
	addTag: function (tag) {
		this._tags.add(tag);
	},
	removeTag: function (tag) {
		this._tags.remove(tag);
	},
	setRows: function (rows, treeField, useTreeField, needSorting, filter) {
        var cmd = new TreeDataSetRowsCommand(this, rows, treeField, useTreeField, needSorting, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	setXmlRows: function (rows, rowsProp, childRowsProp, currency, filter) {
        var cmd = new TreeDataSetXmlRowsCommand(this, rows, rowsProp, childRowsProp, currency, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	setJsonRows: function (rows, rowsProp, childRowsProp, currency, filter) {
        var cmd = new TreeDataSetJsonRowsCommand(this, rows, rowsProp, childRowsProp, currency, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    appendDataRows: function (parent, rows, treeField, useTreeField, needSorting, filter) {
        return this.insertDataRows(parent, parent ? parent.count() : this._rootRow.count(), rows, treeField, useTreeField, needSorting, filter)
    },
    insertDataRows: function (parent, index, rows, treeField, useTreeField, needSorting, filter) {
        var cmd = new TreeDataInsertDataRowsCommand(this, parent, index, rows, treeField, useTreeField, needSorting, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	appendXmlRows: function (parent, rows, rowsProp, childRowsProp, currency, filter) {
        return this.insertXmlRows(parent, parent ? parent.count() : this._rootRow.count(), rows, rowsProp, childRowsProp, currency, filter);
    },
    insertXmlRows: function (parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        var cmd = new TreeDataInsertXmlRowsCommand(this, parent, index, rows, rowsProp, childRowsProp, currency, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	appendJsonRows: function (parent, rows, rowsProp, childRowsProp, currency, filter) {
		return this.insertJsonRows(parent, parent ? parent.count() : this._rootRow.count(), rows, rowsProp, childRowsProp, currency, filter);
	},
	insertJsonRows: function (parent, index, rows, rowsProp, childRowsProp, currency, filter) {
        var cmd = new TreeDataInsertJsonRowsCommand(this, parent, index, rows, rowsProp, childRowsProp, currency, filter);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	addRow: function (parent, values, noState, field) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
		return p && this.insertRow(p, p.count(), values, noState, field);
	},
	insertRow: function (parent, index, values, noState, field) {
        var cmd = new TreeDataInsertRowCommand(this, parent, index, values, noState, field);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	addRows: function (parent, rows, rowEvents, noState) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
		return p && this.insertRows(p, p.count(), rows, rowEvents, noState);
	},
	insertRows: function (parent, index, rows, rowEvents, noState) {
        var cmd = new TreeDataInsertRowsCommand(this, parent, index, rows, rowEvents, noState);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	clearRows: function () {
        var cmd = new TreeDataClearRowsCommand(this);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	deleteRow: function (row) {
        var cmd = new TreeDataDeleteRowCommand(this, row);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	deleteRows: function (rows) {
        if (rows && rows.length > 0) {
            var cmd = rows.length == 1 ? new TreeDataDeleteRowCommand(this, rows[0]) : new TreeDataDeleteRowsCommand(this, rows);
            return this.undoable() ? this.execute(cmd) : cmd.execute({});
        }
	},
	updateRow: function (row, values, checkDiff, strictDiff, checkEmpty, noState) {
        var cmd = new TreeDataUpdateRowCommand(this, row, values, checkDiff, strictDiff, checkEmpty, noState);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
    setValue: function (row, field, newValue) {
        var cmd = new TreeDataSetValueCommand(this, row, field, newValue, true, true, false);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setValueEx: function (row, field, newValue, checkDiff, strictDiff, noEvent) {
        var cmd = new TreeDataSetValueCommand(this, row, field, newValue, checkDiff, strictDiff, noEvent);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setRowTag: function (row, tag) {
        var cmd = new TreeDataSetRowTagCommand(this, row, tag);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setRowTags: function (rows, tag) {
        var cmd = new TreeDataSetRowTagsCommand(this, rows, tag);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    unsetRowTags: function (rows, tags) {
        var cmd;
        rows = (rows && rows.length > 0) ? rows : null;
        tags = (tags && tags.length > 0) ? tags : null;
        if (!rows && !tags) {
            cmd = new TreeDataClearRowTagsCommand(this);
        } else {
            cmd = new TreeDataUnsetRowTagsCommand(this, rows, tags);
        }
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    clearRowTags: function () {
        var cmd = new TreeDataClearRowTagsCommand(this);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setRowState: function (row, newState, force) {
        var cmd = new TreeDataSetRowStateCommand(this, row, newState, force);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    setRowStates: function (rows, newState, force, rowEvents) {
        var cmd = new TreeDataSetRowStatesCommand(this, rows, newState, force, rowEvents);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    clearRowStates: function (states, deleteRows, rowEvents) {
        var cmd = new TreeDataClearRowStatesCommand(this, states, deleteRows, rowEvents);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
    },
    getRowState: function (row) {
        row = this.$_getRow(row);
        if (row) {
            return row._state;
        }
        return DataRowState.NONE;
    },
    createRow: function (values, srcFld) {
        this.refreshFieldFormats();
        return this._doCreateRow(values, undefined, srcFld);
    },
    _doCreateRow: function (values, treeFld, srcFld) {
        var row = null;
        if (_isArray(values)) {
            row = new this._rowClass(this, this._nextRowId++, values, treeFld, srcFld);
        } else if (values) {
            var vals = new Array(this.fieldCount());
            for (var prop in values) {
                var fld = this.getFieldIndex(prop);
                if (fld >= 0) {
                    vals[fld] = values[prop];
                }
            }
            row = new this._rowClass(this, this._nextRowId++, vals, treeFld, srcFld);
        }
        return row;
    },
    $_removeRows: function (cmd, rows, save, scope) {
        var i, row, st, changed, n = 0;
        if (this._softDelete && this._checkStates) {
            for (i = rows.length - 1; i >= 0; i--) {
                row = rows[i];
                st = row.rowState();
                changed = false;
                switch (st) {
                    case DataRowState.CREATED:
                        if (!this.deleteCreated()) {
                            changed = row._changeRowState(cmd, DataRowState.CREATE_AND_DELETED, false);
                            row.$_setChildrenDeleted(DataRowState.CREATE_AND_DELETED, save.states);
                            rows.splice(i, 1);
                        }
                        break;
                    case DataRowState.DELETED:
                    case DataRowState.CREATE_AND_DELETED:
                        rows.splice(i, 1);
                        break;
                    default:
                        changed = row._changeRowState(cmd, DataRowState.DELETED, true);
                        row.$_setChildrenDeleted(DataRowState.DELETED, save.states);
                        rows.splice(i, 1);
                        break;
                }
                if (changed) {
                    if (save) {
                        save.states.children.push(row);
                        save.states.states.push(st);
                    }
                }
            }
        }
        if (rows.length > 0) {
            if (save) {
                save.ids = [];
                save.parents = [];
                rows.sort(function (a, b) {
                    return a.index() - b.index();
                });
                for (i = 0; i < rows.length; i++) {
                    save.ids.push(rows[i].index());
                    save.parents.push(rows[i].parent());
                }
                this._tags.$_saveRows(scope, rows, true);
            }
            for (i = rows.length - 1; i >= 0; i--) {
                row = rows[i];
                p = row.parent();
                n += 1 + row.descendantCount();
                p.$$_removeChild(row, p._children.indexOf(row));
            }
            if (save) {
                save.rows = rows;
            }
        }
        return n;
    },
    $_changeRowStates: function (cmd, rows, newState, recursive, noEvent) {
        var i, cnt, row,
            changed = [];
        var visit = function (row) {
            if (row._changeRowState(cmd, newState, false)) {
                changed.push(row);
            }
        };
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = this.$_getRow(rows[i]);
            if (row && row._changeRowState(cmd, newState, false)) {
                changed.push(row);
            }
            recursive && row.visitAll(visit);
        }
        if (changed.length > 0 && !noEvent) {
            this._fireStatesChanged(cmd, changed);
        }
    },
    $_getRow: function (row) {
        if (typeof row == "number") {
            row = this.rowById(row);
        }
        return (row instanceof TreeDataRow) ? row : null;
    },
    getValue: function (row, field) {
        if (row = this.$_getRow(row)) {
            return row.getValue(field);
        }
    },
    /** @deprecated use visitAllRows instead */
    visitAll: function (callback, level) {
        this.visitAllRows(callback, level);
    },
    visitAllRows: function (callback, level) {
        if (level >= 0) {
            this._rootRow.visit(callback, level);
        } else {
            this._rootRow.visitAll(callback);
        }
    },
    getAllRows: function () {
        var rows = [];
        this._rootRow.visitAll(function (row) {
            rows.push(row);
        });
        return rows;
    },
    getRow: function (parent, index) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        return p ? p.getChild(index) : null;
    },
    getChildCount: function (parent) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        return p ? p.count() : 0;
    },
    getChild: function (parent, index) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        return p ? p.getChild(index) : 0;
    },
    getChildren: function (parent) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        return p ? p.children() : null;
    },
    getDescendantCount: function (parent) {
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        return p ? p.descendantCount() : 0;
    },
    getDescendants: function (parent, maxLevel) {
        maxLevel = arguments.length > 1 ? maxLevel : 0;
        var p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        if (p) {
            if (maxLevel <= 0) {
                return p.getDescendants();
            } else if (maxLevel > p.level()) {
                var rows = [];
                p.visit(function (row) {
                    rows.push(row);
                }, maxLevel - p.level());
                return rows;
            }
        }
        return null;
    },
    /** rows 중에 자신의 부모가 없는 row들만 남겨 놓는다 */
    arrangeRows: function (rows) {
        function checkOrphaned(row, from) {
            for (var i = from; i >= 0; i--) {
                if (rows[i].isAncestorOf(row)) {
                    return false;
                }
            }
            return true;
        }
        var row, map = {};
        rows.sort(function (row1, row2) {
            return row1.level() - row2.level();
        });
        for (i = rows.length; i--;) {
            row = rows[i];
            if (map[row._rowId] || !row.parent() || rows[i].level() > 1 && !checkOrphaned(rows[i], i - 1)) {
                rows.splice(i, 1);
            } else {
                map[row._rowId] = row;
            }
        }
        return rows;
    },
    getJsonRows: function (parent, rowsProp, level) {
        p = (parent === null || parent === undefined) ? this._rootRow : this.$_getRow(parent);
        if (p) {
            rowsProp = rowsProp ? (rowsProp + '').trim() || 'rows' : 'rows';
            level = _int(level);
            level = (isNaN(level) || level <= 0) ? 1000000000 : level;
            var obj = p.$$$_obj = p.getObject();
            if (p.count() > 0) {
                obj[rowsProp] = [];
                p.visit(function (child) {
                    child.$$$_obj = child.getObject();
                    if (child.count() > 0) {
                        child.$$$_obj[rowsProp] = [];
                    }
                    child._parent.$$$_obj[rowsProp].push(child.$$$_obj);
                }, level - 1);
                p.visit(function (child) {
                    delete child.$$_obj;
                }, level - 1)
            }
            var rows = obj[rowsProp];
            delete p.$$$_obj;
            return rows;
        }
        return null;
    },
    hasData: function (rowId) {
        return rowId instanceof TreeDataRow || this.rowById(rowId) != null;
    },
    rowById: function (rowId) {
        var row = this._rowMap[rowId];
        if (!row) {
            row = this._findRowById(rowId);
            if (row) {
                this._rowMap[rowId] = row;
            }
        }
        return row;
    },
    getRowById: function (rowId) {
        return this.rowById(rowId);
    },
    getRowsByIds: function (rowIds) {
        var rows = [];
        if (rowIds) {
            for (var i = 0, cnt = rowIds.length; i < cnt; i++) {
                rows.push(this.rowById(rowIds[i]));
            }
        }
        return rows;
    },
    getNextRowId: function () {
        return this._nextRowId++;
    },
    getRowProps: function (row, props, emptyValue) {
        if (row = this.$_getRow(row)) {
            return row.getProps(props, emptyValue);
        }
    },
    _getRowProps: function (row, props) {
        if (row = this.$_getRow(row)) {
            return row._getProps(props);
        }
    },
    getRowObject: function (row, emptyValue) {
        if (row = this.$_getRow(row)) {
            return row.getObject(emptyValue);
        }
    },
    _getRowObject: function (row) {
        if (row = this.$_getRow(row)) {
            return row._getObject();
        }
    },
    getRowObjects: function (rows, emptyValue, all) {
        var i, cnt, row,
            objs = [];
        emptyValue = this.$_getEmptyValue(emptyValue);
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = this.$_getRow(rows[i]);
            if (row) {
                objs.push(row.$_getObject(this, emptyValue));
            } else if (all) {
                objs.push(null);
            }
        }
        return objs;
    },
    getRowsProps: function (rows, props, emptyValue, all) {
        var i, cnt, row, objs = [];
        emptyValue = this.$_getEmptyValue(emptyValue);
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = this.$_getRow(rows[i]);
            if (row) {
                objs.push(row.$_getProps(this, props, emptyValue));
            } else if (all) {
                objs.push(null);
            }
        }
        return objs;
    },
    exportToJson: function (options, recursive, childrenProp, emptyValue) {
        return this._rootRow.getChildOutputObjects(options, recursive, childrenProp, emptyValue);
    },
	getRowTag: function (row) {
        if (row = this.$_getRow(row)) {
			return row._tag;
		}
	},
    getRowsByTag: function (tag) {
        var rows = [];
        if (tag) {
            this._rootRow.visitAll(function (row) {
                if (row._tag === tag) {
                    rows.push(row);
                }
            });
        }
        return rows;
    },
    getRowsByTags: function (tags) {
        var rows = [];
        if (tags && tags.length) {
            this._rootRow.visitAll(function (row) {
                if (tags.indexOf(row._tag) >= 0) {
                    rows.push(row);
                }
            });
        }
        return rows;
    },
	getStateRows: function (state) {
		var rows = [];
		this._rootRow.visitAll(function (row) {
			if (row.rowState() == state) {
				rows.push(row);
			}
		});
		return rows;
	},
	getAllStateRows: function () {
		var rows = {
				created: [],
				updated: [],
				deleted: [],
				createAndDeleted: []
			};
		this._rootRow.visitAll(function (row) {
			switch (row.rowState()) {
				case DataRowState.CREATED:
					rows.created.push(row);
					break;
				case DataRowState.UPDATED:
					rows.updated.push(row);
					break;
				case DataRowState.DELETED:
					rows.deleted.push(row);
					break;
				case DataRowState.CREATE_AND_DELETED:
					rows.createAndDeleted.push(row);
					break;
			}
		});
		return rows;
	},
	getRowStateCount: function (states) {
		var count = 0;
		this._rootRow.visitAll(function (row) {
			if (states.indexOf(row.rowState()) >= 0) {
				count++;
			}
		});
		return count;
	},
	restoreUpdatedStates: function (rows) {
        var cmd = new TreeDataRestoreUpdatedStatesCommand(this, rows);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	restoreUpdatedRows: function (rows) {
        var cmd = new TreeDataRestoreUpdatedRowsCommand(this, rows);
        return this.undoable() ? this.execute(cmd) : cmd.execute({});
	},
	toTreeString: function () {
		return this._rootRow.toTreeString();
	},
    createActionGroup: function (immediately) {
        return new TreeDataActionGroup(this, immediately);
    },
	rowCount: function () {
		return this._rootRow._descendantCount;
	},
	immediateUpdate: function () {
		return true;
	},
    $_internalInsertField: function (index, field) {
        index = this._super(index, field);
        if (index > 0) {
            this._rootRow && this._rootRow.$_fieldInserted(index, field);
        }
        return index;
    },
    $_internalClearFields: function () {
        TreeDataSet.Base.$_internalClearFields.call(this);
        this._rootRow && this.$_clearRows();
    },
	findRow: function (fields, values, strict) {
        var rows = this.findRows(fields, values, true, strict, 1);
        return (rows.length > 0) ? rows[0] : null;
	},
    findRows: function (fields, values, strict, maxCount) {
        var rows = [];
        if (fields && fields.length > 0 && values && values.length >= fields.length) {
            this._rootRow.findChildren(fields, values, true, strict, rows, maxCount);
        }
        return rows;
    },
	getOptions: function () {
		var options = this._super();
		_extend(options, {
		});
	},
	_doCheckStatesChanged: function () {
		this.$_resetOrgValues();
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
		this.$_resetOrgValues();
	},
	_doGetDistinctValues: function (field, maxCount) {
		var isNum, rows, compFunc, i, cnt, value,
            values = [];
		if (maxCount < 0) {
			maxCount = this._rootRow.descendantCount();
		}
		if (maxCount > 0) {
			isNum = this.getField(field).dataType() == ValueType.NUMBER;
            rows = this.getDescendants(this._rootRow, 0);
            compFunc = this.getComparer(field).bind(this);
            this.$_sortRows(rows, field, compFunc.bind(this), 0, rows.length - 1);
			values.push(rows[0]._values[field]);
			for (i = 1, cnt = rows.length; i < cnt; i++) {
                if (compFunc(field, rows[i - 1], rows[i]) < 0) {
					value = rows[i]._values[field];
                    values.push(value);
					if (values.length >= maxCount) {
						break;
					}
				}
			}
		}
		return values;
	},
	hasData: function (rowId) {
		return this.rowById(rowId);
	},
    /*
	savePoint: function (saveStates, saveTags) {
        if (!this._checkClientState()) return;
        saveStates = arguments.length > 0 ? saveStates : true;
        var flds = this._fields.length;
        if (flds > 0 && this._rootRow.count() > 0) {
            var root = this._rootRow.copy();
            var i = this._nextPoint++;
            if (!saveStates) {
                root._clearRowStates(false, false);
            }
            this._points.push({
                id: i,
                data: root
            });
            return i;
        }
        return -1;
	},
	rollback: function (savePoint) {
        if (!this._checkClientState()) return;
        savePoint = arguments.length > 0 ? savePoint : 0;
        for (var i = this._points.length - 1; i >= 0; i--) {
            var point = this._points[i];
            if (point.id == savePoint) {
                this.$_removeSavePoints(i + 1);
                this._rowMap = [];
                this._rootRow.set(point.data);
                this._fireReset();
                break;
            }
        }
	},
    $_removeSavePoints: function (index) {
        var points = this._points;
        var point;
        for (var i = points.length - 1; i >= index; i--) {
            point = points[i];
            point.data = null;
            points.pop();
        }
    },
    clearSavePoints: function () {
        this.$_removeSavePoints(0);
    },
	getSavePoints: function () {
        var points = [];
        for (var i = 0, cnt = this._points.length; i < cnt; i++) {
            points.push(this._points[i].id);
        }
        return points;
	},
	*/
    equalValues: function (field, row1, row2) {
        if (row1 !== row2) {
            var fld = this._fields[field];
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            return fld.equalValues(v1, v2);
        } else {
            return true;
        }
    },
    sameValues: function (field, row1, row2) {
        if (row1 !== row2) {
            var fld = this._fields[field];
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            return fld.sameValues(v1, v2);
        } else {
            return true;
        }
    },
	compareValues: function (field, row1, row2) {
		if (row1 !== row2) {
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			if (v1 === null) {
				return (v2 === null) ? 0 : -1;
			}
			if (v2 === null) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		} else {
			return 0;
		}
	},
    compareValues: function (field, row1, row2) {
        if (row1 !== row2) {
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            if (v1 === undefined || v1 === null) {
                return (v2 === undefined || v2 === null) ? 0 : -1;
            }
            if (v1 === undefined || v2 === null) {
                return 1;
            }
            return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        } else {
            return 0;
        }
    },
    compareNumbers: function (field, row1, row2) {
        if (row1 !== row2) {
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            if (isNaN(v1)) {
                return (isNaN(v2)) ? 0 : -1;
            }
            if (isNaN(v2)) {
                return 1;
            }
            return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        } else {
            return 0;
        }
    },
    compareDates: function (field, row1, row2) {
        if (row1 !== row2) {
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            if (!(v1 instanceof Date)) {
                return !(v2 instanceof Date) ? 0 : -1;
            }
            if (!(v2 instanceof Date)) {
                return 1;
            }
            return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        } else {
            return 0;
        }
    },
    compareBools: function (field, row1, row2) {
        if (row1 !== row2) {
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            if (v1 === undefined || v2 === undefined) {
                return (v1 === v2) ? 0 : v1 === undefined ? -1 : 1;
            }
            return (v1 && !v2) ? 1 : (!v1 && v2) ? -1 : 0;
        } else {
            return 0;
        }
    },
    compareObjs: function (field, row1, row2) {
        if (row1 !== row2) {
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            if (!v1) {
                return (!v2) ? 0 : -1;
            }
            if (!v2) {
                return 1;
            }
            var fld = this.getField(field);
            cb = fld._compareCallback || fld.$_compareObjs;
            return cb(v1, v2);
        } else {
            return 0;
        }
    },
	$_summarizeChildren: function (parent, summary) {
		var i;
		var row;
		var v;
		var f = summary.field;
		var cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				summary.sum += v;
				if (v < summary.min) summary.min = v;
				if (v > summary.max) summary.max = v;
			}
			this.$_summarizeChildren(row, summary);
		}
	},
	$_summarizeVars: function (parent, summary) {
		var f = summary.field;
		var avg = summary.avg;
		var cnt = parent.count();
		var vars = 0;
        var i, row, v;
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				vars += Math.pow(v - avg, 2);
			}
			vars += this.$_summarizeVars(row, summary);
		}
		return vars;
	},
	aggregate: function (summary, calcVars) {
		if (summary == null) {
			return false;
		}
		summary.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
		summary.count = count;
		summary.sum = 0;
		summary.min = Number.MAX_VALUE;
		summary.max = Number.MIN_VALUE;
		this.$_summarizeChildren(this._rootRow, summary);
		summary.avg = summary.sum / summary.count;
		if (calcVars) {
			var vars = this.$_summarizeVars(this._rootRow, summary);
			summary.varsp = vars / summary.count;
			summary.vars = vars / (summary.count - 1);
		}
        var t = this._fields[summary.field]._dataType;
        if (t === ValueType.DATETIME) {
            summary.min = new Date(summary.min);
            summary.max = new Date(summary.max);
        }
		return true;
	},
	aggregateRange: function (summary, rows, calcVars) {
		if (summary == null || rows == null) {
			return false;
		}
		summary.clear();
		var count = rows.length;
		if (count < 1) {
			return false;
		}
        var n = 0;
        var f = summary.field;
		var sum = 0;
		var min = NaN;
		var max = NaN;
        var i, row, v;
        i = 0;
		while (i < count) {
            row = this.$_getRow(rows[i++]);
			v = row.getValue(f);
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
            row = this.$_getRow(rows[i++]);
			v = row.getValue(f);
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				if (v > max) max = v;
				n++;
			}
		}
		summary.count = count;
		if (n > 0) {
			summary.sum = sum;
			summary.min = min;
			summary.max = max;
			summary.avg = sum / count;
			if (calcVars) {
				if (count > 1) {
					var vars = 0;
					var avg = summary.avg;
					for (i = 0; i < count; i++) {
						row = rows[i++];
						v = row.getValue(f);
						if (!isNaN(v)) {
							vars += Math.pow(v - avg, 2);
						}
					}
					summary.varsp = vars / count;
					summary.vars = vars / (count - 1);
				} else {
					summary.varsp = 0;
					summary.vars = 0;
				}
			}
            var t = this._fields[summary.field]._dataType;
            if (t === ValueType.DATETIME) {
                summary.min = new Date(summary.min);
                summary.max = new Date(summary.max);
            }
		}
		return true;
	},
    _createRootRow: function () {
        return new RootTreeDataRow(this);
    },
    $_maxRowId: function () {
        return this._nextRowId;
    },
	$_resetOrgValues: function () {
		this._needOrgValues = this._checkStates && this._restoreMode != DataRestoreMode.NONE;
		this._needAutoRestore = this._needOrgValues && this._restoreMode == DataRestoreMode.AUTO;
		this._rootRow.$_clearOrgValues();
	},
	_findRowById: function (rowId) {
		return this._rootRow.findById(rowId);
	},
	_checkSum: function (count) {
		if (count != this.rowCount()) {
			throw new Error("Invalid row count: " + count + " <> " + this.rowCount());
		}
	},
    $_saveAll: function (scope, save, deleting) {
        save =  save || {};
        save.nextRowId = this._nextRowId;
        save.children = this._rootRow._children && this._rootRow._children.concat();
        save.rowMap = this._rowMap;
        save.deletedCount = this._deletedCount;
        save._descendantCount = this._descendantCount;
        this._tags.$_saveRows(scope, DataSet.ALL_ROWS, deleting);
        return save;
    },
    $_restoreAll: function (scope, save, created) {
        this._nextRowId = save.nextRowId;
        this._rootRow._setChildren(save.children);
        this._rowMap = save.rowMap;
        this._deletedCount = save.deletedCount;
        this._descendantCount = save._descendantCount;
        this._tags.$_restoreRows(scope, DataSet.ALL_ROWS, created);
    },
	$_clearRows: function () {
		var p = this._rootRow;
        if (p._children && p._children.length > 0) {
            p._children.splice(0, p._children.length);
            p._descendantCountChanged(-p._descendantCount);
            p._doCleared(null, true);
        }
		this._rowMap = [];
        if (this._resetIdWhenClear) {
            this._nextRowId = 0;
        }
		this._tags.clearRows();
		this._checkSum(0);
	},
    _doRecalcAll: function () {
        var ds = this,
            cnt = this.rowCount();
        if (cnt > 0) {
            this._rootRow.visitAll(function (row) {
                ds.$_deriveValues(row._rowId, row._values, -1);
            })
        }
        return cnt;
    },
    _doRecalcRows: function (rows) {
        var i, cnt, row,
            calced = 0;
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            row = this.$_getRow(rows[i]);
            if (row) {
                this.$_deriveValues(row._rowId, row._values, -1);
                calced++;
            }
        }
        return calced;
    },
    _doRecalcRow: function (row) {
        row = this.$_getRow(row);
        if (row) {
            this.$_deriveValues(row._rowId, row._values, -1);
            return 1;
        }
        return 0;
    },
	_summarizeChildren: function (parent, field) {
		var i, row, v, 
			f = field.field,
			cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				field.sum += v;
				if (v < field.min) field.min = v;
				if (v > field.max) field.max = v;
			}
			this.summarizeChildren(row, field);
		}
	},
	_summarizeVars: function (parent, field) {
		var i, row, v, 
			f = field.field,
			avg = field.avg,
			cnt = parent.count(),
			vars = 0;
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				vars += Math.pow(v - avg, 2);
			}
			vars += summarizeChildren(row, field);
		}
		return vars;
	},
	_summarize: function (field, calcVars) {
		if (field == null) {
			return false;
		}
		field.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
		field.count = 0;
		field.sum = 0;
		field.min = Number.MIN_VALUE;
		field.max = Number.MAX_VALUE;
		this._summarizeChildren(this._rootRow, field);
		field.avg = field.sum / field.count;
		if (calcVars) {
			var vars = this._summarizeVars(this._rootRow, field);
			field.vars = vars / field.count;
		}
		return true;
	},
	summarizeRange: function (field, rows, calcVars) {
		return false;
	},
	_stateChanged: function (cmd, row) {
		this._fireStateChanged(cmd, row);
	},
    _statesChanged: function (cmd, rows) {
        this._fireStatesChanged(cmd, rows);
    },
    _valueChanging: function (cmd, row, field, newVal) {
        return this._fireValueChanging(cmd, row, field, newVal);
    },
	_valueChanged: function (cmd, row, field) {
        if (!this._tagLock) {
            this._tags.setValue(row, field);
        }
		this._fireValueChanged(cmd, row, field);
	},
	_rowAdding: function (cmd, row, index, child, field) {
		return this._fireRowAdding(cmd, row, index, child, field);
	},
	_rowAdded: function (cmd, index, row, field) {
		if (!this._tagLock) {
			this._tags.addRow(index, row, field);
		}
        this._fireRowAdded(cmd, index, row, field);
        this._fireRowCountChanged(cmd);
	},
	_rowsAdding: function (cmd, parent, index, rows) {
		return this._fireRowsAdding(cmd, parent, index, rows);
	},
	_rowsAdded: function (cmd, parent, index, rows, rowEvents) {
		if (!rowEvents && !this._tagLock) {
			this._tags.addRows(index, rows);
		}
        this._fireRowsAdded(cmd, parent, index, rows, rowEvents);
        !rowEvents && this._fireRowCountChanged(cmd);
	},
    _rowsInserted: function (cmd, rows) {
        if (!this._tagLock) {
            this._tags.insertRows(rows);
        }
        this._fireRowsInserted(cmd, rows);
        this._fireRowCountChanged(cmd);
    },
	_rowRemoving: function (cmd, row) {
		return this._fireRowDeleting(cmd, row);
	},
	_rowRemoved: function (cmd, row) {
		if (!this._tagLock) {
			this._tags.removeRow(row);
		}
        this._fireRowDeleted(cmd, row);
        this._fireRowCountChanged(cmd);
	},
	_rowsRemoving: function (cmd, rows) {
		return this._fireRowsDeleting(cmd, rows);
	},
	_rowsRemoved: function (cmd, rows) {
		if (!this._tagLock) {
			this._tags.removeRows(rows);
		}
        this._fireRowsDeleted(cmd, rows);
        this._fireRowCountChanged(cmd);
	},
	_rowCleared: function (cmd, row, noEvent) {
		if (row) {
			var rows = row.children();
			this._tags.removeRows(rows);
			if (!noEvent) {
				this._fireRowsDeleted(cmd, rows);
				this._fireRowCountChanged(cmd);
			}
		}
	},
	_rowUpdating: function (cmd, row, values) {
		return this._fireRowUpdating(cmd, row, values);
	},
	_rowUpdated: function (cmd, row) {
		this._tags.updateRow(row);
        this._fireRowUpdated(cmd, row);
	},
    _rowsUpdated: function (cmd, rows) {
        this._tags.updateRows(rows);
        this._fireRowsUpdated(cmd, row);
    },
	/*
	_fireCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeDataSet.CLEARED);
            this.onCleared && this.onCleared(this);
		} 
	},
	*/
	_fireRowCreating: function (cmd, row, index, values) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROW_CREATING, row, index, values);
			if (this.onRowCreating) {
				this.onRowCreating(this, row, index, values);
			}
		}
	},
	_fireRowAdding: function (cmd, row, index, child, field) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.ROW_ADDING, row, index, child);
            if (ret && this.onRowAdding) {
                ret = this.onRowAdding(this, row, index, child, field) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowAdded: function (cmd, index, row, field) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROW_ADDED, index, row);
            this.onRowAdded && (!this._onStack || this._eventable) && this.onRowAdded(this, index, row, field);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowsCreating: function (cmd, parent, index, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROWS_CREATING, parent, index, rows);
			if (this.onRowsCreating) {
				this.onRowsCreating(this, parent, index, rows);
			}
		}
	},
	_fireRowsAdding: function (cmd, parent, index, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.ROWS_ADDING, parent, index, rows);
			if (ret && this.onRowsAdding) {
				ret = this.onRowsAdding(this, parent, index, rows) !== false;
			}
			return ret;
		}
		return true;
	},
	_fireRowsAdded: function (cmd, parent, index, rows, rowEvents) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROWS_ADDED, parent, index, rows, rowEvents);
			this.onRowsAdded && (!this._onStack || this._eventable) && this.onRowsAdded(this, parent, index, rows, rowEvents);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
    _fireRowsInserted: function (cmd, rows) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(TreeDataSet.ROWS_INSERTED, rows);
            this.onRowsInserted && (!this._onStack || this._eventable) && this.onRowsInserted(this, rows);
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
        }
    },
	_fireRowDeleting: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.ROW_DELETING, row);
            if (ret && this.onRowDeleting) {
                ret = this.onRowDeleting(this, row) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowDeleted: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROW_DELETED, row);
            this.onRowDeleted && (!this._onStack || this._eventable) && this.onRowDeleted(this, row);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowsDeleting: function (cmd, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.ROWS_DELETING, rows);
            if (ret && this.onRowsDeleting) {
                ret = this.onRowsDeleting(this, rows) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireRowsDeleted: function (cmd, rows) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROWS_DELETED, rows);
            this.onRowsDeleted && (!this._onStack || this._eventable) && this.onRowsDeleted(this, rows);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireRowUpdating: function (cmd, row, values) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.ROW_UPDATING, row, values);
            if (ret && this.onRowUpdating) {
                ret = this.onRowUpdating(this, row, values) !== false;
            }
            return ret;
		} 
		return true;
	},
	_fireRowUpdated: function (cmd, row) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.ROW_UPDATED, row);
            this.onRowUpdated && (!this._onStack || this._eventable)&& this.onRowUpdated(this, row);
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
    _fireRowsUpdated: function (cmd, rows) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(TreeDataSet.ROWS_UPDATED, rows);
            this.onRowsUpdated && (!this._onStack || this._eventable) && this.onRowsUpdated(this, rows);
            this.$$_cmd = cmd;
            this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
        }
    },
	_fireValueChanging: function (cmd, row, field, newValue) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			var ret = this.fireConfirmEvent(TreeDataSet.VALUE_CHNAGING, row, field, newValue);
            if (ret && this.onValueChanging) {
                ret = this.onValueChanging(this, row, field, newValue) !== false;
            }
            return ret;
		}
		return true;
	},
	_fireValueChanged: function (cmd, row, field) {
		if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.VALUE_CHNAGED, row, field);
            if (!(this.onValueChanged && this.onValueChanged(this, row, field))) {
                this.onRowUpdated && (!this._onStack || this._eventable) && this.onRowUpdated(this, row, field);
            }
            this.$$_cmd = cmd;
			this.fireEvent(DataSet.DATA_CHANGED);
            this.onDataChanged && this.onDataChanged(this);
		}
	},
	_fireStateChanged: function (cmd, row) {
		if (this._eventLock <= 0) {
            var updating = cmd && cmd.$_updating();
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.STATE_CHANGED, row, updating);
            this.onStateChanged && (!this._onStack || this._eventable) && this.onStateChanged(this, row, updating);
		}
	},
	_fireStatesChanged: function (cmd, rows) {
		if (this._eventLock <= 0) {
            var updating = cmd && cmd.$_updating();
            this.$$_cmd = cmd;
			this.fireEvent(TreeDataSet.STATES_CHANGED, rows, updating);
            this.onStatesChanged && (!this._onStack || this._eventable) && this.onStatesChanged(this, rows, updating);
		}
	},
    _fireTagChanged: function (cmd, row) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(TreeDataSet.TAG_CHANGED, row);
            this.onTagChanged && (!this._onStack || this._eventable) && this.onTagChanged(this, row);
        }
    },
    _fireTagsChanged: function (cmd, rows) {
        if (this._eventLock <= 0) {
            this.$$_cmd = cmd;
            this.fireEvent(TreeDataSet.TAGS_CHANGED, rows);
            this.onTagsChanged && (!this._onStack || this._eventable) && this.onTagsChanged(this, rows);
        }
    }
}, null, function (f) {
    f.ROW_COUNT_CHANGED = "onTreeDataSetRowCountChanged";
    f.ROW_CREATING = "onTreeDataSetRowCreating";
    f.ROW_ADDING = "onTreeDataSetRowAdding";
    f.ROW_ADDED = "onTreeDataSetRowAdded";
    f.ROWS_CREATING = "onTreeDataSetRowsCreating";
    f.ROWS_ADDING = "onTreeDataSetRowsAdding";
    f.ROWS_ADDED = "onTreeDataSetRowsAdded";
    f.ROWS_INSERTED = "onTreeDataSetRowsInserted";
    f.ROW_DELETING = "onTreeDataSetRowDeleting";
    f.ROW_DELETED = "onTreeDataSetRowDeleted";
    f.ROWS_DELETING = "onTreeDataSetRowsDeleting";
    f.ROWS_DELETED = "onTreeDataSetRowsDeleted";
    f.ROW_UPDATING = "onTreeDataSetRowUpdating";
    f.ROW_UPDATED = "onTreeDataSetRowUpdated";
    f.ROWS_UPDATED = "onTreeDataSetRowsUpdated";
    f.VALUE_CHANGING = "onTreeDataSetValueChanging";
    f.VALUE_CHNAGED = "onTreeDataSetValueChanged";
    f.STATE_CHANGED = "onTreeDataSetStateChanged";
    f.STATES_CHANGED = "onTreeDataSetStatesChanged";
    f.TAG_CHANGED = "onTreeDataSetTagChanged";
    f.TAGS_CHANGED = "onTreeDataSetTagsChanged";
});
var TreeDataLoader = defineClass("TreeDataLoader", null, {
	init: function (provider) {
		Base.init.call(this);
		this._provider = provider;
        this._filter = null;
	},
	load: function (type, data, options) {
		options = new DataFillOptions(options);
		if (this.$_checkEmpty(data, options)) {
			return 0;
		}
		this.$_prepareLoad(options);
		type = type && type.toLowerCase();
		try {
			switch (type) {
				case "json":
					return this.$_loadJson(data, options, this._filter);
				case "xml":
					return this.$_loadXml(data, options, this._filter);
				case "csv":
					return this.$_loadCsv(data, options, this._filter);
			}
		} finally {
			var callback = _asFunction(options.callback);
			callback && callback(this._provider);
		}
		return 0;
	},
	$_loadJson: function (data, options, filter) {
		if (data) {
			var parent;
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					parent = this._provider.rowById(options.parentId);
					return this._provider.appendJsonRows(parent, data, options.rows, options.childRows, options.currency, filter);
				case DataFillMode.INSERT:
					parent = this._provider.rowById(options.parentId);
					return this._provider.insertJsonRows(parent, options.fillPos, data, options.rows, options.childRows, options.currency, filter);
				case DataFillMode.UPDATE:
					break;
				case DataFillMode.SET:
				default:
					return this._provider.setJsonRows(data, options.rows, options.childRows, options.currency, filter);
			}
		}
		return 0;
	},
	$_loadXml: function (data, options, filter) {
		if (data) {
            var rowProp = options.rows || "row";
            var parent;
            switch (options.fillMode) {
                case DataFillMode.APPEND:
                    parent = this._provider.rowById(options.parentId);
                    return this._provider.appendXmlRows(parent, data, rowProp, options.childRows, options.currency, filter);
                case DataFillMode.INSERT:
                    parent = this._provider.rowById(options.parentId);
                    return this._provider.insertXmlRows(parent, options.fillPos, data, rowProp, options.childRows, options.currency, filter);
                case DataFillMode.UPDATE:
                    break;
                case DataFillMode.SET:
                default:
                    return this._provider.setXmlRows(data, rowProp, options.childRows, options.currency, filter);
            }
        }
		return 0;
	},
	$_loadCsv: function (data, options, filter) {
		var start = options.start;
		var count = options.count;
		var quoted = options.quoted;
        var trim = options.trim;
        var currency = options.currency;
		var delimiter = options.delimiter;
		var treeField = options.treeField;
		var useTreeField = options.useTreeField;
		var needSorting = options.needSorting;
		var treeFld = !useTreeField && treeField >= 0 && treeField < this._provider.fieldCount() ? treeField : -1;
		var rows = DataHelper.csvToArray(this._provider, data, start, count, quoted, trim, delimiter, currency, treeFld);
        var parent;
		if (rows && rows.length > 0) {
            switch (options.fillMode) {
                case DataFillMode.APPEND:
                    parent = this._provider.rowById(options.parentId);
                    return this._provider.appendDataRows(parent, rows, treeField, useTreeField, needSorting, filter);
                case DataFillMode.INSERT:
                    parent = this._provider.rowById(options.parentId);
                    return this._provider.insertDataRows(parent, options.fillPos, rows, treeField, useTreeField, needSorting, filter);
                case DataFillMode.UPDATE:
                    break;
                case DataFillMode.SET:
                default:
                    return this._provider.setRows(rows, treeField, useTreeField, needSorting, filter);
            }
			return rows.length;
		}
		return 0;
	},
	$_fillEmpty: function (options) {
		if (options.fillMode === DataFillMode.SET) {
			this._provider.setRows(null);
		}
	},
	$_checkEmpty: function (data, options) {
		if (!data) {
			this.$_fillEmpty(options);
			return true;
		}
		return false;
	},
	$_prepareLoad: function (options) {
        if (options.filter) {
            this._filter = new TreeDataFilter(options.filter);
        }
	}
});
var TreeRow = defineClass("TreeRow", GroupRow, {
	init: function(dataRow) {
		this._super();
		this._dataRow = dataRow;
		this._footer = null;
	},
	iconHeight: 0,
	iconWidth: 0,
	iconIndex: undefined,
	hasChildren: undefined,
	dataRow: function () {
		return this._dataRow;
	},
	setIconIndex: function (value) {
		if (value != this._iconIndex) {
			this._iconIndex = value;
			var p = this.provider();
			p && p.$_iconIndexChanged(this);
		}
	},
	setHasChildren: function (value) {
		if (value != this._hasChildren) {
			this._hasChildren = value;
			var p = this.provider();
			p && p.$_hasChildrenChanged(this);
		}
	},
	rootRow: function () {
		var p = this;
		while (p.level() > 1) {
			p = p.parent();
		}
		return p;
	},
	/*
	lastVisible: function () {
		return (this.expanded() && this.count() > 0) ? this.lastVisible() : this;
	},
	*/
	headerCount: function () {
		return this._customHeaders ? this._customHeaders.length : 0;
	},
	dataIndexOf: function (child) {
		return this.indexOf(child) - this.headerCount();
	},
	dataIndex: function () {
		return this._dataRow.rowId();
	},
	dataId: function () {
		return this._dataRow.rowId();
	},
	dataTag: function () {
		return this._dataRow.tag();
	},
	dataState: function () {
		return this._dataRow.rowState();
	},
    leaf: function () {
        return this.count() == 0;
    },
	isLeaf: function () {
		return this.count() == 0;
	},
	footer: function () {
		return this._footer;
	},
    editable: function () {
        return true;
    },
	isEditable: function () {
		return true;
	},
    isEditing: function () {
        return false;
    },
	summaryMode: function () {
		return SummaryMode.AGGREGATE;
	},
	setExpanded: function (value) {
		var rs = this.provider();
		if (rs && value != this.expanded()) {
			if (value) {
				rs.expand(this, false, false);
			} else {
				rs.collapse(this);
			}
		}
	},
    resizable: function () {
        return true;
    },
	isResizable: function () {
		return true;
	},
	canEdit: function () {
		return true;
	},
	getValue: function (field) {
		return this._dataRow.getValue(field);
	},
	setValue: function (field, value) {
        var ds = this._dataRow && this._dataRow.dataSet();
        ds && ds.setValue(this._dataRow, field, value);
	},
    getRowObject: function () {
        return this._dataRow._getObject();
    },
    getRowProps: function (propNames) {
        return this._dataRow._getProps(propNames);
    },
    setRowProps: function (props, checkDiff, strictDiff, checkEmpty) {
        var provider = this.provider();
        this._dataRow.$_update(props, checkDiff, strictDiff, checkEmpty);
    },
	setItem: function (item, newItem) {
		this._super(item, newItem);
		newItem._addChildren(item.children());
		item.clear();
	},
	_collectSummaryRows: function (group, rows, scope) {
		var i, cnt, item, row,
			scope = scope || this.provider().rowSummaryScope();
		switch (scope) {
			case TreeSummaryScope.DESCENDTANT:
			case TreeSummaryScope.ALL:
				group.visitRows(false, true, function (child) {
					rows.push(child.dataIndex());
				});
				scope == TreeSummaryScope.ALL && rows.push(group.dataIndex());
				break;
			case TreeSummaryScope.CHILD:
			case TreeSummaryScope.PARENT_CHILD:
				for (i = 0, cnt = group.count(); i < cnt; i++) {
					item = group.getItem(i);
					(row = item.dataIndex()) >= 0 && rows.push(row);
				}
				scope == TreeSummaryScope.PARENT_CHILD && rows.push(group.dataIndex());
				break;
			case TreeSummaryScope.GROUP:
				group.visitRows(false, true, function (child) {
					child.count() > 0 && rows.push(child.dataIndex());
				});
				break;
			case TreeSummaryScope.LEAF:
				group.visitRows(false, true, function (child) {
					child.count() == 0 && rows.push(child.dataIndex());
				});
				break;
		}
    },
    $_saveChecked: function (scope, view, id, exclusive) {
        this._super(scope, view, id, exclusive);
        this.visitAll(function (child) {
            child.$_saveChecked(scope, view, child.dataIndex(), exclusive);
        })
    },
    $_restoreChecked: function (scope, view, id, callback) {
        this._super(scope, view, id, callback);
        this.visitAll(function (child) {
            child.$_restoreChecked(scope, view, child.dataIndex(), callback);
        })
    },
    $_dataKey: function () {
        return this._dataRow;
    },
	$_createFooter: function () {
		if (!this._footer) {
			this._footer = new TreeRowFooter();
		}
        return this._footer;
	},
	exchange: function (index1, index2) {
		this._exchangeItems(index1, index2);
	}
});
var TreeTempRow = defineClass("TreeTempRow", TreeRow, {
	init: function (dataRow, childIndex) {
		this._super(dataRow);
		this.$_childIndex = childIndex;
	},
	childIndex: function () {
		return this.$_childIndex;
	}
});
TreeRow.$_tempTreeItem = new TreeTempRow();
TreeRow.getTemp = function (row, index) {
	TreeRow.$_tempTreeItem._dataRow = row;
	TreeRow.$_tempTreeItem.$_childIndex = index;
	return TreeRow.$_tempTreeItem;
};
var TreeRowFooter = defineClass("TreeRowFooter", GroupFooter, {
    init: function () {
        this._super();
    }
});
var RootTreeRow = defineClass("RootTreeRow", TreeRow, {
	init: function(provider) {
		this._super(null);
		this._provider = provider;
	},
	id: function () {
		return NaN;
	},
	provider: function () {
		return this._provider;
	},
	level: function () {
		return 0;
	},
    expanded: function () {
        return true;
    },
	setExpanded: function (value) {
	},
    leaf: function () {
        return false;
    },
	isLeaf: function () {
		return false;
	},
    visible: function () {
        return true;
    },
	isVisible: function () {
		return true;
	},
	dataSource: function () {
		return this._provider.dataSource();
	},
    makeVisible: function () {
    },
	dataIndexOf: function (child) {
		return this.indexOf(child);
	}
});
var HierarchicalVisibleItems = function (provider) {
	var _provider = provider,
		_customHeaders = null,
		_customFooters = null,
		_fixedCount = 0,
		_items = [],
		_list = [];
	var collectChildren = function (parent, list, recursive, level) {
		var i, cnt, item;
		for (i = 0, cnt = parent.count(); i < cnt; i++) {
			item = parent.getItem(i);
			if (item) {
				list.push(item);
				if (item instanceof TreeRow) {
					if ((recursive && item.level() < level) || item.expanded()) {
						collectChildren(item, list, recursive, level);
					}
				}
			}
		}
	};
	var expandItem = function (item, recursive, level) {
		var i, cnt, idx,
			list = _list;
		if (item instanceof RootTreeRow) {
			idx = _fixedCount;
		} else {
			idx = item.index() + 1;
		}
		level = Math.max(0, level);
		list.length = 0;
		collectChildren(item, list, recursive, level > 0 ? item.level() + level : 1000000);
		if (recursive) {
			for (i = idx, cnt = _items.length; i < cnt; i++) {
				if (_items[i].level() <= item.level()) {
					break;
				}
			}
			_items.splice(idx, i - idx);
		}
		for (i = 0, cnt = list.length; i < cnt; i++) {
			_items.splice(idx + i, 0, list[i]);
		}
	};
	this.provider = function () {
		return _provider;
	};
	this.count = function () {
		return _items.length;
	};
	this.fixedCount = function () {
		return _fixedCount;
	},
	this.getItem = function (index) {
		return _items[index];
	};
	this.setItem = function (index, newItem) {
		_items[index] = newItem;
	};
	this.indexOf = function (item) {
		return _items.indexOf(item);
	};
	this.clear = function () {
		_items.length = 0;
	};
	this.expand = function (item, recursive, level) {
		level = arguments.length > 0 ? level : 0;
		if (item) {
			expandItem(item, recursive, level);
		}
	};
	this.collapse = function (item) {
		if (item) {
			var idx = item.index() + 1;
			while (idx < _items.length && _items[idx].level() > item.level()) {
				if (_items[idx] == item.footer()) {
                        _items[idx]._index = -1;
						_items.splice(idx, 1);
					break;
				}
                _items[idx]._index = -1;
				_items.splice(idx, 1);
			}
		}
	};
	this.getNext = function (item) {
		if (item && item.visible() && item.index() < this.count() - 1) {
			return _items[item.index() + 1];
		}
		return null;
	};
	this.getPrior = function (item) {
		if (item && item.visible() && item.index() > 0) {
			return _items[item.index() - 1];
		}
		return null;
	};
    this.getNextData = function (item) {
        var i, cnt;
        if (item && item.visible() && (i = item.index()) < (cnt = this.count()) - 1) {
            while (++i < cnt) {
                if (_items[i].dataIndex() >= 0) {
                    return _items[i];
                }
            }
        }
        return null;
    };
	this.insert = function (item, index) {
		_items.splice(index, 0, item);
	};
	this.remove = function (item) {
		var i = _items.indexOf(item);
		if (i >= 0) {
			_items.splice(i, 1);
			if (item.expanded()) {
				while (i < _items.length && item.isDescendant(_items[i])) {
					_items.splice(i, 1);
				}
			}
		}
	};
	this._clearAndInit = function (fixedCount) {
		var i;
		this.clear();
		_fixedCount = Math.min(fixedCount, _provider.rowCount());
		if (_provider._maxItemCount > 0) {
			_fixedCount = Math.min(fixedCount, _provider._maxItemCount);
		}
		for (i = 0; i < _fixedCount; i++) {
			_items.push(_provider.getItem(i));
		}
	};
};
var TreeItemProvider = defineClass("TreeItemProvider", FilteredRowProvider, {
	init: function () {
		this._super(true);
		this._maxItemCount = 0;
		this._sorter = new TreeItemsSorter();
		this._visibleItems = new HierarchicalVisibleItems(this);
		this._itemMap = [];
		this._expMap = [];
		this._extents = [];
		this._dataCount = 0;
		this._rowCount = 0;
		this._summaryMap = null;
        this._summarizedMap = {};
		this._saveExps = null;
	},
	passiveFiltering: false,
	dataRoot: null,
	customRowProvider: null,
	setPassiveFiltering: function (value) {
		if (value != this._passiveFiltering) {
			this._passiveFiltering = value;
			this._doApplyFilters(true, true);
		}
	},
	setDataRoot: function (value) {
		if (!(value instanceof TreeDataRow) || value.level() <= 0) {
            value = null;
        }
		if (value !== this._dataRoot) {
			this._dataRoot = value;
			this._saveAndRefresh();
		}
	},
	descendantCount: function () {
		return this._rootRow.descendantCount();
	},
	descendantRowCount: function () {
		return this._rootRow.descendantRowCount();
	},
	$_setFooterCallback: function (value) {
		this._footerCallback = value;
	},
	$_iconIndexChanged: function (row) {
		this._fireItemChanged(row);
	},
	$_hasChildrenChanged: function (row) {
		this._fireItemChanged(row);
	},
	$_fireCountEvents: function (oldDataCount, oldRowCount, oldCount) {
		this._fireDataCountChanged(oldDataCount, this.descendantCount());
		this._fireRowCountChanged(oldRowCount, this.descendantRowCount());
		this._fireCountChanged(oldCount, this.rowCount());
	},
	onDataSetDisposed: function (ds/*TreeDataSet*/) {
        var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
		this.$_clearItems(true);
		this.$_resetSummary();
		this._fireReset();
		this.setDataSource(null);
        this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onDataSetReset: function (ds) {
		var save, restore,
        	prevCount = this._dataCount,
			ds = this._dataSource,
			oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
		if (ds.$$_cmd) {
			save = ds.rowCount() < prevCount;
			restore = ds.rowCount() > prevCount;
		}
		if (save) {
			this.onSaveRows(ds.$$_cmd);
			this.$_saveExpanded(this._saveExps = [], this._rootRow);
		}
        this._sortingDirty = true;
		this.$_clearItems(true);
		this.$_resetSummary();
		this.$_buildTree();
		this.$_refreshExtents();
		restore && this.onRestoreRows(ds.$$_cmd);
		this._fireReset();
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onDataSetRefresh: function (ds) {
        var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
		this._saveAndRefresh(-1, true);
		this.$_refreshExtents();
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onDataSetCleared: function (ds) {
		var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
		this.refreshItems(true);
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onDataSetCalculated: function (rows) {
		this._fireDataCalculated(rows);
	},
    onDataSetCommandStackChanged: function (ds, canUndo, canRedo) {
        this._fireUndoStateChanged(canUndo, canRedo);
    },
	onTreeDataSetRowCountChanged: function (ds, newCount) {
	},
	onTreeDataSetRowAdding: function (ds, dataRow, index) {
		return true;
	},
	onTreeDataSetRowAdded: function (ds, index, dataRow) {
		var p = this._itemMap[dataRow.parent().rowId()],
            oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
		if (this.$_needFilter() || this.$_needSort()) {
			ds.$$_cmd ? this._saveAndRefresh(dataRow) : this._saveAndRefresh();
		} else {
			var item = this.$_internalAddItem(p, p.headerCount() + index, dataRow);
			if (item) {
				this._incDescendants(p, 1, 0);
				this.$_buildItems(item);
				this.$_clearSummary();
                ds.$$_cmd && this.onRestoreRow(ds.$$_cmd, item, dataRow.rowId());
				if (p.expanded() && p.visible()) {
					this._expandItem(p, true, false, 0, false);
				} else {
					this._fireItemChanged(p);
				}
			}
		}
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onTreeDataSetRowsAdded: function (ds, parent, index, rows, rowEvents) {
		if (rowEvents) return;
        var i, row, item, cnt, p, list,
			oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
		if (this.$_needFilter() || this.$_needSort()) {
            ds.$$_cmd ? this._saveAndRefresh(rows) : this._saveAndRefresh();
		} else {
            ds.$$_cmd && (list = []);
            p = parent ? this._itemMap[parent.rowId()] : this._rootRow;
            if (p && rows && (cnt = rows.length) > 0) {
                index += p.headerCount();
                for (i = 0; i < cnt; i++) {
                    row = rows[i];
                    item = this.$_internalAddItem(p, index + i, row);
                    if (item) {
						this._incDescendants(p, 1, 0);
                        list && list.push(item);
                        this.$_buildItems(item);
                    }
                }
                this.$_clearSummary();
                if (p.expanded() && p.visible()) {
                    this._expandItem(p, true, false, 0, false);
                } else {
                    this._fireItemChanged(p);
                }
            }
            list && this.onRestoreRows(ds.$$_cmd, list);
        }
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
    onTreeDataSetRowsInserted: function (ds, rows) {
        var i, row, p, index, item,
			oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
        if (this.$_needFilter() || this.$_needSort()) {
            ds.$$_cmd ? this._saveAndRefresh(rows) : this._saveAndRefresh();
        } else {
            ds.$$_cmd && (list = []);
            for (i = 0; i < rows.length; i++) {
                row = rows[i];
                p = row.parent();
                p = p ? this._itemMap[p.rowId()] : this._rootRow;
                if (p) {
                    index = row.index() + p.headerCount();
                    item = this.$_internalAddItem(p, index, row);
                    if (item) {
						this._incDescendants(p, 1, 0);
                        list && list.push(item);
                        this.$_buildItems(item);
                        this.$_clearSummary();
                        if (p.expanded() && p.visible()) {
                            this._expandItem(p, true, false, 0, false);
                        } else {
                            this._fireItemChanged(p);
                        }
                    }
                }
            }
            list && this.onRestoreRows(ds.$$_cmd, list);
        }
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
    },
	onTreeDataSetRowDeleting: function (ds, row) {
		return true;
	},
	onTreeDataSetRowDeleted: function (ds, row) {
        var oldCount, oldRowCount, oldDataCount, p,
            id = row.rowId(),
		    item = this._itemMap[id];
		if (item) {
            oldCount = this.rowCount();
			oldRowCount = this.descendantRowCount();
			oldDataCount = this.descendantCount();
			p = item.parent();
            ds.$$_cmd && this.onSaveRow(ds.$$_cmd, item, id);
            this._sortingDirty = true;
			if (this.$_needFilter() || this.$_needSort()) {
                this._saveAndRefresh();
			} else {
				this.$_internalRemoveItem(item);
				this._incDescendants(p, -item._descendantCount - 1, 0);
                this.$_clearSummary();
				if (p.expanded() && p.visible()) {
					this._visibleItems.remove(item);
					this._fireRefresh();
				} /*else if (!p.expanded()) {
				 this._fireItemChanged(p);
				 }*/
			}
			this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
		}
	},
	onTreeDataSetRowsDeleting: function (ds, rows) {
		return true;
	},
	onTreeDataSetRowsDeleted: function (ds, rows) {
        var i, cnt, item, p, oldCount, oldRowCount, oldDataCount,
		    removed = false,
            items = [];
        for (i = 0, cnt = rows.length; i < cnt; i++) {
            item = this._itemMap[rows[i].rowId()];
            item && items.push(item);
        }
        if ((cnt = items.length) > 0) {
            ds.$$_cmd && this.onSaveRows(ds.$$_cmd, items);
			oldCount = this.rowCount();
			oldRowCount = this.descendantRowCount();
			oldDataCount = this.descendantCount();
            this._sortingDirty = true;
			if (this.$_needFilter() || this.$_needSort()) {
                this._saveAndRefresh();
				removed = true;
			} else {
				for (i = 0; i < cnt; i++) {
					item = items[i];
					if (item) {
						p = item.parent();
						this.$_internalRemoveItem(item);
						this._incDescendants(p, -item._descendantCount - 1, 0);
                        this.$_clearSummary();
						if (p.expanded() && p.visible()) {
							this._visibleItems.remove(item);
							removed = true;
						}
					}
				}
			}
            removed && this._fireRefresh();
            this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
        }
	},
	onTreeDataSetRowUpdating: function (ds, row) {
		return true;
	},
	onTreeDataSetRowUpdated: function (ds, dataRow) {
        var item, oldCount, oldRowCount, oldDataCount,
			filtering = this.$_needFilter();
		item = this._itemMap[dataRow.rowId()];
        if (item || filtering) {
			this._sortingDirty = true;
			filtering = filtering || this.$_needSort();
            if (filtering) {
                oldCount = this.rowCount();
                oldRowCount = this.descendantRowCount();
                oldDataCount = this.descendantCount();
                filtering = true;
                this._saveAndRefresh();
            } else {
                this.$_clearSummary();
            }
			if (!item) {
				item = this._itemMap[dataRow.rowId()];
			}
            this._fireItemUpdated(item);
            filtering && this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
        }
	},
	onTreeDataSetRowsUpdated: function (ds, dataRows) {
		var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
        this._sortingDirty = true;
        this._saveAndRefresh();
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	onTreeDataSetValueChanging: function (ds, dataRow, field) {
		return true;
	},
	onTreeDataSetValueChanged: function (ds, dataRow, field) {
        var item, oldCount, oldRowCount, oldDataCount,
			filtering = this.$_needFilter();
		item = this._itemMap[dataRow.rowId()];
        if (item || filtering) {
            this._sortingDirty = true;
			filtering = filtering || this.$_needSort();
            if (filtering) {
                oldCount = this.rowCount();
                oldRowCount = this.descendantRowCount();
                oldDataCount = this.descendantCount();
                filtering = true;
                this._saveAndRefresh();
            } else {
                this.$_clearSummary();
            }
			if (!item) {
				item = this._itemMap[dataRow.rowId()];
			}
            this._fireItemUpdated(item);
            filtering && this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
        }
	},
	onTreeDataSetStateChanged: function (ds, dataRow, updating) {
		if (updating) return;
		var p, oldCount, oldRowCount, oldDataCount,
			filtering = this.$_needFilter() && this._dataStateFiltering,
     		item = this._itemMap[dataRow.rowId()];
		if (item || filtering) {
            oldCount = this.rowCount();
            oldRowCount = this.descendantRowCount();
            oldDataCount = this.descendantCount();
            if (this.$_needFilter()) {
                this._saveAndRefresh();
            } else {
                this.$_internalRowStateChanged(item);
            }
			if (!item) {
				item = this._itemMap[dataRow.rowId()];
			}
			this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
		}
	},
	onTreeDataSetStatesChanged: function (ds, dataRows, updating) {
		if (updating) return;
		var row, dataRow, removed, i, p,
            oldCount = this.rowCount(),
            oldRowCount = this.descendantRowCount(),
            oldDataCount = this.descendantCount();
		    len = dataRows.length;
        if (this.$_needFilter() && this._dataStateFiltering) {
            this._saveAndRefresh();
        } else if (len == 1) {
			dataRow = dataRows[0];
			row = this._itemMap[dataRow.rowId()];
			this.$_internalRowStateChanged(row);
		} else if (len > 0) {
			removed = false;
			if (this._hideDeleted) {
                for (i = 0; i < len; i++) {
                    row = this._itemMap[dataRows[i].rowId()];
                    if (row) {
                        if (DataRowState.isDeleted(row.dataState())) {
                            p = row.parent();
                            this.$_internalRemoveItem(row);
                            if (p.expanded() && p.visible()) {
                                this._visibleItems.remove(row);
                            }
                            removed = true;
                        } else if (DataRowState.isDeleted(row.dataRow().oldState())) {
                            removed = true;
                        }
                    }
                }
            }
			if (removed) {
                this.$_clearSummary();
			}
            this._fireRefresh();
		}
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
    onDataSetStatesCleared: function (ds) {
        var oldCount = this.rowCount(),
            oldRowCount = this.descendantRowCount(),
            oldDataCount = this.descendantCount();
        this._saveAndRefresh();
        this._fireRowStatesCleared();
        this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
    },
    onTreeDataSetTagChanged: function (ds, dataRow) {
        var filtering, oldCount, oldRowCount, oldDataCount,
			item = this._itemMap[dataRow.rowId()];
		filtering = this._dataTagFiltering && this.$_needFilter();
		if (item) {
			if (filtering) {
				oldCount = this.rowCount();
				oldRowCount = this.descendantRowCount();
				oldDataCount = this.descendantCount();
    			this._saveAndRefresh();
			}
			if (!item) {
				item = this._itemMap[dataRow.rowId()];
			}
			this._fireRowTagChanged(item);
			filtering && this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
		}
    },
    onTreeDataSetTagsChanged: function (ds, dataRows) {
		var oldCount, oldRowCount, oldDataCount,
			filtering = this._dataTagFiltering && this.$_needFilter();
		if (filtering) {
			oldCount = this.rowCount();
			oldRowCount = this.descendantRowCount();
			oldDataCount = this.descendantCount();
    		this._saveAndRefresh();
		}
		this._fireRowTagsChanged(this.getRowsOfDataRows(dataRows));
		filtering && this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
    },
    onDataSetTagsCleared: function (ds) {
        var oldCount, oldRowCount, oldDataCount,
            filtering = this._dataTagFiltering && this.$_needFilter();
        if (filtering) {
            oldCount = this.rowCount();
            oldRowCount = this.descendantRowCount();
            oldDataCount = this.descendantCount();
            this._saveAndRefresh();
        }
        this._fireRowTagsCleared();
        filtering && this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
    },
	dataSource: function () {
		return this._dataSource;
	},
	setDataSource: function (value) {
		if (value === this._dataSource) {
			return;
		}
		var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount();
		this.$_clearItems();
		this.$_resetSummary();
		if (this._dataSource) {
			this._dataSource.removeListener(this);
		}
		this._dataSource = _cast(value, TreeDataSet);
		if (this._dataSource) {
			this.$_buildTree();
			this._dataSource.addListener(this);
		}
		this._fireReset();
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	rowCount: function () {
		return this._visibleItems.count();
	},
	dataRowCount: function () {
		return this._rowCount;
	},
	getItem: function (index) {
		if (index >= 0 && index < this._visibleItems.count()) {
			return this._visibleItems.getItem(index);
		} else {
			return null;
		}
	},
	getRowOfDataRow: function (dataRow) {
		return (dataRow instanceof TreeDataRow) ? this._itemMap[dataRow.rowId()] : this._itemMap[dataRow];
	},
	getRowsOfDataRows: function (dataRows, all) {
		var rows, i, cnt, row,
			map = this._itemMap;
		if (_isArray(dataRows)) {
			rows = [];
			for (i = 0, cnt = dataRows.length; i < cnt; i++) {
				row = dataRows[i];
				row = (row instanceof TreeDataRow) ? map[row.rowId()] : map[row];
				row && (all || row.index() >= 0) && rows.push(row);
			}
		}
		return rows;
	},
	refreshItems: function (clearExtents) {
		this.$_clearItems(clearExtents);
		this.$_buildTree();
		this._fireRefresh();
	},
	$_refreshItems: function () {
		this.$_clearItems();
		this.$_buildTree();
	},
	_saveAndRefresh: function (restoreRows, clearExtents) {
        var i,
            ds = this._dataSource,
			oldCount = this._dataCount,
			newCount = ds ? ds.rowCount() : 0,
			save = [];
		if (restoreRows == -1) {
			if (ds.$$_cmd) {
				if (newCount < oldCount) {
					this.onSaveRows(ds.$$_cmd);
					this.$_saveExpanded(this._saveExps = [], this._rootRow);
				}
			}
		}
		(newCount > 0) && this.$_saveExpanded(save, this._rootRow);
		this.$_clearItems(clearExtents);
		this.$_buildTree(save);
		if (restoreRows == -1) {
			if (ds.$$_cmd) {
				if (ds.rowCount() > oldCount) {
					this.onRestoreRows(ds.$$_cmd);
				}
			}
		} else if (_isArray(restoreRows)) {
            for (i = restoreRows.length; i--;) {
                restoreRows[i] = this.getRowOfDataRow(restoreRows[i]);
            }
			this.onRestoreRows(ds.$$_cmd, restoreRows);
        } else if (restoreRows) {
			this.onRestoreRow(ds.$$_cmd, this.getRowOfDataRow(restoreRows), restoreRows.rowId());
		}
		this._fireRefresh();
	},
	getIndexOfRow: function (dataRow) {
		var item = this._itemMap[dataRow];
		return item && item.visible() ? item.index() : -1;
	},
	getItemOfRow: function (dataRow, all) {
		var row = this._itemMap[dataRow];
		return (row && (all || row.index() >= 0)) ? row : null;
	},
	fixedCount: function () {
		return 0;
	},
	setFixed: function (count, sorting, filtering) {
	},
	maxItemCount: function () {
		return this._maxItemCount;
	},
	setMaxItemCount: function (value) {
		value = Math.max(0, parseInt(value));
		if (!isNaN(value) && value != this._maxItemCount) {
			var oldCount = this.rowCount(),
				oldRowCount = this.descendantRowCount(),
				oldDataCount = this.descendantCount();
			this._maxItemCount = value;
			this._saveAndRefresh();
			this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
		}
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		var row, flds, types, i, item, found, c, all, textMatch, sensitive, partial,
			vitems = this._visibleItems,
			ds = this.dataSource();
		if (!ds) {
			return -1;
		}
		rows = this.rowCount();
		if (rows < 1) {
			return -1;
		}
		flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
		types = [];
		for (i = 0; i < flds; i++) {
			types.push(ds.getField(fields[i]).dataType() == ValueType.TEXT);
		}
		all = !options || options.allFields === undefined || options.allFields;
		textMatch = options && options.textMatch;
		sensitive = options && options.caseSensitive;
		partial = options && options.partialMatch;
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		for (i = startIndex; i <= endIndex; i++) {
			item = vitems.getItem(i);
			found = item.dataIndex() >= 0;
			if (found) {
				for (c = 0; c < flds; c++) {
					if (textMatch || types[c]) {
						found = $$_compareTextValue(values[c], item.getValue(fields[c]), sensitive, partial);
					} else {
						found = values[c] == item.getValue(fields[c]);
					}
					if (found && !all) {
						return i;
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
    findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
		var rows, types, textMatch, sensitive, partial, fldLen, i, item, f, found, c,
			vitems = this._visibleItems,
        	ds = this.dataSource();
        if (!ds) {
            return null;
        }
        rows = this.rowCount();
        if (rows < 1) {
            return null;
        }
		textMatch = options && options.textMatch;
		sensitive = options && options.caseSensitive;
		partial = options && options.partialMatch;
		fldLen = fields.length;
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(rows - 1, endIndex);
        startFieldIndex = Math.max(0, startFieldIndex);
		types = [];
		for (i = 0; i < fldLen; i++) {
			types.push(ds.getField(fields[i]).dataType() == ValueType.TEXT);
		}
        if (startFieldIndex >= fields.length) {
            startIndex++;
            startFieldIndex = 0;
        }
        for (i = startIndex; i <= endIndex; i++) {
            item = vitems.getItem(i);
            if (item.dataIndex() >= 0) {
                c = (i > startIndex) ? 0 : startFieldIndex;
                for (; c < fldLen; c++) {
                    f = fields[c];
					if (textMatch || types[c]) {
						found = $$_compareTextValue(value, item.getValue(f), sensitive, partial);
					} else {
						found = value == item.getValue(f);
					}
					if (found) {
						return {
							rowIndex: i,
							fieldIndex: f,
							fieldName: ds.getFieldName(f),
							searchFieldIndex: c
						};
					}
                }
            }
        }
        return null;
    },
	expandWhenGrouping: true,
	footerWhenExpanded: true,
	setFooterWhenExpanded: function (value) {
		if (value != this._footerWhenExpanded) {
			this._footerWhenExpanded = value;
			this.$_resetVisibleItems();
			this._resetItemIndices();
			this._fireRefresh();
		}
	},
	footerWhenCollapsed: true,
	setFooterWhenCollapsed: function (value) {
		if (value != this._footerWhenCollapsed) {
			this._footerWhenCollapsed = value;
			this.$_resetVisibleItems();
			this._resetItemIndices();
			this._fireRefresh();
		}
	},
	summaryScope: TreeSummaryScope.DESCENDANT,
	setSummaryScope: function () {
		if (value != this._summaryScope) {
			this._summaryScope = value;
			this.$_clearSummary();
			this._fireRefresh();
		}
	},
	rowSummaryScope: TreeSummaryScope.DESCENDANT,
	setRowSummaryScope: function () {
		if (value != this._rowSummaryScope) {
			this._rowSummaryScope = value;
			this.$_clearGroupSummary();
			this._fireRefresh();
		}
	},
	setSummaryScopes: function (scope, rowScope) {
		var changed = scope != this._summaryScope;
		if (changed || rowScope != this._rowSummaryScope) {
			this._summaryScope = scope;
			this._rowSummaryScope = rowScope;
			changed ? this.$_clearSummary() : this.$_clearGroupSummary();
			this._fireRefresh();
		}
	},
	summaryMode: "aggregate",
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
			this.$_clearSummary();
			this._fireRefresh();
		}
	},
	groupSummaryMode: "aggregate",
	setGroupSummaryMode: function (value) {
		if (value != this._groupSummaryMode) {
			this._groupSummaryMode = value;
			this.$_clearGroupSummary();
			this._fireRefresh();
		}
	},
    getNextDataRow: function (row) {
        return this._visibleItems.getNextData(row);
    },
    $_visitChildren: function (parent, callback, visibleOnly) {
        var i, cnt, child,
			children = parent._children;
        if (children && (cnt = children.length) > 0) {
            for (i = 0; i < cnt; i++) {
                child = children[i];
                if (callback(children[i]) === false) {
					return false;
				}
                if (!visibleOnly || parent.expanded()) {
                    if (this.$_visitChildren(child, callback, visibleOnly) === false) {
						return false;
					}
                }
            }
        }
    },
    visitAll: function (callback, visibleOnly) {
        if (callback) {
            if (visibleOnly) {
                return this._super(callback);
            } else {
                return this.$_visitChildren(this._rootRow, callback, visibleOnly);
            }
        }
    },
	insertItem: function (parent, item, index, after) {
		var i, cnt, lev,
			visibles = this._visibleItems;
		if (parent.collapsed()) {
			visibles.expand(parent, false);
		}
		i = visibles.indexOf(parent.getItem(index));
		if (after) {
			parent.insert(index + 1, item);
			cnt = visibles.count();
			lev = parent.level() + 1;
			while (++i < cnt) {
				if (visibles.getItem(i).level() <= lev) {
					break;
				}
			}
			visibles.insert(item, i);
		} else {
			parent.insert(index, item);
			visibles.insert(item, i);
		}
	},
	appendItem: function (parent, item) {
		var i, cnt, lev,
			visibles = this._visibleItems;
		if (parent.collapsed()) {
			visibles.expand(parent, false);
		}
		if (parent.count() > 0) {
			i = visibles.indexOf(parent.getItem(parent.count() - 1));
		} else {
			i = visibles.indexOf(parent);
		}
		cnt = visibles.count();
		lev = parent.level();
		while (++i < cnt) {
			if (visibles.getItem(i).level() <= lev) {
				break;
			}
		}
		parent.add(item);
		visibles.insert(item, i);
	},
	removeItem: function (item) {
		this._visibleItems.remove(item);
		item.parent().remove(item);
	},
	$_calcLevel: function (item, level, visibleOnly) {
		var i, cnt, child, 
			lev = level;
		for (i = 0, cnt = item.count(); i < cnt; i++) {
			child = item.getItem(i);
			if (child) {
				lev = Math.max(lev, level + 1);
				if (child instanceof GroupRow && (!visibleOnly || child.expanded())) {
					lev = Math.max(lev, this.$_calcLevel(child, level + 1, visibleOnly));
				}
			}
		}
		return lev;
	},
	getLevels: function (visibleOnly) {
		return this.$_calcLevel(this._rootRow, 0, visibleOnly);
	},
	$_setExpanded: function (item, recursive, level) {
		var i, child, cnt;
		this._setExpanded(item, true);
		this._expMap[item._dataRow.rowId()] = true;
		item.setHasChildren(false);
		if (recursive) {
			cnt = item.count();
			for (i = 0; i < cnt; i++) {
				child = item.getItem(i);
				if (child instanceof TreeRow && (child.expanded() || child.level() < level)) {
					this.$_setExpanded(child, true, level);
				}
			}
		}
	},
	_expandItem: function (item, force, recursive, level, fireEvents) {
		if (item && item.visible() && (force || !item.expanded())) {
			if (fireEvents && !this._fireExpanding(item)) {
				return;
			}
			this._visibleItems.collapse(item);
			this._visibleItems.expand(item, recursive, level);
			this._resetItemIndices(item === this._rootRow ? 0 : item.index());
			this.$_setExpanded(item, recursive, level > 0 ? item.level() + level : 1000000);
			try {
				this._fireRefresh();
			} finally {
				if (fireEvents) {
					this._fireExpanded(item);
				}
			}
		}
	},
	expand: function (item, recursive, force) {
		if (this._editing) return;
		var oldCount = this.rowCount();
		this._expandItem(item, force, recursive, 0, true);
		this._fireCountChanged(oldCount, this.rowCount());
	},
	expandAll: function (level) {
		if (this._editing) return;
		var oldCount = this.rowCount();
		this._expandItem(this._rootRow, true, true, level > 0 ? level + 1 : 0, true);
		this._fireCountChanged(oldCount, this.rowCount());
	},
	$_setCollapsed: function (item, recursive) {
		var i, child, cnt;
		this._setExpanded(item, false);
		this._expMap[item._dataRow.rowId()] = false;
		if (recursive) {
			cnt = item.count();
			for (i = 0; i < cnt; i++) {
				child = item.getItem(i);
				if (child instanceof TreeRow) {
					this.$_setCollapsed(child, true);
				}
			}
		}
	},
	_collapseItem: function (item, force, recursive, fireEvents) {
		if (item && item.visible() && (force || item.expanded())) {
			if (fireEvents && !this._fireCollapsing(item)) {
				return;
			}
			this._visibleItems.collapse(item);
			this.$_setCollapsed(item, recursive);
			if (item == this._rootRow) {
				this._visibleItems.expand(this._rootRow, false);
			}
			this._resetItemIndices(item === this._rootRow ? 0 : item.index());
			try {
				this._fireRefresh();
			} finally {
				if (fireEvents) {
					this._fireCollapsed(item);
				}
			}
		}
	},
	collapse: function (item, recursive) {
		if (this._editing) return;
		var oldCount = this.rowCount();
		this._collapseItem(item, false, recursive, true);
		this._fireCountChanged(oldCount, this.rowCount());
	},
	collapseAll: function () {
		if (this._editing) return;
		var oldCount = this.rowCount();
		this._collapseItem(this._rootRow, true, true, true);
		this._fireCountChanged(oldCount, this.rowCount());
	},
	reveal: function (row) {
		if (row) {
			if (!row.visible()) {
				var p = row.parent();
				while (p.parent() != this._rootRow) {
					p = p.parent();
				}
				this._expandItem(p, true, true, row.level() - p.level(), true);
			}
			return row.visible();
		}
	},
	$_saveExpanded: function (map, item) {
		var i, child,
			cnt = item.count();
		for (i = 0; i < cnt; i++) {
			child = _cast(item.getItem(i), TreeRow);
			if (child) {
				if (child.expanded()) {
					map[child.dataId()] = true;
					this.$_saveExpanded(map, child);
				}
			}
		}
	},
	$_saveExtents: function (map, item) {
		item.visitAll(function (child) {
			map[child.dataId()] = child._viewExts;
		});
	},
	orderBy: function (fields, directions, textCases, fireEvent) {
        fireEvent = arguments.length > 3 ? fireEvent : true;
		var cnt, len, clen, i;
		if (!this._fireSorting(fields, directions, textCases)) {
            return;
        }
		this._sortFields = [];
		this._sortDirections = [];
        this._sortCases = [];
		cnt = fields ? fields.length : 0;
		len = directions ? directions.length : 0;
        clen = textCases ? textCases.length : 0;
		for (i = 0; i < cnt; i++) {
			this._sortFields.push(fields[i]);
			if (len > i) {
				this._sortDirections.push(directions[i]);
			} else if (len > 0) {
				this._sortDirections.push(directions[len - 1]);
			} else {
				this._sortDirections.push(SortDirection.ASCENDING);
			}
            if (clen > i) {
                this._sortCases.push(textCases[i]);
            } else if (clen > 0) {
                this._sortCases.push(textCases[clen - 1]);
            } else {
                this._sortCases.push(SortCase.SENSITIVE);
            }
		}
		this._explicitSort = true;
		this.$_refreshItems();
		try {
			if (fireEvent) {
				this._fireRefresh();
			}
		} finally {
			this._fireSorted();
		}
	},
	_doApplyFilters: function (fireEvent, noFilter) {
		var oldCount = this.rowCount(),
			oldRowCount = this.descendantRowCount(),
			oldDataCount = this.descendantCount()
		this.$_refreshItems();
		try {
			if (fireEvent) {
				this._fireRefresh();
			}
		} finally {
			if (!noFilter) {
				this._fireFiltered();
			}
		}
		this.$_fireCountEvents(oldDataCount, oldRowCount, oldCount);
	},
	_doApplyRowFilter: function () {
		this._doApplyFilters(true);
	},
	_createRootRow: function () {
		this._rootRow = new RootTreeRow(this);
		this._setExpanded(this._rootRow, true);
		return this._rootRow;
	},
	$_collectItems: function (item, list) {
		var i, cnt, child;
		for (i = 0, cnt = item.count(); i < cnt; i++) {
			child = item.getChild(i);
            list.push(child);
			if (child instanceof TreeRow) {
				this.$_collectItems(child, list);
			}
		}
		return list;
	},
	getAllItems: function () {
		return this.$_collectItems(this._rootRow, []);
	},
	getTopItems: function () {
		return this._rootRow.children();
	},
	getLeafItems: function (visibleOnly, dataOnly) {
		return this._rootRow.getLeaves(visibleOnly, dataOnly);
	},
    /*
	hasCellstyle: function () {
		return !this._cellStyles.isEmpty();
	},
	setCellStyle: function (row, field, style) {
		this._cellStyles.setCellStyle(row, field, style);
	},
	setCellStyles: function (provider, rows, fieldMap, startRow, count) {
		this._cellStyles.setCellStyles(provider, rows, fieldMap, startRow, count);
	},
	removeCellStyle: function (style) {
		this._cellStyles.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._cellStyles.clearCellStyles();
	},
	getCellStyle: function (dataRow, field) {
		return this._cellStyles.getCellStyle(dataRow, field);
	},
	*/
    getNumber: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.count : this._rowCount;
    },
	getSum: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.sum : NaN;
	},
	getMax: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.max : NaN;
	},
	getMin: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.min : NaN;
	},
	getAvg: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.avg : NaN;
	},
	getVar: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.vars : NaN;
	},
	getVarp: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.varsp : NaN;
	},
	getStdev: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? Math.sqrt(fs.vars) : NaN;
	},
	getStdevp: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? Math.sqrt(fs.varsp) : NaN;
	},
    getSummarized: function (scope) {
        return this._summarizedMap[scope.$_hash];
    },
    setSummarized: function (scope, value) {
        return this._summarizedMap[scope.$_hash] = value;
    },
	_doGetDistinctValues: function (field, dataType) {
		var comparer = this._dataSource.$_getComparer(dataType),
			rows = this._rootRow.getDescendants(false, true);
        if (rows) {
            rows.sort(function (row1, row2) {
                return comparer(field, row1.dataRow(), row2.dataRow());
            });
            return rows;
        }
        return [];
	},
    _hideDeletedChanged: function () {
        this._saveAndRefresh();
    },
    $_refreshExtents: function () {
		var exts = this._extents = [],
			exps = this._expMap = [];
		this._rootRow.visitAll(function (child) {
			var id, row = child._dataRow;
			if (row) {
				id = row.rowId();
				exps[id] = child.expanded();
				exts[id] = child._viewExts;
			}
		});
	},
	$_checkSelected: function (parent) {
		var i, cnt, row, item;
		for (i = 0, cnt = parent.count(); i < cnt; i++) {
			row = parent.getChild(i);
			item = TreeRow.getTemp(row, i);
			item._parent = parent;
			item.$_childIndex = i;
			row.$_selected = this.$_selectItem(item);
			this.$_checkSelected(row);
			if (row.$_selected) {
				parent.$_selected = true;
			}
		}
	},
	$_internalAddItem: function (parent, index, dataRow) {
		var id, item;
		if (this._hideDeleted && DataRowState.isDeleted(dataRow.rowState())) {
			return null;
		}
		item = TreeRow.getTemp(dataRow, index);
		item._parent = parent;
		item.$_childIndex = index;
		if (this._passiveFiltering && dataRow.$_selected || !this._passiveFiltering && this.$_selectItem(item)) {
			item = new TreeRow(dataRow);
            parent.insert(index, item);
			this._rowCount++;
			this._itemMap[dataRow.rowId()] = item;
			return item;
		}
		return null;
	},
	$_internalRemoveItem: function (item) {
		if (item) {
			item.parent().remove(item);
			this._rowCount--;
			this._itemMap[item._dataRow.rowId()] = undefined;
		}
	},
	$_internalRowStateChanged: function (item) {
		if (item && item.visible()) {
			if (this._hideDeleted && (DataRowState.isDeleted(item.dataState()) || DataRowState.isDeleted(item.dataRow().oldState()))) {
				var p = item.parent();
				this.$_internalRemoveItem(item);
				this.$_clearSummary();
				if (p.expanded() && p.visible()) {
					this._visibleItems.remove(item);
					this._fireRefresh();
				}
			} else {
				this._fireItemChanged(item);
			}
		}
	},
	_setItem: function (item, newItem) {
		this._visibleItems.setItem(item.index(), newItem);
		this._resetItemIndex(item.index());
	},
	$_resetVisibleItems: function () {
		this._visibleItems._clearAndInit(this.fixedCount());
		this._visibleItems.expand(this._rootRow, false);
		this._setExpanded(this._rootRow, true);
		this._resetItemIndices(0);
	},
	$_clearItems: function (clearExtents) {
		this._visibleItems.clear();
		this._rootRow.clear();
		this._itemMap = [];
		this._rowCount = 0;
		if (clearExtents) {
			this._expMap = [];
			this._extents = [];
		}
	},
	$_selectItem: function (item) {
		return this.$_select(item, this._activeRowFilter);
	},
	$_buildItem: function (parent, dataRow, index, exps, expandedMap, expMap, footerCallback) {
		var inc, id, list,
			item = this.$_internalAddItem(parent, index, dataRow);
		if (item) {
			this.$_checkCount && this.$_buildCount--;
			inc = 0;
			id = dataRow.rowId();
			if (exps[id] || expandedMap && expandedMap[id] || expMap && expMap[id]) {
				this._setExpanded(item, true);
			}
			if (dataRow.count() > 0) {
				list = item._customHeaders = this._customRowProvider.getCustomHeaderRows(item);
				if (list) {
					item.addAll(list);
					inc += list.length;
				}
				this.$_buildItems(item, expandedMap, expMap);
				list = item._customFooters = this._customRowProvider.getCustomFooterRows(item);
				if (list) {
					item.addAll(list);
					inc += list.length;
				}
				if (footerCallback && footerCallback(item)) {
					item.add(item.$_createFooter());
					inc++;
				}
			}
			this._incDescendants(parent, 1, inc);
			return item;
		}
	},
	$_buildItems: function (parent, expandedMap, expMap, dataRoot) {
		var i, cnt, child, item, inc, id, list, exts,
			exps = this._expMap,
			callback = this._footerCallback,
			dataRow = parent.dataRow(),
			n = parent.count();
		if (this._passiveFiltering) {
			dataRow.$_selected = false;
			this.$_checkSelected(dataRow);
		}
		if (dataRoot instanceof TreeDataRow) {
			this.$_buildItem(parent, dataRoot, n, exps, expandedMap, expMap, callback);
		} else {
			for (i = 0, cnt = dataRow.count(); i < cnt; i++) {
				if (this.$_checkCount && this.$_buildCount <= 0) {
					break;
				}
				child = dataRow.getChild(i);
				this.$_buildItem(parent, child, n + i, exps, expandedMap, expMap, callback);
			}
		}
		exts = this._extents;
		parent.visitAll(function (child) {
			var row = child._dataRow;
			if (row) {
				var id = row.rowId();
				if (exts[id]) {
					child._viewExts = exts[id];
				}
			}
		});
	},
	$_sortItem: function (parent) {
		var cnt = parent.count();
		var i, j;
		if (cnt > 1) {
			i = 0;
			j = cnt - 1;
			while (i < j && !(parent.getItem(i) instanceof TreeRow)) {
				i++;
			}
			while (j > i && !(parent.getItem(j) instanceof TreeRow)) {
				j--;
			}
			if (j == i) return;
			this.$_sort(parent, 0, i, j);
		}
		for (i = 0; i < cnt; i++) {
			var child = parent.getItem(i);
			if (child instanceof TreeRow) {
				this.$_sortItem(child);
			}
		}
	},
	$_sort: function (parent, level, startIndex, endIndex) {
		var t, equalFunc, i, pi,
			field = this._sortFields[level],
			dir = this._sortDirections[level],
        	ds = this._dataSource,
        	ignoreCase = this._sortCases[level] == SortCase.INSENSITIVE;
		this._sorter.run(parent, field, dir, ignoreCase, startIndex, endIndex, level + 1 == this._sortFields.length);
        t = ds.getField(field).dataType();
        if (t == ValueType.TEXT && ignoreCase) {
            equalFunc = ds.equalTexts.bind(ds);
        } else {
            equalFunc = ds.equalValues.bind(ds);
        }
		if (level + 1 < this._sortFields.length) {
			i = startIndex;
			pi = i;
			while (i < endIndex) {
				i++;
				if (!equalFunc(field, parent.getItem(i).dataRow(), parent.getItem(i - 1).dataRow())) {
					this.$_sort(parent, level + 1, pi, i - 1);
					pi = i;
				}
			}
			if (pi < endIndex) {
				this.$_sort(parent, level + 1, pi, endIndex);
			}
		}
	},
	$_buildTree: function (expandedMap) {
		var ds = this._dataSource;
		if (!ds) return;
		this._filtered = this.$_checkFiltered() || this.maxItemCount() > 0; // && this._hiddenCount > 0;
		this.$_prepareFilters(ds);
		this._sorted = this.$_checkSorted();
		this._dataCount = ds.rowCount();
		this._rootRow._dataRow = ds.rootRow();
		this._rootRow._descendantCount = 0;
		this._itemMap[this._rootRow._dataRow.rowId()] = this._rootRow;
		this.$_checkCount = this._maxItemCount > 0;
		this.$_buildCount = this._maxItemCount;
		this.$_buildItems(this._rootRow, expandedMap, this._saveExps, this._dataRoot);
		this.$_checkCount = false;
		this._saveExps = [];
		this.$_clearSummary();
		if (this._sorted && this._rootRow.count() > 1) {
			this.$_sortItem(this._rootRow);
		}
        this._sortingDirty = false;
		this.$_resetVisibleItems();
	},
	$_resetSummary: function () {
		this._summaryMap = [];
        this._summarizedMap = {};
		this._rootRow._clearSummary();
	},
	$_resetGroupSummary: function () {
		this._rootRow._clearSummary();
	},
	$_clearSummary: function () {
		if (this._summaryMap) {
			for (var i = this._summaryMap.length; i--;) {
				this._summaryMap[i] && this._summaryMap[i].clear();
			}
		}
        this._summarizedMap = {};
		this._rootRow._clearSummary();
	},
	$_clearGroupSummary: function () {
		this._rootRow._clearSummary();
	},
	$_getSummary: function (field) {
		var ds,
			summary = this._summaryMap[field];
		if (!summary) {
			ds = this.dataSource();
			if (ds && ds.canSummarize(field)) {
				summary = new FieldSummary(field);
				this._summaryMap[field] = summary;
			}
		}
		if (summary && summary.count == 0 && this.rowCount() > 0) {
			this.$_summarize(summary);
		}
		return summary;
	},
	$_summarize: function (fldSummary) {
		var scope, items, row, r, cnt, rows, i, ti,
			ds = this.dataSource(),
			root = this._rootRow;
		if (!ds) return;
		scope = this.summaryScope();
		switch (scope) {
			case TreeSummaryScope.DESCENDTANT:
			case TreeSummaryScope.ALL:
				if (this._filtered) {
					items = root.getDescendants(false, true);
				} else {
					fldSummary.count = ds.rowCount();
					ds.aggregate(fldSummary, this._summaryMode == SummaryMode.STATISTICAL);
					return;
				}
				break;
			case TreeSummaryScope.CHILD:
			case TreeSummaryScope.PARENT_CHILD:
				items = [];
				for (i = root.count(); i--;) {
					items.push(root.getChild(i));
				}
				break;
			case TreeSummaryScope.GROUP:
				items = [];
				root.visitRows(false, true, function (child) {
					child.count() > 0 && items.push(child);
				});
				break;
			case TreeSummaryScope.LEAF:
				items = [];
				root.visitRows(false, true, function (child) {
					child.count() == 0 && items.push(child);
				});
				break;
		}
		rows = [];
		cnt = items.length;
		for (i = 0; i < cnt; i++) {
			ti = items[i];
			if (ti instanceof TreeRow) {
				rows.push(ti.dataRow());
			}
		}
		fldSummary.count = rows.length;
		ds.aggregateRange(fldSummary, rows, this._summaryMode == SummaryMode.STATISTICAL);
	},
	_fireItemChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.ITEM_CHANGED, item);
		} 
	},
	_fireExpanding: function (item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.EXPANDING, item);
		}
		return true;
	},
	_fireExpanded: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.EXPANDED, item);
		}
	},
	_fireCollapsing: function (item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.COLLAPSING, item);
		} 
		return true;
	},
	_fireCollapsed: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.COLLAPSED, item);
		} 
	}
});
TreeItemProvider.ITEM_CHANGED = "onTreeItemProviderItemChanged";
TreeItemProvider.EXPANDING = "onTreeItemProviderExpanding";
TreeItemProvider.EXPANDED = "onTreeItemProviderExpanded";
TreeItemProvider.COLLAPSING = "onTreeItemProviderCollapsing";
TreeItemProvider.COLLAPSED = "onTreeItemProviderCollapsed";
var TreeEditItem = defineClass("TreeEditItem", TreeRow, {
	init: function (provider, item, state) {
		this._super(item ? item.dataRow() : null);
		this._provider = provider;
		this._item = item;
		this._state = state;
		this._values = [];
		this._started = false;
		this._checkDiff = false;
        this._strictDiff = false;
	},
	values: function () {
		return this._values.concat();
	},
	setValues: function (vals) {
		var i, f, fld, oldValue, newValue,
			ds = this.dataSource(),
			cnt = ds.fieldCount();
		if (_isArray(arr)) {
			cnt = Math.min(cnt, vals.length);
			for (i = 0; i < cnt; i++) {
				fld = ds.getField(i);
				oldValue = this._values[i];
				newValue = fld.readValue(arr[i]);
				this._values[i] = newValue;
				if (this._started && parent && !fld.equalValues(oldValue, newValue)) {
					this._provider._editItemCellUpdated(this, i, oldValue, newValue);
				}
			}
		} else if (vals) {
			for (i = 0; i < cnt; i++) {
				f = ds.getFieldName(i);
				if (vals.hasOwnProperty(f)) {
					fld = ds.getField(i);
					oldValue = this._values[i];
					newValue = fld.readValue(vals[f]);
					this._values[i] = newValue;
					if (this._started && parent && !fld.equalValues(oldValue, newValue)) {
						this._provider._editItemCellUpdated(this, i, oldValue, newValue);
					}
				}
			}
		}
	},
	setDiffs: function (checkDiff, strictDiff) {
		this._checkDiff = checkDiff;
		this._strictDiff = strictDiff;
	},
	beginEdit: function (checkDiff, strictDiff) {
		this._started = true;
		this.setDiffs(checkDiff, strictDiff);
	},
	setEditValue: function (field, value, noCalc) {
		var fld, oldValue,
			ds = this.dataSource();
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		fld = ds.getField(field);
		oldValue = this._values[field];
		value = fld.readValue(value);
		this._values[field] = value;
        !noCalc && ds.updateDerivedValues(this._dataRow, this._values, field);
		if (this._started && this.parent() && !fld.equalValues(oldValue, value)) {
			this._provider._editItemCellUpdated(this, field, oldValue, value);
		}
	},
    isValueEdited: function (field) {
        var ds;
        return GridRowState.isInserting(this._state) ||
            !(ds = this.dataSource()).getField(field).equalValues(ds.getValue(this._item.dataIndex(), field), this._values[field]);
    },
    isEditing: function () {
        return true;
    },
    dataIndex: function () {
        return this._dataRow ? this._dataRow.rowId() : -1;
    },
    dataId: function () {
        return this._dataRow ? this._dataRow.rowId() : -1;
    },
	dataSource: function () {
		return this._provider.dataSource();
	},
	rowState: function () {
		return this._state;
	},
	dataState: function () {
		return this._item ? this._item.dataState() : DataRowState.NONE;
	},
	iconIndex: function () {
		return this._item ? this._super() : -1;
	},
	hasChildren: function () {
		return this._item ? this._super() : false;
	},
	dataRow: function () {
		return this._item ? this._super() : -1;
	},
	expanded: function () {
		return this._item ? this._item.expanded() : false;
	},
	getValue: function (field) {
        var ds = this.dataSource();
        field = ds.getFieldIndexEx(field);
        if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		return this._values[field];
	},
	setValue: function (field, value, noCalc) {
		var fld, oldValue, can,
			ds = this.dataSource();
        field = ds.getFieldIndexEx(field);
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		fld = ds.getField(field);
		oldValue = this._values[field];
		value = fld.readValue(value);
        can = !this._checkDiff;
        if (!can) {
            if (this._strictDiff) {
                can = !fld.equalValues(oldValue, value);
            } else {
                can = !fld.sameValues(oldValue, value);
            }
        }
		if (can) {
			this._values[field] = value;
			!noCalc && ds.updateDerivedValues(this.dataIndex(), this._values, field);
			if (this.parent()) {
				this._provider._editItemCellUpdated(this, field, oldValue, value);
			}
		}
	},
	getRowData: function () {
		return this._values.concat();
	},
	getRowObject: function () {
		var ds = this.dataSource();
		if (ds) {
			var row = {};
			for (var i = 0, cnt = ds.fieldCount(); i < cnt; i++) {
				var fld = ds.getFieldName(i);
				row[fld] = this._values[i];
			}
			return row;
		} else {
			return null;
		}
	},
    copyToObject: function (vals) {
        var ds = this.dataSource();
        if (ds) {
            var row = {};
            for (var i = 0, cnt = ds.fieldCount(); i < cnt; i++) {
                var fld = ds.getFieldName(i);
                vals[fld] = this._values[i];
            }
        }
    }
});
var TreeGridRowProvider = defineClass("TreeGridRowProvider", EditableRowProvider, {
	init: function (indexing) {
		this._super(null, indexing);
		var rs = this._items = new TreeItemProvider();
        rs.onSaveRow = function (scope, row, rowId) {
            this.fireEvent(TreeGridRowProvider.SAVE_ROW, scope, row, rowId);
        }.bind(this);
        rs.onSaveRows = function (scope, rows) {
            this.fireEvent(TreeGridRowProvider.SAVE_ROWS, scope, rows);
        }.bind(this);
        rs.onRestoreRow = function (scope, row, rowId) {
            this.fireEvent(TreeGridRowProvider.RESTORE_ROW, scope, row, rowId);
        }.bind(this);
        rs.onRestoreRows = function (scope, rows) {
            this.fireEvent(TreeGridRowProvider.RESTORE_ROWS, scope, rows);
        }.bind(this);
		this.setSource(rs);
		this._summarizer = new DefaultSummarizer(rs);
		this._editingItem = null;
		this._appending = false;
		this._insertAfter = false;
		this._insertIndex = -1;
	},
	onRowProviderFilterAdd: function (provider, field, expression) {
	},
	onRowProviderFilterRemove: function (provider, field, filter) {
	},
	onRowProviderFilterClear: function (provider, field) {
	},
	onRowProviderFilterClearAll: function (provider) {
	},
	onRowProviderFiltered: function (provider) {
	},
	onRowProviderSorting: function (provider, fields, directions) {
		return this._fireSorting(fields, directions);
	},	
	onRowProviderSorted: function (provider) {
		this._fireSorted();
	},
	pageSorting: false,
	pageFiltering: false,
	dataRoot: function () {
		return this._items.dataRoot();
	},
	setDataRoot: function (value) {
		this._items.setDataRoot(value);
	},
    sortMode: function () {
        return this._items.sortMode();
    },
    setSortMode: function (value) {
        this._items.setSortMode(value);
    },
    filterMode: function () {
        return this._items.filterMode();
    },
    setFilterMode: function (value) {
        this._items.setFilterMode(value);
    },
	passiveFiltering: function () {
		return this._items.passiveFiltering();
	},
	setPassiveFiltering: function (value) {
		this._items.setPassiveFiltering(value);
	},
	setCustomRowProvider: function (value) {
		this._items.setCustomRowProvider(value);
	},
	setAggregateMode: function (value) {
		this._items.setAggregateMode(value);
	},
	setSummaryMode: function (value) {
		this._items.setSummaryMode(value);
	},
	setGroupSummaryMode: function (value) {
		this._items.setGroupSummaryMode(value);
	},
	summarizer: function () {
		return this._summarizer;
	},
	dataStateFiltering: function () {
		return this._items.dataStateFiltering();
	},
	setDataStateFiltering: function (value) {
		return this._items.setDataStateFiltering(value);
	},
	dataTagFiltering: function () {
		return this._items.dataTagFiltering();
	},
	setDataTagFiltering: function (value) {
		return this._items.setDataTagFiltering(value);
	},
	sortFirst: function () {
		return this._items.sortFirst();
	},
	setSortFirst: function (value) {
		return this._items.setSortFirst(value);
	},
    isSorted: function () {
        return this._items.isSorted();
    },
    isFiltered: function () {
        return this._items.isFiltered();
    },
	setSummaryScopes: function (scope, groupScope) {
		this._items.setSummaryScopes(scope, groupScope);
	},
	clearSummary: function () {
		this._items.$_clearSummary();
	},
	resetCustomGroupItems: function (item) {
		this._items && this._items._saveAndRefresh();
	},
	setFooterCallback: function (value) {
		this._items && this._items.$_setFooterCallback(value);
	},
	requestRefresh: function () {
		this._items._saveAndRefresh();
	},
	getLevels: function (visibleOnly) {
		return this._items.getLevels(visibleOnly);
	},
    canSorting: function (fields, directions, cases) {
        return !this.isEditing();
    },
	orderBy: function (fields, directions, textCases) {
        if (this.canSorting(fields, directions, textCases)) {
            this._items.orderBy(fields, directions, textCases);
        }
	},
	getSortFieldCount: function () {
		return this._items.length;
	},
	getSortFields: function () {
		return this._items.getSortFields();
	},
	getSortDirections: function () {
		return this._items.getSortDirections();
	},
    getSortCases: function () {
        return this._items.getSortCases();
    },
    canFiltering: function () {
        return !this.isEditing();
    },
	addFilter: function (field, expression) {
        if (this.canFiltering()) {
            this._items.addFilter(field, expression);
        }
	},
	removeFilter: function (field, filter) {
        if (this.canFiltering()) {
            this._items.removeFilter(field, filter);
        }
	},
	clearFilters: function (field) {
        if (this.canFiltering()) {
            this._items.clearFilters(field);
        }
	},
	clearAllFilters: function () {
        if (this.canFiltering()) {
            this._items.clearAllFilters();
        }
	},
	beginFiltering: function () {
        if (this.canFiltering()) {
            this._items.beginFilter();
        }
	},
	endFiltering: function () {
        if (this.canFiltering()) {
            this._items.endFilter();
        }
	},
    visitAll: function (callback, visibleOnly) {
        return this._items.visitAll(callback, visibleOnly);
    },
	expand: function (item, recursive, force) {
		this._items.expand(item, recursive, force);
	},
	collapse: function (item, recursive) {
		this._items.collapse(item, recursive);
	},
	expandAll: function (level) {
		this._items.expandAll(level);
	},
	collapseAll: function () {
		this._items.collapseAll();
	},
	reveal: function (row) {
		return this._items.reveal(row);
	},
	getRowOfDataRow: function (dataRow) {
		return this._items.getRowOfDataRow(dataRow);
	},
	getRowsOfDataRows: function (dataRows, all) {
		return this._items.getRowsOfDataRows(dataRows, all);
	},
    getNextDataRow: function (row) {
        return this._items.getNextDataRow(row);
    },
	descendantCount: function () {
		return this._items._rootRow.descendantCount();
	},
    descendantRowCount: function () {
        return this._items._rootRow.descendantRowCount();
    },
	getDescendantRows: function (visibleOnly, dataOnly) {
		var filter = this.isEditing() ? function (item) {
			return (item === this._editingItem) ? item._item : item;
		}.bind(this) : null;
		return this._items._rootRow.getDescendants(visibleOnly, dataOnly, filter);
	},
    visitRows: function (visibleOnly, dataOnly, callback) {
        return this._items._rootRow.visitRows(visibleOnly, dataOnly, callback);
    },
	hideDeleted: function () {
		return this._items.hideDeleted;
	},
	setHideDeleted: function (value) {
		this._items.setHideDeleted(value);			
	},
	getAllItems: function () {
		return this._items.getAllItems();
	},
	getTopItems: function () {
		return this._items.getTopItems();
	},
	getLeafItems: function (visibleOnly, dataOnly) {
		return this._items.getLeafItems(visibleOnly, dataOnly);
	},
	getItem: function (index) {
		return this._items.getItem(index);
	},
	getItemOfRow: function (dataRow, all) {
		var item = this._items.getItemOfRow(dataRow, all);
        return item && (all || item.visible()) ? item : null;
	},
	getDistinctValues: function (field, maxCount, ignoreCase) {
		return this._items.getDistinctValues(field, maxCount, ignoreCase);
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		return this._items.findItem(fields, values, options, startIndex, endIndex);
	},
    findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
        return this._items.findCell(fields, value, options, startIndex, endIndex, startFieldIndex);
    },
	hasCellStyle: function () {
		return this._items.hasCellstyle();
	},
	setCellStyle: function (row, field, style) {
		this._items.setCellStyle(row, field, style);
	},
	setCellStyles: function (provider, rows, fieldMap) {
		this._items.setCellStyles(provider, rows, fieldMap);
	},
	removeCellStyle: function (style) {
		this._items.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._items.clearCellStyles();
	},
	getCellStyle: function (dataRow, field) {
		return this._items.getCellStyle(dataRow, field);
	},
    currentDataRow: function () {
        var curr = this._currentIndex;
        var item = curr >= 0 && curr < this.rowCount() ? this.getItem(curr) : null;
        return (item instanceof TreeRow) ? item.dataRow() : null;
    },
	/*
	canUpdate: function (item, field) {
		if (item) {
			return true;
		}
		return false;
	},
	*/
	canAppend: function () {
		return this._super();
	},
	canInsert: function (item) {
        return !!item;
	},
	canDelete: function (item, field) {
        return !!item;
	},
	$_replaceItem: function (item, newItem) {
		var parent = item.parent();
		parent.setItem(item, newItem);
		this._items._setItem(item, newItem);
	},
    _doEditingStarted: function (editItem) {
        this._items.$_setEditing(true);
    },
    _doEditingFinished: function (completed) {
        this._items.$_setEditing(false);
    },
	_doBeginUpdate: function (item) {
		this._editingItem = this._createEditItem(item, GridRowState.UPDATING, null);
		this.$_replaceItem(item, this._editingItem);
		return this._editingItem;
	},
	_doBeginAppend: function (defaultValues) {
		var p = this.source()._rootRow;
		this._appending = true;
		this._editingItem = this._createEditItem(null, GridRowState.APPENDING, defaultValues);
		this._items.appendItem(p, this._editingItem);
		return this._editingItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		var p;
		if (ctrl) {
			this._appending = true;
			item.setExpanded(true);
			this._editingItem = this._createEditItem(null, GridRowState.INSERTING, defaultValues);
			this._items.appendItem(p = item, this._editingItem);
		} else {
			p = item.parent();
			this._appending = false;
			this._insertAfter = shift;
			this._insertIndex = p.indexOf(item);
			this._editingItem = this._createEditItem(item, GridRowState.INSERTING, defaultValues);
			this._items.insertItem(p, this._editingItem, this._insertIndex, this._insertAfter);
		}
		return this._editingItem;
	},
	_doCompleteUpdate: function (orgItem, field) {
		var row,
			rslt = false,
			ds = this.dataSource();
		if (ds) {
			row = this._editingItem.dataRow();
			this.$_replaceItem(this._editingItem, orgItem);
			try {
                if (field >= 0) {
                    rslt = ds.setValue(row, field, this._editingItem.values()[field]);
                } else {
                    rslt = ds.updateRow(row, this._editingItem.values());
                }
			} catch (e) {
				this.$_replaceItem(orgItem, this._editingItem);
				throw e;
			}
			if (rslt) {
				this._copyExtents(this._editingItem, orgItem);
			} else {
				this.$_replaceItem(orgItem, this._editingItem);
			}
		}
		return rslt;
	},
	_doCompleteInsert: function (appending, field) {
        var child, parent, row, values, index, item,
		    rslt = false,
		    ds = this.dataSource();
		if (ds) {
			parent = this._editingItem.parent();
			row = parent.dataRow();
            values = this._editingItem.values();
			index = parent.dataIndexOf(this._editingItem);
			this._items.removeItem(this._editingItem);
			try {
				if (this.isAppending()) {
					child = ds.addRow(row, values, false, field);
				} else {
					child = ds.insertRow(row, index, values, false, field);
				}
			} catch (e) {
				if (this._appending) {
					this._items.appendItem(parent, this._editingItem);
				} else {
					this._items.insertItem(parent, this._editingItem, this._insertIndex, this._insertAfter);
				}
				throw e;
			}
			if (child) {
				item = parent.itemOfRow(child.rowId());
				this._copyExtents(this._editingItem, item);
			} else {
				if (this._appending) {
					this._items.appendItem(parent, this._editingItem);
				} else {
					this._items.insertItem(parent, this._editingItem, this._insertIndex, this._insertAfter);
				}
			}
		}
		return child;
	},
	_doCancelEdit: function (state, orgItem) {
		if (state == GridRowState.UPDATING) {
			this.$_replaceItem(this._editingItem, orgItem);
			this._copyExtents(this._editingItem, orgItem);
		} else if (state == GridRowState.INSERTING || state == GridRowState.APPENDING) {
			var p = this._editingItem.parent();
			if (p) {
				this._items.removeItem(this._editingItem);
			}
		}
		this._super(state, orgItem);
	},
	_doCommitEdit: function (state, orgItem) {
		if (state == GridRowState.UPDATING) {
		} else if (state == GridRowState.INSERTING) {
		}
		this._super(state, orgItem);
	},
	remove: function (item) {
		if (item instanceof TreeRow) {
			var row = item.dataRow();
			if (row) {
                this.dataSource().deleteRow(row);
			}
		}
	},
	removeAll: function (items) {
		if (items && items.length > 0) {
			var i, cnt, item, rows = [];
			for (i = 0, cnt = items.length; i < cnt; i++) {
				item = this._items.getItem(items[i]);
				if (item instanceof TreeRow) {
					rows.push(item.dataRow());
				}
			}
			this.dataSource().deleteRows(rows);
		}
	},
	getRemovableRows: function (items) {
		if (items.length > 0) {
			var i, cnt, item, rows = [];
			for (i = 0, cnt = items.length; i < cnt; i++) {
				item = this._items.getItem(items[i]);
				if (item instanceof TreeRow) {
					rows.push(item.dataRow());
				}
			}
			return rows;
		}
	},
	removeRows: function (rows) {
		if (rows) {
			this.dataSource().deleteRows(rows);
		}
	},
	dataSource: function () {
		return this._items.dataSource();
	},
	setDataSource: function (value) {
		this._items.setDataSource(value);
	},
	rootRow: function () {
		return this._items._rootRow;
	},
	_createEditItem: function (target, state, defaultValues) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		var i,
            item = null,
			flds = ds.fieldCount();
		switch (state) {
			case GridRowState.UPDATING:
				item = new TreeEditItem(this, target, state);
				for (i = 0; i < flds; i++) {
					item.setEditValue(i, target.getValue(i), true);
				}
				this._copyExtents(target, item);
				break;
			case GridRowState.INSERTING:
			case GridRowState.APPENDING:
				item = new TreeEditItem(this, null, state);
				if (defaultValues) {
					for (i = 0; i < flds; i++) {
						if (defaultValues.length > i) {
							item.setEditValue(i, defaultValues[i], true);
						}
					}
                    ds.updateDerivedValues(item._dataRow, item._values, -1);
				}
				break;
		}
		return item;
	},
	onTreeItemProviderItemChanged: function (provider, item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.ITEM_CHANGED, item);
		} 
	},
	onTreeItemProviderExpanding: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.EXPANDING, item);
		} 
		return true;
	},
	onTreeItemProviderExpanded: function (provider, item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.EXPANDED, item);
		} 
	},
	onTreeItemProviderCollapsing: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.COLLAPSING, item);
		} 
		return true;
	},
	onTreeItemProviderCollapsed: function (provider, item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.COLLAPSED, item);
		} 
	},
	onRowProviderDataCountChanged: function (rs, oldCount, newCount) {
		this._fireDataCountChanged(oldCount, newCount);
	},
	onRowProviderRowCountChanged: function (rs, oldCount, newCount) {
		this._fireRowCountChanged(oldCount, newCount);
	},
	onRowProviderFilterAdded: function (provider, field, expression) {
		this._fireFilterAdded(field, expression);
	},
	onRowProviderFilterRemoved: function (provider, field, filter) {
		this._fireFilterRemoved(field, filter);
	},
	onRowProviderFilterCleared: function (provider, field) {
		this._fireFilterCleared(field);
	},
	onRowProviderFilterAllCleared: function (provider) {
		this._fireFilterAllCleared();
	},
	onRowProviderFiltering: function (provider) {
		return this._fireFiltering(RowProvider.FILTERING);
	},
	onRowProviderFiltered: function (provider) {
		this._fireFiltered(RowProvider.FILTERED);
	},
	onRowProviderSorting: function (provider, fields, directions) {
		return this._fireSorting(fields, directions);
	},
	onRowProviderSorted: function (provider) {
		this._fireSorted();
	}
}, {
    SAVE_ROW: "onTreeGridRowProviderSaveRow",
    SAVE_ROWS: "onTreeGridRowProviderSaveRows",
    RESTORE_ROW: "onTreeGridRowProviderRestoreRow",
    RESTORE_ROWS: "onTreeGridRowProviderRestoreRows"
});
var TreeOptions = defineClass("TreeOptions", GridBaseOptions, {
	init : function (treeView) {
		this._super(treeView);
		this._headerItems = new CustomGroupItemCollection(treeView);
		this._footerItems = new CustomGroupItemCollection(treeView);
		this._expanderStyles = new GridStyles(this, "treeExpanderStyles");
		this._footerStyles = new GridStyles(this, "treeFooterStyles");
        this._indentStyles = new GridStyles(this, "treeIndentStyles");
		this._allFooters = false;
	},
    iconField: null,
    iconCallback: null,
    childrenCallback: null,
	footerLevels: null,             // "*" or []
	footerDisplayCallback: null,    // function (row):Boolean
	headerItems: null,
	footerItems: null,
    /** @deprecated Use TreeView.styles().line instead */
    line: null,
	expanderStyles: null,
	footerStyles: null,
    indentStyles: null,
    linesVisible: true,
	expanderWidth: 17,
	checkBoxVisible: false,
	checkBoxSize: 17,
	iconList: null,
	iconWidth: 0,
	iconHeight: 0,
	rowSummaryMode: EnumProp(SummaryMode, SummaryMode.AGGREGATE),
	summaryScope: EnumProp(TreeSummaryScope, TreeSummaryScope.DESCENDTANT),
	rowSummaryScope: EnumProp(TreeSummaryScope, TreeSummaryScope.DESCENDTANT),
    setIconField: function (value) {
        if (value != this._iconField) {
            this._iconField = value;
            this._refreshOwner();
        }
    },
    setIconCallback: function (value) {
        if (value != this._iconCallback) {
            this._iconCallback = value;
            this._refreshOwner();
        }
    },
    setChildrenCallback: function (value) {
        if (value != this._childrenCallback) {
            this._childrenCallback = value;
            this._refreshOwner();
        }
    },
	setFooterLevels: function (value) {
		var all = typeof value === "string" && value.trim() === "*";
		var levels = all ? null : _asArray(value);
		if (all != this._allFooters || levels != this._footerLevels) {
			if (all) {
				this._allFooters = true;
				this._footerLevels = null;
			} else {
				this._allFooters = false;
				this._footerLevels = levels;
			}
			this._grid.refreshTreeItems();
		}
	},
	setFooterDisplayCallback: function (value) {
		value = _asFunction(value);
		if (value != this._footerDisplayCallback) {
			this._footerDisplayCallback = value;
			this._grid.refreshTreeItems();
		}
	},
	getFooterDisplayCallback: function () {
		var self = this;
		return function (row) {
			var callback = self._footerDisplayCallback;
			if (callback) {
				return callback(row);
			}
			if (self._allFooters) {
				return true;
			}
			var levels = self._footerLevels;
			return levels && levels.indexOf(row.level()) >= 0;
		};
	},
	setHeaderItems: function (value) {
		if (value !== this._headerItems) {
			this._headerItems.assign(value);
			this._grid.refreshTreeItems();
		}
	},
	setFooterItems: function (value) {
		if (value !== this._footerItems) {
			this._footerItems.assign(value);
			this._grid.refreshTreeItems();
		}
	},
    line_: function () {
        return this._grid.styles().line();
    },
    setLine: function (value) {
        this._grid.styles().setLine(value);
    },
    setExpanderStyles: function (value) {
        if (value !== this._expanderStyles) {
            this._expanderStyles.extend(value);
            this._refreshOwner();
        }
    },
    setFooterStyles: function (value) {
        if (value !== this._footerStyles) {
            this._footerStyles.extend(value);
            this._refreshOwner();
        }
    },
    setLineStyles: function (value) {
        if (value !== this._indentStyles) {
            this._indentStyles.extend(value);
            this._refreshOwner();
        }
    },
	setLinesVisible: function (value) {
		if (value != this._linesVisible) {
			this._linesVisible = value;
			this._refreshOwner();
		}
	},
	setExpanderWidth: function (value) {
		if (value != this._expanderWidth) {
			this._expanderWidth = value;
			this._refreshOwner();
		}
	},
	setCheckBoxVisible: function (value) {
		if (value != this._checkBoxVisible) {
			this._checkBoxVisible = value;
			this._refreshOwner();
		}
	},
	setCheckBoxSize: function (value) {
		value = Math.max(0, value);
		if (value != this._checkBoxSize) {
			this._checkBoxSize = value;
			this._refreshOwner();
		}
	},
	setIconList: function (value) {
		if (value != this._iconList) {
			this._iconList = value;
			this._refreshOwner();
		}
	},
	setIconWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._iconWidth) {
			this._iconWidth = value;
			this._refreshOwner();
		}
	},
	setIconHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._iconHeight) {
			this._iconHeight = value;
			this._refreshOwner();
		}
	},
	setRowSummaryMode: function (value) {
		if (value != this._rowSummaryMode) {
			this._rowSummaryMode = value;
			this._grid.$_groupSummaryModeChanged();
		}
		return this;
	},
	setSummaryScope: function (value) {
		if (value != this._summaryScope) {
			this._summaryScope = value;
			this._grid.$_summaryScopeChanged();
		}
	},
	setRowSummaryScope: function (value) {
		if (value != this._rowSummaryScope) {
			this._rowSummaryScope = value;
			this._grid.$_summaryScopeChanged();
		}
	}
});
var TreeItemExpanderCell = defineClass("TreeItemExpanderCell", GridCell, {
	init : function(grid) {
		this._super(grid, "treeItemExpanderCell");
	},
	displayText: function () {
		return null;
	},
	value: function () {
		return null;
	}
});
var TreeItemIndentCell = defineClass("TreeItemIndentCell", GridCell, {
    init : function(grid) {
        this._super(grid, "treeItemIndentCell");
    }
});
var TreeItemFooterCell = defineClass("TreeItemFooterCell", GridCell, {
	init : function(grid) {
		this._super(grid, "treeItemFooterCell");
        this._value = NaN;
        this._error = null;
        this._errorDetail = null;
	},
    calculate: function () {
        this._value = NaN;
        this._error = null;
        try {
            this._value = RowGroupFooterCell.$_getValue(this._index.getRow(this._grid), this._index.dataColumn());
        } catch (err) {
            this._error = err;
            this._errorDetail = err;
            _throwDebugError(err);
        }
    },
	displayText: function () {
		var v, s, column;
        if (this._error) {
            return GridCell.ERROR;
        } else {
            v = this._value;
            s = isNaN(v) ? (typeof v === 'string' ? v : null) : String(v);
            if (!s && (column = this.index().valueColumn())) {
                s = column.groupFooter().text();
            }
            return s;
        }
	},
	value: function () {
		return this._value;
    },
    error: function () {
        return this._error;
    },
    errorDetail: function () {
        return this._errorDetail;
    }
});
var TreeSelectionTool = defineClass("TreeSelectionTool", GridSelectionTool, {
	init: function(tree) {
		this._super(tree);
	},
	_doKeyDown: function (key, ctrl, shift) {
        function isTreeCell(index) {
            var v = index.isFirstColumn();
            if (!v) {
                var col = index.column;
                v = col instanceof ValueColumn && ColumnGroup.isLeft(col);
            }
            return v;
        }
		var row,
        	tree = this.grid(),
        	editing = tree.isEditing(),
        	selecting = shift && tree.selections().count() > 0,
			idx = this.focused().clone();
		if (idx && (row = idx.getRow(tree)) && !row.isEditing() && isTreeCell(idx)) {
			switch (key) {
				case Keys.RIGHT:
                    if (!editing && !selecting && row instanceof GroupRow && row.collapsed() && ctrl) {
                        row.setExpanded(true);
                        return true;
                    }
					break;
                case Keys.LEFT:
                    if (!editing && !selecting) {
                        if (row.leaf() || row.collapsed()) {
                            if (!(row.parent() instanceof RootTreeRow)) {
                                idx.setRow(row.parent());
                                this.setFocused(idx, true);
                                return true;
                            }
                        } else {
                            row.setExpanded(false);
                            return true;
                        }
                    }
					break;
				case Keys.DOWN:
					if (!editing /*&& !selecting*/ && (ctrl || shift) && row && row.index() == tree.rowCount() - 1) {
						if (tree.insert(shift, ctrl)) {
							return true;
						}
					}
					break;
			}
		}
		return this._super(key, ctrl, shift);
	},
	_doColumnHeaderClicked: function (column) {
		this._super(column);
		this.grid().$_sortColumnByUser(column);
	},
	_doElementClicked: function (element) {
		this._super(element);
		if (element instanceof TreeCheckElement) {
			var tree = this.grid();
			if (tree.editOptions().checkable()) {
				var item = element.item();
				item && tree.isCheckable(item) && tree.setChecked(item, !tree.isChecked(item), tree.checkBar().exclusive());
			}
		}
	},
	_doHandleClicked: function (handle) {
		if (handle instanceof TreeExpandHandle) {
			var row = handle.cellView().row();
            row && row.setExpanded(!row.expanded());
		} else {
			this._super(handle);
		}
	}
});
var TreeExpandHandle = defineClass("TreeExpandHandle", CellHandle, {
	init : function(dom, cell) {
		this._super(dom, cell, "treeItemExpandHandle");
		this._figureBackground = SolidBrush.BLACK;
		this.setClickable(true);
	},
	expanded: false,
	shapeSize: 9,
	shapeColor: null,
	shapeName: null,
	fill: null,
	_doDraw: function (g) {
		var sz = this._shapeSize;
		var	r = new Rectangle(0, 0, this.width(), this.height());
		if (this._fill) {
		}
		if (this._expanded) {
			if (this._shapeName == "itriangle") {
					$$_drawItriangle(g, r, sz, this._shapeColor);
			} else if (this._shapeName == "triangle") {
					$$_drawRightTriangle(g, r, sz, this._shapeColor);
			} else {
				$$_drawMinusBox(g, r, sz, this._shapeColor);
			}
		} else {
			if (this._shapeName == "itriangle" || this._shapeName == "triangle") {
				$$_drawTriangleRight(g, r, sz, this._shapeColor);
			} else {
				$$_drawPlusBox(g, r, sz, this._shapeColor);
			}
		}
	},
	_doDrawHtml: function () {
		this._doDraw(this.$_getGraphics(true));
	}
});
var TREE_CHECK_SIZE = 12;
var TREE_CHECK_BOX_SIZE = TREE_CHECK_SIZE - 2;
var TREE_CHECK_BORDER = new SolidPen(0xffbbbbbb);
var TREE_CHECK_FILL = new SolidBrush(0xffffffff);
var TREE_CHECK_FILL2 = new SolidBrush(0xffeeeeee);
var TREE_CHECK_MARK_FILL = new SolidBrush(0xff444444);
var TreeCheckElement = defineClass("TreeCheckElement", UIElement, {
	init : function(dom) {
		this._super(dom, "treeCheckView");
		this.setClickable(true);
	},
	item: null,
	checkable: true,
	checked: false,
	exclusive: false,
	_doDraw: function (g) {
		var r = new Rectangle(0, 0, this.width(), this.height());
		g.drawRectI(null, null, r);
		var checkSize = TREE_CHECK_SIZE;
		var sz = TREE_CHECK_BOX_SIZE;
		var x = _floor(r.x + (r.width - sz) / 2);
		var y = _floor(r.y + (r.height - sz) / 2);
		var stroke = TREE_CHECK_BORDER;
		if (this._exclusive) {
			var rd = sz / 2;
			g.drawCircle(this._checkable ? TREE_CHECK_FILL : TREE_CHECK_FILL2, TREE_CHECK_BORDER, x + rd, y + rd, rd);
			if (this._checked) {
				g.drawCircle(TREE_CHECK_MARK_FILL, null, x + rd, y + rd, rd / 2);
			}
		} else {
			g.drawBoundsI(this._checkable ? TREE_CHECK_FILL : TREE_CHECK_FILL2, TREE_CHECK_BORDER, x, y, sz, sz);
			if (this._checked) {
				checkSize *= 0.9;
				$$_drawCheckMark(g, TREE_CHECK_MARK_FILL, r, checkSize);
			}
		}
	},
	_doDrawHtml: function () {
		var r = new Rectangle(0, 0, this.width(), this.height());
		var fill = this._checkable ? TREE_CHECK_FILL : TREE_CHECK_FILL2, TREE_CHECK_BORDER;
		this._css.background = fill ? fill.css() : '';
		var check = this._checkElement;
		if (!check) {
			check = this._checkElement = document.createElement("input");
			check.type = "checkbox";
			check.style.position = "absolute";
			check.style.padding = "0px";
			check.style.margin = "0px";
			this._dom.appendChild(check);
		}
		var cr = _getCheckSize(check);
		check.checked = this.checked();
		check.style.left = (r.x + (r.width - cr.width) / 2) + "px";
		check.style.top = (r.y + (r.height - cr.height) / 2) + "px";
		/*
		 if (this._markVisible) {
		 this._exclusive ? this.$_drawRadio(g, r) : this.$_drawCheck(g, r);
		 }
		 */
	},
    propertyChanged: function (prop, value) {
        this.invalidate();
    }
});
var TreeExpanderElement = defineClass("TreeExpanderElement", CellElement, {
	init : function(dom, name) {
		this._super(dom, name);
		this._handle = new TreeExpandHandle(dom, this);
		this.addElement(this._handle);
		this._checkView = new TreeCheckElement(dom, this);
		this.addElement(this._checkView);
		this._iconView = new IconElement(dom, "treeIconView");
		this._iconView.setMouseEnabled(false);
		this.addElement(this._iconView);
		this._line = null;
		this._expanderWidth = 0;
		this._dataCell = null;
	},
	setHandleWidth: function (value) {
		this._handle.setWidth(value);
	},
	setShowCheck: function (value) {
		this._checkView.setVisible(value);
	},
	setCheckSize: function (value) {
		this._checkView.setWidth(value);
	},
	setIconWidth: function (value) {
		this._iconView.setWidth(value);
	},
	setExpanderWidth: function (value) {
		this._expanderWidth = value;
	},
	setExclusive: function (value) {
		this._checkView.setExclusive(value);
	},
	getAdapter: function (adapter) {
		if (adapter == DataCellElement) {
			return this._dataCell;
		}
		return this._super(adapter);
	},
	_doUpdateContent: function (cell) {
		this._super(cell);
		var tree = this.grid(),
		    item = this.index().getRow(tree);
		if (this._checkView.visible()) {
			this._checkView.setItem(item);
			this._checkView.setCheckable(tree.isCheckable(item));
			this._checkView.setChecked(tree.isChecked(item));
		}
		this._iconView.setImage(tree.getTreeIcon(item));
		item.setIconHeight(this._iconView.iconHeight());
		item.setIconWidth(this._iconView.iconWidth());
		this._handle.setVisible(tree.getHasChildren(item));
		this._handle.setExpanded(item.expanded());
		var styles = cell.styles();
		this._handle.setFill(null);
		this._handle.setShapeColor(styles.shapeColor());
		this._handle.setShapeName(styles.shapeName())
		this._handle.setShapeSize(styles.shapeSize() ? styles.shapeSize().getDimension(this._handle.width()) : 9);
	},
	_doLayoutContent: function (layout) {
        var eh, w,
            tree = this.grid(),
            item = this.index().getRow(tree),
		    styles = tree.treeOptions().expanderStyles(),
		    wCheck = this._checkView.visible() ? this._checkView.width() : 0,
            x = this._handle.width() * (item.level() - 1) + styles.paddingLeft(),
            y = this.borderTopWidth(),
            h = this.height() - y - this.borderBottomWidth();
        eh = this._handle.width();
        switch (this.lineAlignment()) {
        }
		this._handle.setBoundsI(x, y + (h - eh) / 2, this._handle.width(), eh);
		if (wCheck > 0) {
            eh = wCheck;
			this._checkView.setBoundsI(x + this._handle.width() + (this._handle.width() - wCheck) / 2, y + (h - eh) / 2, wCheck, eh);
		}
		var wIcon = this._iconView.width();
		if (wIcon > 0) {
			this._iconView.setVisible(true);
            eh = this._iconView.iconHeight();
			this._iconView.setBoundsI(x + this._handle.width() + this._handle.width() / 2 + wCheck - wIcon/2,  y + (h - eh) / 2, wIcon, eh);
		} else {
			this._iconView.setVisible(false);
		}
	},
	_doRender: function (g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		var wBottom = this.borderBottomWidth(),
		    wRight = this.borderRightWidth();
		if (wBottom) {
			wBottom = _floor((wBottom + 1) / 2);
			g.drawLineI(this._borderBottom, r.x, r.bottom() - wBottom, r.right(), r.bottom() - wBottom);
		}
		if (this.width() <= this._expanderWidth && wRight) {
			wRight = _floor((wRight + 1) / 2);
			g.drawLineI(this._borderRight, r.right() - wRight, r.y, r.right() - wRight, r.bottom());
		}
	},
	_doRenderHtml: function (r) {
		this._doRender(this.$_getGraphics(true, null, this._handle._dom), r);
	},
	canHovering: function () {
		return false;
	},
	_setDataCell: function (cell) {
		this._dataCell = cell;
	}
});
var TreeItemElement = defineClass("TreeItemElement", DataRowElement, {
	init : function(dom) {
		this._super(dom);
		this.setName("treeItemView");
		this._expander = new TreeExpanderElement(dom, "treeExpanderView");
		this.addElement(this._expander);
	},
	_clearChildren: function () {
		this._super();
		this.addElement(this._expander);
	},
	_prepareCells: function (lm) {
		this._super(lm);
        this.$_prepareExpander(lm);
	},
	_layoutCells: function (lm) {
		this._super(lm);
        this.$_layoutExpander(lm);
	},
    $_prepareExpander: function (lm) {
        var cell, view, expander = this._expander;
        if (this.childCount() > 0 && (lm.firstCol() == 0 || this.fixed())) {
            cell = this.grid().getExpanderCell(this.rowIndex());
            view = this._getFirstCell(lm);
            expander._setDataCell(view);
            expander.setVisible(true);
            expander.updateCell(cell);
        } else {
            expander.setVisible(false);
        }
    },
    $_layoutExpander: function (lm) {
        var tree, checkBar, item, options, view, level, wHandle, wCheck, wIcon, expander, icon, styles, wExpander, wView;
        if (this._expander.visible()) {
            tree = this.grid();
            checkBar = tree.checkBar();
            item = this.item();
            options = tree.treeOptions();
            view = this._getFirstCell(lm);
            level = item.level();
            wHandle = options.expanderWidth();
            wCheck = options.checkBoxVisible() ? options.checkBoxSize() : 0;
            wIcon = options.iconWidth();
            expander = this._expander;
            if (wIcon <= 0) {
                icon = tree.getTreeIcon(item);
                if (icon) {
                    wIcon = icon.width;
                }
            }
            styles = options.expanderStyles();
			wExpander = wHandle * level + (wHandle + wIcon) / 2 + wCheck + styles.paddingHorz();
            wView = view.width();
            view.setWidth(wView - wExpander);
            view.setX(view.x() + wExpander);
            view.layoutTreeContent(lm);
            expander.setHandleWidth(wHandle);
            expander.setShowCheck(wCheck > 0);
            expander.setExclusive(checkBar.exclusive() && checkBar.exclusiveDisplay());
            expander.setCheckSize(wCheck);
            expander.setIconWidth(wIcon);
            expander.setExpanderWidth(wExpander);
            expander.setBounds(0, 0, Math.min(wExpander, wView), this.height());
            expander.setIndex(CellIndex.temp(this._item.index(), null));
            expander.layoutContent(lm);
        }
    }
});
var TreeItemIndentElement = defineClass("TreeItemIndentElement", CellElement, {
    init: function (dom) {
        this._super(dom, "treeItemIndentView");
    },
    _getModel: function (grid, index) {
        return grid.getFooterCell(index);
    },
    _doRender: function (g, r) {
        var fill = this.background();
        if (fill) {
            g.drawRectI(fill, null, r);
        }
        var wBottom = this.borderBottomWidth();
        var wRight = this.borderRightWidth();
        if (wBottom) {
            wBottom = _floor((wBottom + 1) / 2);
            g.drawLineI(this._borderBottom, r.x, r.bottom() - wBottom, r.right(), r.bottom() - wBottom);
        }
        if (wRight) {
            wRight = _floor((wRight + 1) / 2);
            g.drawLineI(this._borderRight, r.right() - wRight, r.y, r.right() - wRight, r.bottom());
        }
    },
    _doRenderHtml: function (r) {
        this._doRender(this.$_getGraphics(true), r);
    },
    canHovering: function () {
        return false;
    },
});
var TreeItemFooterGroupCellElement = defineClass("TreeItemFooterGroupCellElement", GroupFooterGroupCellElement, {
	init: function (dom, fixed) {
		this._super(dom, "treeItemFooterView");
	},
	_getModel: function (grid, index) {
		return grid.getFooterCell(index);
	},
	_createGroupCellView: function () {
		return new TreeItemFooterGroupCellElement(this._dom);
	}
});
var TreeItemFooterElement = defineClass("TreeItemFooterElement", RowElement, {
	init: function(dom, fixed) {
		this._super(dom, "treeItemFooterView");
		this._fixed = fixed;
		this._cells = {};
        this.addElement(this._indentView = new TreeItemIndentElement(dom));
	},
	fixed: false,
	background: null,
	borderBottom: null,
	getCell: function (column) {
		if (column) {
			var root = column.root();
			var view = this._cells[root.$_hash];
			if (view && view.visible()) {
				if (root != column) {
					view = view.findCell(column);
				}
				return view;
			}
		}
		return null;
	},
	_doUpdateElement: function (styles) {
		this.setBackground(styles.background());
		this.setBorderBottom(styles.borderBottom());
		this.$_wBottom = this._borderBottom ? this._borderBottom.width() : 0;
	},
	_doMesasure: function (grid, hintWidth, hintHeight) {
		return { width: hintWidth, height: hintHeight };
	},
	_doLayoutContent: function (lm) {
		this.$_prepareCells(lm);
		this.$_layoutCells(lm);
	},
	_doDraw: function (g) {
        /*
        g.drawRect(SolidBrush.YELLOW, null, this.getClientRect(this._drawRect));
        g.drawText(null, SolidBrush.BLACK, this.width(), 0, 0);
        */
	},
	_doDrawHtml: function (g) {
	},
	/*
	_doRender: function (g, r) {
        g.drawRect(SolidBrush.YELLOW, null, r);
		var stroke = this._borderBottom;
		if (stroke) {
			g.drawHLineI(this._borderBottom, r.bottom() - _floor((stroke.width() + 1) / 2), r.x, r.right());
		}
        return;
		if (this.fixed()) {
			var grid = this.grid();
			var	options = grid.displayOptions();
			var fill, stroke;
			r.setLeft(r.right() - grid.body().fixedColumnBarWidth());
			fill = options.fixedColumnBarStyles().background();
			if (fill) {
				g.drawRectI(fill, null, r);
			}
			stroke = options.fixedColumnBarStyles().borderRight();
			if (stroke) {
				g.drawLine(stroke, r.right() - 1, r.y, r.right() - 1, r.bottom());
			}
		}
	},
	_doRenderHtml: function (r) {
		var fill = this._background;
		_norgba ? this.$_setCssFill(fill) : (this._css.background = fill ? fill.css() : '');
		var stroke = this._borderBottom;
		this._css.borderBottom = stroke ? stroke.css() : "";
	},
	*/
	$_createCellView: function (tree, rowIndex, column) {
        var index = CellIndex.temp(rowIndex, column);
        var model = tree.getFooterCell(index);
        var view = this._cells[column.$_hash];
        if (!(view instanceof CellElement)) {
            if (column instanceof ColumnGroup) {
                view = new TreeItemFooterGroupCellElement(this._dom);
            } else {
                view = new GroupFooterCellElement(this._dom);
            }
            this._cells[column.$_hash] = view;
            this.addElement(view);
        }
        view.setVisible(true);
        view.updateCell(model);
        return view;
    },
    $_prepareCells: function (lm) {
		var i, column,
			tree = this.grid(),
			rowIndex = this._item.index(),
			fixed = lm.fixedColCount(),
			start = this._fixed ? 0 : lm.firstCol(),
			end = this._fixed ? fixed - 1 : lm.lastCol();
		if (tree.columnLayoutChanged()) {
			this.clear();
			this._cells = {};
		}
		this.hideAll();
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
            this.$_createCellView(tree, rowIndex, column);
		}
	},
	$_layoutCells: function (lm) {
		var i, col, column, view, cv, r,
			options, item, level, wHandle, wCheck, wIcon, styles, off,
			tree = this.grid(),
        	rowIndex = this._item.index(),
			leftPos = tree.leftPos(),
        	fixed = this._fixed,
			fixedCols = lm.fixedColCount(),
        	cells = this._cells,
			start = fixed ? 0 : lm.firstCol(),
			end = fixed ? fixedCols - 1 : lm.lastCol(),
        	group = lm.getColumn(start),
        	spans = (group && (group = group.parent()).$_groupFooterSpanned) ? group.$_groupFooterSpans : null,
        	height = this.height();
        if (spans) {
            i = start;
            while (i <= end) {
                r = lm.columnBounds(i);
                col = lm.getColumn(i);
                column = spans[i++];
                view = this.$_createCellView(tree, rowIndex, column);
                if (col !== column) {
                    cv = cells[col.$_hash];
                    cv && cv.setVisible(false);
                }
                for (; i <= end; i++) {
                    col = spans[i];
                    if (col !== column) break;
                    r.width += lm.getColumnBounds(i).width;
                    col = lm.getColumn(i);
                    if (col !== column) {
                        cv = cells[col.$_hash];
                        cv && cv.setVisible(false);
                    }
                }
                if (!fixed) {
                    r.x -= leftPos;
                }
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        } else {
            for (i = start; i <= end; i++) {
                view = cells[lm.getColumn(i).$_hash];
                r = lm.columnBounds(i);
                if (!fixed) {
                    r.x -= leftPos;
                }
                r.height = height;
                view.setRect(r);
                view.layoutContent(lm);
            }
        }
		if (start == 0 || fixed) {
			options = tree.treeOptions();
			item = this.item();
			level = item.level();
			wHandle = options.expanderWidth();
			wCheck = 0;// options.checkBoxVisible() ? options.checkBoxSize() : 0;
			wIcon = options.iconWidth();
			styles = options.expanderStyles();
			off = wHandle * level + wCheck + wIcon + styles.paddingHorz();
            if (fixedCols && fixed) {
				leftPos = 0;
			}
			view = cells[lm.getColumn(start).$_hash];
			view.setX(off - leftPos);
			view.setWidth(view.width() - off);
            view instanceof GroupCellElement  ? view.layoutTreeContent(lm) : view.layoutContent(lm);
            view = this._indentView;
            view.setBounds(0, 0, off - leftPos, height);
            view.setVisible(true);
            view.updateCell(tree.getIndentCell(CellIndex.temp(this._item.index(), null)));
		}
	}
});
var TreeLinesElement = defineClass("TreeLinesElement", LayerElement, {
	init : function(dom, tree) {
		this._super(dom, "treeLinesView");
		this._tree = tree;
		this._startIndex = -1;
		this._endIndex = -1;
		this._levelWidth = 20;
		this._handleWidth = 9;
		this._handleHeight = 9;
		this._stroke = SolidPen.LTGRAY;
		this._options = null;
	},
	setLevelWidth: function (value) {
		if (value != this._levelWidth) {
			this._levelWidth = value;
			this.invalidate();
		}
	},
	setHandleWidth: function (value) {
		if (value != this._handleWidth) {
			this._handleWidth = value;
			this.invalidate();
		}
	},
	setHandleHeight: function (value) {
		if (value != this._handleHeight) {
			this._handleHeight = value;
			this.invalidate();
		}
	},
	setStroke: function (value) {
		if (value != this._stroke) {
			this._stroke = value;
			this.invalidate();
		}
	},
	setRange: function (tree, startIndex, endIndex) {
		this._options = tree.treeOptions();
		if (startIndex != this._startIndex || endIndex != this._endIndex) {
			this._startIndex = startIndex;
			this._endIndex = endIndex;
			this.invalidate();
		}
	},
	$_findLevelItem: function (tree, level, start) {
		var i, item;
		for (i = start; i <= this._endIndex; i++) {
			item = tree.getRow(i);
			if (item && item.level() == level) {
				return item;
			}
		}
		return null;
	},
	$_drawVertLine: function (g, src, dst, level) {
		var r, sz,
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = level * this._levelWidth + this._levelWidth / 2,
			y1 = 0,
			y2 = this.height();
		if (src) {
			r = lm.itemBounds(src.index() - top);
			sz = (src instanceof TreeRow && this._tree.getHasChildren(src)) ? this._handleHeight : 0;
			y1 = r.y + r.height / 2 + sz / 2;
		}
		if (dst) {
			r = lm.itemBounds(dst.index() - top);
			sz = (dst instanceof TreeRow && this._tree.getHasChildren(dst)) ? this._handleHeight : 0;
			y2 = r.y + r.height / 2 - sz / 2;
		}
		x1 = _floor(x1);
        g.drawVLineI(this._stroke, x1, _int(y1), _int(y2));
	},
	$_drawChildLine: function (g, src, dst) {
		var y1, r, sz,
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = src.level() * this._levelWidth + this._levelWidth / 2,
			y2 = this.height();
        r = lm.itemBounds(src.index() - top);
		if (this._options.checkBoxVisible()) {
			y1 = r.y + r.height / 2 + TREE_CHECK_BOX_SIZE / 2;
		} else if (src instanceof TreeRow && src.iconHeight() > 0) {
			y1 = r.y + r.height / 2 + src.iconHeight() / 2;
		} else {
			y1 = r.bottom() - r.height / 4;
		}
		if (dst) {
			r = lm.itemBounds(dst.index() - top);
			sz = (dst instanceof TreeRow && this._tree.getHasChildren(dst)) ? this._handleHeight : 0;
			y2 = r.y + r.height / 2 - sz / 2;
		}
		x1 = _floor(x1);
        g.drawVLineI(this._stroke, x1, _int(y1), _int(y2));
	},
	$_drawHorzLine: function (g, item) {
		var r, options,
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = item.parent().level() * this._levelWidth + this._levelWidth / 2,
			x2 = item.level() * this._levelWidth + this._levelWidth / 2,
			y = 0;
		options = this._tree.treeOptions();
		if (item instanceof TreeRow) {
			x2 -= this._levelWidth / 2;
			if (this._tree.getHasChildren(item)) {
                x1 += this._handleWidth / 2;
            }
        } else {
            options = this._tree.treeOptions();
			x2 -= this._levelWidth / 2;
        }
		r = lm.itemBounds(item.index() - top);
		y = _floor(r.y + r.height / 2);
		g.drawHLineI(this._stroke, y, _int(x1), _int(x2));
	},
	_doDraw: function (g) {
		var i, j, item, level, parent, next, prev, last, r1, r2, x1, y1, y2 ,sz,
			tree = this._tree,
			lm = tree.layoutManager(),
			szExp = 9,
			startLevel = -1, // 현재 표시되는 아이템들의 최소 level.
			top = tree.topIndex();
		!this._dom && g.clipBounds(0, 0, this.width(), this.height());
		if (!tree || this._startIndex < 0 || this._endIndex < 0 || this._startIndex > this._endIndex) {
			return;
		}
		item = null;
		for (i = this._startIndex; i <= this._endIndex; i++) {
			item = tree.getRow(i);
			if (item) {
				break;
			}
		}
		if (!item) {
			return;
		}
		level = item.level();
		if (level > 1 || item.childIndex() > 0) {
			for (j = 0; j < level; j++) {
				parent = item.getAncestor(j);
				next = parent.last();
				if (next && next.index() >= i) {
					next = this.$_findLevelItem(tree, j + 1, i);
					this.$_drawVertLine(g, null, next, parent.level());
				}
			}
			if (item.childIndex() > 0) {
				this.$_drawVertLine(g, null, item, item.parent().level());
			}
		}
		for (; i <= this._endIndex; i++) {
			item = tree.getRow(i);
			parent = item.parent();
			j = item.childIndex();
			if (j < parent.count() - 1) {
                next = parent.getItem(j + 1);
                if (next && next.index() > this._endIndex) {
                    next = null;
                }
                this.$_drawVertLine(g, item, next, parent.level());
			}
			parent = item;
			if (parent instanceof GroupRow && parent.expanded() && parent.count() > 0) {
				next = parent.getItem(0);
				if (next.index() > this._endIndex) {
					next = null;
				}
				this.$_drawChildLine(g, item, next);
			}
			this.$_drawHorzLine(g, item);
		}
	},
	_doDrawHtml: function () {
		var svg = this._svg;
		if (!svg) {
			svg = this._svg = new SvgSprite(null, this.container());
			this._dom.appendChild(svg._svg);
		}
		this._doDraw(svg.getGraphics(true, new Rectangle(0, 0, this.width(), this.height())));
	}
});
var TreeBodyElement = defineClass("TreeBodyElement", GridBodyElement, {
	init : function(dom, body, fixed) {
		this._super(dom, body, fixed);
	}
});
var TreeRowGroupElement = defineClass("TreeRowGroupElement", RowGroupElement, {
    init: function (dom) {
        this._super(dom, "treeRowGroupLayer");
        this._footers = [];
        this._footerBuff = [];
        this._fixedFooterBuff = [];	// RowGroupFooterElement
        this._footerViews = [];
        this._fixedFooterViews = [];
        this._customHeaders = [];
        this._customHeaderBuff = [];
        this._customHeaderViews = [];
        this._customFooters = [];
        this._customFooterBuff = [];
        this._customFooterViews = [];
        this.setWidth(101);
        this.setHeight(101);
		this.setClickable(false);
    },
	clearBody: function () {
		this._footers = [];
        this._customHeaders = [];
		this._customFooters = [];
	},
	addFooter: function (model) {
		this._footers.push(model);
	},
	addCustomHeader: function (model) {
		this._customHeaders.push(model);
	},
	addCustomFooter: function (model) {
		this._customFooters.push(model);
	},
    getFooterView: function (row, fixed) {
        var views = fixed ? this._fixedFooterViews : this._footerViews;
        for (var i = views.length; i--;) {
            if (views[i].item() === row) {
                return views[i];
            }
        }
    },
    getGroupRowView: function (row) {
        var views = this._customHeaderViews;
        for (var i = views.length; i--;) {
            if (views[i].item() === row) {
                return views[i];
            }
        }
        views = this._customFooterViews;
        for (var i = views.length; i--;) {
            if (views[i].item() === row) {
                return views[i];
            }
        }
    },
    isLayer: function () {
        return true;
    },
    _doMeasure: function (grid, hintWidth, hintHeight) {
        return new Size(hintWidth, hintHeight);
    },
    _doLayoutContent: function (lm) {
        var grid = this.grid();
        this.$_layoutFooters(grid, lm);
        this.$_layoutCustomHeaders(grid, lm);
        this.$_layoutCustomFooters(grid, lm);
    },
    _doDraw: function (g) {
        var r = this.getClientRect(this._drawRect);
        r.width--;
        r.height--;
    },
    _doDrawHtml: function (r) {
    },
    $_layoutFooters: function (tree, lm) {
		var cnt, i, view, footer, dirty, r, w, wBar,
        	width = this.width(),
        	hasFixed = lm.fixedColCount() > 0,
        	wFixed = lm.fixedWidth(),
        	styles = tree.treeOptions().footerStyles(),
        	top = tree.topIndex();
        cnt = this._footerViews.length;
        for (i = 0; i < cnt; i++) {
            this._footerViews[i].recycling = false;
        }
        while (cnt < this._footers.length) {
            view = this.$_borrowFooterView(this._footers[cnt]);
            this.addElement(view);
            this._footerViews.push(view);
            cnt++;
        }
        while (cnt > this._footers.length) {
            cnt--;
            this.$_removeFooterView(this._footerViews[cnt]);
            this._footerViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            footer = this._footers[i];
            view = this._footerViews[i];
            view._fixed = false;
            dirty = (view.item() !== footer);
            view.updateElement(footer, styles);
            r = lm.itemBounds(footer.index() - top);
            w = wFixed;
            r.setLeft(w);
            r.width = width - wFixed;// - tree.leftPos();
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
        if (hasFixed) {
            cnt = this._fixedFooterViews.length;
            for (i = 0; i < cnt; i++) {
                this._fixedFooterViews[i].recycling = false;
            }
            while (cnt < this._footers.length) {
                view = this.$_borrowFixedFooterView(this._footers[cnt]);
                this.addElement(view);
                this._fixedFooterViews.push(view);
                cnt++;
            }
            while (cnt > this._footers.length) {
                cnt--;
                this.$_removeFixedFooterView(this._fixedFooterViews[cnt]);
                this._fixedFooterViews.pop();
            }
            wBar = tree.body().fixedColumnBarWidth()
            for (i = 0; i < cnt; i++) {
                footer = this._footers[i];
                view = this._fixedFooterViews[i];
                view._fixed = true;
                dirty = (view.item() !== footer);
                view.updateElement(footer, styles);
                r = lm.itemBounds(footer.index() - top);
                w = 0;//lm.rowGroupLevels() * levelIndent;
                r.setLeft(w);
                r.width = wFixed - wBar;
                view.setRect(r);
                if (dirty || !view.recycling) {
                    view.layoutContent(lm);
                }
            }
        }
    },
    $_removeFooterView: function (view/*RowGroupFooterElement*/) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._footerBuff.push(view);
        }
    },
    $_removeFixedFooterView: function (view/*RowGroupFooterElement*/) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._fixedFooterBuff.push(view);
        }
    },
    $_borrowFooterView: function (footer/*GroupFooter*/) {
        var view;
        if (this._footerBuff.length > 0) {
            view = this._footerBuff.pop();
        } else {
            view = this.grid().delegate().borrowItemView(footer, false);
        }
        view.recycling = false;
        return view;
    },
    $_borrowFixedFooterView: function (footer/*GroupFooter*/) {
        var view; // RowGroupFooterElement
        if (this._fixedFooterBuff.length > 0) {
            view = this._fixedFooterBuff.pop();
        } else {
            view = this.grid().delegate().borrowItemView(footer, true);
        }
        view.recycling = false;
        return view;
    },
    $_layoutCustomHeaders: function (tree, lm) {
		var i, view, header, level, wHandle, wCheck, wIcon, styles, off, dirty, r,
        	options = tree.treeOptions(),
        	leftPos = tree.leftPos(),
        	fixed = lm.fixedColCount(),
        	cnt = this._customHeaderViews.length;
        for (i = 0; i < cnt; i++) {
            this._customHeaderViews[i].recycling = false;
        }
        while (cnt < this._customHeaders.length) {
            view = this.$_borrowCustomHeaderView(this._customHeaders[cnt++]);
            this.addElement(view);
            this._customHeaderViews.push(view);
        }
        while (cnt > this._customHeaders.length) {
            this.$_removeCustomHeaderView(this._customHeaderViews[--cnt]);
            this._customHeaderViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            header = this._customHeaders[i];
            view = this._customHeaderViews[i];
            level = header.parent().level() + 1;
            wHandle = options.expanderWidth();
            wCheck = 0;// options.checkBoxVisible() ? options.checkBoxSize() : 0;
            wIcon = options.iconWidth();
            styles = options.expanderStyles();
            off = wHandle * level + wCheck + wIcon + styles.paddingHorz();
            dirty = (view.item() !== header);
            view.updateElement(header, header.model().styles());
            r = lm.itemBounds(header.index() - tree.topIndex());
            r.x -= leftPos;
            view.setWidth(r.width);
            view.setRect(r);
            if (dirty || !view.recycling) {
                view._indentWidth = off;
                view.layoutContent(lm);
            }
        }
    },
    $_borrowCustomHeaderView: function (header) {
        var view;
        if (this._customHeaderBuff.length > 0) {
            view = this._customHeaderBuff.pop();
        } else {
            view = header.model().createRowView(this._dom);
        }
        view.recycling = false;
        return view;
    },
    $_removeCustomHeaderView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._customHeaderBuff.push(view);
        }
    },
    $_layoutCustomFooters: function (tree, lm) {
		var i, r, footer, view, level, wHandle, wCheck, wIcon, styles, off, dirty,
			options = tree.treeOptions(),
			leftPos = tree.leftPos(),
			fixed = lm.fixedColCount(),
        	cnt = this._customFooterViews.length;
        for (i = 0; i < cnt; i++) {
            this._customFooterViews[i].recycling = false;
        }
        while (cnt < this._customFooters.length) {
            view = this.$_borrowCustomFooterView(this._customFooters[cnt++]);
            this.addElement(view);
            this._customFooterViews.push(view);
        }
        while (cnt > this._customFooters.length) {
            this.$_removeCustomFooterView(this._customFooterViews[--cnt]);
            this._customFooterViews.pop();
        }
        for (i = 0; i < cnt; i++) {
			footer = this._customFooters[i];
			view = this._customFooterViews[i];
			level = footer.parent().level() + 1;
			wHandle = options.expanderWidth();
			wCheck = 0;// options.checkBoxVisible() ? options.checkBoxSize() : 0;
			wIcon = options.iconWidth();
			styles = options.expanderStyles();
			off = wHandle * level + wCheck + wIcon + styles.paddingHorz();
            dirty = (view.item() !== footer);
            view.updateElement(footer, footer.model().styles());
            r = lm.itemBounds(footer.index() - tree.topIndex());
            r.x -= leftPos;
			view.setWidth(r.width);
            view.setRect(r);
            if (dirty || !view.recycling) {
                view._indentWidth = off;
                view.layoutContent(lm);
            }
        }
    },
    $_borrowCustomFooterView: function (footer) {
        var view;
        if (this._customFooterBuff.length > 0) {
            view = this._customFooterBuff.pop();
        } else {
            view = footer.model().createRowView(this._dom);
        }
        view.recycling = false;
        return view;
    },
    $_removeCustomFooterView: function (view) {
        var idx = this.getChildIndex(view);
        if (idx >= 0) {
            this.removeChildAt(idx);
            view.validate(true);
            this._customFooterBuff.push(view);
        }
    }
});
var TreeComponent = defineClass("TreeComponent", GridComponent, {
	init : function(dom, containerId, readMode) {
		this._super(dom, containerId, readMode);
	},
	treeView: function () {
		return this._gridView;
	},
	_createGridView: function(dom, container, readMode)  {
		return new TreeView(dom, container, readMode);
	},
	_createDefaultTool: function () {
		return ($_mobileEnabled && _isMobile()) ? this._super() : new TreeSelectionTool(this);
	}
});
var TreeView = defineClass("TreeView", GridBase, {
	init : function(dom, container, readMode) {
        this._super(dom, container, readMode);
		this._focusedRow = -1;
		this._expanderCell = new TreeItemExpanderCell(this);
        this._indentCell = new TreeItemIndentCell(this);
		this._footerCell = new TreeItemFooterCell(this);
		this._footerRuntime = new FooterExpressionRuntime();
		this._runStyles = new GridStyles(this, "treeViewRuntimeStyles", null, false);
		this.panel().setVisible(false);
        this.groupPanel().setVisible(false);
		this.setRowSource(this._createItemSource());
		this._treeOptions.headerItems().registerType("chart", TreeChartItem);
		this._treeOptions.footerItems().registerType("chart", TreeChartItem);
        this._iconField = null;
        this._iconCallback = null;
        this._childrenCallback = null;
	},
	customGroupItemChanged: function (item) {
		this._items && this._items.resetCustomGroupItems(item);
	},
	getCustomHeaderRows: function (groupRow, list) {
		return this._treeOptions._headerItems.getRows(groupRow, list);
	},
	getCustomFooterRows: function (groupRow, list) {
		return this._treeOptions._footerItems.getRows(groupRow, list);
	},
    onRowChanged: DLCallback,
    onExpanding: DLCallback,
    onExpaned: DLCallback,
    onCollapsing: DLCallback,
    onCollapsed: DLCallback,
	treeOptions: {
		value: function () {
			return new TreeOptions(this);
		},
		set: function (value) {
			if (value !== this._treeOptions) {
				this._treeOptions.assign(value);
			}
			return this;
		}
    },
	dataRoot: null,
	dataRoot_: function () {
		return this._items.dataRoot();
	},
	setDataRoot: function (value) {
		this._items.setDataRoot(value);
		return this;
	},
    treeGroupView: function () {
        return this._treeGroupView;
    },
	treeLinesView: function () {
		return this._treeLinesView;
	},
	rootRow: function () {
		return this._items.rootRow();
	},
	getLevels: function (visibleOnly) {
		return this._items.getLevels(visibleOnly);
	},
	refreshTreeItems: function () {
		this._items.requestRefresh();
	},
	getExpanderCell: function (index) {
		this._expanderCell.setStyles(this._treeOptions.expanderStyles());
		this._expanderCell.setIndex(CellIndex.temp(index));
		return this._expanderCell;
	},
	getFooterCell: function (index) {
		var column = _cast(index.column, ValueColumn);
		this._runStyles.clearValues();
		if (column) {
			this._runStyles.extend(column.groupFooter().styles());
		}
		this._runStyles.setParent(this._treeOptions._footerStyles, false);
		this._footerCell.setStyles(this._runStyles);;
		this._footerCell.setIndex(index);
        this._footerCell.calculate();
		return this._footerCell;
	},
    getIndentCell: function (index) {
        this._indentCell.setStyles(this._treeOptions.indentStyles());
        this._indentCell.setIndex(CellIndex.temp(index));
        return this._indentCell;
    },
	expand: function (item, recursive, force) {
		this._items.expand(item, recursive, force);
	},
	collapse: function (item, recursive) {
		this._items.collapse(item, recursive);
	},
	expandRows: function (groups, recursive, force) {
	},
	collapseRows: function (groups, recursive, force) {
	},
	expandAll: function (level) {
		level = arguments.length > 0 ? level : 0;
		this._items.expandAll(level);
	},
	collapseAll: function () {
		this._items.collapseAll();
	},
	getIconIndex: function (row) {
		var idx = row.iconIndex();
		if (idx === undefined) {
			if (this._iconField !== undefined) {
				idx = row.dataRow().getValue(this._iconField);
			} else if (this._iconCallback) {
				idx = this._iconCallback(row);
			}
		}
		return idx;
	},
	getTreeIcon: function (row) {
		var images = this._treeIcons;
		if (images) {
			var idx = this.getIconIndex(row);
			return images.getImage(idx);
		}
		return null;
	},
    getHasChildren: function (item) {
        var has = item.count() > 0;
        if (!has) {
            has = item.hasChildren();
            if (has === undefined && this._childrenCallback) {
                has = this._childrenCallback(item);
            }
        }
        return has;
    },
    $_checkChildren: function (parent, checked, recursive, visibleOnly, checkableOnly, list, rowEvents) {
        var i, cnt, item;
		for (i = 0, cnt = parent.count(); i < cnt; i++) {
            item = parent.getItem(i);
            if (!checkableOnly || this.isCheckable(item)) {
                if (item.$_setChecked(this, checked)) {
					rowEvents && this._fireRowChecked(item, checked);
                    list.push(item);
                }
            }
            if (recursive && (item.expanded() || !visibleOnly)) {
                this.$_checkChildren(item, checked, true, visibleOnly, checkableOnly, list, rowEvents);
            }
        }
    },
	checkChildren: function (parent, checked, recursive, visibleOnly, checkableOnly, rowEvents) {
        var list = [];
        parent = parent || this._items.rootRow();
        this.$_checkChildren(parent, checked, recursive, visibleOnly, checkableOnly, list, rowEvents);
        if (list.length > 0) {
            this.refreshView();
            this._fireRowsChecked(list, checked);
        }
        return list;
	},
	getRowOfDataRow: function (dataRow) {
		return this._items.getRowOfDataRow(dataRow);
	},
	getRowsOfDataRows: function (dataRows, all) {
		return this._items.getRowsOfDataRows(dataRows, all);
	},
    getDataRowsOfRows: function (rows) {
		var list, i, cnt, row;
        if (rows) {
            list = [];
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                row = rows[i];
                if (row instanceof TreeRow) {
                    row = row.dataRow();
                } else {
                    row = this.getRow(row);
                    if (row instanceof TreeRow) {
                        row = row.dataRow();
                    }
                }
                row && list.push(row);
            }
            return list;
        }
        return null;
    },
    getCheckedDataRows: function () {
        var i, dataRow,
			list = [],
        	rows = this.getCheckedRows(),
			cnt = rows.length;
        for (i = 0; i < cnt; i++) {
            dataRow = rows[i].dataRow();
            dataRow && list.push(dataRow);
        }
        return list;
    },
	getSelectedDataRows: function (uniquify) {
		var i, cnt, sel,
			selections = this.selections(),
			list = [],
			ds = this.dataSource();
		if (ds) {
			for (i = 0, cnt = selections.count(); i < cnt; i++) {
				sel = selections.getItem(i);
				if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
					list = list.concat(sel.getDataIndices());
				}
			}
			for (i = 0, cnt = list.length; i < cnt; i++) {
				list[i] = ds.rowById(list[i]);
			}
			if (uniquify && selections.count() > 1) {
				list.sort(function (r1, r2) {
					return r1.rowId() - r2.rowId();
				});
				_dedupe(list);
			}
		}
		return list;
	},
    visitAllRows: function (callback) {
        this._items.visitAll(callback);
    },
    createCellStyleMap: function () {
        return new TreeCellStyleMap();
    },
	setRowSource: function (value) {
		if (value != this.rowSource()) {
			this._super(value);
			var options = this._treeOptions;
			this._items = value;
			if (value instanceof TreeGridRowProvider) {
				value.setCustomRowProvider(this);
				value.setSummaryMode(this.displayOptions().summaryMode());
				value.setGroupSummaryMode(this.rowGroup().summaryMode());
				value.setSummaryScopes(options.summaryScope(), options.rowSummaryScope());
				value.setFooterCallback(options.getFooterDisplayCallback());
			}
		}
	},
    setOptions: function (source) {
		source && source.tree && this._treeOptions.assign(source.tree);
		this._super(source);
    },
    heightMeasurer: function () {
        return this._heightMeasurer || TreeSimpleHeightsMeasurer.Default;
    },
    _createHeightMeasurer: function (type) {
        if (type == "fixed") {
            return new TreeFixedHeightsMeasurer();
        }
        return null;
    },
	_addGroupView: function () {
		var dom = this._dom;
		this._treeGroupView = new TreeRowGroupElement(dom);
		this.addElement(this._treeGroupView);
		this._treeLinesView = new TreeLinesElement(dom, this);
		this.addElement(this._treeLinesView);
	},
	addMasks: function () {
	},
    _createBodyView: function (dom, body, fixed) {
        return new TreeBodyElement(dom, body, fixed);
    },
	_createDelegate: function () {
		return new TreeGridDelegate(this);
	},
	_createLayoutManager: function () {
		return new TreeGridLayoutManager(this);
	},
    _createDataTagManager: function () {
        return new TreeDataTagManager(this);
    },
	canShowGroupFooters: function () {
		return true;
	},
	_doCanInsert: function (item, shift, ctrl) {
        if (!(item instanceof TreeRow)) {
            item = this._items.getNextDataRow(item);
        }
		return item instanceof TreeRow && (item.count() > 0 || !ctrl || item.level() == 0 || this.editOptions().appendable());
	},
	getSummarizer: function () {
		return this._items.summarizer();
	},
	onImageListImageLoaded: function (images, index) {
		this._super(images, index);
		if (images === this._treeIcons) {
			this.refreshView();
			this._treeLinesView.invalidate();
		}
	},
	onImageLoaded: function (url) {
		this._super(url);
	},
    _doSummaryModeChanged: function () {
        this._items.setSummaryMode(this.displayOptions().summaryMode());
    },
    _doGroupSummaryModeChanged: function () {
		this._items.setGroupSummaryMode(this.treeOptions().rowSummaryMode());
    },
	initStyles: function () {
		this._super();
        var d = this.defaultStyles();
		this._treeOptions.footerStyles().setParent(d);
		this._treeOptions.expanderStyles().setParent(d);
        this._treeOptions.indentStyles().setParent(d);
		var sheet = GridStyleSheet.Default;
		this._treeOptions.footerStyles().setSysDefault(sheet.treeFooter());
		this._treeOptions.expanderStyles().setSysDefault(sheet.treeExpander());
        this._treeOptions.indentStyles().setSysDefault(sheet.treeIndent());
	},
	$_doLayout: function (bounds) {
		var options = this._treeOptions;
        var ds = this.dataSource();
		this._treeIcons = this.getImageList(options.iconList());
        this._iconCallback = options.iconCallback();
        this._iconField = options.iconField() && !this._iconCallback && ds ? ds.getFieldIndexEx(options.iconField(), true) : undefined;
        this._childrenCallback = options.childrenCallback();
        if (this.$_reqFoucsedRow != undefined) {
            this.setFocusedDataRow(this.$_reqFoucsedRow);
            this.$_reqFoucsedRow = undefined;
        }
		var rslt = this._super(bounds);
        var line = this._styles.line();
        if (options.linesVisible() && line) {
			this._treeLinesView.setVisible(true);
            this._treeLinesView.setStroke(line);
            this._treeLinesView.invalidate();
		} else {
			this._treeLinesView.setVisible(false);
		}
		/*
		var r = m_treeLinesView.getGlobalBounds();
		var g = m_linesMask.graphics;
		g.clear();
		if (r.width > 0 && r.height > 0) {
			g.beginFill(0, 0);
			g.drawRect(r.x, r.y, r.width, r.height);
			g.endFill();
		}
		*/
		return rslt;
	},
	assignImageList: function (list) {
		this._super(list);
		if (this.treeOptions().iconImages() == list.name()) {
			this.treeOptions._icons = list;
		}
	},
	refreshView: function () {
        this._super();
		if (this._treeLinesView) {
			this._treeLinesView.invalidate();
		}
	},
	updatePastedRow: function (row, values, checkEmpty) {
        var drow,
			ds = this.dataSource();
		if (ds) {
            if (row instanceof TreeRow) {
                drow = row.dataRow();
                if (row) {
                    ds.updateRow(drow, values, false, false, checkEmpty);
                }
            }
        }
	},
    updatePastedCell: function (row, field, value) {
        var drow,
			ds = this.dataSource();
		if (ds) {
            if (row instanceof TreeRow) {
                drow = row.dataRow();
                if (drow) {
                    ds.setValue(drow, field, value);
                }
            }
        }
    },
	appendPastedRow: function (values) {
		var row,
			ds = this.dataSource();
		if (ds) {
			row = ds.createRow(values, -1, false);
			ds.rootRow().addChild(row);
		}
	},
	clearStyles: function (recursive) {
		this._super(recursive);
		if (recursive) {
			treeOptions.expanderStyles().clearValues();
			treeOptions.footerStyles().clearValues();
		}
	},
    getFocusedCellView: function (index) {
        var fixed, row,
			view = this._super(index);
        if (!view) {
            fixed = index.isFixedCol(this);
            row = index.getRow(this);
            if (row instanceof TreeRowFooter) {
                view = this._treeGroupView.getFooterView(row, fixed);
            } else if (row instanceof CustomGroupItemRow) {
                view = this._treeGroupView.getGroupRowView(row);
            }
        }
        return view;
    },
	_doRevealRow: function (row) {
		return this._items.reveal(row);
	},
	_createItemSource: function () {
		return new TreeGridRowProvider(true);
	},
	$_getVisibleAncestor: function (rowId) {
		var item = this._items.getItemOfRow(rowId);
		if (item) {
			while (item && !item.visible()) {
				item = item.parent();
			}
			return item;
		} else {
			return null;
		}
	},
	$_summaryScopeChanged: function () {
		var options = this.treeOptions();
		this._items.setSummaryScopes(options.summaryScope(), options.rowSummaryScope());
	},
    fireRowChanged: function (row) {
        this.onRowChanged && this.onRowChanged(this, row);
        this.fireEvent(TreeView.ITEM_CHANGED, row);
    },
    fireExpanding: function (row) {
        var ret = !this.onExpanding || this.onExpanding(this, row) !== false;
        return ret && this.fireConfirmEvent(TreeView.EXPANDING, row);
    },
    fireExpanded: function (row) {
        this.onExpanded && this.onExpanded(this, row);
        this.fireEvent(TreeView.EXPANDED, row);
    },
    fireCollapsing: function (row) {
        var ret = !this.onCollapsing || this.onCollapsing(this, row) !== false;
        return ret && this.fireConfirmEvent(TreeView.COLLAPSING, row);
    },
    fireCollapsed: function (row) {
        this.onCollapsed && this.onCollapsed(this, row);
        this.fireEvent(TreeView.COLLAPSED, row);
    },
	onTreeItemProviderItemChanged: function (provider, row) {
        this._treeLinesView.invalidate();
		this.invalidateLayout();
        this.fireRowChanged(row);
	},
	onTreeItemProviderExpanding: function (provider, row) {
		this._focusedRow = this.$_focusedIndex() ? this.$_focusedIndex().dataRow : -1;
		if (this.editController().isEditing() && !this._items.isEditing()) {
			this.editController().cancelEditor(true);
		}
		return !this.editController().isEditing() && !this._items.isEditing() && this.fireExpanding(row);
	},
	onTreeItemProviderExpanded: function (provider, row) {
		if (this._focusedRow >= 0) {
			var index = this.focusedIndex();
			var item = this.$_getVisibleAncestor(this._focusedRow);
			index._itemIndex = item ? item.index() : -1;
			this.setFocusedIndex(index, false, true);
		}
        this.fireExpanded(row);
	},
	onTreeItemProviderCollapsing: function (provider, row) {
		this._focusedRow = this.$_focusedIndex() ? this.$_focusedIndex().dataRow : -1;
		if (this.editController().isEditing() && !this._items.isEditing()) {
			this.editController().cancelEditor(true);
		}
		return !this.editController().isEditing() && !this._items.isEditing() && this.fireCollapsing(row);
	},
	onTreeItemProviderCollapsed: function (provider, row) {
		if (this._focusedRow >= 0) {
			var index = this.focusedIndex();
			var item = this.$_getVisibleAncestor(this._focusedRow);
			index._itemIndex = item ? item.index() : -1;
			this.setFocusedIndex(index, false, true);
		}
		this.fireCollapsed(row);
	},
    $$_uncheckAll: function () {
        this.checkAll(false);
    },
    onTreeGridRowProviderSaveRow: function (rs, scope, row, rowId) {
        row.$_saveChecked(scope, this, rowId, this.checkBar().exclusive());
    },
    onTreeGridRowProviderSaveRows: function (rs, scope, rows) {
        var i, cnt, r, ex = this.checkBar().exclusive();
        if (rows) {
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                rows[i].$_saveChecked(scope, this, rows[i].dataIndex(), ex);
            }
        } else {
            for (i = 0, cnt = this.rowCount(); i < cnt; i++) {
                r = this.getRow(i);
                (r instanceof TreeRow) && r.$_saveChecked(scope, this, r.dataIndex(), ex);
            }
        }
    },
    onTreeGridRowProviderRestoreRow: function (rs, scope, row, rowId) {
        row.$_restoreChecked(scope, this, rowId, this.$$_uncheckAll);
        this.$_reqFoucsedRow = rowId;
    },
    onTreeGridRowProviderRestoreRows: function (rs, scope, rows) {
        var i, cnt;
        if (rows) {
            if (rows.length > 0) {
                for (i = 0, cnt = rows.length; i < cnt; i++) {
                    rows[i].$_restoreChecked(scope, this, rows[i].dataIndex(), this.$$_uncheckAll);
                }
                this.$_reqFoucsedRow = rows[0].dataIndex();
            }
        } else {
            for (i = 0, cnt = this.rowCount(); i < cnt; i++) {
                r = this.getRow(i);
                (r instanceof TreeRow) && r.$_restoreChecked(scope, this, r.dataIndex(), this.$$_uncheckAll);
                this.$_reqFoucsedRow = r.dataIndex();
            }
        }
    }
});
TreeView.ROW_CHANGED = "onTreeViewRowChanged";
TreeView.EXPANDING = "onTreeViewExpanding";
TreeView.EXPANDED = "onTreeViewExpanded";
TreeView.COLLAPSING = "onTreeViewCollapsing";
TreeView.COLLAPSED = "onTreeViewCollapsed";
var TreeGridDelegate = defineClass("TreeGridDelegate", GridDelegate, {
	init : function(tree) {
		this._super(tree);
        this._rowViewClass = TreeItemElement;
		this._rowViews = [];
		this._footerViews = [];
		this._groupItemViews = {};
	},
	borrowItemView: function (model, fixed) {
		var i, row, footer;
		if (model instanceof TreeRow) {
			if (this._rowViews.length == 0) {
				this._rowViews.push(new this._rowViewClass(this._dom));
			}
			i = this._rowViews.length - 1;
			row = this._rowViews[i];
			row.setFixed(fixed);
			this._rowViews.pop();
			return row;
		} else if (model instanceof TreeRowFooter) {
			if (this._footerViews.length == 0) {
				this._footerViews.push(new TreeItemFooterElement(this._dom));
			}
			i = this._footerViews.length - 1;
			footer = this._footerViews[i];
			footer.setFixed(fixed);
			this._footerViews.pop();
			return footer;
		} else if (model instanceof CustomGroupItemRow) {
			var clazz = model.model().constructor.prototype.$name;
			view = this._groupItemViews[clazz];
			if (!view) {
				this._groupItemViews[clazz] = view = model.model().createRowView(this._dom);
			}
			return view;
		}
		return null;
	},
    returnItemView: function (view) {
        if (view instanceof this._rowViewClass) {
            this._rowViews.push(view);
        } else if (view instanceof TreeItemFooterElement) {
            this._footerViews.push(view);
        } else if (view instanceof GroupRowElement) {
			var clazz = view.item().model().constructor.prototype.$name;
			this._groupItemViews[clazz] = view;
		}
    }
});
/** @internal */
var TreeSimpleHeightsMeasurer = defineClass("TreeSimpleHeightsMeasurer", SimpleHeightsMeasurer, {
    init: function () {
        this._super();
    },
    treeFooterHeight: function () {
        return this._treeFooterHeight;
    },
    calculate: function (grid, body, header, footer, summary, rowGroup) {
        this._super(grid, body, header, footer, summary, null);
        this._treeFooterHeight = this.$_calcTreeFooterHeight(grid, grid.getGroupFooterLevel());
    },
    $_calcTreeFooterHeight: function (grid, levels) {
        var hItem = 0;//_int(rowGroup.footerHeight());
        if (hItem <= 0) {
            hItem = levels * this.$_calcLine(grid.treeOptions().footerStyles());
        }
        return hItem;
    }
});
TreeSimpleHeightsMeasurer.Default = new TreeSimpleHeightsMeasurer();
/** @internal */
var TreeFixedHeightsMeasurer = defineClass("TreeFixedHeightsMeasurer", FixedHeightsMeasurer, {
    init: function () {
        this._super();
    },
    treeFooterHeight: function () {
        return this._treeFooterHeight;
    },
    calculate: function (grid, body, header, footer, summary, rowGroup) {
        this._super(grid, body, header, footer, summar, null);
        this._treeFooterHeight = this.$_calcTreeFooterHeight(grid, grid.getGroupFooterLevel());
    },
    $_calcTreeFooterHeight: function (grid, levels) {
        var hItem = 0;//_int(rowGroup.footerHeight());
        if (hItem <= 0) {
            hItem = levels * this.$_calcLine(grid.treeOptions().footerStyles());
        }
        return hItem;
    }
});
var TreeGridLayoutManager = defineClass("TreeGridLayoutManager", GridLayoutManager, {
	init: function(tree) {
		this._super(tree);
	},
    _layoutItems: function (parent, r) {
		var i, model, top,
        	grid = this._grid,
        	bodyView = grid.bodyView(),
        	fixedView = grid.fixedBodyView(),
        	groupView = grid.treeGroupView(),
        	fixed = this._fixedCols > 0;
        bodyView.clearItems();
        fixedView.clearItems();
		groupView.clearBody();
        for (i = 0; i < this._fixedItemCount; i++) {
            model = this._items.getItem(i);
            if (model instanceof GroupFooter) {
                groupView.addFooter(model);
            } else {
                model.$_state = model.dataState();
                model.$_checked = model.$_isChecked(grid);
                bodyView.addItem(model);
                if (fixed) {
                    fixedView.addItem(model);
                }
            }
        }
        top = this._topIndex + this._fixedRows;
        for (i = 0; i < this._itemCount; i++) {
            model = this._items.getItem(i + top);
            if (model instanceof GroupFooter) {
                groupView.addFooter(model);
			} else if (model instanceof CustomGroupItemRow) {
				model.model().isHeader() ? groupView.addCustomHeader(model) : groupView.addCustomFooter(model);
			} else {
                model.$_state = model.dataState();
                model.$_checked = model.$_isChecked(grid);
                bodyView.addItem(model);
                if (fixed) {
                    fixedView.addItem(model);
                }
            }
        }
        bodyView.layoutContent(this);
        if (fixed) {
            fixedView.layoutContent(this);
        }
    },
    $_getItemHeight: function (grid, delegate, index) {
        var h, view, sz,
			item = this._items.getItem(index);
        if (item instanceof TreeRowFooter) {
            h = this._heightMeasurer.treeFooterHeight();
            view = delegate.borrowItemView(item, false);
            view.updateElement(item, grid.treeOptions().footerStyles());
            sz = view.measure(grid, 10000, h);
            delegate.returnItemView(view);
            return sz.height;
        }
        return this._super(grid, delegate, index);
    },
    _doMeasure: function (bounds, sw, sh) {
        this._super(bounds, sw, sh);
    },
    _doLayout: function (bounds) {
		this._super(bounds);
		var elt, r,
			tree = this.grid();
        elt = tree.treeGroupView();
        if (elt) {
            r = this._bodyBounds.clone();
            r.setLeft(this._fixedBounds.x);
            elt.setRect(r);
            elt.layoutContent(this);
        }
        elt = tree.treeLinesView();
		if (elt) {
			r = this.fixedColCount() > 0 ? this.fixedBounds() : this.bodyBounds();
			if (this.columnCount() > 0) {
				r.width = Math.max(0, this.columnRect(0).width);
			} else {
				r.width = 0;
			}
			elt.setRect(r);
			elt.setLevelWidth(tree.treeOptions().expanderWidth());
			elt.setRange(tree, this.topIndex(), Math.min(tree.rowCount(), this.topIndex() + this.itemCount()) - 1);
		}
	}
});
var TreeRowSource = defineClass("TreeRowSource", TreeGridRowProvider, {
	init: function () {
		this._super(true);
	}
});
var TreeDataTagManager = defineClass("TreeDataTagManager", DataTagManager, {
    init: function (grid) {
        this._super(grid);
    },
    _createSeriesTag: function (column) {
        return new TreeSeriesValueTag(column);
    },
    _createCalculatedTag: function (column) {
        return new TreeCalcluatedValueTag(column);
    },
    connect: function (dataSet) {
        this._dataSource = dataSet;
        this._lm = this._grid.layoutManager();
        this._anis = this._grid._animations;
        this._visitTags(function (tag) {
            tag.connect(dataSet);
        });
    },
    disconnect: function () {
        this._dataSource = undefined;
        this._visitTags(function (tag) {
            tag.disconnect();
        });
    },
    clearRows: function () {
        this._visitTags(function (tag) {
            tag.clearRows();
        });
        this._anis.clear();
    },
    setRows: function () {
        this._visitTags(function (tag) {
            tag.setRows();
        });
        this._grid.requestLoadAnimation(true);
    },
    addRow: function (index, row) {
        this._visitTags(function (tag) {
            tag.addRow(index, row);
        });
    },
    addRows: function (index, rows) {
        this._visitTags(function (tag) {
            tag.addRows(index, rows);
        });
    },
    insertRows: function (rows) {
        this._visitTags(function (tag) {
            tag.insertRows(rows);
        });
    },
    removeRow: function (row) {
        this._visitTags(function (tag) {
            tag.removeRow(row);
        });
    },
    removeRows: function (rows) {
        this._visitTags(function (tag) {
            tag.removeRows(rows);
        });
    },
    updateRow: function (row) {
        this._visitTags(function (tag) {
            tag.updateRow(row);
        });
        this._anis.requestUpdate(this._lm, row.rowId(), -1);
    },
    setValue: function (row, field) {
        this._visitTags(function (tag) {
            tag.setValue(row, field);
        });
        this._anis.requestUpdate(this._lm, row.rowId(), field);
    }
});
var TreeSeriesValueTag = defineClass("TreeSeriesValueTag", SeriesValueTag, {
    init: function (column) {
        this._super(column);
        this._rows = {};
    },
    clearValues: function () {
        this._rows = {};
    },
    getValues: function (dataIndex) {
        var v = this._rows[dataIndex];
        if (v === undefined) {
            v = this.$_calculate(dataIndex);
            this._rows[dataIndex] = v;
        }
        return v;
    },
    connect: function (dataSource) {
        this._dataSource = dataSource;
        this._rows = {};
    },
    disconnect: function () {
        this._dataSource = undefined;
        this._rows = undefined;
    },
    clearRows: function () {
        this._rows = {};
    },
    setRows: function () {
        this._rows = {};
    },
    addRow: function (index, row) {
    },
    addRows: function (index, rows) {
    },
    insertRows: function (rows) {
    },
    removeRow: function (row) {
        delete this._rows[row.rowId()];
    },
    removeRows: function (rows) {
        for (var i = rows.length; i--;) {
            delete this._rows[rows[i].rowId()];
        }
    },
    updateRow: function (row) {
        delete this._rows[row.rowId()];
    },
    setValue: function (row, field) {
        delete this._rows[row.rowId()];
    }
});
var TreeCalcluatedValueTag = defineClass("TreeCalcluatedValueTag", CalcluatedValueTag, {
    init: function (column) {
        this._super(column);
        this._values = {};
    },
    clearValues: function () {
        this._values = {};
    },
    hasValue: function (dataIndex) {
        return this._values.hasOwnProperty(dataIndex);
    },
	_isGrouped: function (grid) {
		return false;
	},
    connect: function (dataSet) {
        this._values = {};
        this.requestAll();
    },
    disconnect: function () {
        this._values = undefined;
    },
    clearRows: function () {
        this._values = {};
    },
    setRows: function () {
        this._values = {};
        this.requestAll();
    },
    addRow: function (index, row) {
        this.requestRow(row);
    },
    addRows: function (index, rows) {
        this.requestRow(rows[0]);
    },
    insertRows: function (rows) {
        this.requestRow(rows[0]);
    },
    removeRow: function (row) {
        this.requestRow(row);
    },
    removeRows: function (rows) {
        this.requestRow(rows[0]);
    },
    updateRow: function (row) {
        this.requestRow(row);
    },
    setValue: function (row, field) {
        this.requestRow(row);
    },
	saveRow: function (scope, row) {
	},
	restoreRow: function (scope, row, created) {
		this._values.length > row && (this._values[row] = undefined);
	},
	saveRows: function (scope, rows) {
	},
	restoreRows: function (scope, rows, created) {
	},
});
/** @internal */
var TreeCellStyleMap = defineClass("TreeCellStyleMap", CellStyleMap, {
	init: function() {
		this._super();
	},
	connect: function (ds) {
		this._ds = ds;
	},
	disconnect: function () {
		this._ds = null;
	},
	clearRows: function () {
		this._styleMap = {};
	},
	setRows: function () {
	},
    addRow: function (index, row) {
    },
    addRows: function (index, rows) {
    },
    insertRows: function (rows) {
    },
	removeRow: function (row) {
		var children, i;
		if (row) {
			children = row.getDescendants();
			if (children) {
				for (i = children.length; i--;) {
					delete this._styleMap[children[i].rowId()];
				}
				delete this._styleMap[row.rowId()];
			}
		}
	},
	removeRows: function (rows) {
		for (var i = rows.length; i--;) {
			this.removeRow(rows[i]);
		}
	},
	updateRow: function (row) {
	},
	setValue: function (row, field) {
	},
    _initMap: function () {
        this._styleMap = {};
    },
    _maxRowIndex: function (ds) {
        return ds.$_maxRowId();
    },
    isEmpty: function () {
        return _isEmptyObject(this._styleMap);
    },
	_saveRow: function (scope, row) {
		var r = row.rowId(),
			key = this.$_hash + '_' + r,
			val = this._styleMap[r];
		scope.set(key, val);
		row.visit(function (child) {
			this._saveRow(scope, child);
		}.bind(this));
	},
	_restoreRow: function (scope, row) {
		var r = row.rowId(),
			key = this.$_hash + '_' + r,
			val = scope.get(key);
		scope.unset(key);
		this._styleMap[r] = val;
		row.visit(function (child) {
			this._restoreRow(scope, child);
		}.bind(this));
	},
	saveRow: function (scope, row, deleting) {
		deleting && this._saveRow(scope, row);
	},
	restoreRow: function (scope, row, created) {
		created && this._restoreRow(scope, row);
	},
	saveRows: function (scope, rows, deleting) {
		if (deleting) {
			if (rows === DataSet.ALL_ROWS) {
				this._ds.visitAllRows(function (row) {
					this._saveRow(scope, row);
				}.bind(this), 0);
			} else {
				for (var i = rows.length; i--;) {
					this._saveRow(scope, rows[i]);
				}
			}
		}
	},
	restoreRows: function (scope, rows, created) {
		if (created) {
			if (rows === DataSet.ALL_ROWS) {
				this._ds.visitAllRows(function (row) {
					this._restoreRow(scope, row);
				}.bind(this), 0);
			} else {
				for (var i = rows.length; i--;) {
					this._restoreRow(scope, rows[i]);
				}
			}
		}
	}
});
var TreeChartItem = defineClass("TreeChartItem", GroupChartItem, {
    init: function (owner, config) {
        this._super(owner, config);
    },
    createRowView: function (dom) {
        return new TreeChartRowElement(dom);
    }
});
var TreeChartRowElement = defineClass("TreeChartRowElement", GroupChartRowElement, {
    init: function (dom) {
        this._super(dom, "treeChartRowView");
        this.addElement(this._indentView = new TreeItemIndentElement(dom));
    },
    _doLayoutContent: function (lm) {
        if (this._chartView) {
            var r = this.getClientRect(this._drawRect);
            this._styles.deflatePaddings(r);
            r.x += this._indentWidth;
            r.width -= this._indentWidth;
            this._chartView.setRectI(r);
            this._chartView.layoutContent(lm);
            var tree = this.grid();
            var view = this._indentView;
            view.setBounds(0, 0, this._indentWidth, this.height());
            view.setVisible(true);
            view.updateCell(tree.getIndentCell(CellIndex.temp(this._item.index(), null)));
        } else {
            this._indentView.setVisible(false);
        }
        this._styles = null;
    }
});

    var _locale = GridLocale.getLocale(null);

    var setLanguage = function (lang) {
        Locale.setLanguage(lang);
        GridLocale.setLanguage(lang);
    };
    var setLocale = function (lang, common, grid) {
        if (typeof lang == "string") {
            Locale.setLocale(lang, common);
            GridLocale.setLocale(lang, grid);
        }
    };
    var resetLanguage = function () {
        setLanguage($_language);
    };

    var setTextVerticalOffset = function (off) {
        $_TEXT_OFF = off;
    };

    var setMaxPrecision = function (precision) {
        $$$_MAX_PRECISION = precision;
    };
    var setMaxDigits = function (digits) {
        $$$_MAX_DIGITS = digits;
    };

    var createGridDataSet = function (fields, calcedFields) {
        var ds = new GridDataSet();
        fields && ds.setFields(fields, calcedFields);
        return ds;
    };
    var createGridView = function (containerId, columns, dom, popupOwner) {
        var grid = new GridComponent(dom, containerId, popupOwner).gridView();
        grid.setViewId(containerId);
        columns && grid.setColumns(columns);
        return grid;
    };
/// NO-LITE
    var createTreeDataSet = function (fields, calcedFields) {
        var ds = new TreeDataSet();
        fields && ds.setFields(fields, calcedFields);
        return ds;
    };
    var createTreeView = function (containerId, columns, dom, popupOwner) {
        var grid = new TreeComponent(dom, containerId, popupOwner).gridView();
        grid.setViewId(containerId);
        grid && grid.setColumns(columns);
        return grid;
    };
/// NO-LITE END
    var createIndex = function (rowIndex, column) {
        return new CellIndex(rowIndex, column);
    };
    var throwValidationError = function (level, message, column) {
        throw new ValidationError(level, message, column);
    };
    var loadCsvData = function (dataset, data, options) {
        if (dataset instanceof TreeDataSet) {
            new TreeDataLoader(dataset).load("csv", data, options);
        } else {
            new DataLoader(dataset).load("csv", data, options);
        }
    };
    var loadJsonData = function (dataset, data, options) {
        if (dataset instanceof TreeDataSet) {
            new TreeDataLoader(dataset).load("json", data, options);
        } else {
            new DataLoader(dataset).load("json", data, options);
        }
    };
    var loadXmlData = function (dataset, data, options) {
        if (dataset instanceof TreeDataSet) {
            new TreeDataLoader(dataset).load("xml", data, options);
        } else {
            new DataLoader(dataset).load("xml", data, options);
        }
    };
    var exportToExcel = function (grid, options) {
        new GridExcelExporter()["export"](grid, options);
    };
    var setMobileThresholds = function (config) {
        if ('tap' in config) $_TAP_THRESHOLD = config.tap;
        if ('doubleTap' in config) $_DOUBLE_TAP_THRESHOLD = config.doubleTap;
        if ('longTap' in config) $_LONG_TAP_THRESHOLD = config.longTap;
        if ('swipe' in config) $_SWIPE_THRESHOLD = config.swipe;
    };

    var _loadLog = "### DATALUDI GRID MODULE LOADED in " + _getTimer() + ' ms. (v ' + _ver + ')';

	return {
		getVersion: _getVersion,
		setRootContext: _setRootContext,
        setAssetRoot: _setAssetRoot,
        setDebug: _setDebug,
		setLogging: _setLogging,
		setTrace: _setLogging,
        _log: _log,
        _dlog: _dlog,
        _check: _check,
        abort: _abort,
        _createError: _createError,
        AbortError: AbortError,
        AssertError: AssertError,
        _assert: _assert,
        _throwDebugError: _throwDebugError,
        _getEnumNames: _getEnumNames,
        _getEnumValues: _getEnumValues,
        getClipboardText: _getClipboardText,
        setClipboardText: _setClipboardText,
		setMobile: $$_setMobile,
        $_isMobile: function () { return $_mobileEnabled && _isMobile(); },
		$_setMobileEnabled: function (value) { $_mobileEnabled = value; },
        _isMac: _isMac,
		getTimer: getTimer,
		setLanguage: setLanguage,
		setLang: setLanguage,
        setLocale: setLocale,
        resetLanguage: resetLanguage,
        setMaxPrecision: setMaxPrecision,
        setMaxDigits: setMaxDigits,
        parseXml: _parseXml,
        parseXmlList: _parseXmlList,
        parseCsv: $_parseCSV,
        capitalize: _capitalize,
        uncapitalize: _uncapitalize,
        extend: _extend,
        isObject: _isObject,
        asObject: _asObject,
        isProperty: DLBase.isProperty,
        getPropertyNames: DLBase.getPropertyNames,
        //getPropertyInt: DLBase.getPropertyInt,
        saveToFile: _saveToFile,
        saveTextToFile: _saveTextToFile,
        loadTextFile: _loadTextFile,
        defineClass: defineClass,
        defineEnum: _enum,
        formatNumber: DecimalFormatter.formatNumber,
        sigma: _sigma,
        setMobileThresholds: setMobileThresholds,
        Keys: Keys,
        setTextVerticalOffset: setTextVerticalOffset,

		Dictionary: Dictionary,
		Dimensoion: Dimension,
		Dom: Dom,
        //Dialog: Dialog,
        //FormDialog: FormDialog,

        SummaryMode: SummaryMode,
		ValueType: ValueType,
		DataField: DataField,
		DataRowState: DataRowState,
        DataRestoreMode: DataRestoreMode,
        DataFillMode: DataFillMode,
        FieldSummary: FieldSummary,
        RowIndicatorValue: RowIndicatorValue,
        ScrollBarIndent: ScrollBarIndent,
        ScrollButtonLocation: ScrollButtonLocation,
        GridScrollTool: GridScrollTool,
        IconLocation: IconLocation,
        ImageDisplay: ImageDisplay,
        HeaderItemLocation: HeaderItemLocation,
        SubTextLocation: SubTextLocation,
        SortMode: SortMode,
        SortDirection: SortDirection,
        SortCase: SortCase,
        SortStyle: SortStyle,
        ImeMode: ImeMode,
        SelectionMode: SelectionMode,
        SelectionStyle: SelectionStyle,
        SelectionDisplay: SelectionDisplay,
        SummaryMode: SummaryMode,
        ValidationLevel: ValidationLevel,
        ValidationMode: ValidationMode,
        ButtonVisibility: ButtonVisibility,
        CellButton: CellButton,
        TextWrap: TextWrap,
        FillGradient: FillGradient,
        SolidBrush: SolidBrush,
        SolidPen: SolidPen,
        ShapeDrawing: ShapeDrawing,
        ColumnCalcRange: ColumnCalcRange,
        ColumnCalcBounds: ColumnCalcBounds,
        RowGroupDisplayMode: RowGroupDisplayMode,
        RowGroupAdornments: RowGroupAdornments,
		FilterMode: FilterMode,
		GridRowState: GridRowState,
		RowHoverMaskExtent: RowHoverMaskExtent,
		TextDecoration: TextDecoration,
        DateTimeScale: DateTimeScale,
        TextCase: TextCase,
        DragTracker: DragTracker,
        ScrollBar: ScrollBar,
        ScrollBarElement: ScrollBarElement,
        ScrollEventType: ScrollEventType,
        ScrollThumbTracker: ScrollThumbTracker,
        
		GridDataSet: GridDataSet,
        DataLoader: DataLoader,
        GridRowSource: GridRowSource,
        GridComponent: GridComponent,
        GridBase: GridBase,
		GridView: GridView,
        GridHeader: GridHeader,
        GridFooter: GridFooter,
        RowIndicator: RowIndicator,
		CheckBar: CheckBar,
        RowGroupPanel: RowGroupPanel,
        GridBody: GridBody,
		CellIndex:CellIndex,
        ColumnFooter: ColumnFooter,
		ColumnHeader: ColumnHeader,
		ColumnGroupHeader: ColumnGroupHeader,
		ColumnGroup: ColumnGroup,
		GroupRow: GroupRow,
		GroupFooter: GroupFooter,
		GridColumn: GridColumn,
		GridRow: GridRow,
		ValueColumn: ValueColumn,
		DataColumn: DataColumn,
		DataRow: DataRow,
		SeriesColumn: SeriesColumn,
        CalculatedColumn: CalculatedColumn,
        LabelColumn: LabelColumn,
        ColumnFilter: ColumnFilter,
		ColumnLayout: ColumnLayout,
		GridStyles: GridStyles,
        DynamicStyleImpl: DynamicStyleImpl,
        DynamicStyleCollection: DynamicStyleCollection,
        GridStyleSheet: GridStyleSheet,
        SelectionManager: SelectionManager,
		BlockSelection: BlockSelection,
		RowSelection: RowSelection,
		ColumnSelection: ColumnSelection,
        DropDownSortStyle: DropDownSortStyle,
        DropDownPosition: DropDownPosition,
		ColumnGroupLayout: ColumnGroupLayout,
        DataCellRenderer: DataCellRenderer,
		TextCellRenderer: TextCellRenderer,
		BarCellRenderer: BarCellRenderer,
		CheckCellRenderer: CheckCellRenderer,
		IconCellRenderer: IconCellRenderer,
		ImageCellRenderer: ImageCellRenderer,
		ShapeCellRenderer: ShapeCellRenderer,
        ToastOptions: ToastOptions,
        DisplayOptions: DisplayOptions,
        EditOptions: EditOptions,
        OperateOptions: OperateOptions,
        CellStyleManager: CellStyleManager,
        GridFitStyle: GridFitStyle,
        ListItemDisplay: ListItemDisplay,
        GridDelegate: GridDelegate,
        GridSelectionTool: GridSelectionTool,
        Cursor: Cursor,
        HandleVisibility: HandleVisibility,
        SortOrderVisibility: SortOrderVisibility,
        TextInputCase: TextInputCase,
/// NO-LITE
        CircleGaugeCellRenderer: CircleGaugeCellRenderer,
        LinearGaugeCellRenderer: LinearGaugeCellRenderer,
        Code128CellRenderer: Code128CellRenderer,
        Code39CellRenderer: Code39CellRenderer,
/// NO-LITE END

/// NO-LITE
        // tree
		TreeDataSet: TreeDataSet,
        TreeDataRow: TreeDataRow,
        TreeDataRowImpl: TreeDataRowImpl,
        RootTreeDataRow: RootTreeDataRow,
        TreeRow: TreeRow,
        TreeRowSource: TreeRowSource,
		TreeComponent: TreeComponent,
		TreeView: TreeView,
		TreeGridDelegate: TreeGridDelegate,
		TreeSelectionTool: TreeSelectionTool,
        TreeSummaryScope: TreeSummaryScope,
/// NO-LITE END

/// NO-LITE
        // gauge
		GaugeValueLocation: GaugeValueLocation,
		GaugeLabelLocation: GaugeLabelLocation,
		GaugeBodyShape: GaugeBodyShape,
		GaugeRangeCollection: GaugeRangeCollection,
		GaugeScale: GaugeScale,
		LinearGauge: LinearGauge,
		CircleGauge: CircleGauge,
		//BulletGraph: BulletGraph,
/// NO-LITE END

/// NO-LITE
        // chart
		ChartDataDirection: ChartDataDirection,
		ChartDataSyncMode: ChartDataSyncMode,
		ChartItemPosition: ChartItemPosition,
		ChartItemDisplayOrder: ChartItemDisplayOrder,
		ChartStackMode: ChartStackMode,
		ChartAxisOrientation: ChartAxisOrientation,
		ChartAxisLocation: ChartAxisLocation,
		NumericAxisBase: NumericAxisBase,
		ChartLineType: ChartLineType,
		ChartLabelPosition: ChartLabelPosition,
		ChartLegendDirection: ChartLegendDirection,
		ChartHorizontalAlign: ChartHorizontalAlign,
		ChartVerticalAlign: ChartVerticalAlign,
/// NO-LITE END

        // global functions
        createGridDataSet: createGridDataSet,
        createGridView: createGridView,
/// NO-LITE
        createTreeDataSet: createTreeDataSet,
        createTreeView: createTreeView,
/// NO-LITE END
        createIndex: createIndex,
        throwValidationError: throwValidationError,
        loadCsvData: loadCsvData,
        loadJsonData: loadJsonData,
        loadXmlData: loadXmlData,
        exportToExcel: exportToExcel,

		// for internal only
        MaskEditor: MaskEditor,
		EventAware: EventAware,
        $_DataSet: DataSet,
        $_RowProvider: RowProvider,
        $_DefaultRowProvider: DefaultRowProvider,
/// NO-LITE
        $_TreeRowProvider: TreeItemProvider,
/// NO-LITE END
		RowFilterRuntime: RowFilterRuntime,
		RowProvider: RowProvider,
		ColumnSummaryRuntime: ColumnSummaryRuntime,
		UIComponent: UIComponent,
		UIElement: UIElement,
		LayerElement: LayerElement,
		VisualTool: VisualTool,
		Progress: Progress,
		PopupMenu: PopupMenu,
		PopupMenuManager: PopupMenuManager,
		GridBase: GridBase,
		ColumnHeader: ColumnHeader,
		BooleanConverter: BooleanConverter,
		DateTimeReader: DateTimeReader,
		DateTimeWriter: DateTimeWriter,
		DecimalFormatter: DecimalFormatter,
		SeriesCell: SeriesCell,
		ExpressionParser: ExpressionParser,
		ExpressionSyntaxError: ExpressionSyntaxError,
		ExpressionRuntime: ExpressionRuntime,
		DataRowExpressionRuntime: DataRowExpressionRuntime,
		GridExcelExporter: GridExcelExporter,
		StylesArchiver: StylesArchiver,
		Rectangle: Rectangle,
        Size: Size,
		PercentSize: PercentSize,
		Alignment: Alignment,
        TextAlign: TextAlign,
        GridCell: GridCell,
        RowGroup: RowGroup,
        $_RowGroupElement: RowGroupElement,
        CellElement: CellElement,
        RowElement: RowElement,
        GroupRowElement: GroupRowElement,
        DataRowElement: DataRowElement,
/// NO-LITE
        TreeGridRowProvider: TreeGridRowProvider,
        TreeItemElement: TreeItemElement,
        TreeBodyElement: TreeBodyElement,
/// NO-LITE END
        HeaderElement: HeaderElement,
        FooterElement: FooterElement,
        $_CheckBarElement: CheckBarElement,
        GridLayoutManager: GridLayoutManager,
/// NO-LITE
        GridChart: GridChart,
        GridChartView: GridChartView,
        ChartElement: ChartElement,
/// NO-LITE END
        EllipseShape: EllipseShape,
        PolygonShape: PolygonShape,
        SvgSprite: SvgSprite,
        IntProp: IntProp,
		toStr: _toStr,
		trim: _trim,
		isObject: _isObject,
		isDate: _isDate,
		isEmpty: _isEmpty,
		isArray: _isArray,
		isChrome: _isChrome,
		EnumProp: EnumProp,
        DLCallback: DLCallback,
		createFill: _createFill,
		createStroke: _createStroke,
		createFont: _createFont,
		invalidFieldIndex: _invalidFieldIndex
	};
})(this);
var dataludi = DataLudi;
